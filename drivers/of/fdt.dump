
fdt.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <kernel_tree_alloc>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	e1a0c00d 	mov	ip, sp
   4:	e92dd800 	push	{fp, ip, lr, pc}
   8:	e24cb004 	sub	fp, ip, #4
   c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  10:	ebfffffe 	bl	0 <__gnu_mcount_nc>
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
  14:	e30810c0 	movw	r1, #32960	; 0x80c0
  18:	e3401240 	movt	r1, #576	; 0x240
  1c:	ebfffffe 	bl	0 <__kmalloc>
	return kzalloc(size, GFP_KERNEL);
}
  20:	e89da800 	ldm	sp, {fp, sp, pc}

00000024 <of_fdt_raw_read>:

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	e1a0c00d 	mov	ip, sp
  28:	e92dd800 	push	{fp, ip, lr, pc}
  2c:	e24cb004 	sub	fp, ip, #4
  30:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  34:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	memcpy(buf, initial_boot_params + off, count);
  38:	e3002000 	movw	r2, #0
  3c:	e3402000 	movt	r2, #0
  40:	e1a00003 	mov	r0, r3

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	e59b3004 	ldr	r3, [fp, #4]
	memcpy(buf, initial_boot_params + off, count);
  48:	e5921000 	ldr	r1, [r2]
  4c:	e59b200c 	ldr	r2, [fp, #12]
  50:	e0811003 	add	r1, r1, r3
  54:	ebfffffe 	bl	0 <memcpy>
	return count;
}
  58:	e59b000c 	ldr	r0, [fp, #12]
  5c:	e89da800 	ldm	sp, {fp, sp, pc}

00000060 <unflatten_dt_node>:
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	e1a0c00d 	mov	ip, sp
  64:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
  68:	e24cb004 	sub	fp, ip, #4
  6c:	e24dd04c 	sub	sp, sp, #76	; 0x4c
  70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  74:	ebfffffe 	bl	0 <__gnu_mcount_nc>
  78:	e1a05003 	mov	r5, r3
  7c:	e5db300c 	ldrb	r3, [fp, #12]
  80:	e1a0c002 	mov	ip, r2
  84:	e50b205c 	str	r2, [fp, #-92]	; 0xffffffa4
  88:	e1a08001 	mov	r8, r1
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	e24b2038 	sub	r2, fp, #56	; 0x38
  90:	e59c1000 	ldr	r1, [ip]
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	e1a06000 	mov	r6, r0
  98:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	ebfffffe 	bl	0 <fdt_get_name>
	if (!pathp)
  a0:	e2503000 	subs	r3, r0, #0
  a4:	e50b3060 	str	r3, [fp, #-96]	; 0xffffffa0
  a8:	e1a02003 	mov	r2, r3
  ac:	0a000127 	beq	550 <unflatten_dt_node+0x4f0>
		return mem;

	allocl = ++l;
  b0:	e51b4038 	ldr	r4, [fp, #-56]	; 0xffffffc8
  b4:	e2843001 	add	r3, r4, #1
  b8:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	e5d22000 	ldrb	r2, [r2]
  c0:	e352002f 	cmp	r2, #47	; 0x2f
  c4:	02844059 	addeq	r4, r4, #89	; 0x59
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	03a09000 	moveq	r9, #0
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	0a00000a 	beq	fc <unflatten_dt_node+0x9c>
		new_format = 1;
		if (fpsize == 0) {
  d0:	e59b2008 	ldr	r2, [fp, #8]
  d4:	e3520000 	cmp	r2, #0
  d8:	1a0000f0 	bne	4a0 <unflatten_dt_node+0x440>
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	e3a03001 	mov	r3, #1
  e0:	e3a0405a 	mov	r4, #90	; 0x5a
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	e1a09003 	mov	r9, r3
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	e3002000 	movw	r2, #0
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
			pathp = "";
  f0:	e3402000 	movt	r2, #0
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	e58b3008 	str	r3, [fp, #8]
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	e50b2060 	str	r2, [fp, #-96]	; 0xffffffa0
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	e2888003 	add	r8, r8, #3
 104:	e3c88003 	bic	r8, r8, #3
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	e3530000 	cmp	r3, #0
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	e0884004 	add	r4, r8, r4
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	13a03000 	movne	r3, #0
 114:	150b3044 	strne	r3, [fp, #-68]	; 0xffffffbc
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	0a0000e8 	beq	4c0 <unflatten_dt_node+0x460>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	e51b305c 	ldr	r3, [fp, #-92]	; 0xffffffa4
 120:	e1a00006 	mov	r0, r6
 124:	e5931000 	ldr	r1, [r3]
 128:	ebfffffe 	bl	0 <fdt_first_property_offset>
 12c:	e2505000 	subs	r5, r0, #0
 130:	ba000093 	blt	384 <unflatten_dt_node+0x324>

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	e3003000 	movw	r3, #0
 138:	e3403000 	movt	r3, #0
 13c:	e50b3048 	str	r3, [fp, #-72]	; 0xffffffb8
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	e3003000 	movw	r3, #0
 144:	e3403000 	movt	r3, #0
 148:	e50b3054 	str	r3, [fp, #-84]	; 0xffffffac
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	e3a03000 	mov	r3, #0
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	e3002000 	movw	r2, #0
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	e1a07003 	mov	r7, r3
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	e3402000 	movt	r2, #0
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	e50b804c 	str	r8, [fp, #-76]	; 0xffffffb4
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	e50b2050 	str	r2, [fp, #-80]	; 0xffffffb0
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	e3002000 	movw	r2, #0
 168:	e3402000 	movt	r2, #0
 16c:	e50b2058 	str	r2, [fp, #-88]	; 0xffffffa8
 170:	ea000032 	b	240 <unflatten_dt_node+0x1e0>
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	e51ba034 	ldr	sl, [fp, #-52]	; 0xffffffcc
 178:	e35a0000 	cmp	sl, #0
 17c:	0a0000fb 	beq	570 <unflatten_dt_node+0x510>
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	e51b1048 	ldr	r1, [fp, #-72]	; 0xffffffb8
 184:	e1a0000a 	mov	r0, sl
 188:	ebfffffe 	bl	0 <strcmp>
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	e2844003 	add	r4, r4, #3
 194:	e3c48003 	bic	r8, r4, #3
	res = *mem;
	*mem += size;
 198:	e2884034 	add	r4, r8, #52	; 0x34
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	e3500000 	cmp	r0, #0
 1a0:	03a07001 	moveq	r7, #1
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	e3530000 	cmp	r3, #0
 1a8:	1a00001f 	bne	22c <unflatten_dt_node+0x1cc>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	e51b1050 	ldr	r1, [fp, #-80]	; 0xffffffb0
 1b0:	e1a0000a 	mov	r0, sl
 1b4:	ebfffffe 	bl	0 <strcmp>
 1b8:	e3500000 	cmp	r0, #0
 1bc:	0a000004 	beq	1d4 <unflatten_dt_node+0x174>
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	e51b1058 	ldr	r1, [fp, #-88]	; 0xffffffa8
 1c4:	e1a0000a 	mov	r0, sl
 1c8:	ebfffffe 	bl	0 <strcmp>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	e3500000 	cmp	r0, #0
 1d0:	1a000006 	bne	1f0 <unflatten_dt_node+0x190>
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
 1d8:	e5931008 	ldr	r1, [r3, #8]
 1dc:	e3510000 	cmp	r1, #0
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	05991000 	ldreq	r1, [r9]
					np->phandle = be32_to_cpup(p);
 1e4:	051b304c 	ldreq	r3, [fp, #-76]	; 0xffffffb4
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	06bf1f31 	reveq	r1, r1
 1ec:	05831008 	streq	r1, [r3, #8]
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	e51b1054 	ldr	r1, [fp, #-84]	; 0xffffffac
 1f4:	e1a0000a 	mov	r0, sl
 1f8:	ebfffffe 	bl	0 <strcmp>
 1fc:	e3500000 	cmp	r0, #0
 200:	05991000 	ldreq	r1, [r9]
				np->phandle = be32_to_cpup(p);
 204:	051b304c 	ldreq	r3, [fp, #-76]	; 0xffffffb4
 208:	06bf1f31 	reveq	r1, r1
 20c:	05831008 	streq	r1, [r3, #8]
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	e588a000 	str	sl, [r8]
			pp->length = sz;
 21c:	e9880202 	stmib	r8, {r1, r9}
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	e5838000 	str	r8, [r3]
			prev_pp = &pp->next;
 224:	e288300c 	add	r3, r8, #12
 228:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	e1a01005 	mov	r1, r5
 230:	e1a00006 	mov	r0, r6
 234:	ebfffffe 	bl	0 <fdt_next_property_offset>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	e2505000 	subs	r5, r0, #0
 23c:	ba000006 	blt	25c <unflatten_dt_node+0x1fc>
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	e24b3030 	sub	r3, fp, #48	; 0x30
 244:	e24b2034 	sub	r2, fp, #52	; 0x34
 248:	e1a01005 	mov	r1, r5
 24c:	e1a00006 	mov	r0, r6
 250:	ebfffffe 	bl	0 <fdt_getprop_by_offset>
 254:	e2509000 	subs	r9, r0, #0
 258:	1affffc5 	bne	174 <unflatten_dt_node+0x114>
 25c:	e51b804c 	ldr	r8, [fp, #-76]	; 0xffffffb4
 260:	e1a05007 	mov	r5, r7
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	e3550000 	cmp	r5, #0
 268:	0a000045 	beq	384 <unflatten_dt_node+0x324>
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 270:	e3530000 	cmp	r3, #0
 274:	0a000070 	beq	43c <unflatten_dt_node+0x3dc>
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	e51b705c 	ldr	r7, [fp, #-92]	; 0xffffffa4
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	e3005000 	movw	r5, #0
 280:	e3405000 	movt	r5, #0
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	e1a00006 	mov	r0, r6
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	e1a02005 	mov	r2, r5
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	e5971000 	ldr	r1, [r7]
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	e5b29004 	ldr	r9, [r2, #4]!
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	ebfffffe 	bl	0 <fdt_next_node>
 298:	e5870000 	str	r0, [r7]
	if (depth < 0)
 29c:	e5953004 	ldr	r3, [r5, #4]
 2a0:	e3530000 	cmp	r3, #0
		depth = 0;
 2a4:	b3a03000 	movlt	r3, #0
 2a8:	b5853004 	strlt	r3, [r5, #4]
 2ac:	b51b305c 	ldrlt	r3, [fp, #-92]	; 0xffffffa4
 2b0:	b5930000 	ldrlt	r0, [r3]
	while (*poffset > 0 && depth > old_depth)
 2b4:	e3500000 	cmp	r0, #0
 2b8:	da000018 	ble	320 <unflatten_dt_node+0x2c0>
 2bc:	e5953004 	ldr	r3, [r5, #4]
 2c0:	e1590003 	cmp	r9, r3
 2c4:	aa000017 	bge	328 <unflatten_dt_node+0x2c8>
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	e1a01004 	mov	r1, r4
 2cc:	e3a0a000 	mov	sl, #0
 2d0:	e1a04005 	mov	r4, r5
 2d4:	e51b705c 	ldr	r7, [fp, #-92]	; 0xffffffa4
 2d8:	e59b5008 	ldr	r5, [fp, #8]
 2dc:	ea000002 	b	2ec <unflatten_dt_node+0x28c>

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	e5943004 	ldr	r3, [r4, #4]
 2e4:	e1590003 	cmp	r9, r3
 2e8:	aa000072 	bge	4b8 <unflatten_dt_node+0x458>
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 2f0:	e1a02007 	mov	r2, r7
 2f4:	e58d5004 	str	r5, [sp, #4]
 2f8:	e1a00006 	mov	r0, r6
 2fc:	e58da000 	str	sl, [sp]
 300:	e58d3008 	str	r3, [sp, #8]
 304:	e1a03008 	mov	r3, r8
 308:	ebffff54 	bl	60 <unflatten_dt_node>
 30c:	e1a01000 	mov	r1, r0

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	e5970000 	ldr	r0, [r7]
 314:	e3500000 	cmp	r0, #0
 318:	cafffff0 	bgt	2e0 <unflatten_dt_node+0x280>
 31c:	e1a04001 	mov	r4, r1
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	e3700001 	cmn	r0, #1
 324:	ba000097 	blt	588 <unflatten_dt_node+0x528>

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 32c:	e3530000 	cmp	r3, #0
 330:	1a00000c 	bne	368 <unflatten_dt_node+0x308>
 334:	e5983024 	ldr	r3, [r8, #36]	; 0x24
 338:	e3530000 	cmp	r3, #0
 33c:	0a000009 	beq	368 <unflatten_dt_node+0x308>
		struct device_node *child = np->child;
		np->child = NULL;
 340:	e51b2040 	ldr	r2, [fp, #-64]	; 0xffffffc0
 344:	e1a07002 	mov	r7, r2
 348:	e5882024 	str	r2, [r8, #36]	; 0x24
		while (child) {
			struct device_node *next = child->sibling;
 34c:	e5932028 	ldr	r2, [r3, #40]	; 0x28
			child->sibling = np->child;
 350:	e5837028 	str	r7, [r3, #40]	; 0x28
 354:	e1a07003 	mov	r7, r3
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	e3520000 	cmp	r2, #0
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	e5883024 	str	r3, [r8, #36]	; 0x24
 360:	e1a03002 	mov	r3, r2
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	1afffff8 	bne	34c <unflatten_dt_node+0x2ec>
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	e59b3004 	ldr	r3, [fp, #4]
		*nodepp = np;
 36c:	e1a00004 	mov	r0, r4
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	e3530000 	cmp	r3, #0
		*nodepp = np;
 374:	159b3004 	ldrne	r3, [fp, #4]
 378:	15838000 	strne	r8, [r3]

	return mem;
}
 37c:	e24bd028 	sub	sp, fp, #40	; 0x28
 380:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	e51b0060 	ldr	r0, [fp, #-96]	; 0xffffffa0
 388:	e5d02000 	ldrb	r2, [r0]
 38c:	e3520000 	cmp	r2, #0
 390:	0a000073 	beq	564 <unflatten_dt_node+0x504>
 394:	e2803001 	add	r3, r0, #1
 398:	e3a0c000 	mov	ip, #0
			if ((*p1) == '@')
 39c:	e3520040 	cmp	r2, #64	; 0x40
 3a0:	e243e001 	sub	lr, r3, #1
				pa = p1;
			if ((*p1) == '/')
 3a4:	e1a01003 	mov	r1, r3
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	01a0c00e 	moveq	ip, lr
 3ac:	0a000001 	beq	3b8 <unflatten_dt_node+0x358>
				pa = p1;
			if ((*p1) == '/')
 3b0:	e352002f 	cmp	r2, #47	; 0x2f
 3b4:	01a00003 	moveq	r0, r3
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	e4d32001 	ldrb	r2, [r3], #1
 3bc:	e3520000 	cmp	r2, #0
 3c0:	1afffff5 	bne	39c <unflatten_dt_node+0x33c>
 3c4:	e50b0060 	str	r0, [fp, #-96]	; 0xffffffa0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	e2844003 	add	r4, r4, #3
 3d0:	e3c45003 	bic	r5, r4, #3
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	e15c0003 	cmp	ip, r3
 3d8:	21a0100c 	movcs	r1, ip
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	e0412003 	sub	r2, r1, r3
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	e2824035 	add	r4, r2, #53	; 0x35
 3e8:	e0854004 	add	r4, r5, r4
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	e2829001 	add	r9, r2, #1
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	e3530000 	cmp	r3, #0
 3f4:	1affff9f 	bne	278 <unflatten_dt_node+0x218>
			pp->name = "name";
 3f8:	e3003000 	movw	r3, #0
 3fc:	e3403000 	movt	r3, #0
 400:	e5853000 	str	r3, [r5]
			pp->length = sz;
			pp->value = pp + 1;
 404:	e2853034 	add	r3, r5, #52	; 0x34
 408:	e5853008 	str	r3, [r5, #8]
			*prev_pp = pp;
 40c:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
 410:	e5859004 	str	r9, [r5, #4]
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
 414:	e51b1060 	ldr	r1, [fp, #-96]	; 0xffffffa0
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
 418:	e5835000 	str	r5, [r3]
			prev_pp = &pp->next;
 41c:	e285300c 	add	r3, r5, #12
			memcpy(pp->value, ps, sz - 1);
 420:	e5950008 	ldr	r0, [r5, #8]
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
 424:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
			memcpy(pp->value, ps, sz - 1);
 428:	ebfffffe 	bl	0 <memcpy>
			((char *)pp->value)[sz - 1] = 0;
 42c:	e5953008 	ldr	r3, [r5, #8]
 430:	e0839009 	add	r9, r3, r9
 434:	e55b3040 	ldrb	r3, [fp, #-64]	; 0xffffffc0
 438:	e5493001 	strb	r3, [r9, #-1]
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 43c:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 440:	e3a05000 	mov	r5, #0
		np->name = of_get_property(np, "name", NULL);
 444:	e1a02005 	mov	r2, r5
 448:	e3001000 	movw	r1, #0
 44c:	e1a00008 	mov	r0, r8
 450:	e3401000 	movt	r1, #0
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 454:	e5835000 	str	r5, [r3]
		np->name = of_get_property(np, "name", NULL);
 458:	ebfffffe 	bl	0 <of_get_property>
		np->type = of_get_property(np, "device_type", NULL);
 45c:	e1a02005 	mov	r2, r5
 460:	e3001000 	movw	r1, #0
 464:	e3401000 	movt	r1, #0
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
 468:	e5880000 	str	r0, [r8]
		np->type = of_get_property(np, "device_type", NULL);
 46c:	e1a00008 	mov	r0, r8
 470:	ebfffffe 	bl	0 <of_get_property>

		if (!np->name)
 474:	e5983000 	ldr	r3, [r8]
 478:	e1530005 	cmp	r3, r5
			np->name = "<NULL>";
 47c:	03003000 	movweq	r3, #0
 480:	03403000 	movteq	r3, #0
 484:	05883000 	streq	r3, [r8]
		if (!np->type)
 488:	e3500000 	cmp	r0, #0
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
 48c:	e5880004 	str	r0, [r8, #4]

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
 490:	03003000 	movweq	r3, #0
 494:	03403000 	movteq	r3, #0
 498:	05883004 	streq	r3, [r8, #4]
 49c:	eaffff75 	b	278 <unflatten_dt_node+0x218>
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a0:	e59b2008 	ldr	r2, [fp, #8]
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
 4a4:	e3a09001 	mov	r9, #1
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a8:	e0823003 	add	r3, r2, r3
 4ac:	e58b3008 	str	r3, [fp, #8]
 4b0:	e2834058 	add	r4, r3, #88	; 0x58
 4b4:	eaffff10 	b	fc <unflatten_dt_node+0x9c>
 4b8:	e1a04001 	mov	r4, r1
 4bc:	eaffff99 	b	328 <unflatten_dt_node+0x2c8>

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
 4c0:	e3001000 	movw	r1, #0
 4c4:	e288002c 	add	r0, r8, #44	; 0x2c
 4c8:	e3401000 	movt	r1, #0
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4cc:	e288a058 	add	sl, r8, #88	; 0x58
 4d0:	ebfffffe 	bl	0 <kobject_init>
		if (new_format) {
 4d4:	e3590000 	cmp	r9, #0
	node->fwnode.type = FWNODE_OF;
 4d8:	e3a03001 	mov	r3, #1
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4dc:	e588a00c 	str	sl, [r8, #12]
 4e0:	e5883010 	str	r3, [r8, #16]
		if (new_format) {
 4e4:	0a00000d 	beq	520 <unflatten_dt_node+0x4c0>
			/* rebuild full path for new format */
			if (dad && dad->parent) {
 4e8:	e3550000 	cmp	r5, #0
 4ec:	0a00001a 	beq	55c <unflatten_dt_node+0x4fc>
 4f0:	e5953020 	ldr	r3, [r5, #32]
 4f4:	e3530000 	cmp	r3, #0
 4f8:	0a000017 	beq	55c <unflatten_dt_node+0x4fc>
				strcpy(fn, dad->full_name);
 4fc:	e595100c 	ldr	r1, [r5, #12]
 500:	e1a0000a 	mov	r0, sl
 504:	ebfffffe 	bl	0 <strcpy>
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
 508:	e1a0000a 	mov	r0, sl
 50c:	ebfffffe 	bl	0 <strlen>
 510:	e08a0000 	add	r0, sl, r0
			}
			*(fn++) = '/';
 514:	e280a001 	add	sl, r0, #1
 518:	e3a0302f 	mov	r3, #47	; 0x2f
 51c:	e5c03000 	strb	r3, [r0]
		}
		memcpy(fn, pathp, l);
 520:	e1a0000a 	mov	r0, sl
 524:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 528:	e51b1060 	ldr	r1, [fp, #-96]	; 0xffffffa0

		prev_pp = &np->properties;
 52c:	e2883018 	add	r3, r8, #24
 530:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
 534:	ebfffffe 	bl	0 <memcpy>

		prev_pp = &np->properties;
		if (dad != NULL) {
 538:	e3550000 	cmp	r5, #0
			np->parent = dad;
 53c:	15885020 	strne	r5, [r8, #32]
			np->sibling = dad->child;
 540:	15953024 	ldrne	r3, [r5, #36]	; 0x24
 544:	15883028 	strne	r3, [r8, #40]	; 0x28
			dad->child = np;
 548:	15858024 	strne	r8, [r5, #36]	; 0x24
 54c:	eafffef2 	b	11c <unflatten_dt_node+0xbc>
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
 550:	e1a00008 	mov	r0, r8

	if (nodepp)
		*nodepp = np;

	return mem;
}
 554:	e24bd028 	sub	sp, fp, #40	; 0x28
 558:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 55c:	e1a0000a 	mov	r0, sl
 560:	eaffffeb 	b	514 <unflatten_dt_node+0x4b4>
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 564:	e1a0c002 	mov	ip, r2
 568:	e51b1060 	ldr	r1, [fp, #-96]	; 0xffffffa0
 56c:	eaffff95 	b	3c8 <unflatten_dt_node+0x368>
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
 570:	e3000000 	movw	r0, #0
 574:	e3400000 	movt	r0, #0
 578:	e1a05007 	mov	r5, r7
 57c:	e51b804c 	ldr	r8, [fp, #-76]	; 0xffffffb4
 580:	ebfffffe 	bl	0 <printk>
			break;
 584:	eaffff36 	b	264 <unflatten_dt_node+0x204>
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
 588:	e1a01000 	mov	r1, r0
 58c:	e3000000 	movw	r0, #0
 590:	e3400000 	movt	r0, #0
 594:	ebfffffe 	bl	0 <printk>
 598:	eaffff62 	b	328 <unflatten_dt_node+0x2c8>

0000059c <__unflatten_device_tree>:
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 59c:	e1a0c00d 	mov	ip, sp
 5a0:	e92ddbf0 	push	{r4, r5, r6, r7, r8, r9, fp, ip, lr, pc}
 5a4:	e24cb004 	sub	fp, ip, #4
 5a8:	e24dd018 	sub	sp, sp, #24
 5ac:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 5b0:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5b4:	e2508000 	subs	r8, r0, #0
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 5b8:	e1a09001 	mov	r9, r1
 5bc:	e1a07002 	mov	r7, r2
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5c0:	0a000029 	beq	66c <__unflatten_device_tree+0xd0>
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
 5c4:	ebfffffe 	bl	0 <fdt_check_header>
 5c8:	e2505000 	subs	r5, r0, #0
 5cc:	1a00003c 	bne	6c4 <__unflatten_device_tree+0x128>
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5d0:	e24b6024 	sub	r6, fp, #36	; 0x24
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5d4:	e3a01001 	mov	r1, #1
 5d8:	e1a03005 	mov	r3, r5
 5dc:	e58d1008 	str	r1, [sp, #8]
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5e0:	e5265004 	str	r5, [r6, #-4]!
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5e4:	e1a01005 	mov	r1, r5
 5e8:	e1a02006 	mov	r2, r6
 5ec:	e58d5004 	str	r5, [sp, #4]
 5f0:	e58d5000 	str	r5, [sp]
 5f4:	e1a00008 	mov	r0, r8
 5f8:	ebfffe98 	bl	60 <unflatten_dt_node>
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 5fc:	e3a02004 	mov	r2, #4
 600:	e3a03000 	mov	r3, #0
 604:	e1a01005 	mov	r1, r5
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
 608:	e2800003 	add	r0, r0, #3
 60c:	e3c04003 	bic	r4, r0, #3

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 610:	e2840004 	add	r0, r4, #4
 614:	e12fff37 	blx	r7
	memset(mem, 0, size);
 618:	e3540000 	cmp	r4, #0
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 61c:	e1a07000 	mov	r7, r0
	memset(mem, 0, size);
 620:	1a000013 	bne	674 <__unflatten_device_tree+0xd8>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 624:	e1a02006 	mov	r2, r6
 628:	e1a00008 	mov	r0, r8

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 62c:	e30a1dde 	movw	r1, #44510	; 0xadde

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 630:	e1a03004 	mov	r3, r4

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 634:	e34e1fbe 	movt	r1, #61374	; 0xefbe
 638:	e5871000 	str	r1, [r7]

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 63c:	e1a01007 	mov	r1, r7
 640:	e58d4008 	str	r4, [sp, #8]
 644:	e58d4004 	str	r4, [sp, #4]
 648:	e58d9000 	str	r9, [sp]
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 64c:	e50b4028 	str	r4, [fp, #-40]	; 0xffffffd8
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 650:	ebfffe82 	bl	60 <unflatten_dt_node>
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 654:	e5971000 	ldr	r1, [r7]
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 658:	e6bf1f31 	rev	r1, r1
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 65c:	e30b3eef 	movw	r3, #48879	; 0xbeef
 660:	e34d3ead 	movt	r3, #57005	; 0xdead
 664:	e1510003 	cmp	r1, r3
 668:	1a000011 	bne	6b4 <__unflatten_device_tree+0x118>
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
 66c:	e24bd024 	sub	sp, fp, #36	; 0x24
 670:	e89dabf0 	ldm	sp, {r4, r5, r6, r7, r8, r9, fp, sp, pc}

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
 674:	e1a01004 	mov	r1, r4
 678:	ebfffffe 	bl	0 <__memzero>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 67c:	e1a02006 	mov	r2, r6
 680:	e1a00008 	mov	r0, r8

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 684:	e30a1dde 	movw	r1, #44510	; 0xadde

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 688:	e1a03005 	mov	r3, r5

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 68c:	e34e1fbe 	movt	r1, #61374	; 0xefbe
 690:	e7871004 	str	r1, [r7, r4]

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 694:	e1a01007 	mov	r1, r7
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 698:	e50b5028 	str	r5, [fp, #-40]	; 0xffffffd8
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 69c:	e58d9000 	str	r9, [sp]
 6a0:	e58d5008 	str	r5, [sp, #8]
 6a4:	e58d5004 	str	r5, [sp, #4]
 6a8:	ebfffe6c 	bl	60 <unflatten_dt_node>
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 6ac:	e7971004 	ldr	r1, [r7, r4]
 6b0:	eaffffe8 	b	658 <__unflatten_device_tree+0xbc>
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
 6b4:	e3000000 	movw	r0, #0
 6b8:	e3400000 	movt	r0, #0
 6bc:	ebfffffe 	bl	0 <printk>
 6c0:	eaffffe9 	b	66c <__unflatten_device_tree+0xd0>
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
 6c4:	e3000000 	movw	r0, #0
 6c8:	e3400000 	movt	r0, #0
 6cc:	ebfffffe 	bl	0 <printk>
		return;
 6d0:	eaffffe5 	b	66c <__unflatten_device_tree+0xd0>

000006d4 <of_fdt_unflatten_tree>:
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6d4:	e1a0c00d 	mov	ip, sp
 6d8:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
 6dc:	e24cb004 	sub	fp, ip, #4
 6e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 6e4:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	mutex_lock(&of_fdt_unflatten_mutex);
 6e8:	e59f402c 	ldr	r4, [pc, #44]	; 71c <of_fdt_unflatten_tree+0x48>
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6ec:	e1a05000 	mov	r5, r0
 6f0:	e1a06001 	mov	r6, r1
	mutex_lock(&of_fdt_unflatten_mutex);
 6f4:	e1a00004 	mov	r0, r4
 6f8:	ebfffffe 	bl	0 <mutex_lock>
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
 6fc:	e1a00005 	mov	r0, r5
 700:	e1a01006 	mov	r1, r6
 704:	e3002000 	movw	r2, #0
 708:	e3402000 	movt	r2, #0
 70c:	ebffffa2 	bl	59c <__unflatten_device_tree>
	mutex_unlock(&of_fdt_unflatten_mutex);
 710:	e1a00004 	mov	r0, r4
 714:	ebfffffe 	bl	0 <mutex_unlock>
 718:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
 71c:	0000001c 	andeq	r0, r0, ip, lsl r0

00000720 <of_fdt_limit_memory>:
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 720:	e1a0c00d 	mov	ip, sp
 724:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
 728:	e24cb004 	sub	fp, ip, #4
 72c:	e24dd010 	sub	sp, sp, #16
 730:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 734:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 738:	e3004000 	movw	r4, #0
 73c:	e3404000 	movt	r4, #0
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 740:	e1a07000 	mov	r7, r0
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 744:	e3001000 	movw	r1, #0
 748:	e5940000 	ldr	r0, [r4]
 74c:	e3401000 	movt	r1, #0
 750:	ebfffffe 	bl	0 <fdt_path_offset>
	if (root_offset < 0)
 754:	e2506000 	subs	r6, r0, #0
 758:	ba000027 	blt	7fc <of_fdt_limit_memory+0xdc>
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
 75c:	e3a03000 	mov	r3, #0
 760:	e3002000 	movw	r2, #0
 764:	e1a01006 	mov	r1, r6
 768:	e3402000 	movt	r2, #0
 76c:	e5940000 	ldr	r0, [r4]
 770:	ebfffffe 	bl	0 <fdt_getprop>
				"#address-cells", NULL);
	if (addr_prop)
 774:	e2503000 	subs	r3, r0, #0
 778:	0a00002c 	beq	830 <of_fdt_limit_memory+0x110>
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 77c:	e593c000 	ldr	ip, [r3]
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 780:	e1a01006 	mov	r1, r6
 784:	e3002000 	movw	r2, #0
 788:	e3a03000 	mov	r3, #0
 78c:	e3402000 	movt	r2, #0
 790:	e5940000 	ldr	r0, [r4]
 794:	e6bf5f3c 	rev	r5, ip
 798:	ebfffffe 	bl	0 <fdt_getprop>
				"#size-cells", NULL);
	if (size_prop)
 79c:	e3500000 	cmp	r0, #0
 7a0:	0285c001 	addeq	ip, r5, #1
 7a4:	01a0510c 	lsleq	r5, ip, #2
 7a8:	0a000003 	beq	7bc <of_fdt_limit_memory+0x9c>
		nr_size_cells = fdt32_to_cpu(*size_prop);
 7ac:	e5903000 	ldr	r3, [r0]
 7b0:	e6bfcf33 	rev	ip, r3
 7b4:	e08cc005 	add	ip, ip, r5
 7b8:	e1a0510c 	lsl	r5, ip, #2

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
 7bc:	e3001000 	movw	r1, #0
 7c0:	e5940000 	ldr	r0, [r4]
 7c4:	e3401000 	movt	r1, #0
 7c8:	ebfffffe 	bl	0 <fdt_path_offset>
	if (memory > 0) {
 7cc:	e2506000 	subs	r6, r0, #0
 7d0:	da000009 	ble	7fc <of_fdt_limit_memory+0xdc>
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
 7d4:	e3002000 	movw	r2, #0
 7d8:	e24b3020 	sub	r3, fp, #32
 7dc:	e3402000 	movt	r2, #0
 7e0:	e1a01006 	mov	r1, r6
 7e4:	e5940000 	ldr	r0, [r4]
 7e8:	ebfffffe 	bl	0 <fdt_getprop>
		if (len > limit*cell_size) {
 7ec:	e00c0795 	mul	ip, r5, r7
 7f0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 7f4:	e15c0002 	cmp	ip, r2
 7f8:	ba000001 	blt	804 <of_fdt_limit_memory+0xe4>
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
 7fc:	e24bd01c 	sub	sp, fp, #28
 800:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 804:	e594e000 	ldr	lr, [r4]
 808:	e1a03000 	mov	r3, r0
 80c:	e58dc000 	str	ip, [sp]
 810:	e1a01006 	mov	r1, r6
 814:	e3002000 	movw	r2, #0
 818:	e3402000 	movt	r2, #0
 81c:	e1a0000e 	mov	r0, lr

	memory = fdt_path_offset(initial_boot_params, "/memory");
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
 820:	e50bc020 	str	ip, [fp, #-32]	; 0xffffffe0
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 824:	ebfffffe 	bl	0 <fdt_setprop>
					len);
		}
	}
}
 828:	e24bd01c 	sub	sp, fp, #28
 82c:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 830:	e1a01006 	mov	r1, r6
 834:	e3002000 	movw	r2, #0
 838:	e5940000 	ldr	r0, [r4]
 83c:	e3402000 	movt	r2, #0
 840:	ebfffffe 	bl	0 <fdt_getprop>
				"#size-cells", NULL);
	if (size_prop)
 844:	e3500000 	cmp	r0, #0
 848:	03a05008 	moveq	r5, #8
 84c:	0affffda 	beq	7bc <of_fdt_limit_memory+0x9c>
		nr_size_cells = fdt32_to_cpu(*size_prop);
 850:	e5903000 	ldr	r3, [r0]
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 854:	e3a05001 	mov	r5, #1
 858:	eaffffd4 	b	7b0 <of_fdt_limit_memory+0x90>

0000085c <of_fdt_is_compatible>:
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
 85c:	e1a0c00d 	mov	ip, sp
 860:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
 864:	e24cb004 	sub	fp, ip, #4
 868:	e24dd008 	sub	sp, sp, #8
 86c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 870:	ebfffffe 	bl	0 <__gnu_mcount_nc>
 874:	e1a07002 	mov	r7, r2
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
 878:	e24b3020 	sub	r3, fp, #32
 87c:	e3002000 	movw	r2, #0
 880:	e3402000 	movt	r2, #0
 884:	ebfffffe 	bl	0 <fdt_getprop>
	if (cp == NULL)
 888:	e2504000 	subs	r4, r0, #0
 88c:	0a000015 	beq	8e8 <of_fdt_is_compatible+0x8c>
		return 0;
	while (cplen > 0) {
 890:	e51b5020 	ldr	r5, [fp, #-32]	; 0xffffffe0
 894:	e3550000 	cmp	r5, #0
 898:	da000012 	ble	8e8 <of_fdt_is_compatible+0x8c>
 89c:	e3a06000 	mov	r6, #0
 8a0:	ea000006 	b	8c0 <of_fdt_is_compatible+0x64>
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
 8a4:	ebfffffe 	bl	0 <strlen>
 8a8:	e2800001 	add	r0, r0, #1
		cp += l;
		cplen -= l;
 8ac:	e0455000 	sub	r5, r5, r0
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
 8b0:	e0844000 	add	r4, r4, r0
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8b4:	e3550000 	cmp	r5, #0
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
 8b8:	e50b5020 	str	r5, [fp, #-32]	; 0xffffffe0
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8bc:	da000009 	ble	8e8 <of_fdt_is_compatible+0x8c>
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8c0:	e1a01007 	mov	r1, r7
 8c4:	e1a00004 	mov	r0, r4
 8c8:	ebfffffe 	bl	0 <strcasecmp>

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
 8cc:	e2866001 	add	r6, r6, #1
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d0:	e3500000 	cmp	r0, #0
			return score;
		l = strlen(cp) + 1;
 8d4:	e1a00004 	mov	r0, r4
	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d8:	1afffff1 	bne	8a4 <of_fdt_is_compatible+0x48>
			return score;
 8dc:	e1a00006 	mov	r0, r6
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8e0:	e24bd01c 	sub	sp, fp, #28
 8e4:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
 8e8:	e3a00000 	mov	r0, #0
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8ec:	e24bd01c 	sub	sp, fp, #28
 8f0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

000008f4 <of_fdt_is_big_endian>:
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
 8f4:	e1a0c00d 	mov	ip, sp
 8f8:	e92dd800 	push	{fp, ip, lr, pc}
 8fc:	e24cb004 	sub	fp, ip, #4
 900:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 904:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	if (fdt_getprop(blob, node, "big-endian", NULL))
 908:	e3a03000 	mov	r3, #0
 90c:	e3002000 	movw	r2, #0
 910:	e3402000 	movt	r2, #0
 914:	ebfffffe 	bl	0 <fdt_getprop>
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
 918:	e2900000 	adds	r0, r0, #0
 91c:	13a00001 	movne	r0, #1
 920:	e89da800 	ldm	sp, {fp, sp, pc}

00000924 <of_fdt_match>:
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 924:	e1a0c00d 	mov	ip, sp
 928:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
 92c:	e24cb004 	sub	fp, ip, #4
 930:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
 934:	ebfffffe 	bl	0 <__gnu_mcount_nc>
	unsigned int tmp, score = 0;

	if (!compat)
 938:	e2525000 	subs	r5, r2, #0
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 93c:	e1a06000 	mov	r6, r0
 940:	e1a07001 	mov	r7, r1
	unsigned int tmp, score = 0;

	if (!compat)
 944:	0a000014 	beq	99c <of_fdt_match+0x78>
		return 0;

	while (*compat) {
 948:	e5952000 	ldr	r2, [r5]
 94c:	e3520000 	cmp	r2, #0
 950:	0a000013 	beq	9a4 <of_fdt_match+0x80>
 954:	e3a04000 	mov	r4, #0
		tmp = of_fdt_is_compatible(blob, node, *compat);
 958:	e1a01007 	mov	r1, r7
 95c:	e1a00006 	mov	r0, r6
 960:	ebfffffe 	bl	85c <of_fdt_is_compatible>
		if (tmp && (score == 0 || (tmp < score)))
 964:	e3500000 	cmp	r0, #0
 968:	0a000006 	beq	988 <of_fdt_match+0x64>
 96c:	e1500004 	cmp	r0, r4
 970:	23a03000 	movcs	r3, #0
 974:	33a03001 	movcc	r3, #1
 978:	e3540000 	cmp	r4, #0
 97c:	03833001 	orreq	r3, r3, #1
 980:	e3530000 	cmp	r3, #0
 984:	11a04000 	movne	r4, r0
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 988:	e5b52004 	ldr	r2, [r5, #4]!
 98c:	e3520000 	cmp	r2, #0
 990:	1afffff0 	bne	958 <of_fdt_match+0x34>
 994:	e1a00004 	mov	r0, r4
 998:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
 99c:	e1a00005 	mov	r0, r5
			score = tmp;
		compat++;
	}

	return score;
}
 9a0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 9a4:	e1a00002 	mov	r0, r2
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
 9a8:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

Disassembly of section .init.text:

00000000 <setup_of_earlycon>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	e1a0c00d 	mov	ip, sp
   4:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
   8:	e24cb004 	sub	fp, ip, #4
   c:	e24dd008 	sub	sp, sp, #8
  10:	e3500000 	cmp	r0, #0
  14:	13a06000 	movne	r6, #0
  18:	1a000047 	bne	13c <setup_of_earlycon+0x13c>
  1c:	e3003000 	movw	r3, #0
	return kzalloc(size, GFP_KERNEL);
}
  20:	e3403000 	movt	r3, #0

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	e3001000 	movw	r1, #0
  28:	e3401000 	movt	r1, #0
  2c:	e5935000 	ldr	r5, [r3]
  30:	e1a00005 	mov	r0, r5
  34:	ebfffffe 	bl	0 <fdt_path_offset>
	memcpy(buf, initial_boot_params + off, count);
  38:	e2506000 	subs	r6, r0, #0
  3c:	aa000007 	bge	60 <setup_of_earlycon+0x60>
  40:	e3001000 	movw	r1, #0

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	e1a00005 	mov	r0, r5
	memcpy(buf, initial_boot_params + off, count);
  48:	e3401000 	movt	r1, #0
  4c:	ebfffffe 	bl	0 <fdt_path_offset>
  50:	e2506000 	subs	r6, r0, #0
  54:	aa000001 	bge	60 <setup_of_earlycon+0x60>
	return count;
}
  58:	e3e06001 	mvn	r6, #1
  5c:	ea000036 	b	13c <setup_of_earlycon+0x13c>
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	e3002000 	movw	r2, #0
  64:	e1a01006 	mov	r1, r6
  68:	e3402000 	movt	r2, #0
  6c:	e24b3020 	sub	r3, fp, #32
  70:	e1a00005 	mov	r0, r5
  74:	ebfffffe 	bl	0 <fdt_getprop>
  78:	e2504000 	subs	r4, r0, #0
  7c:	1a000007 	bne	a0 <setup_of_earlycon+0xa0>
  80:	e24b3020 	sub	r3, fp, #32
  84:	e1a01006 	mov	r1, r6
  88:	e3002000 	movw	r2, #0
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	e1a00005 	mov	r0, r5
  90:	e3402000 	movt	r2, #0
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	ebfffffe 	bl	0 <fdt_getprop>
  98:	e2504000 	subs	r4, r0, #0
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	0affffed 	beq	58 <setup_of_earlycon+0x58>
	if (!pathp)
  a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  a4:	e3530000 	cmp	r3, #0
  a8:	0affffea 	beq	58 <setup_of_earlycon+0x58>
  ac:	e1a00004 	mov	r0, r4
		return mem;

	allocl = ++l;
  b0:	e3a0103a 	mov	r1, #58	; 0x3a
  b4:	ebfffffe 	bl	0 <strchrnul>
  b8:	e1a01004 	mov	r1, r4
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	e0402004 	sub	r2, r0, r4
  c0:	e1a00005 	mov	r0, r5
  c4:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	ebfffffe 	bl	0 <fdt_path_offset_namelen>
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	e2507000 	subs	r7, r0, #0
		new_format = 1;
		if (fpsize == 0) {
  d0:	a3004000 	movwge	r4, #0
  d4:	a3404000 	movtge	r4, #0
  d8:	aa000005 	bge	f4 <setup_of_earlycon+0xf4>
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	e3e06012 	mvn	r6, #18
  e0:	ea000015 	b	13c <setup_of_earlycon+0x13c>
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	ebfffffe 	bl	0 <fdt_node_check_compatible>
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	e2506000 	subs	r6, r0, #0
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	0a000007 	beq	110 <setup_of_earlycon+0x110>
			pathp = "";
  f0:	e28440c4 	add	r4, r4, #196	; 0xc4
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	e5d43040 	ldrb	r3, [r4, #64]	; 0x40
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	e2842040 	add	r2, r4, #64	; 0x40
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	e1a01007 	mov	r1, r7
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	e1a00005 	mov	r0, r5
 104:	e3530000 	cmp	r3, #0
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	1afffff5 	bne	e4 <setup_of_earlycon+0xe4>
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	eafffff2 	b	dc <setup_of_earlycon+0xdc>
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	e1a01007 	mov	r1, r7
 114:	e1a00005 	mov	r0, r5
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	ebfffffe 	bl	0 <fdt_translate_address>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	e3e03000 	mvn	r3, #0
 120:	e3e02000 	mvn	r2, #0
 124:	e1510003 	cmp	r1, r3
 128:	01500002 	cmpeq	r0, r2
 12c:	03e06005 	mvneq	r6, #5
 130:	0a000001 	beq	13c <setup_of_earlycon+0x13c>

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	e59410c0 	ldr	r1, [r4, #192]	; 0xc0
 138:	ebfffffe 	bl	0 <of_setup_earlycon>
 13c:	e1a00006 	mov	r0, r6
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	e24bd01c 	sub	sp, fp, #28
 144:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

00000148 <early_init_dt_alloc_memory_arch>:
 148:	e1a0c00d 	mov	ip, sp
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	e92dd800 	push	{fp, ip, lr, pc}
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	e24cb004 	sub	fp, ip, #4
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	ebfffffe 	bl	0 <memblock_alloc>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	e2400481 	sub	r0, r0, #-2130706432	; 0x81000000
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	e89da800 	ldm	sp, {fp, sp, pc}

00000160 <of_fdt_raw_init>:
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	e1a0c00d 	mov	ip, sp
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 168:	e24cb004 	sub	fp, ip, #4
 16c:	e3005000 	movw	r5, #0
 170:	e3405000 	movt	r5, #0
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	e5951000 	ldr	r1, [r5]
 178:	e3510000 	cmp	r1, #0
 17c:	0a00000a 	beq	1ac <of_fdt_raw_init+0x4c>
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	e5914004 	ldr	r4, [r1, #4]
 184:	e3e00000 	mvn	r0, #0
 188:	e6bf4f34 	rev	r4, r4
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	e1a02004 	mov	r2, r4
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	ebfffffe 	bl	0 <crc32_be>
 194:	e5953008 	ldr	r3, [r5, #8]
	res = *mem;
	*mem += size;
 198:	e1500003 	cmp	r0, r3
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	0a000004 	beq	1b4 <of_fdt_raw_init+0x54>
 1a0:	e3000000 	movw	r0, #0
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	e3400000 	movt	r0, #0
 1a8:	ebfffffe 	bl	0 <printk>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	e3a00000 	mov	r0, #0
 1b0:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
 1b4:	e3003000 	movw	r3, #0
 1b8:	e3002000 	movw	r2, #0
 1bc:	e3403000 	movt	r3, #0
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	e3402000 	movt	r2, #0
 1c4:	e1a01003 	mov	r1, r3
 1c8:	e5920000 	ldr	r0, [r2]
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	e5834008 	str	r4, [r3, #8]
 1d0:	ebfffffe 	bl	0 <sysfs_create_bin_file>
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

000001d8 <of_scan_flat_dt>:
 1d8:	e1a0c00d 	mov	ip, sp
 1dc:	e92ddbf0 	push	{r4, r5, r6, r7, r8, r9, fp, ip, lr, pc}
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	e24cb004 	sub	fp, ip, #4
					np->phandle = be32_to_cpup(p);
 1e4:	e24dd008 	sub	sp, sp, #8
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	e3003000 	movw	r3, #0
 1ec:	e3403000 	movt	r3, #0
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	e24b5024 	sub	r5, fp, #36	; 0x24
 1f4:	e3e02000 	mvn	r2, #0
 1f8:	e1a09000 	mov	r9, r0
 1fc:	e5937000 	ldr	r7, [r3]
 200:	e1a08001 	mov	r8, r1
				np->phandle = be32_to_cpup(p);
 204:	e5252004 	str	r2, [r5, #-4]!
 208:	e1a01002 	mov	r1, r2
 20c:	e1a02005 	mov	r2, r5
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	e3a06000 	mov	r6, #0
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	e1a00007 	mov	r0, r7
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	ebfffffe 	bl	0 <fdt_next_node>
			pp->length = sz;
 21c:	e1a04000 	mov	r4, r0
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	e3a02000 	mov	r2, #0
			prev_pp = &pp->next;
 224:	e1540002 	cmp	r4, r2
 228:	e1a01004 	mov	r1, r4
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	e1a00007 	mov	r0, r7
 230:	ba000017 	blt	294 <of_scan_flat_dt+0xbc>
 234:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	e1530002 	cmp	r3, r2
 23c:	a1560002 	cmpge	r6, r2
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	1a000013 	bne	294 <of_scan_flat_dt+0xbc>
 244:	ebfffffe 	bl	0 <fdt_get_name>
 248:	e5d01000 	ldrb	r1, [r0]
 24c:	e1a06000 	mov	r6, r0
 250:	e351002f 	cmp	r1, #47	; 0x2f
 254:	1a000002 	bne	264 <of_scan_flat_dt+0x8c>
 258:	ebfffffe 	bl	0 <strrchr>
 25c:	e3500000 	cmp	r0, #0
 260:	12806001 	addne	r6, r0, #1
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	e1a01006 	mov	r1, r6
 268:	e1a03008 	mov	r3, r8
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 270:	e1a00004 	mov	r0, r4
 274:	e12fff39 	blx	r9
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	e1a01004 	mov	r1, r4
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	e1a02005 	mov	r2, r5
 280:	e1a06000 	mov	r6, r0
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	e1a00007 	mov	r0, r7
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	ebfffffe 	bl	0 <fdt_next_node>
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	e1a04000 	mov	r4, r0
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	eaffffe2 	b	220 <of_scan_flat_dt+0x48>
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	e1a00006 	mov	r0, r6
 298:	e24bd024 	sub	sp, fp, #36	; 0x24
	if (depth < 0)
 29c:	e89dabf0 	ldm	sp, {r4, r5, r6, r7, r8, r9, fp, sp, pc}

000002a0 <of_get_flat_dt_root>:
 2a0:	e1a0c00d 	mov	ip, sp
		depth = 0;
 2a4:	e92dd800 	push	{fp, ip, lr, pc}
 2a8:	e24cb004 	sub	fp, ip, #4
 2ac:	e3a00000 	mov	r0, #0
 2b0:	e89da800 	ldm	sp, {fp, sp, pc}

000002b4 <of_get_flat_dt_size>:
	while (*poffset > 0 && depth > old_depth)
 2b4:	e1a0c00d 	mov	ip, sp
 2b8:	e92dd800 	push	{fp, ip, lr, pc}
 2bc:	e24cb004 	sub	fp, ip, #4
 2c0:	e3003000 	movw	r3, #0
 2c4:	e3403000 	movt	r3, #0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	e5933000 	ldr	r3, [r3]
 2cc:	e5930004 	ldr	r0, [r3, #4]
 2d0:	e6bf0f30 	rev	r0, r0
 2d4:	e89da800 	ldm	sp, {fp, sp, pc}

000002d8 <of_get_flat_dt_prop>:
 2d8:	e1a0c00d 	mov	ip, sp
 2dc:	e92dd800 	push	{fp, ip, lr, pc}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	e24cb004 	sub	fp, ip, #4
 2e4:	e300c000 	movw	ip, #0
 2e8:	e340c000 	movt	ip, #0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	e1a03002 	mov	r3, r2
 2f0:	e1a02001 	mov	r2, r1
 2f4:	e1a01000 	mov	r1, r0
 2f8:	e59c0000 	ldr	r0, [ip]
 2fc:	ebfffffe 	bl	0 <fdt_getprop>
 300:	e89da800 	ldm	sp, {fp, sp, pc}

00000304 <early_init_dt_scan_root>:
 304:	e1a0c00d 	mov	ip, sp
 308:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 30c:	e24cb004 	sub	fp, ip, #4

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	e3520000 	cmp	r2, #0
 314:	e1a05000 	mov	r5, r0
 318:	1a000017 	bne	37c <early_init_dt_scan_root+0x78>
 31c:	e3004000 	movw	r4, #0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	e3404000 	movt	r4, #0
 324:	e3001000 	movw	r1, #0

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	e3401000 	movt	r1, #0
 32c:	e3a03001 	mov	r3, #1
 330:	e5843000 	str	r3, [r4]
 334:	e5843004 	str	r3, [r4, #4]
 338:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 33c:	e3001000 	movw	r1, #0
		struct device_node *child = np->child;
		np->child = NULL;
 340:	e3a02000 	mov	r2, #0
 344:	e3401000 	movt	r1, #0
 348:	e3500000 	cmp	r0, #0
		while (child) {
			struct device_node *next = child->sibling;
 34c:	15903000 	ldrne	r3, [r0]
			child->sibling = np->child;
 350:	e1a00005 	mov	r0, r5
 354:	16bf3f33 	revne	r3, r3
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	15843000 	strne	r3, [r4]
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 360:	e3500000 	cmp	r0, #0
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	0a000006 	beq	384 <early_init_dt_scan_root+0x80>
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	e5903000 	ldr	r3, [r0]
		*nodepp = np;
 36c:	e3a00001 	mov	r0, #1
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	e6bf3f33 	rev	r3, r3
		*nodepp = np;
 374:	e5843004 	str	r3, [r4, #4]
 378:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

	return mem;
}
 37c:	e3a00000 	mov	r0, #0
 380:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	e3a00001 	mov	r0, #1
 388:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

0000038c <early_init_dt_scan_chosen>:
 38c:	e1a0c00d 	mov	ip, sp
 390:	e92ddbf0 	push	{r4, r5, r6, r7, r8, r9, fp, ip, lr, pc}
 394:	e24cb004 	sub	fp, ip, #4
 398:	e24dd010 	sub	sp, sp, #16
			if ((*p1) == '@')
 39c:	e16f4f13 	clz	r4, r3
 3a0:	e1a09000 	mov	r9, r0
				pa = p1;
			if ((*p1) == '/')
 3a4:	e1a05001 	mov	r5, r1
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	e1a042a4 	lsr	r4, r4, #5
 3ac:	e1a08003 	mov	r8, r3
				pa = p1;
			if ((*p1) == '/')
 3b0:	e3520001 	cmp	r2, #1
 3b4:	13844001 	orrne	r4, r4, #1
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	e3540000 	cmp	r4, #0
 3bc:	13a00000 	movne	r0, #0
 3c0:	1a00005b 	bne	534 <early_init_dt_scan_chosen+0x1a8>
 3c4:	e3001000 	movw	r1, #0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	e1a00005 	mov	r0, r5
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	e3401000 	movt	r1, #0
 3d0:	ebfffffe 	bl	0 <strcmp>
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	e3500000 	cmp	r0, #0
 3d8:	0a000006 	beq	3f8 <early_init_dt_scan_chosen+0x6c>
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	e1a00005 	mov	r0, r5
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	e3001000 	movw	r1, #0
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	e3401000 	movt	r1, #0
 3e8:	ebfffffe 	bl	0 <strcmp>
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	e3500000 	cmp	r0, #0
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	11a00004 	movne	r0, r4
 3f4:	1a00004e 	bne	534 <early_init_dt_scan_chosen+0x1a8>
			pp->name = "name";
 3f8:	e3001000 	movw	r1, #0
 3fc:	e1a00009 	mov	r0, r9
 400:	e3401000 	movt	r1, #0
			pp->length = sz;
			pp->value = pp + 1;
 404:	e24b2028 	sub	r2, fp, #40	; 0x28
 408:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
			*prev_pp = pp;
 40c:	e3500000 	cmp	r0, #0
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
 410:	0a000030 	beq	4d8 <early_init_dt_scan_chosen+0x14c>
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
 414:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
 418:	e3a04000 	mov	r4, #0
			prev_pp = &pp->next;
 41c:	e2832003 	add	r2, r3, #3
			memcpy(pp->value, ps, sz - 1);
 420:	e3530000 	cmp	r3, #0
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
 424:	b1a03002 	movlt	r3, r2
			memcpy(pp->value, ps, sz - 1);
 428:	e1a03143 	asr	r3, r3, #2
			((char *)pp->value)[sz - 1] = 0;
 42c:	e2433001 	sub	r3, r3, #1
 430:	e3a06000 	mov	r6, #0
 434:	e3730001 	cmn	r3, #1
 438:	14902004 	ldrne	r2, [r0], #4
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 43c:	16bf2f32 	revne	r2, r2
 440:	11864002 	orrne	r4, r6, r2
		np->name = of_get_property(np, "name", NULL);
 444:	1afffff8 	bne	42c <early_init_dt_scan_chosen+0xa0>
 448:	e3001000 	movw	r1, #0
 44c:	e24b2028 	sub	r2, fp, #40	; 0x28
 450:	e3401000 	movt	r1, #0
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 454:	e1a00009 	mov	r0, r9
		np->name = of_get_property(np, "name", NULL);
 458:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
		np->type = of_get_property(np, "device_type", NULL);
 45c:	e3500000 	cmp	r0, #0
 460:	0a00001c 	beq	4d8 <early_init_dt_scan_chosen+0x14c>
 464:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
 468:	e3a06000 	mov	r6, #0
		np->type = of_get_property(np, "device_type", NULL);
 46c:	e2832003 	add	r2, r3, #3
 470:	e3530000 	cmp	r3, #0

		if (!np->name)
 474:	b1a03002 	movlt	r3, r2
 478:	e1a03143 	asr	r3, r3, #2
			np->name = "<NULL>";
 47c:	e2433001 	sub	r3, r3, #1
 480:	e3a02000 	mov	r2, #0
 484:	e3730001 	cmn	r3, #1
		if (!np->type)
 488:	e50b6030 	str	r6, [fp, #-48]	; 0xffffffd0
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
 48c:	e50b2034 	str	r2, [fp, #-52]	; 0xffffffcc

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
 490:	0a000004 	beq	4a8 <early_init_dt_scan_chosen+0x11c>
 494:	e4902004 	ldr	r2, [r0], #4
 498:	e14b63d4 	ldrd	r6, [fp, #-52]	; 0xffffffcc
 49c:	e6bf2f32 	rev	r2, r2
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a0:	e1866002 	orr	r6, r6, r2
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
 4a4:	eafffff4 	b	47c <early_init_dt_scan_chosen+0xf0>
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a8:	e3001000 	movw	r1, #0
 4ac:	e3002000 	movw	r2, #0
 4b0:	e3401000 	movt	r1, #0
 4b4:	e3402000 	movt	r2, #0
 4b8:	e3003000 	movw	r3, #0
 4bc:	e3403000 	movt	r3, #0

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
 4c0:	e2444481 	sub	r4, r4, #-2130706432	; 0x81000000
 4c4:	e2466481 	sub	r6, r6, #-2130706432	; 0x81000000
 4c8:	e5814000 	str	r4, [r1]
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4cc:	e3a01001 	mov	r1, #1
 4d0:	e5826000 	str	r6, [r2]
		if (new_format) {
 4d4:	e5831000 	str	r1, [r3]
	node->fwnode.type = FWNODE_OF;
 4d8:	e24b2028 	sub	r2, fp, #40	; 0x28
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4dc:	e1a00009 	mov	r0, r9
 4e0:	e3001000 	movw	r1, #0
		if (new_format) {
 4e4:	e3401000 	movt	r1, #0
			/* rebuild full path for new format */
			if (dad && dad->parent) {
 4e8:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 4ec:	e2501000 	subs	r1, r0, #0
 4f0:	0a000006 	beq	510 <early_init_dt_scan_chosen+0x184>
 4f4:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 4f8:	e3520000 	cmp	r2, #0
				strcpy(fn, dad->full_name);
 4fc:	da000003 	ble	510 <early_init_dt_scan_chosen+0x184>
 500:	e3520b01 	cmp	r2, #1024	; 0x400
 504:	e1a00008 	mov	r0, r8
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
 508:	a3a02b01 	movge	r2, #1024	; 0x400
 50c:	ebfffffe 	bl	0 <strlcpy>
 510:	e5d83000 	ldrb	r3, [r8]
			}
			*(fn++) = '/';
 514:	e3530000 	cmp	r3, #0
 518:	1a000004 	bne	530 <early_init_dt_scan_chosen+0x1a4>
 51c:	e3001000 	movw	r1, #0
		}
		memcpy(fn, pathp, l);
 520:	e1a00008 	mov	r0, r8
 524:	e3a02b01 	mov	r2, #1024	; 0x400
 528:	e3401000 	movt	r1, #0

		prev_pp = &np->properties;
 52c:	ebfffffe 	bl	0 <strlcpy>
 530:	e3a00001 	mov	r0, #1
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
 534:	e24bd024 	sub	sp, fp, #36	; 0x24

		prev_pp = &np->properties;
		if (dad != NULL) {
 538:	e89dabf0 	ldm	sp, {r4, r5, r6, r7, r8, r9, fp, sp, pc}

0000053c <of_flat_dt_is_compatible>:
			np->parent = dad;
 53c:	e1a0c00d 	mov	ip, sp
			np->sibling = dad->child;
 540:	e92dd800 	push	{fp, ip, lr, pc}
 544:	e24cb004 	sub	fp, ip, #4
			dad->child = np;
 548:	e3003000 	movw	r3, #0
 54c:	e3403000 	movt	r3, #0
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
 550:	e1a02001 	mov	r2, r1

	if (nodepp)
		*nodepp = np;

	return mem;
}
 554:	e1a01000 	mov	r1, r0
 558:	e5930000 	ldr	r0, [r3]
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 55c:	ebfffffe 	bl	85c <early_init_dt_add_memory_arch+0x130>
 560:	e89da800 	ldm	sp, {fp, sp, pc}

00000564 <of_flat_dt_match>:
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 564:	e1a0c00d 	mov	ip, sp
 568:	e92dd800 	push	{fp, ip, lr, pc}
 56c:	e24cb004 	sub	fp, ip, #4
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
 570:	e3003000 	movw	r3, #0
 574:	e3403000 	movt	r3, #0
 578:	e1a02001 	mov	r2, r1
 57c:	e1a01000 	mov	r1, r0
 580:	e5930000 	ldr	r0, [r3]
			break;
 584:	ebfffffe 	bl	924 <early_init_dt_scan_memory+0x68>
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
 588:	e89da800 	ldm	sp, {fp, sp, pc}

0000058c <of_flat_dt_get_machine_name>:
 58c:	e1a0c00d 	mov	ip, sp
 590:	e92dd800 	push	{fp, ip, lr, pc}
 594:	e24cb004 	sub	fp, ip, #4
 598:	e3a02000 	mov	r2, #0
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 59c:	e3001000 	movw	r1, #0
 5a0:	e1a00002 	mov	r0, r2
 5a4:	e3401000 	movt	r1, #0
 5a8:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 5ac:	e2502000 	subs	r2, r0, #0
 5b0:	1a000003 	bne	5c4 <of_flat_dt_get_machine_name+0x38>
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5b4:	e3001000 	movw	r1, #0
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 5b8:	e3401000 	movt	r1, #0
 5bc:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5c0:	e1a02000 	mov	r2, r0
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
 5c4:	e1a00002 	mov	r0, r2
 5c8:	e89da800 	ldm	sp, {fp, sp, pc}

000005cc <of_flat_dt_match_machine>:
 5cc:	e1a0c00d 	mov	ip, sp
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5d0:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5d4:	e24cb004 	sub	fp, ip, #4
 5d8:	e24dd008 	sub	sp, sp, #8
 5dc:	e3e05001 	mvn	r5, #1
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5e0:	e1a04000 	mov	r4, r0
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5e4:	e1a06001 	mov	r6, r1
 5e8:	e24b0024 	sub	r0, fp, #36	; 0x24
 5ec:	e12fff36 	blx	r6
 5f0:	e2507000 	subs	r7, r0, #0
 5f4:	0a00000b 	beq	628 <of_flat_dt_match_machine+0x5c>
 5f8:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 5fc:	e3a00000 	mov	r0, #0
 600:	ebfffffe 	bl	564 <of_flat_dt_match>
 604:	e3500000 	cmp	r0, #0
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
 608:	11550000 	cmpne	r5, r0
 60c:	e1a03000 	mov	r3, r0

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 610:	83a00001 	movhi	r0, #1
 614:	93a00000 	movls	r0, #0
	memset(mem, 0, size);
 618:	e3500000 	cmp	r0, #0
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 61c:	11a05003 	movne	r5, r3
	memset(mem, 0, size);
 620:	11a04007 	movne	r4, r7

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 624:	eaffffef 	b	5e8 <of_flat_dt_match_machine+0x1c>
 628:	e3540000 	cmp	r4, #0

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 62c:	1a000021 	bne	6b8 <of_flat_dt_match_machine+0xec>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 630:	e3000000 	movw	r0, #0

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 634:	e3400000 	movt	r0, #0
 638:	ebfffffe 	bl	0 <printk>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 63c:	e1a00004 	mov	r0, r4
 640:	e3001000 	movw	r1, #0
 644:	e24b2020 	sub	r2, fp, #32
 648:	e3401000 	movt	r1, #0
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 64c:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 650:	e2504000 	subs	r4, r0, #0
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 654:	13005000 	movwne	r5, #0
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 658:	13405000 	movtne	r5, #0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 65c:	1a000004 	bne	674 <of_flat_dt_match_machine+0xa8>
 660:	e3000000 	movw	r0, #0
 664:	e3400000 	movt	r0, #0
 668:	ebfffffe 	bl	0 <printk>
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
 66c:	e3a00000 	mov	r0, #0
 670:	ea000016 	b	6d0 <of_flat_dt_match_machine+0x104>

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
 674:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 678:	e3530000 	cmp	r3, #0

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 67c:	dafffff7 	ble	660 <of_flat_dt_match_machine+0x94>
 680:	e1a01004 	mov	r1, r4

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 684:	e1a00005 	mov	r0, r5

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 688:	ebfffffe 	bl	0 <printk>

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 68c:	e1a00004 	mov	r0, r4
 690:	ebfffffe 	bl	0 <strlen>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 694:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 698:	e2433001 	sub	r3, r3, #1
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 69c:	e0433000 	sub	r3, r3, r0
 6a0:	e1a00004 	mov	r0, r4
 6a4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 6a8:	ebfffffe 	bl	0 <strlen>
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 6ac:	e2800001 	add	r0, r0, #1
 6b0:	e0844000 	add	r4, r4, r0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
 6b4:	eaffffee 	b	674 <of_flat_dt_match_machine+0xa8>
 6b8:	ebfffffe 	bl	58c <of_flat_dt_get_machine_name>
 6bc:	e1a01000 	mov	r1, r0
 6c0:	e3000000 	movw	r0, #0
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
 6c4:	e3400000 	movt	r0, #0
 6c8:	ebfffffe 	bl	0 <printk>
 6cc:	e1a00004 	mov	r0, r4
		return;
 6d0:	e24bd01c 	sub	sp, fp, #28
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6d4:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

000006d8 <dt_mem_next_cell>:
 6d8:	e1a0c00d 	mov	ip, sp
 6dc:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 6e0:	e24cb004 	sub	fp, ip, #4
 6e4:	e5912000 	ldr	r2, [r1]
	mutex_lock(&of_fdt_unflatten_mutex);
 6e8:	e1a0c001 	mov	ip, r1
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6ec:	e1a03000 	mov	r3, r0
 6f0:	e3a01000 	mov	r1, #0
	mutex_lock(&of_fdt_unflatten_mutex);
 6f4:	e3a00000 	mov	r0, #0
 6f8:	e082e103 	add	lr, r2, r3, lsl #2
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
 6fc:	e58ce000 	str	lr, [ip]
 700:	e2433001 	sub	r3, r3, #1
 704:	e1a05000 	mov	r5, r0
 708:	e3730001 	cmn	r3, #1
 70c:	e3a04000 	mov	r4, #0
	mutex_unlock(&of_fdt_unflatten_mutex);
 710:	0a000004 	beq	728 <dt_mem_next_cell+0x50>
 714:	e492c004 	ldr	ip, [r2], #4
 718:	e1a01005 	mov	r1, r5
 71c:	e6bfcf3c 	rev	ip, ip
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 720:	e184000c 	orr	r0, r4, ip
 724:	eafffff5 	b	700 <dt_mem_next_cell+0x28>
 728:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

0000072c <early_init_dt_add_memory_arch>:
 72c:	e1a0c00d 	mov	ip, sp
 730:	e92ddbf0 	push	{r4, r5, r6, r7, r8, r9, fp, ip, lr, pc}
 734:	e24cb004 	sub	fp, ip, #4
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 738:	e24dd010 	sub	sp, sp, #16
 73c:	e1a04000 	mov	r4, r0
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 740:	e1a05001 	mov	r5, r1
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 744:	e1a08002 	mov	r8, r2
 748:	e1a09003 	mov	r9, r3
 74c:	e3a07081 	mov	r7, #129	; 0x81
 750:	e3a03103 	mov	r3, #-1073741824	; 0xc0000000
	if (root_offset < 0)
 754:	e2936481 	adds	r6, r3, #-2130706432	; 0x81000000
 758:	e2a77000 	adc	r7, r7, #0
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
 75c:	e3001000 	movw	r1, #0
 760:	e1cd60f0 	strd	r6, [sp]
 764:	e3401000 	movt	r1, #0
 768:	e3000000 	movw	r0, #0
 76c:	e30023e5 	movw	r2, #997	; 0x3e5
 770:	e3400000 	movt	r0, #0
				"#address-cells", NULL);
	if (addr_prop)
 774:	ebfffffe 	bl	0 <printk>
 778:	e7eb3054 	ubfx	r3, r4, #0, #12
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 77c:	e3530000 	cmp	r3, #0
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 780:	0a000026 	beq	820 <early_init_dt_add_memory_arch+0xf4>
 784:	e3000fff 	movw	r0, #4095	; 0xfff
 788:	e0000004 	and	r0, r0, r4
 78c:	e3a02a01 	mov	r2, #4096	; 0x1000
 790:	e3a01000 	mov	r1, #0
 794:	e0011005 	and	r1, r1, r5
 798:	e14b02fc 	strd	r0, [fp, #-44]	; 0xffffffd4
				"#size-cells", NULL);
	if (size_prop)
 79c:	e0520000 	subs	r0, r2, r0
 7a0:	e3a03000 	mov	r3, #0
 7a4:	e0c31001 	sbc	r1, r3, r1
 7a8:	e1590001 	cmp	r9, r1
		nr_size_cells = fdt32_to_cpu(*size_prop);
 7ac:	01580000 	cmpeq	r8, r0
 7b0:	2a000008 	bcs	7d8 <early_init_dt_add_memory_arch+0xac>
 7b4:	e0988004 	adds	r8, r8, r4
 7b8:	e1a02004 	mov	r2, r4

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
 7bc:	e0a99005 	adc	r9, r9, r5
 7c0:	e1a03005 	mov	r3, r5
 7c4:	e1cd80f0 	strd	r8, [sp]
 7c8:	e3000000 	movw	r0, #0
	if (memory > 0) {
 7cc:	e3400000 	movt	r0, #0
 7d0:	ebfffffe 	bl	0 <printk>
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
 7d4:	ea000036 	b	8b4 <early_init_dt_add_memory_arch+0x188>
 7d8:	e2588a01 	subs	r8, r8, #4096	; 0x1000
 7dc:	e14b02dc 	ldrd	r0, [fp, #-44]	; 0xffffffd4
 7e0:	e2c99000 	sbc	r9, r9, #0
 7e4:	e3002fff 	movw	r2, #4095	; 0xfff
 7e8:	e0922004 	adds	r2, r2, r4
		if (len > limit*cell_size) {
 7ec:	e3a03000 	mov	r3, #0
 7f0:	e0a33005 	adc	r3, r3, r5
 7f4:	e0900008 	adds	r0, r0, r8
 7f8:	e1a04002 	mov	r4, r2
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
 7fc:	e0a11009 	adc	r1, r1, r9
 800:	e3a02a0f 	mov	r2, #61440	; 0xf000
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 804:	e34f2fff 	movt	r2, #65535	; 0xffff
 808:	e1a05003 	mov	r5, r3
 80c:	e0044002 	and	r4, r4, r2
 810:	e3e03000 	mvn	r3, #0
 814:	e0055003 	and	r5, r5, r3
 818:	e1a08000 	mov	r8, r0
 81c:	e1a09001 	mov	r9, r1

	memory = fdt_path_offset(initial_boot_params, "/memory");
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
 820:	e3a02a0f 	mov	r2, #61440	; 0xf000
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 824:	e34f2fff 	movt	r2, #65535	; 0xffff
					len);
		}
	}
}
 828:	e0088002 	and	r8, r8, r2
 82c:	e3e03000 	mvn	r3, #0
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 830:	e0942008 	adds	r2, r4, r8
 834:	e0099003 	and	r9, r9, r3
 838:	e0a53009 	adc	r3, r5, r9
 83c:	e1530007 	cmp	r3, r7
 840:	01520006 	cmpeq	r2, r6
				"#size-cells", NULL);
	if (size_prop)
 844:	2a000006 	bcs	864 <early_init_dt_add_memory_arch+0x138>
 848:	e1cd20f0 	strd	r2, [sp]
 84c:	e3000000 	movw	r0, #0
		nr_size_cells = fdt32_to_cpu(*size_prop);
 850:	e1a02004 	mov	r2, r4
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 854:	e1a03005 	mov	r3, r5
 858:	e3400000 	movt	r0, #0
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
 85c:	ebfffffe 	bl	0 <printk>
 860:	ea000013 	b	8b4 <early_init_dt_add_memory_arch+0x188>
 864:	e1550007 	cmp	r5, r7
 868:	01540006 	cmpeq	r4, r6
 86c:	2a00000b 	bcs	8a0 <early_init_dt_add_memory_arch+0x174>
 870:	e1a02004 	mov	r2, r4
 874:	e1a03005 	mov	r3, r5
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
 878:	e1cd60f0 	strd	r6, [sp]
 87c:	e3000000 	movw	r0, #0
 880:	e3400000 	movt	r0, #0
 884:	ebfffffe 	bl	0 <printk>
	if (cp == NULL)
 888:	e0544006 	subs	r4, r4, r6
 88c:	e0c55007 	sbc	r5, r5, r7
		return 0;
	while (cplen > 0) {
 890:	e0988004 	adds	r8, r8, r4
 894:	e0a99005 	adc	r9, r9, r5
 898:	e1a04006 	mov	r4, r6
 89c:	e1a05007 	mov	r5, r7
 8a0:	e1a02008 	mov	r2, r8
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
 8a4:	e1a03009 	mov	r3, r9
 8a8:	e1a00004 	mov	r0, r4
		cp += l;
		cplen -= l;
 8ac:	e1a01005 	mov	r1, r5
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
 8b0:	ebfffffe 	bl	0 <memblock_add>
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8b4:	e24bd024 	sub	sp, fp, #36	; 0x24
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
 8b8:	e89dabf0 	ldm	sp, {r4, r5, r6, r7, r8, r9, fp, sp, pc}

000008bc <early_init_dt_scan_memory>:
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8bc:	e1a0c00d 	mov	ip, sp
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8c0:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
 8c4:	e24cb004 	sub	fp, ip, #4
 8c8:	e24dd008 	sub	sp, sp, #8

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
 8cc:	e3001000 	movw	r1, #0
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d0:	e3a02000 	mov	r2, #0
			return score;
		l = strlen(cp) + 1;
 8d4:	e3401000 	movt	r1, #0
	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d8:	e1a04000 	mov	r4, r0
			return score;
 8dc:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8e0:	e3500000 	cmp	r0, #0
 8e4:	0a000030 	beq	9ac <early_init_dt_scan_memory+0xf0>
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
 8e8:	e3001000 	movw	r1, #0
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8ec:	e3401000 	movt	r1, #0
 8f0:	ebfffffe 	bl	0 <strcmp>
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
 8f4:	e3500000 	cmp	r0, #0
 8f8:	1a00002b 	bne	9ac <early_init_dt_scan_memory+0xf0>
 8fc:	e3001000 	movw	r1, #0
 900:	e1a00004 	mov	r0, r4
 904:	e3401000 	movt	r1, #0
	if (fdt_getprop(blob, node, "big-endian", NULL))
 908:	e24b2020 	sub	r2, fp, #32
 90c:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 910:	e3500000 	cmp	r0, #0
 914:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
 918:	1a000005 	bne	934 <early_init_dt_scan_memory+0x78>
 91c:	e24b2020 	sub	r2, fp, #32
 920:	e1a00004 	mov	r0, r4
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 924:	e3001000 	movw	r1, #0
 928:	e3401000 	movt	r1, #0
 92c:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 930:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
 934:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
	unsigned int tmp, score = 0;

	if (!compat)
 938:	e3520000 	cmp	r2, #0
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 93c:	0a00001a 	beq	9ac <early_init_dt_scan_memory+0xf0>
 940:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
	unsigned int tmp, score = 0;

	if (!compat)
 944:	e3004000 	movw	r4, #0
		return 0;

	while (*compat) {
 948:	e3404000 	movt	r4, #0
 94c:	e3c33003 	bic	r3, r3, #3
 950:	e0825003 	add	r5, r2, r3
 954:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
		tmp = of_fdt_is_compatible(blob, node, *compat);
 958:	e5940004 	ldr	r0, [r4, #4]
 95c:	e5943000 	ldr	r3, [r4]
 960:	e0452002 	sub	r2, r5, r2
		if (tmp && (score == 0 || (tmp < score)))
 964:	e0803003 	add	r3, r0, r3
 968:	e1530142 	cmp	r3, r2, asr #2
 96c:	ca00000e 	bgt	9ac <early_init_dt_scan_memory+0xf0>
 970:	e24b1024 	sub	r1, fp, #36	; 0x24
 974:	ebfffffe 	bl	6d8 <dt_mem_next_cell>
 978:	e1a06000 	mov	r6, r0
 97c:	e1a07001 	mov	r7, r1
 980:	e5940000 	ldr	r0, [r4]
 984:	e24b1024 	sub	r1, fp, #36	; 0x24
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 988:	ebfffffe 	bl	6d8 <dt_mem_next_cell>
 98c:	e1a02000 	mov	r2, r0
 990:	e1a03001 	mov	r3, r1
 994:	e1921003 	orrs	r1, r2, r3
 998:	0affffed 	beq	954 <early_init_dt_scan_memory+0x98>
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
 99c:	e1a00006 	mov	r0, r6
			score = tmp;
		compat++;
	}

	return score;
}
 9a0:	e1a01007 	mov	r1, r7
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 9a4:	ebfffffe 	bl	72c <early_init_dt_add_memory_arch>
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
 9a8:	eaffffe9 	b	954 <early_init_dt_scan_memory+0x98>
	}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
 9ac:	e3a00000 	mov	r0, #0
 9b0:	e24bd01c 	sub	sp, fp, #28
 9b4:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

000009b8 <early_init_dt_reserve_memory_arch>:
 9b8:	e1a0c00d 	mov	ip, sp
	if (buf)
 9bc:	e92dd800 	push	{fp, ip, lr, pc}
		return 0;
 9c0:	e24cb004 	sub	fp, ip, #4
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
	if (buf)
 9c4:	e5dbc004 	ldrb	ip, [fp, #4]
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
 9c8:	e35c0000 	cmp	ip, #0
 9cc:	0a000001 	beq	9d8 <early_init_dt_reserve_memory_arch+0x20>

	offset = fdt_path_offset(fdt, "/chosen");
 9d0:	ebfffffe 	bl	0 <memblock_remove>
 9d4:	e89da800 	ldm	sp, {fp, sp, pc}
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
 9d8:	ebfffffe 	bl	0 <memblock_reserve>

	offset = fdt_path_offset(fdt, "/chosen");
 9dc:	e89da800 	ldm	sp, {fp, sp, pc}

000009e0 <early_init_fdt_scan_reserved_mem>:
 9e0:	e1a0c00d 	mov	ip, sp
	if (offset < 0)
 9e4:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 9e8:	e24cb004 	sub	fp, ip, #4
		offset = fdt_path_offset(fdt, "/chosen@0");
 9ec:	e24dd018 	sub	sp, sp, #24
 9f0:	e3003000 	movw	r3, #0
 9f4:	e3403000 	movt	r3, #0
 9f8:	e5932000 	ldr	r2, [r3]
	if (offset < 0)
 9fc:	e1a04003 	mov	r4, r3
 a00:	e3520000 	cmp	r2, #0
		return -ENOENT;
 a04:	0a000013 	beq	a58 <early_init_fdt_scan_reserved_mem+0x78>
 a08:	e3a05000 	mov	r5, #0

	p = fdt_getprop(fdt, offset, "stdout-path", &l);
 a0c:	e24b301c 	sub	r3, fp, #28
 a10:	e24b2024 	sub	r2, fp, #36	; 0x24
 a14:	e1a01005 	mov	r1, r5
 a18:	e5940000 	ldr	r0, [r4]
 a1c:	ebfffffe 	bl	0 <fdt_get_mem_rsv>
 a20:	e14b21dc 	ldrd	r2, [fp, #-28]	; 0xffffffe4
	if (!p)
 a24:	e1921003 	orrs	r1, r2, r3
 a28:	0a000005 	beq	a44 <early_init_fdt_scan_reserved_mem+0x64>
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
 a2c:	e3a0c000 	mov	ip, #0
 a30:	e14b02d4 	ldrd	r0, [fp, #-36]	; 0xffffffdc
 a34:	e58dc000 	str	ip, [sp]
 a38:	e2855001 	add	r5, r5, #1
 a3c:	ebfffffe 	bl	9b8 <early_init_dt_reserve_memory_arch>
 a40:	eafffff1 	b	a0c <early_init_fdt_scan_reserved_mem+0x2c>
	if (!p || !l)
 a44:	e3000000 	movw	r0, #0
 a48:	e3a01000 	mov	r1, #0
 a4c:	e3400000 	movt	r0, #0
 a50:	ebfffffe 	bl	1d8 <of_scan_flat_dt>
 a54:	ebfffffe 	bl	0 <fdt_init_reserved_mem>
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a58:	e24bd014 	sub	sp, fp, #20
 a5c:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00000a60 <__fdt_scan_reserved_mem>:
 a60:	e1a0c00d 	mov	ip, sp

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a64:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a68:	e24cb004 	sub	fp, ip, #4

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a6c:	e24dd024 	sub	sp, sp, #36	; 0x24
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a70:	e3006000 	movw	r6, #0

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a74:	e3406000 	movt	r6, #0
	if (offset < 0)
 a78:	e1a09001 	mov	r9, r1
 a7c:	e1a08002 	mov	r8, r2
 a80:	e1a04000 	mov	r4, r0
 a84:	e596300c 	ldr	r3, [r6, #12]
		return -ENODEV;
 a88:	e3530000 	cmp	r3, #0
 a8c:	1a00002c 	bne	b44 <__fdt_scan_reserved_mem+0xe4>

	while (match->compatible[0]) {
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 a90:	e3520001 	cmp	r2, #1
 a94:	0a000001 	beq	aa0 <__fdt_scan_reserved_mem+0x40>
 a98:	e3a05000 	mov	r5, #0
			match++;
 a9c:	ea00009f 	b	d20 <__fdt_scan_reserved_mem+0x2c0>
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
 aa0:	e1a00001 	mov	r0, r1
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 aa4:	e3001000 	movw	r1, #0
 aa8:	e3401000 	movt	r1, #0
 aac:	ebfffffe 	bl	0 <strcmp>
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
 ab0:	e2505000 	subs	r5, r0, #0
 ab4:	1afffff7 	bne	a98 <__fdt_scan_reserved_mem+0x38>
 ab8:	e3001000 	movw	r1, #0
		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
 abc:	e1a02005 	mov	r2, r5
 ac0:	e3401000 	movt	r1, #0
 ac4:	e1a00004 	mov	r0, r4
		if (addr == OF_BAD_ADDR)
 ac8:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 acc:	e3500000 	cmp	r0, #0
 ad0:	0a00008e 	beq	d10 <__fdt_scan_reserved_mem+0x2b0>
 ad4:	e3007000 	movw	r7, #0
			return -ENXIO;
 ad8:	e3407000 	movt	r7, #0
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
		if (addr == OF_BAD_ADDR)
 adc:	e5903000 	ldr	r3, [r0]
			return -ENXIO;

		of_setup_earlycon(addr, match->data);
 ae0:	e5972000 	ldr	r2, [r7]
 ae4:	e6bf3f33 	rev	r3, r3
{
	if (buf)
		return 0;

	return early_init_dt_scan_chosen_serial();
}
 ae8:	e1530002 	cmp	r3, r2
 aec:	1a000087 	bne	d10 <__fdt_scan_reserved_mem+0x2b0>
 af0:	e3001000 	movw	r1, #0
/*
 * called from unflatten_device_tree() to bootstrap devicetree itself
 * Architectures can override this definition if memblock isn't used
 */
void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
{
 af4:	e1a02005 	mov	r2, r5
 af8:	e3401000 	movt	r1, #0
 afc:	e1a00004 	mov	r0, r4
	return __va(memblock_alloc(size, align));
 b00:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
	 * 'unsigned long' cast discard upper word when
	 * phys_addr_t is 64 bit, and makes sure that inline
	 * assembler expression receives 32 bit argument
	 * in place where 'r' 32 bit operand is expected.
	 */
	__pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);
 b04:	e3500000 	cmp	r0, #0
}
 b08:	0a000080 	beq	d10 <__fdt_scan_reserved_mem+0x2b0>
	memcpy(buf, initial_boot_params + off, count);
	return count;
}

static int __init of_fdt_raw_init(void)
{
 b0c:	e5903000 	ldr	r3, [r0]
 b10:	e5972004 	ldr	r2, [r7, #4]
 b14:	e6bf3f33 	rev	r3, r3
	static struct bin_attribute of_fdt_raw_attr =
		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);

	if (!initial_boot_params)
 b18:	e1530002 	cmp	r3, r2
 b1c:	1a00007b 	bne	d10 <__fdt_scan_reserved_mem+0x2b0>
 b20:	e1a00004 	mov	r0, r4
 b24:	e3001000 	movw	r1, #0
 b28:	e1a02005 	mov	r2, r5
 b2c:	e3401000 	movt	r1, #0
		return 0;

	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
 b30:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 b34:	e3500000 	cmp	r0, #0
 b38:	1586800c 	strne	r8, [r6, #12]
 b3c:	1a000077 	bne	d20 <__fdt_scan_reserved_mem+0x2c0>
 b40:	ea000072 	b	d10 <__fdt_scan_reserved_mem+0x2b0>
 b44:	e3520001 	cmp	r2, #1
 b48:	da000073 	ble	d1c <__fdt_scan_reserved_mem+0x2bc>
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
 b4c:	e3001000 	movw	r1, #0
 b50:	e3a02000 	mov	r2, #0
 b54:	e3401000 	movt	r1, #0
		return 0;
 b58:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 b5c:	e2505000 	subs	r5, r0, #0
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b60:	0a00000a 	beq	b90 <__fdt_scan_reserved_mem+0x130>
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b64:	e3001000 	movw	r1, #0
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b68:	e3401000 	movt	r1, #0
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b6c:	ebfffffe 	bl	0 <strcmp>
 b70:	e3500000 	cmp	r0, #0
 b74:	0a000005 	beq	b90 <__fdt_scan_reserved_mem+0x130>
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b78:	e1a00005 	mov	r0, r5
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b7c:	e3001000 	movw	r1, #0
 b80:	e3401000 	movt	r1, #0
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 b84:	ebfffffe 	bl	0 <strcmp>
 b88:	e3500000 	cmp	r0, #0
 b8c:	1affffc1 	bne	a98 <__fdt_scan_reserved_mem+0x38>
 b90:	e3005000 	movw	r5, #0
	const void *blob = initial_boot_params;
 b94:	e3405000 	movt	r5, #0
 b98:	e3001000 	movw	r1, #0
	const char *pathp;
	int offset, rc = 0, depth = -1;
 b9c:	e24b203c 	sub	r2, fp, #60	; 0x3c
 ba0:	e5958004 	ldr	r8, [r5, #4]
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 ba4:	e3401000 	movt	r1, #0
	const void *blob = initial_boot_params;
 ba8:	e5953000 	ldr	r3, [r5]
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 bac:	e1a00004 	mov	r0, r4
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
 bb0:	e0888003 	add	r8, r8, r3

        for (offset = fdt_next_node(blob, -1, &depth);
 bb4:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
 bb8:	e1a08108 	lsl	r8, r8, #2
				     void *data),
			   void *data)
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
 bbc:	e3500000 	cmp	r0, #0

        for (offset = fdt_next_node(blob, -1, &depth);
 bc0:	e1a06000 	mov	r6, r0
 bc4:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
 bc8:	0a000041 	beq	cd4 <__fdt_scan_reserved_mem+0x274>
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bcc:	e51b003c 	ldr	r0, [fp, #-60]	; 0xffffffc4
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
 bd0:	e3500000 	cmp	r0, #0
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bd4:	0a000008 	beq	bfc <__fdt_scan_reserved_mem+0x19c>
 bd8:	e1a01008 	mov	r1, r8
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
 bdc:	ebfffffe 	bl	0 <__aeabi_idivmod>
             offset >= 0 && depth >= 0 && !rc;
 be0:	e3510000 	cmp	r1, #0
 be4:	0a000004 	beq	bfc <__fdt_scan_reserved_mem+0x19c>
 be8:	e1a01009 	mov	r1, r9
 bec:	e3000000 	movw	r0, #0
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bf0:	e3400000 	movt	r0, #0
		if (*pathp == '/')
 bf4:	ebfffffe 	bl	0 <printk>

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bf8:	eaffffa6 	b	a98 <__fdt_scan_reserved_mem+0x38>
		if (*pathp == '/')
 bfc:	e3001000 	movw	r1, #0
 c00:	e3a02000 	mov	r2, #0
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
	const char *tail = strrchr(path, '/');
 c04:	e3401000 	movt	r1, #0
	return tail ? tail + 1 : path;
 c08:	e1a00004 	mov	r0, r4
 c0c:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
 c10:	e300a000 	movw	sl, #0
 c14:	e3a03001 	mov	r3, #1
 c18:	e340a000 	movt	sl, #0
 c1c:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0
 c20:	e2903000 	adds	r3, r0, #0
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
 c24:	13a03001 	movne	r3, #1
 c28:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc

		pathp = fdt_get_name(blob, offset, NULL);
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
 c2c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
 c30:	e1580003 	cmp	r8, r3
 c34:	caffff97 	bgt	a98 <__fdt_scan_reserved_mem+0x38>
 c38:	e24b1038 	sub	r1, fp, #56	; 0x38
 c3c:	e5950004 	ldr	r0, [r5, #4]
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
	}
	return rc;
}
 c40:	ebfffffe 	bl	6d8 <dt_mem_next_cell>
 c44:	e14b03f4 	strd	r0, [fp, #-52]	; 0xffffffcc
 c48:	e24b1038 	sub	r1, fp, #56	; 0x38

/**
 * of_get_flat_dt_root - find the root node in the flat blob
 */
unsigned long __init of_get_flat_dt_root(void)
{
 c4c:	e5950000 	ldr	r0, [r5]
 c50:	ebfffffe 	bl	6d8 <dt_mem_next_cell>
 c54:	e1a06000 	mov	r6, r0
	return 0;
}
 c58:	e1a07001 	mov	r7, r1
 c5c:	e1a03001 	mov	r3, r1

/**
 * of_get_flat_dt_size - Return the total size of the FDT
 */
int __init of_get_flat_dt_size(void)
{
 c60:	e1961007 	orrs	r1, r6, r7
 c64:	e1a02000 	mov	r2, r0
 c68:	1a000005 	bne	c84 <__fdt_scan_reserved_mem+0x224>
	return fdt_totalsize(initial_boot_params);
 c6c:	e1a03a26 	lsr	r3, r6, #20
 c70:	e24b2034 	sub	r2, fp, #52	; 0x34
 c74:	e1a01009 	mov	r1, r9
 c78:	e1a0000a 	mov	r0, sl
}
 c7c:	ebfffffe 	bl	0 <printk>
 c80:	ea000005 	b	c9c <__fdt_scan_reserved_mem+0x23c>
 * This function can be used within scan_flattened_dt callback to get
 * access to properties
 */
const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
				       int *size)
{
 c84:	e51bc044 	ldr	ip, [fp, #-68]	; 0xffffffbc
 c88:	e14b03d4 	ldrd	r0, [fp, #-52]	; 0xffffffcc
 c8c:	e58dc000 	str	ip, [sp]
	return fdt_getprop(initial_boot_params, node, name, size);
 c90:	ebfffffe 	bl	9b8 <early_init_dt_reserve_memory_arch>
 c94:	e3500000 	cmp	r0, #0
 c98:	1afffff3 	bne	c6c <__fdt_scan_reserved_mem+0x20c>
 c9c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 ca0:	e3530000 	cmp	r3, #0
 ca4:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 ca8:	e0433008 	sub	r3, r3, r8
}
 cac:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
 cb0:	0affffdd 	beq	c2c <__fdt_scan_reserved_mem+0x1cc>
 cb4:	e14b23d4 	ldrd	r2, [fp, #-52]	; 0xffffffcc
 cb8:	e1a01009 	mov	r1, r9
	const __be32 *prop;

	if (depth != 0)
 cbc:	e1cd60f0 	strd	r6, [sp]
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
 cc0:	e1a00004 	mov	r0, r4
	const __be32 *prop;

	if (depth != 0)
 cc4:	e3a0c000 	mov	ip, #0
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 cc8:	e50bc040 	str	ip, [fp, #-64]	; 0xffffffc0
 ccc:	ebfffffe 	bl	0 <fdt_reserved_mem_save_node>
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
 cd0:	eaffffd5 	b	c2c <__fdt_scan_reserved_mem+0x1cc>
 cd4:	e1a02000 	mov	r2, r0
	const __be32 *prop;

	if (depth != 0)
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 cd8:	e3001000 	movw	r1, #0
 cdc:	e1a00004 	mov	r0, r4
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 ce0:	e3401000 	movt	r1, #0

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
 ce4:	ebfffffe 	bl	2d8 <of_get_flat_dt_prop>
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 ce8:	e3500000 	cmp	r0, #0
 cec:	0affff69 	beq	a98 <__fdt_scan_reserved_mem+0x38>
 cf0:	e3a02000 	mov	r2, #0

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
 cf4:	e3a03000 	mov	r3, #0
 cf8:	e1a01009 	mov	r1, r9
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 cfc:	e1a00004 	mov	r0, r4
 d00:	e1cd20f0 	strd	r2, [sp]
	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
 d04:	e1a05006 	mov	r5, r6
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 d08:	ebfffffe 	bl	0 <fdt_reserved_mem_save_node>
	if (prop)
 d0c:	ea000003 	b	d20 <__fdt_scan_reserved_mem+0x2c0>
 d10:	e3000000 	movw	r0, #0
 d14:	e3400000 	movt	r0, #0
		dt_root_addr_cells = be32_to_cpup(prop);
 d18:	ebfffffe 	bl	0 <printk>
 d1c:	e3a05001 	mov	r5, #1
 d20:	e1a00005 	mov	r0, r5
 d24:	e24bd028 	sub	sp, fp, #40	; 0x28
				   int depth, void *data)
{
	const __be32 *prop;

	if (depth != 0)
		return 0;
 d28:	e89daff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, pc}

00000d2c <early_init_fdt_reserve_self>:
 d2c:	e1a0c00d 	mov	ip, sp
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (prop)
 d30:	e92dd800 	push	{fp, ip, lr, pc}
		dt_root_addr_cells = be32_to_cpup(prop);
	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);

	/* break now */
	return 1;
}
 d34:	e24cb004 	sub	fp, ip, #4
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
 d38:	e24dd008 	sub	sp, sp, #8
 d3c:	e3003000 	movw	r3, #0
 d40:	e3403000 	movt	r3, #0
 d44:	e5933000 	ldr	r3, [r3]
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d48:	e3530000 	cmp	r3, #0
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
 d4c:	0a000007 	beq	d70 <early_init_fdt_reserve_self+0x44>
 d50:	e3a01081 	mov	r1, #129	; 0x81
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d54:	e2930481 	adds	r0, r3, #-2130706432	; 0x81000000
 d58:	e2a11000 	adc	r1, r1, #0
 d5c:	e5932004 	ldr	r2, [r3, #4]
 d60:	e3a03000 	mov	r3, #0
 d64:	e58d3000 	str	r3, [sp]
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
		return 0;
 d68:	e6bf2f32 	rev	r2, r2
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d6c:	ebfffffe 	bl	9b8 <early_init_dt_reserve_memory_arch>
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 d70:	e24bd00c 	sub	sp, fp, #12
 d74:	e89da800 	ldm	sp, {fp, sp, pc}

00000d78 <early_init_dt_verify>:
 d78:	e1a0c00d 	mov	ip, sp
 d7c:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d80:	e24cb004 	sub	fp, ip, #4
 d84:	e2505000 	subs	r5, r0, #0
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 d88:	1a000001 	bne	d94 <early_init_dt_verify+0x1c>
 d8c:	e3a03000 	mov	r3, #0
 d90:	ea00000c 	b	dc8 <early_init_dt_verify+0x50>
 d94:	ebfffffe 	bl	0 <fdt_check_header>
 d98:	e3500000 	cmp	r0, #0
		return 0;
 d9c:	1afffffa 	bne	d8c <early_init_dt_verify+0x14>
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 da0:	e5952004 	ldr	r2, [r5, #4]
	int len;
	const __be32 *prop;

	pr_debug("Looking for initrd properties... ");

	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
 da4:	e3004000 	movw	r4, #0
 da8:	e3404000 	movt	r4, #0
 dac:	e1a01005 	mov	r1, r5
 db0:	e6bf2f32 	rev	r2, r2
 db4:	e3e00000 	mvn	r0, #0
	if (!prop)
 db8:	e5845000 	str	r5, [r4]
 dbc:	ebfffffe 	bl	0 <crc32_be>
		return;
	start = of_read_number(prop, len/4);
 dc0:	e3a03001 	mov	r3, #1
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
 dc4:	e5840008 	str	r0, [r4, #8]
 dc8:	e1a00003 	mov	r0, r3
 dcc:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00000dd0 <early_init_dt_scan_nodes>:
 dd0:	e1a0c00d 	mov	ip, sp
 dd4:	e92dd800 	push	{fp, ip, lr, pc}
	while (size--)
 dd8:	e24cb004 	sub	fp, ip, #4
		r = (r << 32) | be32_to_cpu(*(cell++));
 ddc:	e3001000 	movw	r1, #0

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
 de0:	e3000000 	movw	r0, #0
 de4:	e3401000 	movt	r1, #0
 de8:	e3400000 	movt	r0, #0
		r = (r << 32) | be32_to_cpu(*(cell++));
 dec:	ebfffffe 	bl	1d8 <of_scan_flat_dt>
 df0:	e3a01000 	mov	r1, #0

	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
 df4:	e3000000 	movw	r0, #0
 df8:	e3400000 	movt	r0, #0
 dfc:	ebfffffe 	bl	1d8 <of_scan_flat_dt>
 e00:	e3000000 	movw	r0, #0
 e04:	e3a01000 	mov	r1, #0
	if (!prop)
 e08:	e3400000 	movt	r0, #0
 e0c:	ebfffffe 	bl	1d8 <of_scan_flat_dt>
		return;
	end = of_read_number(prop, len/4);
 e10:	e89da800 	ldm	sp, {fp, sp, pc}

00000e14 <early_init_dt_scan>:
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
 e14:	e1a0c00d 	mov	ip, sp
 e18:	e92dd800 	push	{fp, ip, lr, pc}
 e1c:	e24cb004 	sub	fp, ip, #4
 e20:	ebfffffe 	bl	d78 <early_init_dt_verify>
 e24:	e3500000 	cmp	r0, #0
	while (size--)
 e28:	089da800 	ldmeq	sp, {fp, sp, pc}
		r = (r << 32) | be32_to_cpu(*(cell++));
 e2c:	ebfffffe 	bl	dd0 <early_init_dt_scan_nodes>

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
 e30:	e3a00001 	mov	r0, #1
		r = (r << 32) | be32_to_cpu(*(cell++));
 e34:	e89da800 	ldm	sp, {fp, sp, pc}

00000e38 <unflatten_device_tree>:
 e38:	e1a0c00d 	mov	ip, sp

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
 e3c:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
 e40:	e24cb004 	sub	fp, ip, #4
		r = (r << 32) | be32_to_cpu(*(cell++));
 e44:	e3004000 	movw	r4, #0
 e48:	e3003000 	movw	r3, #0
 e4c:	e3404000 	movt	r4, #0
 e50:	e3403000 	movt	r3, #0
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
 e54:	e3001000 	movw	r1, #0
	initrd_end = (unsigned long)__va(end);
 e58:	e3401000 	movt	r1, #0
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
 e5c:	e5930000 	ldr	r0, [r3]
	initrd_end = (unsigned long)__va(end);
 e60:	e1a02004 	mov	r2, r4
	initrd_below_start_ok = 1;
 e64:	ebfffffe 	bl	59c <of_flat_dt_get_machine_name+0x10>
 e68:	e1a00004 	mov	r0, r4
 e6c:	ebfffffe 	bl	0 <of_alias_scan>
 e70:	e89da830 	ldm	sp, {r4, r5, fp, sp, pc}

00000e74 <unflatten_and_copy_device_tree>:
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
 e74:	e1a0c00d 	mov	ip, sp
	initrd_end = (unsigned long)__va(end);
	initrd_below_start_ok = 1;
 e78:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
	initrd_end = (unsigned long)__va(end);
 e7c:	e24cb004 	sub	fp, ip, #4
	initrd_below_start_ok = 1;
 e80:	e3004000 	movw	r4, #0
		return 0;

	early_init_dt_check_for_initrd(node);

	/* Retrieve command line */
	p = of_get_flat_dt_prop(node, "bootargs", &l);
 e84:	e3404000 	movt	r4, #0
 e88:	e5943000 	ldr	r3, [r4]
 e8c:	e3530000 	cmp	r3, #0
 e90:	1a000003 	bne	ea4 <unflatten_and_copy_device_tree+0x30>
 e94:	e3000000 	movw	r0, #0
	if (p != NULL && l > 0)
 e98:	e3400000 	movt	r0, #0
 e9c:	ebfffffe 	bl	0 <printk>
 ea0:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}
 ea4:	e5935004 	ldr	r5, [r3, #4]
 ea8:	e3a02040 	mov	r2, #64	; 0x40
		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
 eac:	e3a03000 	mov	r3, #0
 eb0:	e6bf5f35 	rev	r5, r5
 eb4:	e1a00005 	mov	r0, r5
 eb8:	e1a01fc5 	asr	r1, r5, #31
	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE
	 * is set in which case we override whatever was found earlier.
	 */
#ifdef CONFIG_CMDLINE
#ifndef CONFIG_CMDLINE_FORCE
	if (!((char *)data)[0])
 ebc:	ebfffffe 	bl	148 <early_init_dt_alloc_memory_arch>
 ec0:	e2506000 	subs	r6, r0, #0
 ec4:	0a000003 	beq	ed8 <unflatten_and_copy_device_tree+0x64>
#endif
		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
 ec8:	e1a02005 	mov	r2, r5
 ecc:	e5941000 	ldr	r1, [r4]
 ed0:	ebfffffe 	bl	0 <memcpy>
 ed4:	e5846000 	str	r6, [r4]
 ed8:	ebfffffe 	bl	e38 <unflatten_device_tree>
 edc:	e89da8f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, pc}

Disassembly of section .pv_table:

00000000 <.pv_table>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00000158 	andeq	r0, r0, r8, asr r1
   4:	000004c0 	andeq	r0, r0, r0, asr #9
   8:	000004c4 	andeq	r0, r0, r4, asr #9
   c:	0000074c 	andeq	r0, r0, ip, asr #14
  10:	00000754 	andeq	r0, r0, r4, asr r7
  14:	00000d50 	andeq	r0, r0, r0, asr sp
  18:	00000d54 	andeq	r0, r0, r4, asr sp

Disassembly of section .rodata:

00000000 <__func__.28354>:
   0:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
   4:	6e695f79 	mcrvs	15, 3, r5, cr9, cr9, {3}
   8:	645f7469 	ldrbvs	r7, [pc], #-1129	; 10 <__func__.28354+0x10>
   c:	64615f74 	strbtvs	r5, [r1], #-3956	; 0xfffff08c
  10:	656d5f64 	strbvs	r5, [sp, #-3940]!	; 0xfffff09c
  14:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
  18:	6372615f 	cmnvs	r2, #-1073741801	; 0xc0000017
  1c:	Address 0x000000000000001c is out of bounds.


Disassembly of section ___kcrctab_gpl+of_fdt_unflatten_tree:

00000000 <__kcrctab_of_fdt_unflatten_tree>:
   0:	00000000 	andeq	r0, r0, r0

Disassembly of section ___ksymtab_gpl+of_fdt_unflatten_tree:

00000000 <__ksymtab_of_fdt_unflatten_tree>:
	...

Disassembly of section __ksymtab_strings:

00000000 <__kstrtab_of_fdt_unflatten_tree>:
   0:	665f666f 	ldrbvs	r6, [pc], -pc, ror #12
   4:	755f7464 	ldrbvc	r7, [pc, #-1124]	; fffffba8 <__crc_of_fdt_unflatten_tree+0x792be5eb>
   8:	616c666e 	cmnvs	ip, lr, ror #12
   c:	6e657474 	mcrvs	4, 3, r7, cr5, cr4, {3}
  10:	6572745f 	ldrbvs	r7, [r2, #-1119]!	; 0xfffffba1
  14:	Address 0x0000000000000014 is out of bounds.


Disassembly of section .rodata.str1.4:

00000000 <.LC0>:
   0:	00000000 	andeq	r0, r0, r0

00000004 <.LC1>:
   4:	61433601 	cmpvs	r3, r1, lsl #12
   8:	2074276e 	rsbscs	r2, r4, lr, ror #14
   c:	646e6966 	strbtvs	r6, [lr], #-2406	; 0xfffff69a
  10:	6f727020 	svcvs	0x00727020
  14:	74726570 	ldrbtvc	r6, [r2], #-1392	; 0xfffffa90
  18:	616e2079 	smcvs	57865	; 0xe209
  1c:	6920656d 	stmdbvs	r0!, {r0, r2, r3, r5, r6, r8, sl, sp, lr}
	return kzalloc(size, GFP_KERNEL);
}
  20:	696c206e 	stmdbvs	ip!, {r1, r2, r3, r5, r6, sp}^

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	21207473 			; <UNDEFINED> instruction: 0x21207473
  28:	0000000a 	andeq	r0, r0, sl

0000002c <.LC2>:
  2c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
  30:	00000000 	andeq	r0, r0, r0

00000034 <.LC3>:
  34:	6e616870 	mcrvs	8, 3, r6, cr1, cr0, {3}
	memcpy(buf, initial_boot_params + off, count);
  38:	00656c64 	rsbeq	r6, r5, r4, ror #24

0000003c <.LC4>:
  3c:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
  40:	68702c78 	ldmdavs	r0!, {r3, r4, r5, r6, sl, fp, sp}^

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
	memcpy(buf, initial_boot_params + off, count);
  48:	00000065 	andeq	r0, r0, r5, rrx

0000004c <.LC5>:
  4c:	2c6d6269 	sfmcs	f6, 2, [sp], #-420	; 0xfffffe5c
  50:	6e616870 	mcrvs	8, 3, r6, cr1, cr0, {3}
  54:	00656c64 	rsbeq	r6, r5, r4, ror #24

00000058 <.LC6>:
	return count;
}
  58:	69766564 	ldmdbvs	r6!, {r2, r5, r6, r8, sl, sp, lr}^
  5c:	745f6563 	ldrbvc	r6, [pc], #-1379	; 64 <.LC7>
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	00657079 	rsbeq	r7, r5, r9, ror r0

00000064 <.LC7>:
  64:	4c554e3c 	mrrcmi	14, 3, r4, r5, cr12
  68:	00003e4c 	andeq	r3, r0, ip, asr #28

0000006c <.LC8>:
  6c:	6e753301 	cdpvs	3, 7, cr3, cr5, cr1, {0}
  70:	74616c66 	strbtvc	r6, [r1], #-3174	; 0xfffff39a
  74:	3a6e6574 	bcc	1b9964c <unflatten_and_copy_device_tree+0x1b987d8>
  78:	72726520 	rsbsvc	r6, r2, #32, 10	; 0x8000000
  7c:	2520726f 	strcs	r7, [r0, #-623]!	; 0xfffffd91
  80:	72702064 	rsbsvc	r2, r0, #100	; 0x64
  84:	7365636f 	cmnvc	r5, #-1140850687	; 0xbc000001
  88:	676e6973 			; <UNDEFINED> instruction: 0x676e6973
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	54444620 	strbpl	r4, [r4], #-1568	; 0xfffff9e0
  90:	0000000a 	andeq	r0, r0, sl

00000094 <.LC9>:
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	6f68632f 	svcvs	0x0068632f
  98:	006e6573 	rsbeq	r6, lr, r3, ror r5

0000009c <.LC10>:
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	6f68632f 	svcvs	0x0068632f
	if (!pathp)
  a0:	406e6573 	rsbmi	r6, lr, r3, ror r5
  a4:	00000030 	andeq	r0, r0, r0, lsr r0

000000a8 <.LC11>:
  a8:	6f647473 	svcvs	0x00647473
  ac:	702d7475 	eorvc	r7, sp, r5, ror r4
		return mem;

	allocl = ++l;
  b0:	00687461 	rsbeq	r7, r8, r1, ror #8

000000b4 <.LC12>:
  b4:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
  b8:	74732c78 	ldrbtvc	r2, [r3], #-3192	; 0xfffff388
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	74756f64 	ldrbtvc	r6, [r5], #-3940	; 0xfffff09c
  c0:	7461702d 	strbtvc	r7, [r1], #-45	; 0xffffffd3
  c4:	00000068 	andeq	r0, r0, r8, rrx

000000c8 <.LC13>:
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	64663401 	strbtvs	r3, [r6], #-1025	; 0xfffffbff
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	6e203a74 	mcrvs	10, 1, r3, cr0, cr4, {3}
		new_format = 1;
		if (fpsize == 0) {
  d0:	6320746f 			; <UNDEFINED> instruction: 0x6320746f
  d4:	74616572 	strbtvc	r6, [r1], #-1394	; 0xfffffa8e
  d8:	20676e69 	rsbcs	r6, r7, r9, ror #28
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	79732f27 	ldmdbvc	r3!, {r0, r1, r2, r5, r8, r9, sl, fp, sp}^
  e0:	69662f73 	stmdbvs	r6!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, sp}^
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	61776d72 	cmnvs	r7, r2, ror sp
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	662f6572 			; <UNDEFINED> instruction: 0x662f6572
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	3a277464 	bcc	9dd284 <unflatten_and_copy_device_tree+0x9dc410>
			pathp = "";
  f0:	43524320 	cmpmi	r2, #32, 6	; 0x80000000
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	65686320 	strbvs	r6, [r8, #-800]!	; 0xfffffce0
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	66206b63 	strtvs	r6, [r0], -r3, ror #22
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	656c6961 	strbvs	r6, [ip, #-2401]!	; 0xfffff69f
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	00000a64 	andeq	r0, r0, r4, ror #20

00000104 <.LC14>:
 104:	6e493301 	cdpvs	3, 4, cr3, cr9, cr1, {0}
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	696c6176 	stmdbvs	ip!, {r1, r2, r4, r5, r6, r8, sp, lr}^
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	65642064 	strbvs	r2, [r4, #-100]!	; 0xffffff9c
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	65636976 	strbvs	r6, [r3, #-2422]!	; 0xfffff68a
 114:	65727420 	ldrbvs	r7, [r2, #-1056]!	; 0xfffffbe0
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	6c622065 	stclvs	0, cr2, [r2], #-404	; 0xfffffe6c
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	6820626f 	stmdavs	r0!, {r0, r1, r2, r3, r5, r6, r9, sp, lr}
 120:	65646165 	strbvs	r6, [r4, #-357]!	; 0xfffffe9b
 124:	00000a72 	andeq	r0, r0, r2, ror sl

00000128 <.LC15>:
 128:	6e453401 	cdpvs	4, 4, cr3, cr5, cr1, {0}
 12c:	666f2064 	strbtvs	r2, [pc], -r4, rrx
 130:	65727420 	ldrbvs	r7, [r2, #-1056]!	; 0xfffffbe0

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	616d2065 	cmnvs	sp, r5, rrx
 138:	72656b72 	rsbvc	r6, r5, #116736	; 0x1c800
 13c:	65766f20 	ldrbvs	r6, [r6, #-3872]!	; 0xfffff0e0
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	69727772 	ldmdbvs	r2!, {r1, r4, r5, r6, r8, r9, sl, ip, sp, lr}^
 144:	6e657474 	mcrvs	4, 3, r7, cr5, cr4, {3}
 148:	3025203a 	eorcc	r2, r5, sl, lsr r0
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	000a7838 	andeq	r7, sl, r8, lsr r8

00000150 <.LC16>:
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	0000002f 	andeq	r0, r0, pc, lsr #32

00000154 <.LC17>:
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	64646123 	strbtvs	r6, [r4], #-291	; 0xfffffedd
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	73736572 	cmnvc	r3, #478150656	; 0x1c800000
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	6c65632d 	stclvs	3, cr6, [r5], #-180	; 0xffffff4c
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	0000736c 	andeq	r7, r0, ip, ror #6

00000164 <.LC18>:
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	7a697323 	bvc	1a5cdf8 <unflatten_and_copy_device_tree+0x1a5bf84>
 168:	65632d65 	strbvs	r2, [r3, #-3429]!	; 0xfffff29b
 16c:	00736c6c 	rsbseq	r6, r3, ip, ror #24

00000170 <.LC19>:
 170:	6d656d2f 	stclvs	13, cr6, [r5, #-188]!	; 0xffffff44
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	0079726f 	rsbseq	r7, r9, pc, ror #4

00000178 <.LC20>:
 178:	00676572 	rsbeq	r6, r7, r2, ror r5

0000017c <.LC21>:
 17c:	706d6f63 	rsbvc	r6, sp, r3, ror #30
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	62697461 	rsbvs	r7, r9, #1627389952	; 0x61000000
 184:	0000656c 	andeq	r6, r0, ip, ror #10

00000188 <.LC22>:
 188:	2d676962 	stclcs	9, cr6, [r7, #-392]!	; 0xfffffe78
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	00006e61 	andeq	r6, r0, r1, ror #28

00000194 <.LC23>:
 194:	736f6863 	cmnvc	pc, #6488064	; 0x630000
	res = *mem;
	*mem += size;
 198:	00006e65 	andeq	r6, r0, r5, ror #28

0000019c <.LC24>:
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	736f6863 	cmnvc	pc, #6488064	; 0x630000
 1a0:	30406e65 	subcc	r6, r0, r5, ror #28
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	00000000 	andeq	r0, r0, r0

000001a8 <.LC25>:
 1a8:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	6e692c78 	mcrvs	12, 3, r2, cr9, cr8, {3}
 1b0:	64727469 	ldrbtvs	r7, [r2], #-1129	; 0xfffffb97
 1b4:	6174732d 	cmnvs	r4, sp, lsr #6
 1b8:	00007472 	andeq	r7, r0, r2, ror r4

000001bc <.LC26>:
 1bc:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	6e692c78 	mcrvs	12, 3, r2, cr9, cr8, {3}
 1c4:	64727469 	ldrbtvs	r7, [r2], #-1129	; 0xfffffb97
 1c8:	646e652d 	strbtvs	r6, [lr], #-1325	; 0xfffffad3
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	00000000 	andeq	r0, r0, r0

000001d0 <.LC27>:
 1d0:	746f6f62 	strbtvc	r6, [pc], #-3938	; 1d8 <.LC27+0x8>
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	73677261 	cmnvc	r7, #268435462	; 0x10000006
 1d8:	00000000 	andeq	r0, r0, r0

000001dc <.LC28>:
 1dc:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	0000006c 	andeq	r0, r0, ip, rrx

000001e4 <.LC29>:
					np->phandle = be32_to_cpup(p);
 1e4:	200a3301 	andcs	r3, sl, r1, lsl #6
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	65726e75 	ldrbvs	r6, [r2, #-3701]!	; 0xfffff18b
 1ec:	6e676f63 	cdpvs	15, 6, cr6, cr7, cr3, {3}
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	64657a69 	strbtvs	r7, [r5], #-2665	; 0xfffff597
 1f4:	76656420 	strbtvc	r6, [r5], -r0, lsr #8
 1f8:	20656369 	rsbcs	r6, r5, r9, ror #6
 1fc:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
 200:	73696c20 	cmnvc	r9, #32, 24	; 0x2000
				np->phandle = be32_to_cpup(p);
 204:	5b0a3a74 	blpl	28ebdc <unflatten_and_copy_device_tree+0x28dd68>
 208:	00000020 	andeq	r0, r0, r0, lsr #32

0000020c <.LC30>:
 20c:	000a0a5d 	andeq	r0, sl, sp, asr sl

00000210 <.LC31>:
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	27732527 	ldrbcs	r2, [r3, -r7, lsr #10]!
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	00000020 	andeq	r0, r0, r0, lsr #32

00000218 <.LC32>:
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	614d3601 	cmpvs	sp, r1, lsl #12
			pp->length = sz;
 21c:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	6f6d2065 	svcvs	0x006d2065
			prev_pp = &pp->next;
 224:	3a6c6564 	bcc	1b197bc <unflatten_and_copy_device_tree+0x1b18948>
 228:	0a732520 	beq	1cc96b0 <unflatten_and_copy_device_tree+0x1cc883c>
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	00000000 	andeq	r0, r0, r0

00000230 <.LC33>:
 230:	3a67776c 	bcc	19ddfe8 <unflatten_and_copy_device_tree+0x19dd174>
 234:	253a7325 	ldrcs	r7, [sl, #-805]!	; 0xfffffcdb
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	68703a64 	ldmdavs	r0!, {r2, r5, r6, r9, fp, ip, sp}^
 23c:	6f5f7379 	svcvs	0x005f7379
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
 244:	203d2074 	eorscs	r2, sp, r4, ror r0
 248:	786c6c25 	stmdavc	ip!, {r0, r2, r5, sl, fp, sp, lr}^
 24c:	0000000a 	andeq	r0, r0, sl

00000250 <.LC34>:
 250:	67493401 	strbvs	r3, [r9, -r1, lsl #8]
 254:	69726f6e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
 258:	6d20676e 	stcvs	7, cr6, [r0, #-440]!	; 0xfffffe48
 25c:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
 260:	6c622079 	stclvs	0, cr2, [r2], #-484	; 0xfffffe1c
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	206b636f 	rsbcs	r6, fp, pc, ror #6
 268:	6c257830 	stcvs	8, cr7, [r5], #-192	; 0xffffff40
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	2d20786c 	stccs	8, cr7, [r0, #-432]!	; 0xfffffe50
 270:	25783020 	ldrbcs	r3, [r8, #-32]!	; 0xffffffe0
 274:	0a786c6c 	beq	1e1b42c <unflatten_and_copy_device_tree+0x1e1a5b8>
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	00000000 	andeq	r0, r0, r0

0000027c <.LC35>:
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	67493401 	strbvs	r3, [r9, -r1, lsl #8]
 280:	69726f6e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	6d20676e 	stcvs	7, cr6, [r0, #-440]!	; 0xfffffe48
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	61722079 	cmnvs	r2, r9, ror r0
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	2065676e 	rsbcs	r6, r5, lr, ror #14
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	6c257830 	stcvs	8, cr7, [r5], #-192	; 0xffffff40
 298:	2d20786c 	stccs	8, cr7, [r0, #-432]!	; 0xfffffe50
	if (depth < 0)
 29c:	25783020 	ldrbcs	r3, [r8, #-32]!	; 0xffffffe0
 2a0:	0a786c6c 	beq	1e1b458 <unflatten_and_copy_device_tree+0x1e1a5e4>
		depth = 0;
 2a4:	00000000 	andeq	r0, r0, r0

000002a8 <.LC36>:
 2a8:	6f6d656d 	svcvs	0x006d656d
 2ac:	00007972 	andeq	r7, r0, r2, ror r9

000002b0 <.LC37>:
 2b0:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
	while (*poffset > 0 && depth > old_depth)
 2b4:	73752c78 	cmnvc	r5, #120, 24	; 0x7800
 2b8:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
 2bc:	6d656d2d 	stclvs	13, cr6, [r5, #-180]!	; 0xffffff4c
 2c0:	0079726f 	rsbseq	r7, r9, pc, ror #4

000002c4 <.LC38>:
 2c4:	65736572 	ldrbvs	r6, [r3, #-1394]!	; 0xfffffa8e
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	64657672 	strbtvs	r7, [r5], #-1650	; 0xfffff98e
 2cc:	6d656d2d 	stclvs	13, cr6, [r5, #-180]!	; 0xffffff4c
 2d0:	0079726f 	rsbseq	r7, r9, pc, ror #4

000002d4 <.LC39>:
 2d4:	676e6172 			; <UNDEFINED> instruction: 0x676e6172
 2d8:	00007365 	andeq	r7, r0, r5, ror #6

000002dc <.LC40>:
 2dc:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	00007375 	andeq	r7, r0, r5, ror r3

000002e4 <.LC41>:
 2e4:	79616b6f 	stmdbvc	r1!, {r0, r1, r2, r3, r5, r6, r8, r9, fp, sp, lr}^
 2e8:	00000000 	andeq	r0, r0, r0

000002ec <.LC42>:
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	00006b6f 	andeq	r6, r0, pc, ror #22

000002f0 <.LC43>:
 2f0:	65523301 	ldrbvs	r3, [r2, #-769]	; 0xfffffcff
 2f4:	76726573 			; <UNDEFINED> instruction: 0x76726573
 2f8:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	; 0xfffffe6c
 2fc:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
 300:	69203a79 	stmdbvs	r0!, {r0, r3, r4, r5, r6, r9, fp, ip, sp}
 304:	6c61766e 	stclvs	6, cr7, [r1], #-440	; 0xfffffe48
 308:	72206469 	eorvc	r6, r0, #1761607680	; 0x69000000
 30c:	70206765 	eorvc	r6, r0, r5, ror #14

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	65706f72 	ldrbvs	r6, [r0, #-3954]!	; 0xfffff08e
 314:	20797472 	rsbscs	r7, r9, r2, ror r4
 318:	27206e69 	strcs	r6, [r0, -r9, ror #28]!
 31c:	2c277325 	stccs	3, cr7, [r7], #-148	; 0xffffff6c
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	696b7320 	stmdbvs	fp!, {r5, r8, r9, ip, sp, lr}^
 324:	6e697070 	mcrvs	0, 3, r7, cr9, cr0, {3}

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	6f6e2067 	svcvs	0x006e2067
 32c:	0a2e6564 	beq	b998c4 <unflatten_and_copy_device_tree+0xb98a50>
 330:	00000000 	andeq	r0, r0, r0

00000334 <.LC44>:
 334:	6d2d6f6e 	stcvs	15, cr6, [sp, #-440]!	; 0xfffffe48
 338:	00007061 	andeq	r7, r0, r1, rrx

0000033c <.LC45>:
 33c:	65523601 	ldrbvs	r3, [r2, #-1537]	; 0xfffff9ff
		struct device_node *child = np->child;
		np->child = NULL;
 340:	76726573 			; <UNDEFINED> instruction: 0x76726573
 344:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	; 0xfffffe6c
 348:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
		while (child) {
			struct device_node *next = child->sibling;
 34c:	66203a79 			; <UNDEFINED> instruction: 0x66203a79
			child->sibling = np->child;
 350:	656c6961 	strbvs	r6, [ip, #-2401]!	; 0xfffff69f
 354:	6f742064 	svcvs	0x00742064
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	73657220 	cmnvc	r5, #32, 4
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
 360:	6d656d20 	stclvs	13, cr6, [r5, #-128]!	; 0xffffff80
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	2079726f 	rsbscs	r7, r9, pc, ror #4
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	20726f66 	rsbscs	r6, r2, r6, ror #30
		*nodepp = np;
 36c:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	73252720 			; <UNDEFINED> instruction: 0x73252720
		*nodepp = np;
 374:	62203a27 	eorvs	r3, r0, #159744	; 0x27000
 378:	20657361 	rsbcs	r7, r5, r1, ror #6

	return mem;
}
 37c:	2c617025 	stclcs	0, cr7, [r1], #-148	; 0xffffff6c
 380:	7a697320 	bvc	1a5d008 <unflatten_and_copy_device_tree+0x1a5c194>
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	6c252065 	stcvs	0, cr2, [r5], #-404	; 0xfffffe6c
 388:	694d2064 	stmdbvs	sp, {r2, r5, r6, sp}^
 38c:	00000a42 	andeq	r0, r0, r2, asr #20

00000390 <.LC46>:
 390:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
 394:	00000000 	andeq	r0, r0, r0

00000398 <.LC47>:
 398:	65523301 	ldrbvs	r3, [r2, #-769]	; 0xfffffcff
			if ((*p1) == '@')
 39c:	76726573 			; <UNDEFINED> instruction: 0x76726573
 3a0:	6d206465 	cfstrsvs	mvf6, [r0, #-404]!	; 0xfffffe6c
				pa = p1;
			if ((*p1) == '/')
 3a4:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	75203a79 	strvc	r3, [r0, #-2681]!	; 0xfffff587
 3ac:	7075736e 	rsbsvc	r7, r5, lr, ror #6
				pa = p1;
			if ((*p1) == '/')
 3b0:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xfffff090
 3b4:	6e206465 	cdpvs	4, 2, cr6, cr0, cr5, {3}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	2065646f 	rsbcs	r6, r5, pc, ror #8
 3bc:	6d726f66 	ldclvs	15, cr6, [r2, #-408]!	; 0xfffffe68
 3c0:	202c7461 	eorcs	r7, ip, r1, ror #8
 3c4:	6f6e6769 	svcvs	0x006e6769
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	0000000a 	andeq	r0, r0, sl

000003d0 <.LC48>:
 3d0:	6f4e3401 	svcvs	0x004e3401
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	6c617620 	stclvs	6, cr7, [r1], #-128	; 0xffffff80
 3d8:	64206469 	strtvs	r6, [r0], #-1129	; 0xfffffb97
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	63697665 	cmnvs	r9, #105906176	; 0x6500000
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	72742065 	rsbsvc	r2, r4, #101	; 0x65
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	66206565 	strtvs	r6, [r0], -r5, ror #10
 3e8:	646e756f 	strbtvs	r7, [lr], #-1391	; 0xfffffa91
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	6f63202c 	svcvs	0x0063202c
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	6e69746e 	cdpvs	4, 6, cr7, cr9, cr14, {3}
 3f4:	676e6975 			; <UNDEFINED> instruction: 0x676e6975
			pp->name = "name";
 3f8:	74697720 	strbtvc	r7, [r9], #-1824	; 0xfffff8e0
 3fc:	74756f68 	ldrbtvc	r6, [r5], #-3944	; 0xfffff098
 400:	0000000a 	andeq	r0, r0, sl
			pp->length = sz;
			pp->value = pp + 1;
 404:	00746466 	rsbseq	r6, r4, r6, ror #8

Disassembly of section .init.rodata:

00000000 <__setup_str_setup_of_earlycon>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
   4:	6e6f6379 	mcrvs	3, 3, r6, cr15, cr9, {3}
	...

Disassembly of section .data:

00000000 <of_fdt_raw_attr.28393>:
   0:	00000404 	andeq	r0, r0, r4, lsl #8
   4:	00000100 	andeq	r0, r0, r0, lsl #2
	...

0000001c <of_fdt_unflatten_mutex>:
  1c:	00000001 	andeq	r0, r0, r1
	return kzalloc(size, GFP_KERNEL);
}
  20:	00000000 	andeq	r0, r0, r0

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	00000024 	andeq	r0, r0, r4, lsr #32
  28:	00000024 	andeq	r0, r0, r4, lsr #32
	...

Disassembly of section .initcall7.init:

00000000 <__initcall_of_fdt_raw_init7>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00000000 	andeq	r0, r0, r0

Disassembly of section .init.setup:

00000000 <__setup_setup_of_earlycon>:
	...
   8:	00000001 	andeq	r0, r0, r1

Disassembly of section .init.data:

00000000 <dt_root_size_cells>:
   0:	00000000 	andeq	r0, r0, r0

00000004 <dt_root_addr_cells>:
   4:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss:

00000000 <initial_boot_params>:
   0:	00000000 	andeq	r0, r0, r0

00000004 <depth.28113>:
   4:	00000000 	andeq	r0, r0, r0

00000008 <of_fdt_crc32>:
   8:	00000000 	andeq	r0, r0, r0

0000000c <found.28198>:
   c:	00000000 	andeq	r0, r0, r0

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
   8:	7c010003 	stcvc	0, cr0, [r1], {3}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000028 	andeq	r0, r0, r8, lsr #32
	...
  1c:	00000024 	andeq	r0, r0, r4, lsr #32
	return kzalloc(size, GFP_KERNEL);
}
  20:	00000404 	andeq	r0, r0, r4, lsl #8

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
  28:	00000004 	andeq	r0, r0, r4
  2c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
  30:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
  34:	0c000000 	stceq	0, cr0, [r0], {-0}
	memcpy(buf, initial_boot_params + off, count);
  38:	0000040b 	andeq	r0, r0, fp, lsl #8
  3c:	00000028 	andeq	r0, r0, r8, lsr #32
  40:	00000000 	andeq	r0, r0, r0

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	00000024 	andeq	r0, r0, r4, lsr #32
	memcpy(buf, initial_boot_params + off, count);
  48:	0000003c 	andeq	r0, r0, ip, lsr r0
  4c:	00000404 	andeq	r0, r0, r4, lsl #8
  50:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
  54:	00000004 	andeq	r0, r0, r4
	return count;
}
  58:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
  5c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	0c000000 	stceq	0, cr0, [r0], {-0}
  64:	0000040b 	andeq	r0, r0, fp, lsl #8
  68:	00000054 	andeq	r0, r0, r4, asr r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	00000060 	andeq	r0, r0, r0, rrx
  74:	0000053c 	andeq	r0, r0, ip, lsr r5
  78:	00000404 	andeq	r0, r0, r4, lsl #8
  7c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
  80:	00000004 	andeq	r0, r0, r4
  84:	0a850b84 	beq	fe142e9c <__crc_of_fdt_unflatten_tree+0x774018df>
  88:	08870986 	stmeq	r7, {r1, r2, r7, r8, fp}
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	06890788 	streq	r0, [r9], r8, lsl #15
  90:	048b058a 	streq	r0, [fp], #1418	; 0x58a
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	028e038d 	addeq	r0, lr, #872415234	; 0x34000002
  98:	00000404 	andeq	r0, r0, r4, lsl #8
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	040b0c00 	streq	r0, [fp], #-3072	; 0xfffff400
	if (!pathp)
  a0:	00031404 	andeq	r1, r3, r4, lsl #8
  a4:	0d0c0a00 	vstreq	s0, [ip, #-0]
  a8:	0004042c 	andeq	r0, r4, ip, lsr #8
  ac:	040b0000 	streq	r0, [fp], #-0
		return mem;

	allocl = ++l;
  b0:	000001d4 	ldrdeq	r0, [r0], -r4
  b4:	2c0d0c0a 	stccs	12, cr0, [sp], {10}
  b8:	00000404 	andeq	r0, r0, r4, lsl #8
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	00000b00 	andeq	r0, r0, r0, lsl #22
  c0:	00000038 	andeq	r0, r0, r8, lsr r0
	...
  cc:	00000148 	andeq	r0, r0, r8, asr #2
		new_format = 1;
		if (fpsize == 0) {
  d0:	00000404 	andeq	r0, r0, r4, lsl #8
  d4:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
  d8:	00000004 	andeq	r0, r0, r4
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	07850884 	streq	r0, [r5, r4, lsl #17]
  e0:	05870686 	streq	r0, [r7, #1670]	; 0x686
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	0c000000 	stceq	0, cr0, [r0], {-0}
			pathp = "";
  f0:	3804040b 	stmdacc	r4, {r0, r1, r3, sl}
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	0c000001 	stceq	0, cr0, [r0], {1}
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	0000200d 	andeq	r2, r0, sp
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	00000028 	andeq	r0, r0, r8, lsr #32
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	00000000 	andeq	r0, r0, r0
 104:	00000148 	andeq	r0, r0, r8, asr #2
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	00000018 	andeq	r0, r0, r8, lsl r0
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	00000404 	andeq	r0, r0, r4, lsl #8
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 114:	00000004 	andeq	r0, r0, r4
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 120:	0c000000 	stceq	0, cr0, [r0], {-0}
 124:	0000040b 	andeq	r0, r0, fp, lsl #8
 128:	0000002c 	andeq	r0, r0, ip, lsr #32
 12c:	00000000 	andeq	r0, r0, r0
 130:	00000160 	andeq	r0, r0, r0, ror #2

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	00000078 	andeq	r0, r0, r8, ror r0
 138:	00000404 	andeq	r0, r0, r4, lsl #8
 13c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	00000004 	andeq	r0, r0, r4
 144:	05850684 	streq	r0, [r5, #1668]	; 0x684
 148:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	0c000000 	stceq	0, cr0, [r0], {-0}
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	0000040b 	andeq	r0, r0, fp, lsl #8
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	00000044 	andeq	r0, r0, r4, asr #32
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	00000000 	andeq	r0, r0, r0
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	0000059c 	muleq	r0, ip, r5
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	00000138 	andeq	r0, r0, r8, lsr r1
 168:	00000404 	andeq	r0, r0, r4, lsl #8
 16c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 170:	00000004 	andeq	r0, r0, r4
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	09850a84 	stmibeq	r5, {r2, r7, r9, fp}
 178:	07870886 	streq	r0, [r7, r6, lsl #17]
 17c:	05890688 	streq	r0, [r9, #1672]	; 0x688
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 184:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 188:	0c000000 	stceq	0, cr0, [r0], {-0}
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	c804040b 	stmdagt	r4, {r0, r1, r3, sl}
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	0a000000 	beq	198 <.debug_frame+0x198>
 194:	04280d0c 	strteq	r0, [r8], #-3340	; 0xfffff2f4
	res = *mem;
	*mem += size;
 198:	00000004 	andeq	r0, r0, r4
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	0000000b 	andeq	r0, r0, fp
 1a0:	00000030 	andeq	r0, r0, r0, lsr r0
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	00000000 	andeq	r0, r0, r0
 1a8:	000006d4 	ldrdeq	r0, [r0], -r4
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	0000004c 	andeq	r0, r0, ip, asr #32
 1b0:	00000404 	andeq	r0, r0, r4, lsl #8
 1b4:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 1b8:	00000004 	andeq	r0, r0, r4
 1bc:	07850884 	streq	r0, [r5, r4, lsl #17]
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	05870686 	streq	r0, [r7, #1670]	; 0x686
 1c4:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 1c8:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	0c000000 	stceq	0, cr0, [r0], {-0}
 1d0:	0000040b 	andeq	r0, r0, fp, lsl #8
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	0000004c 	andeq	r0, r0, ip, asr #32
 1d8:	00000000 	andeq	r0, r0, r0
 1dc:	00000720 	andeq	r0, r0, r0, lsr #14
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	0000013c 	andeq	r0, r0, ip, lsr r1
					np->phandle = be32_to_cpup(p);
 1e4:	00000404 	andeq	r0, r0, r4, lsl #8
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 1ec:	00000004 	andeq	r0, r0, r4
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	07850884 	streq	r0, [r5, r4, lsl #17]
 1f4:	05870686 	streq	r0, [r7, #1670]	; 0x686
 1f8:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 1fc:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 200:	0c000000 	stceq	0, cr0, [r0], {-0}
				np->phandle = be32_to_cpup(p);
 204:	d404040b 	strle	r0, [r4], #-1035	; 0xfffffbf5
 208:	0a000000 	beq	210 <.debug_frame+0x210>
 20c:	04200d0c 	strteq	r0, [r0], #-3340	; 0xfffff2f4
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	00000004 	andeq	r0, r0, r4
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	0028040b 	eoreq	r0, r8, fp, lsl #8
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	0c0a0000 	stceq	0, cr0, [sl], {-0}
			pp->length = sz;
 21c:	0404200d 	streq	r2, [r4], #-13
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	0b000000 	bleq	228 <.debug_frame+0x228>
			prev_pp = &pp->next;
 224:	00000048 	andeq	r0, r0, r8, asr #32
 228:	00000000 	andeq	r0, r0, r0
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	0000085c 	andeq	r0, r0, ip, asr r8
 230:	00000098 	muleq	r0, r8, r0
 234:	00000404 	andeq	r0, r0, r4, lsl #8
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 23c:	00000004 	andeq	r0, r0, r4
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	07850884 	streq	r0, [r5, r4, lsl #17]
 244:	05870686 	streq	r0, [r7, #1670]	; 0x686
 248:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 24c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 250:	0c000000 	stceq	0, cr0, [r0], {-0}
 254:	7c04040b 	cfstrsvc	mvf0, [r4], {11}
 258:	0a000000 	beq	260 <.debug_frame+0x260>
 25c:	04200d0c 	strteq	r0, [r0], #-3340	; 0xfffff2f4
 260:	00000004 	andeq	r0, r0, r4
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	0008040b 	andeq	r0, r8, fp, lsl #8
 268:	0d0c0000 	stceq	0, cr0, [ip, #-0]
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	00000020 	andeq	r0, r0, r0, lsr #32
 270:	00000028 	andeq	r0, r0, r8, lsr #32
 274:	00000000 	andeq	r0, r0, r0
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	000008f4 	strdeq	r0, [r0], -r4
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	00000030 	andeq	r0, r0, r0, lsr r0
 280:	00000404 	andeq	r0, r0, r4, lsl #8
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	00000004 	andeq	r0, r0, r4
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	0c000000 	stceq	0, cr0, [r0], {-0}
 298:	0000040b 	andeq	r0, r0, fp, lsl #8
	if (depth < 0)
 29c:	00000030 	andeq	r0, r0, r0, lsr r0
 2a0:	00000000 	andeq	r0, r0, r0
		depth = 0;
 2a4:	00000924 	andeq	r0, r0, r4, lsr #18
 2a8:	00000088 	andeq	r0, r0, r8, lsl #1
 2ac:	00000404 	andeq	r0, r0, r4, lsl #8
 2b0:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
	while (*poffset > 0 && depth > old_depth)
 2b4:	00000004 	andeq	r0, r0, r4
 2b8:	07850884 	streq	r0, [r5, r4, lsl #17]
 2bc:	05870686 	streq	r0, [r7, #1670]	; 0x686
 2c0:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 2c4:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	0c000000 	stceq	0, cr0, [r0], {-0}
 2cc:	0000040b 	andeq	r0, r0, fp, lsl #8
 2d0:	0000003c 	andeq	r0, r0, ip, lsr r0
 2d4:	00000000 	andeq	r0, r0, r0
 2d8:	000001d8 	ldrdeq	r0, [r0], -r8
 2dc:	000000c8 	andeq	r0, r0, r8, asr #1

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	00000404 	andeq	r0, r0, r4, lsl #8
 2e4:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 2e8:	00000004 	andeq	r0, r0, r4
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	09850a84 	stmibeq	r5, {r2, r7, r9, fp}
 2f0:	07870886 	streq	r0, [r7, r6, lsl #17]
 2f4:	05890688 	streq	r0, [r9, #1672]	; 0x688
 2f8:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 2fc:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 300:	0c000000 	stceq	0, cr0, [r0], {-0}
 304:	b804040b 	stmdalt	r4, {r0, r1, r3, sl}
 308:	0c000000 	stceq	0, cr0, [r0], {-0}
 30c:	0000280d 	andeq	r2, r0, sp, lsl #16

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	00000028 	andeq	r0, r0, r8, lsr #32
 314:	00000000 	andeq	r0, r0, r0
 318:	000002a0 	andeq	r0, r0, r0, lsr #5
 31c:	00000014 	andeq	r0, r0, r4, lsl r0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	00000404 	andeq	r0, r0, r4, lsl #8
 324:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	00000004 	andeq	r0, r0, r4
 32c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 330:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 334:	0c000000 	stceq	0, cr0, [r0], {-0}
 338:	0000040b 	andeq	r0, r0, fp, lsl #8
 33c:	00000028 	andeq	r0, r0, r8, lsr #32
		struct device_node *child = np->child;
		np->child = NULL;
 340:	00000000 	andeq	r0, r0, r0
 344:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
 348:	00000024 	andeq	r0, r0, r4, lsr #32
		while (child) {
			struct device_node *next = child->sibling;
 34c:	00000404 	andeq	r0, r0, r4, lsl #8
			child->sibling = np->child;
 350:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 354:	00000004 	andeq	r0, r0, r4
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 360:	0c000000 	stceq	0, cr0, [r0], {-0}
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	0000040b 	andeq	r0, r0, fp, lsl #8
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	00000028 	andeq	r0, r0, r8, lsr #32
		*nodepp = np;
 36c:	00000000 	andeq	r0, r0, r0
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	000002d8 	ldrdeq	r0, [r0], -r8
		*nodepp = np;
 374:	0000002c 	andeq	r0, r0, ip, lsr #32
 378:	00000404 	andeq	r0, r0, r4, lsl #8

	return mem;
}
 37c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 380:	00000004 	andeq	r0, r0, r4
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 388:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 38c:	0c000000 	stceq	0, cr0, [r0], {-0}
 390:	0000040b 	andeq	r0, r0, fp, lsl #8
 394:	0000002c 	andeq	r0, r0, ip, lsr #32
 398:	00000000 	andeq	r0, r0, r0
			if ((*p1) == '@')
 39c:	00000304 	andeq	r0, r0, r4, lsl #6
 3a0:	00000088 	andeq	r0, r0, r8, lsl #1
				pa = p1;
			if ((*p1) == '/')
 3a4:	00000404 	andeq	r0, r0, r4, lsl #8
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 3ac:	00000004 	andeq	r0, r0, r4
				pa = p1;
			if ((*p1) == '/')
 3b0:	05850684 	streq	r0, [r5, #1668]	; 0x684
 3b4:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 3bc:	0c000000 	stceq	0, cr0, [r0], {-0}
 3c0:	0000040b 	andeq	r0, r0, fp, lsl #8
 3c4:	0000003c 	andeq	r0, r0, ip, lsr r0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	00000000 	andeq	r0, r0, r0
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	0000038c 	andeq	r0, r0, ip, lsl #7
 3d0:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	00000404 	andeq	r0, r0, r4, lsl #8
 3d8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	00000004 	andeq	r0, r0, r4
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	09850a84 	stmibeq	r5, {r2, r7, r9, fp}
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	07870886 	streq	r0, [r7, r6, lsl #17]
 3e8:	05890688 	streq	r0, [r9, #1672]	; 0x688
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 3f4:	0c000000 	stceq	0, cr0, [r0], {-0}
			pp->name = "name";
 3f8:	a004040b 	andge	r0, r4, fp, lsl #8
 3fc:	0c000001 	stceq	0, cr0, [r0], {1}
 400:	0000280d 	andeq	r2, r0, sp, lsl #16
			pp->length = sz;
			pp->value = pp + 1;
 404:	00000028 	andeq	r0, r0, r8, lsr #32
 408:	00000000 	andeq	r0, r0, r0
			*prev_pp = pp;
 40c:	0000053c 	andeq	r0, r0, ip, lsr r5
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
 410:	00000028 	andeq	r0, r0, r8, lsr #32
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
 414:	00000404 	andeq	r0, r0, r4, lsl #8
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
 418:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
			prev_pp = &pp->next;
 41c:	00000004 	andeq	r0, r0, r4
			memcpy(pp->value, ps, sz - 1);
 420:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
 424:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
			memcpy(pp->value, ps, sz - 1);
 428:	0c000000 	stceq	0, cr0, [r0], {-0}
			((char *)pp->value)[sz - 1] = 0;
 42c:	0000040b 	andeq	r0, r0, fp, lsl #8
 430:	00000028 	andeq	r0, r0, r8, lsr #32
 434:	00000000 	andeq	r0, r0, r0
 438:	00000564 	andeq	r0, r0, r4, ror #10
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 43c:	00000028 	andeq	r0, r0, r8, lsr #32
 440:	00000404 	andeq	r0, r0, r4, lsl #8
		np->name = of_get_property(np, "name", NULL);
 444:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 448:	00000004 	andeq	r0, r0, r4
 44c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 450:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 454:	0c000000 	stceq	0, cr0, [r0], {-0}
		np->name = of_get_property(np, "name", NULL);
 458:	0000040b 	andeq	r0, r0, fp, lsl #8
		np->type = of_get_property(np, "device_type", NULL);
 45c:	00000028 	andeq	r0, r0, r8, lsr #32
 460:	00000000 	andeq	r0, r0, r0
 464:	0000058c 	andeq	r0, r0, ip, lsl #11
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
 468:	00000040 	andeq	r0, r0, r0, asr #32
		np->type = of_get_property(np, "device_type", NULL);
 46c:	00000404 	andeq	r0, r0, r4, lsl #8
 470:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300

		if (!np->name)
 474:	00000004 	andeq	r0, r0, r4
 478:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			np->name = "<NULL>";
 47c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 480:	0c000000 	stceq	0, cr0, [r0], {-0}
 484:	0000040b 	andeq	r0, r0, fp, lsl #8
		if (!np->type)
 488:	00000038 	andeq	r0, r0, r8, lsr r0
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
 48c:	00000000 	andeq	r0, r0, r0

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
 490:	000005cc 	andeq	r0, r0, ip, asr #11
 494:	0000010c 	andeq	r0, r0, ip, lsl #2
 498:	00000404 	andeq	r0, r0, r4, lsl #8
 49c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a0:	00000004 	andeq	r0, r0, r4
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
 4a4:	07850884 	streq	r0, [r5, r4, lsl #17]
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a8:	05870686 	streq	r0, [r7, #1670]	; 0x686
 4ac:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 4b0:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 4b4:	0c000000 	stceq	0, cr0, [r0], {-0}
 4b8:	fc04040b 	stc2	4, cr0, [r4], {11}
 4bc:	0c000000 	stceq	0, cr0, [r0], {-0}

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
 4c0:	0000200d 	andeq	r2, r0, sp
 4c4:	0000002c 	andeq	r0, r0, ip, lsr #32
 4c8:	00000000 	andeq	r0, r0, r0
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4cc:	000006d8 	ldrdeq	r0, [r0], -r8
 4d0:	00000054 	andeq	r0, r0, r4, asr r0
		if (new_format) {
 4d4:	00000404 	andeq	r0, r0, r4, lsl #8
	node->fwnode.type = FWNODE_OF;
 4d8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4dc:	00000004 	andeq	r0, r0, r4
 4e0:	05850684 	streq	r0, [r5, #1668]	; 0x684
		if (new_format) {
 4e4:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
			/* rebuild full path for new format */
			if (dad && dad->parent) {
 4e8:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 4ec:	0c000000 	stceq	0, cr0, [r0], {-0}
 4f0:	0000040b 	andeq	r0, r0, fp, lsl #8
 4f4:	0000003c 	andeq	r0, r0, ip, lsr r0
 4f8:	00000000 	andeq	r0, r0, r0
				strcpy(fn, dad->full_name);
 4fc:	0000072c 	andeq	r0, r0, ip, lsr #14
 500:	00000190 	muleq	r0, r0, r1
 504:	00000404 	andeq	r0, r0, r4, lsl #8
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
 508:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 50c:	00000004 	andeq	r0, r0, r4
 510:	09850a84 	stmibeq	r5, {r2, r7, r9, fp}
			}
			*(fn++) = '/';
 514:	07870886 	streq	r0, [r7, r6, lsl #17]
 518:	05890688 	streq	r0, [r9, #1672]	; 0x688
 51c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
		}
		memcpy(fn, pathp, l);
 520:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 524:	0c000000 	stceq	0, cr0, [r0], {-0}
 528:	8004040b 	andhi	r0, r4, fp, lsl #8

		prev_pp = &np->properties;
 52c:	0c000001 	stceq	0, cr0, [r0], {1}
 530:	0000280d 	andeq	r2, r0, sp, lsl #16
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
 534:	00000038 	andeq	r0, r0, r8, lsr r0

		prev_pp = &np->properties;
		if (dad != NULL) {
 538:	00000000 	andeq	r0, r0, r0
			np->parent = dad;
 53c:	000008bc 			; <UNDEFINED> instruction: 0x000008bc
			np->sibling = dad->child;
 540:	000000fc 	strdeq	r0, [r0], -ip
 544:	00000404 	andeq	r0, r0, r4, lsl #8
			dad->child = np;
 548:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 54c:	00000004 	andeq	r0, r0, r4
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
 550:	07850884 	streq	r0, [r5, r4, lsl #17]

	if (nodepp)
		*nodepp = np;

	return mem;
}
 554:	05870686 	streq	r0, [r7, #1670]	; 0x686
 558:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 55c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 560:	0c000000 	stceq	0, cr0, [r0], {-0}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 564:	ec04040b 	cfstrs	mvf0, [r4], {11}
 568:	0c000000 	stceq	0, cr0, [r0], {-0}
 56c:	0000200d 	andeq	r2, r0, sp
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
 570:	00000028 	andeq	r0, r0, r8, lsr #32
 574:	00000000 	andeq	r0, r0, r0
 578:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
 57c:	00000028 	andeq	r0, r0, r8, lsr #32
 580:	00000404 	andeq	r0, r0, r4, lsl #8
			break;
 584:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
 588:	00000004 	andeq	r0, r0, r4
 58c:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 590:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 594:	0c000000 	stceq	0, cr0, [r0], {-0}
 598:	0000040b 	andeq	r0, r0, fp, lsl #8
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 59c:	00000034 	andeq	r0, r0, r4, lsr r0
 5a0:	00000000 	andeq	r0, r0, r0
 5a4:	000009e0 	andeq	r0, r0, r0, ror #19
 5a8:	00000080 	andeq	r0, r0, r0, lsl #1
 5ac:	00000404 	andeq	r0, r0, r4, lsl #8
 5b0:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5b4:	00000004 	andeq	r0, r0, r4
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 5b8:	05850684 	streq	r0, [r5, #1668]	; 0x684
 5bc:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5c0:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
 5c4:	0c000000 	stceq	0, cr0, [r0], {-0}
 5c8:	7004040b 	andvc	r0, r4, fp, lsl #8
 5cc:	0c000000 	stceq	0, cr0, [r0], {-0}
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5d0:	0000180d 	andeq	r1, r0, sp, lsl #16
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5d4:	0000003c 	andeq	r0, r0, ip, lsr r0
 5d8:	00000000 	andeq	r0, r0, r0
 5dc:	00000a60 	andeq	r0, r0, r0, ror #20
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5e0:	000002cc 	andeq	r0, r0, ip, asr #5
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5e4:	00000404 	andeq	r0, r0, r4, lsl #8
 5e8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 5ec:	00000004 	andeq	r0, r0, r4
 5f0:	0a850b84 	beq	fe143408 <__crc_of_fdt_unflatten_tree+0x77401e4b>
 5f4:	08870986 	stmeq	r7, {r1, r2, r7, r8, fp}
 5f8:	06890788 	streq	r0, [r9], r8, lsl #15
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 5fc:	048b058a 	streq	r0, [fp], #1418	; 0x58a
 600:	028e038d 	addeq	r0, lr, #872415234	; 0x34000002
 604:	00000404 	andeq	r0, r0, r4, lsl #8
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
 608:	040b0c00 	streq	r0, [fp], #-3072	; 0xfffff400
 60c:	0002bc04 	andeq	fp, r2, r4, lsl #24

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 610:	2c0d0c00 	stccs	12, cr0, [sp], {-0}
 614:	00000030 	andeq	r0, r0, r0, lsr r0
	memset(mem, 0, size);
 618:	00000000 	andeq	r0, r0, r0
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 61c:	00000d2c 	andeq	r0, r0, ip, lsr #26
	memset(mem, 0, size);
 620:	0000004c 	andeq	r0, r0, ip, asr #32

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 624:	00000404 	andeq	r0, r0, r4, lsl #8
 628:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 62c:	00000004 	andeq	r0, r0, r4

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 630:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 634:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 638:	0c000000 	stceq	0, cr0, [r0], {-0}

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 63c:	3c04040b 	cfstrscc	mvf0, [r4], {11}
 640:	0c000000 	stceq	0, cr0, [r0], {-0}
 644:	0000100d 	andeq	r1, r0, sp
 648:	0000002c 	andeq	r0, r0, ip, lsr #32
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 64c:	00000000 	andeq	r0, r0, r0
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 650:	00000d78 	andeq	r0, r0, r8, ror sp
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 654:	00000058 	andeq	r0, r0, r8, asr r0
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 658:	00000404 	andeq	r0, r0, r4, lsl #8
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 65c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 660:	00000004 	andeq	r0, r0, r4
 664:	05850684 	streq	r0, [r5, #1668]	; 0x684
 668:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
 66c:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 670:	0c000000 	stceq	0, cr0, [r0], {-0}

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
 674:	0000040b 	andeq	r0, r0, fp, lsl #8
 678:	00000028 	andeq	r0, r0, r8, lsr #32

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 67c:	00000000 	andeq	r0, r0, r0
 680:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 684:	00000044 	andeq	r0, r0, r4, asr #32

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 688:	00000404 	andeq	r0, r0, r4, lsl #8

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 68c:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 690:	00000004 	andeq	r0, r0, r4

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 694:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 698:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 69c:	0c000000 	stceq	0, cr0, [r0], {-0}
 6a0:	0000040b 	andeq	r0, r0, fp, lsl #8
 6a4:	00000028 	andeq	r0, r0, r8, lsr #32
 6a8:	00000000 	andeq	r0, r0, r0
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 6ac:	00000e14 	andeq	r0, r0, r4, lsl lr
 6b0:	00000024 	andeq	r0, r0, r4, lsr #32
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
 6b4:	00000404 	andeq	r0, r0, r4, lsl #8
 6b8:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 6bc:	00000004 	andeq	r0, r0, r4
 6c0:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
 6c4:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 6c8:	0c000000 	stceq	0, cr0, [r0], {-0}
 6cc:	0000040b 	andeq	r0, r0, fp, lsl #8
		return;
 6d0:	0000002c 	andeq	r0, r0, ip, lsr #32
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6d4:	00000000 	andeq	r0, r0, r0
 6d8:	00000e38 	andeq	r0, r0, r8, lsr lr
 6dc:	0000003c 	andeq	r0, r0, ip, lsr r0
 6e0:	00000404 	andeq	r0, r0, r4, lsl #8
 6e4:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
	mutex_lock(&of_fdt_unflatten_mutex);
 6e8:	00000004 	andeq	r0, r0, r4
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6ec:	05850684 	streq	r0, [r5, #1668]	; 0x684
 6f0:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
	mutex_lock(&of_fdt_unflatten_mutex);
 6f4:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 6f8:	0c000000 	stceq	0, cr0, [r0], {-0}
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
 6fc:	0000040b 	andeq	r0, r0, fp, lsl #8
 700:	00000030 	andeq	r0, r0, r0, lsr r0
 704:	00000000 	andeq	r0, r0, r0
 708:	00000e74 	andeq	r0, r0, r4, ror lr
 70c:	0000006c 	andeq	r0, r0, ip, rrx
	mutex_unlock(&of_fdt_unflatten_mutex);
 710:	00000404 	andeq	r0, r0, r4, lsl #8
 714:	040c0d00 	streq	r0, [ip], #-3328	; 0xfffff300
 718:	00000004 	andeq	r0, r0, r4
 71c:	07850884 	streq	r0, [r5, r4, lsl #17]
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 720:	05870686 	streq	r0, [r7, #1670]	; 0x686
 724:	038d048b 	orreq	r0, sp, #-1962934272	; 0x8b000000
 728:	0404028e 	streq	r0, [r4], #-654	; 0xfffffd72
 72c:	0c000000 	stceq	0, cr0, [r0], {-0}
 730:	0000040b 	andeq	r0, r0, fp, lsl #8

Disassembly of section .debug_info:

00000000 <.debug_info>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
       0:	0000ba79 	andeq	fp, r0, r9, ror sl
       4:	00000004 	andeq	r0, r0, r4
       8:	01040000 	mrseq	r0, (UNDEF: 4)
       c:	0000653e 	andeq	r6, r0, lr, lsr r5
      10:	00247d01 	eoreq	r7, r4, r1, lsl #26
      14:	00269c00 	eoreq	r9, r6, r0, lsl #24
      18:	00034000 	andeq	r4, r3, r0
	...

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      24:	06010200 	streq	r0, [r1], -r0, lsl #4
      28:	000052de 	ldrdeq	r5, [r0], -lr
      2c:	d9080102 	stmdble	r8, {r1, r8}
      30:	02000031 	andeq	r0, r0, #49	; 0x31
      34:	45050502 	strmi	r0, [r5, #-1282]	; 0xfffffafe
	memcpy(buf, initial_boot_params + off, count);
      38:	00030000 	andeq	r0, r3, r0
      3c:	07000062 	streq	r0, [r0, -r2, rrx]
      40:	00004517 	andeq	r4, r0, r7, lsl r5

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      44:	07020200 	streq	r0, [r2, -r0, lsl #4]
	memcpy(buf, initial_boot_params + off, count);
      48:	00002c6d 	andeq	r2, r0, sp, ror #24
      4c:	005a7a03 	subseq	r7, sl, r3, lsl #20
      50:	57190700 	ldrpl	r0, [r9, -r0, lsl #14]
      54:	04000000 	streq	r0, [r0], #-0
	return count;
}
      58:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
      5c:	ad030074 	stcge	0, cr0, [r3, #-464]	; 0xfffffe30
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      60:	07000063 	streq	r0, [r0, -r3, rrx]
      64:	0000691a 	andeq	r6, r0, sl, lsl r9
      68:	07040200 	streq	r0, [r4, -r0, lsl #4]
      6c:	0000673d 	andeq	r6, r0, sp, lsr r7
      70:	1e050802 	cdpne	8, 0, cr0, cr5, cr2, {0}
      74:	03000000 	movweq	r0, #0
      78:	0000002c 	andeq	r0, r0, ip, lsr #32
      7c:	00821e07 	addeq	r1, r2, r7, lsl #28
      80:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
      84:	0055fa07 	subseq	pc, r5, r7, lsl #20
      88:	38730500 	ldmdacc	r3!, {r8, sl}^
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      8c:	250f0800 	strcs	r0, [pc, #-2048]	; fffff894 <__crc_of_fdt_unflatten_tree+0x792be2d7>
      90:	05000000 	streq	r0, [r0, #-0]
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      94:	08003875 	stmdaeq	r0, {r0, r2, r4, r5, r6, fp, ip, sp}
      98:	00002c10 	andeq	r2, r0, r0, lsl ip
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      9c:	31750500 	cmncc	r5, r0, lsl #10
	if (!pathp)
      a0:	13080036 	movwne	r0, #32822	; 0x8036
      a4:	00000045 	andeq	r0, r0, r5, asr #32
      a8:	32337305 	eorscc	r7, r3, #335544320	; 0x14000000
      ac:	57150800 	ldrpl	r0, [r5, -r0, lsl #16]
		return mem;

	allocl = ++l;
      b0:	05000000 	streq	r0, [r0, #-0]
      b4:	00323375 	eorseq	r3, r2, r5, ror r3
      b8:	00691608 	rsbeq	r1, r9, r8, lsl #12
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      bc:	73050000 	movwvc	r0, #20480	; 0x5000
      c0:	08003436 	stmdaeq	r0, {r1, r2, r4, r5, sl, ip, sp}
      c4:	00007018 	andeq	r7, r0, r8, lsl r0
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
      c8:	36750500 	ldrbtcc	r0, [r5], -r0, lsl #10
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      cc:	19080034 	stmdbne	r8, {r2, r4, r5}
		new_format = 1;
		if (fpsize == 0) {
      d0:	00000082 	andeq	r0, r0, r2, lsl #1
      d4:	da070402 	ble	1c1010 <unflatten_and_copy_device_tree+0x1c019c>
      d8:	06000000 	streq	r0, [r0], -r0
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      dc:	000000d4 	ldrdeq	r0, [r0], -r4
      e0:	000000eb 	andeq	r0, r0, fp, ror #1
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
      e4:	0000eb07 	andeq	lr, r0, r7, lsl #22
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
      e8:	02000100 	andeq	r0, r0, #0, 2
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      ec:	4c440704 	mcrrmi	7, 0, r0, r4, cr4
			pathp = "";
      f0:	04080000 	streq	r0, [r8], #-0
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
      f4:	000000ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
			allocl = 2;
			l = 1;
			pathp = "";
      f8:	8c080102 	stfhis	f0, [r8], {2}
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
      fc:	0900005a 	stmdbeq	r0, {r1, r3, r4, r6}
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     100:	000000f8 	strdeq	r0, [r0], -r8
     104:	0069040a 	rsbeq	r0, r9, sl, lsl #8
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     108:	091c0000 	ldmdbeq	ip, {}	; <UNPREDICTABLE>
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     10c:	0000011d 	andeq	r0, r0, sp, lsl r1
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
     110:	0009440b 	andeq	r4, r9, fp, lsl #8
     114:	e20b0000 	and	r0, fp, #0
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     118:	0100004c 	tsteq	r0, ip, asr #32
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     11c:	01280c00 			; <UNDEFINED> instruction: 0x01280c00
     120:	570d0000 	strpl	r0, [sp, -r0]
     124:	00000000 	andeq	r0, r0, r0
     128:	0059d703 	subseq	sp, r9, r3, lsl #14
     12c:	330e0900 	movwcc	r0, #59648	; 0xe900
     130:	02000001 	andeq	r0, r0, #1

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     134:	48500504 	ldmdami	r0, {r2, r8, sl}^
     138:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
     13c:	0900005d 	stmdbeq	r0, {r0, r2, r3, r4, r6}
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     140:	0000d40f 	andeq	sp, r0, pc, lsl #8
     144:	34ac0300 	strtcc	r0, [ip], #768	; 0x300
     148:	1b090000 	blne	240150 <unflatten_and_copy_device_tree+0x23f2dc>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     14c:	00000057 	andeq	r0, r0, r7, asr r0
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     150:	00562303 	subseq	r2, r6, r3, lsl #6
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     154:	69300900 	ldmdbvs	r0!, {r8, fp}
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     158:	03000000 	movweq	r0, #0
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     15c:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     160:	00693109 	rsbeq	r3, r9, r9, lsl #2
			    (strcmp(pname, "linux,phandle") == 0)) {
     164:	89030000 	stmdbhi	r3, {}	; <UNPREDICTABLE>
     168:	09000044 	stmdbeq	r0, {r2, r6}
     16c:	00006943 	andeq	r6, r0, r3, asr #18
     170:	5a430300 	bpl	10c0c08 <unflatten_and_copy_device_tree+0x10bfd94>
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
     174:	44090000 	strmi	r0, [r9], #-0
     178:	00000057 	andeq	r0, r0, r7, asr r0
     17c:	003ad203 	eorseq	sp, sl, r3, lsl #4
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     180:	70570900 	subsvc	r0, r7, r0, lsl #18
     184:	03000000 	movweq	r0, #0
     188:	000040c3 	andeq	r4, r0, r3, asr #1
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     18c:	01285809 			; <UNDEFINED> instruction: 0x01285809
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     190:	75030000 	strvc	r0, [r3, #-0]
     194:	0900004d 	stmdbeq	r0, {r0, r2, r3, r6}
	res = *mem;
	*mem += size;
     198:	00012859 	andeq	r2, r1, r9, asr r8
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
     19c:	20fd0300 	rscscs	r0, sp, r0, lsl #6
     1a0:	5a090000 	bpl	2401a8 <unflatten_and_copy_device_tree+0x23f334>
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     1a4:	00000057 	andeq	r0, r0, r7, asr r0
     1a8:	00330203 	eorseq	r0, r3, r3, lsl #4
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1ac:	575b0900 	ldrbpl	r0, [fp, -r0, lsl #18]
     1b0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     1b4:	0000f804 	andeq	pc, r0, r4, lsl #16
     1b8:	4d6e0300 	stclmi	3, cr0, [lr, #-0]
     1bc:	230a0000 	movwcs	r0, #40960	; 0xa000
			    (strcmp(pname, "linux,phandle") == 0)) {
     1c0:	0000005e 	andeq	r0, r0, lr, asr r0
     1c4:	00450f03 	subeq	r0, r5, r3, lsl #30
     1c8:	5e0c0b00 	vmlapl.f64	d0, d12, d0
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1cc:	03000000 	movweq	r0, #0
     1d0:	0000635d 	andeq	r6, r0, sp, asr r3
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
     1d4:	01c40f0b 	biceq	r0, r4, fp, lsl #30
     1d8:	0f030000 	svceq	0x00030000
     1dc:	0b000005 	bleq	1f8 <.debug_info+0x1f8>
     1e0:	00004512 	andeq	r4, r0, r2, lsl r5
					np->phandle = be32_to_cpup(p);
     1e4:	55e20300 	strbpl	r0, [r2, #768]!	; 0x300
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     1e8:	150b0000 	strne	r0, [fp, #-0]
     1ec:	00000145 	andeq	r0, r0, r5, asr #2
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     1f0:	0051eb03 	subseq	lr, r1, r3, lsl #22
     1f4:	a81a0b00 	ldmdage	sl, {r8, r9, fp}
     1f8:	03000001 	movweq	r0, #1
     1fc:	00000b84 	andeq	r0, r0, r4, lsl #23
     200:	02061d0b 	andeq	r1, r6, #704	; 0x2c0
				np->phandle = be32_to_cpup(p);
     204:	01020000 	mrseq	r0, (UNDEF: 2)
     208:	0022d302 	eoreq	sp, r2, r2, lsl #6
     20c:	3ce80300 	stclcc	3, cr0, [r8]
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     210:	1f0b0000 	svcne	0x000b0000
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
     214:	00000150 	andeq	r0, r0, r0, asr r1
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
     218:	002c1f03 	eoreq	r1, ip, r3, lsl #30
			pp->length = sz;
     21c:	5b200b00 	blpl	802e24 <unflatten_and_copy_device_tree+0x801fb0>
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     220:	03000001 	movweq	r0, #1
			prev_pp = &pp->next;
     224:	00000648 	andeq	r0, r0, r8, asr #12
     228:	017c2d0b 	cmneq	ip, fp, lsl #26
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
     22c:	fe030000 	cdp2	0, 0, cr0, cr3, cr0, {0}
     230:	0b00000d 	bleq	26c <.debug_info+0x26c>
     234:	00016636 	andeq	r6, r1, r6, lsr r6
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     238:	632d0300 			; <UNDEFINED> instruction: 0x632d0300
     23c:	3b0b0000 	blcc	2c0244 <unflatten_and_copy_device_tree+0x2bf3d0>
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
     240:	00000171 	andeq	r0, r0, r1, ror r1
     244:	000f7b03 	andeq	r7, pc, r3, lsl #22
     248:	87450b00 	strbhi	r0, [r5, -r0, lsl #22]
     24c:	03000001 	movweq	r0, #1
     250:	000063e8 	andeq	r6, r0, r8, ror #7
     254:	004c660b 	subeq	r6, ip, fp, lsl #12
     258:	1a030000 	bne	c0008 <unflatten_and_copy_device_tree+0xbf194>
     25c:	0b000008 	bleq	284 <.debug_info+0x284>
     260:	00005e6c 	andeq	r5, r0, ip, ror #28
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
     264:	40e60300 	rscmi	r0, r6, r0, lsl #6
     268:	820b0000 	andhi	r0, fp, #0
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
     26c:	000000c9 	andeq	r0, r0, r9, asr #1
     270:	00407e03 	subeq	r7, r0, r3, lsl #28
     274:	c9830b00 	stmibgt	r3, {r8, r9, fp}
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
     278:	03000000 	movweq	r0, #0
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     27c:	0000593f 	andeq	r5, r0, pc, lsr r9
     280:	00699d0b 	rsbeq	r9, r9, fp, lsl #26
	*poffset = fdt_next_node(blob, *poffset, &depth);
     284:	e0030000 	and	r0, r3, r0
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     288:	0b000020 	bleq	310 <.debug_info+0x310>
	*poffset = fdt_next_node(blob, *poffset, &depth);
     28c:	0000699e 	muleq	r0, lr, r9
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     290:	5d0e0300 	stcpl	3, cr0, [lr, #-0]
	*poffset = fdt_next_node(blob, *poffset, &depth);
     294:	9f0b0000 	svcls	0x000b0000
     298:	00000069 	andeq	r0, r0, r9, rrx
	if (depth < 0)
     29c:	0033a903 	eorseq	sl, r3, r3, lsl #18
     2a0:	c9a20b00 	stmibgt	r2!, {r8, r9, fp}
		depth = 0;
     2a4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     2a8:	bcaf0b04 	vstmialt	pc!, {d0-d1}
     2ac:	0f000002 	svceq	0x00000002
     2b0:	00003b5c 	andeq	r3, r0, ip, asr fp
	while (*poffset > 0 && depth > old_depth)
     2b4:	0057b00b 	subseq	fp, r7, fp
     2b8:	00000000 	andeq	r0, r0, r0
     2bc:	00370f03 	eorseq	r0, r7, r3, lsl #30
     2c0:	a7b10b00 	ldrge	r0, [r1, r0, lsl #22]!
     2c4:	10000002 	andne	r0, r0, r2
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2c8:	00003bb7 			; <UNDEFINED> instruction: 0x00003bb7
     2cc:	ecb90b08 	vldmia	r9!, {d0-d3}
     2d0:	0f000002 	svceq	0x00000002
     2d4:	00002222 	andeq	r2, r0, r2, lsr #4
     2d8:	02ecba0b 	rsceq	fp, ip, #45056	; 0xb000
     2dc:	0f000000 	svceq	0x00000000

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     2e0:	00004d34 	andeq	r4, r0, r4, lsr sp
     2e4:	02ecba0b 	rsceq	fp, ip, #45056	; 0xb000
     2e8:	00040000 	andeq	r0, r4, r0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2ec:	02c70408 	sbceq	r0, r7, #8, 8	; 0x8000000
     2f0:	4a100000 	bmi	400008 <unflatten_and_copy_device_tree+0x3ff194>
     2f4:	04000067 	streq	r0, [r0], #-103	; 0xffffff99
     2f8:	030bbd0b 	movweq	fp, #48395	; 0xbd0b
     2fc:	b80f0000 	stmdalt	pc, {}	; <UNPREDICTABLE>
     300:	0b00000c 	bleq	338 <.debug_info+0x338>
     304:	000330be 	strheq	r3, [r3], -lr
     308:	10000000 	andne	r0, r0, r0
     30c:	00005440 	andeq	r5, r0, r0, asr #8

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     310:	30c10b08 	sbccc	r0, r1, r8, lsl #22
     314:	0f000003 	svceq	0x00000003
     318:	00002222 	andeq	r2, r0, r2, lsr #4
     31c:	0330c20b 	teqeq	r0, #-1342177280	; 0xb0000000
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
     320:	0f000000 	svceq	0x00000000
     324:	00003bf3 	strdeq	r3, [r0], -r3	; <UNPREDICTABLE>

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
     328:	0336c20b 	teqeq	r6, #-1342177280	; 0xb0000000
     32c:	00040000 	andeq	r0, r4, r0
     330:	030b0408 	movweq	r0, #46088	; 0xb408
     334:	04080000 	streq	r0, [r8], #-0
     338:	00000330 	andeq	r0, r0, r0, lsr r3
     33c:	0010f310 	andseq	pc, r0, r0, lsl r3	; <UNPREDICTABLE>
		struct device_node *child = np->child;
		np->child = NULL;
     340:	df0b0800 	svcle	0x000b0800
     344:	00000361 	andeq	r0, r0, r1, ror #6
     348:	0022220f 	eoreq	r2, r2, pc, lsl #4
		while (child) {
			struct device_node *next = child->sibling;
     34c:	61e00b00 	mvnvs	r0, r0, lsl #22
			child->sibling = np->child;
     350:	00000003 	andeq	r0, r0, r3
     354:	001bf20f 	andseq	pc, fp, pc, lsl #4
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     358:	72e10b00 	rscvc	r0, r1, #0, 22
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
     35c:	04000003 	streq	r0, [r0], #-3
     360:	3c040800 	stccc	8, cr0, [r4], {-0}
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     364:	0c000003 	stceq	0, cr0, [r0], {3}
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     368:	00000372 	andeq	r0, r0, r2, ror r3
		*nodepp = np;
     36c:	0003610d 	andeq	r6, r3, sp, lsl #2
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     370:	04080000 	streq	r0, [r8], #-0
		*nodepp = np;
     374:	00000367 	andeq	r0, r0, r7, ror #6
     378:	80100411 	andshi	r0, r0, r1, lsl r4

	return mem;
}
     37c:	0800001d 	stmdaeq	r0, {r0, r2, r3, r4}
     380:	039f1a0c 	orrseq	r1, pc, #12, 20	; 0xc000
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     384:	2a0f0000 	bcs	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
     388:	0c000039 	stceq	0, cr0, [r0], {57}	; 0x39
     38c:	0000d41c 	andeq	sp, r0, ip, lsl r4
     390:	9b0f0000 	blls	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
     394:	0c000005 	stceq	0, cr0, [r0], {5}
     398:	0000f21d 	andeq	pc, r0, sp, lsl r2	; <UNPREDICTABLE>
			if ((*p1) == '@')
     39c:	03000400 	movweq	r0, #1024	; 0x400
     3a0:	000049a0 	andeq	r4, r0, r0, lsr #19
				pa = p1;
			if ((*p1) == '/')
     3a4:	03aa7c0d 			; <UNDEFINED> instruction: 0x03aa7c0d
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
     3a8:	04080000 	streq	r0, [r8], #-0
     3ac:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
				pa = p1;
			if ((*p1) == '/')
     3b0:	00005712 	andeq	r5, r0, r2, lsl r7
     3b4:	bb040800 	bllt	1023bc <unflatten_and_copy_device_tree+0x101548>
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     3b8:	13000003 	movwne	r0, #3
     3bc:	0050a510 	subseq	sl, r0, r0, lsl r5
     3c0:	ec0d0c00 	stc	12, cr0, [sp], {-0}
     3c4:	000003ed 	andeq	r0, r0, sp, ror #7
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3c8:	72747314 	rsbsvc	r7, r4, #20, 6	; 0x50000000
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     3cc:	f2ed0d00 	vqdmull.s32	q8, d13, d0
     3d0:	00000000 	andeq	r0, r0, r0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3d4:	0023690f 	eoreq	r6, r3, pc, lsl #18
     3d8:	fcee0d00 	stc2l	13, cr0, [lr]
			pa = p1;
		sz = (pa - ps) + 1;
     3dc:	04000003 	streq	r0, [r0], #-3
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3e0:	0011610f 	andseq	r6, r1, pc, lsl #2
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     3e4:	57ef0d00 	strbpl	r0, [pc, r0, lsl #26]!
     3e8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
     3ec:	00571500 	subseq	r1, r7, r0, lsl #10
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3f0:	03fc0000 	mvnseq	r0, #0
     3f4:	b30d0000 	movwlt	r0, #53248	; 0xd000
			pp->name = "name";
     3f8:	00000001 	andeq	r0, r0, r1
     3fc:	03ed0408 	mvneq	r0, #8, 8	; 0x8000000
     400:	200e0000 	andcs	r0, lr, r0
			pp->length = sz;
			pp->value = pp + 1;
     404:	0453170e 	ldrbeq	r1, [r3], #-1806	; 0xfffff8f2
     408:	e80f0000 	stmda	pc, {}	; <UNPREDICTABLE>
			*prev_pp = pp;
     40c:	0e00005a 	mcreq	0, 0, r0, cr0, cr10, {2}
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
     410:	00045318 	andeq	r5, r4, r8, lsl r3
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
     414:	76140000 	ldrvc	r0, [r4], -r0
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
     418:	0e006c61 	cdpeq	12, 0, cr6, cr0, cr1, {3}
			prev_pp = &pp->next;
     41c:	0000b319 	andeq	fp, r0, r9, lsl r3
			memcpy(pp->value, ps, sz - 1);
     420:	6a0f0400 	bvs	3c1008 <unflatten_and_copy_device_tree+0x3c0194>
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
     424:	0e000059 	mcreq	0, 0, r0, cr0, cr9, {2}
			memcpy(pp->value, ps, sz - 1);
     428:	0000b31a 	andeq	fp, r0, sl, lsl r3
			((char *)pp->value)[sz - 1] = 0;
     42c:	7b0f0800 	blvc	3c2008 <unflatten_and_copy_device_tree+0x3c1194>
     430:	0e000019 	mcreq	0, 0, r0, cr0, cr9, {0}
     434:	0000b31b 	andeq	fp, r0, fp, lsl r3
     438:	1f0f0c00 	svcne	0x000f0c00
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     43c:	0e00004d 	cdpeq	0, 0, cr0, cr0, cr13, {2}
     440:	0000c91c 	andeq	ip, r0, ip, lsl r9
		np->name = of_get_property(np, "name", NULL);
     444:	260f1000 	strcs	r1, [pc], -r0
     448:	0e000021 	cdpeq	0, 0, cr0, cr0, cr1, {1}
     44c:	0004531d 	andeq	r5, r4, sp, lsl r3
     450:	08001800 	stmdaeq	r0, {fp, ip}
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     454:	0000b304 	andeq	fp, r0, r4, lsl #6
		np->name = of_get_property(np, "name", NULL);
     458:	0e100e00 	cdpeq	14, 1, cr0, cr0, cr0, {0}
		np->type = of_get_property(np, "device_type", NULL);
     45c:	00048620 	andeq	r8, r4, r0, lsr #12
     460:	5d520f00 	ldclpl	15, cr0, [r2, #-0]
     464:	210e0000 	mrscs	r0, (UNDEF: 14)
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
     468:	000001f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		np->type = of_get_property(np, "device_type", NULL);
     46c:	37f30f00 	ldrbcc	r0, [r3, r0, lsl #30]!
     470:	220e0000 	andcs	r0, lr, #0

		if (!np->name)
     474:	000004ab 	andeq	r0, r0, fp, lsr #9
     478:	4f940f04 	svcmi	0x00940f04
			np->name = "<NULL>";
     47c:	260e0000 	strcs	r0, [lr], -r0
     480:	000000c9 	andeq	r0, r0, r9, asr #1
     484:	91100008 	tstls	r0, r8
		if (!np->type)
     488:	08000015 	stmdaeq	r0, {r0, r2, r4}
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
     48c:	04ab090f 	strteq	r0, [fp], #2319	; 0x90f

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
     490:	7e0f0000 	cdpvc	0, 0, cr0, cr15, cr0, {0}
     494:	0f000050 	svceq	0x00000050
     498:	0001870a 	andeq	r8, r1, sl, lsl #14
     49c:	be0f0000 	cdplt	0, 0, cr0, cr15, cr0, {0}
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a0:	0f000025 	svceq	0x00000025
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
     4a4:	0001330b 	andeq	r3, r1, fp, lsl #6
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a8:	08000400 	stmdaeq	r0, {sl}
     4ac:	00048604 	andeq	r8, r4, r4, lsl #12
     4b0:	0e140e00 	cdpeq	14, 1, cr0, cr4, cr0, {0}
     4b4:	0004f629 	andeq	pc, r4, r9, lsr #12
     4b8:	4d690f00 	stclmi	15, cr0, [r9, #-0]
     4bc:	2a0e0000 	bcs	3804c4 <unflatten_and_copy_device_tree+0x37f650>

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
     4c0:	000004fb 	strdeq	r0, [r0], -fp
     4c4:	4a930f00 	bmi	fe4c3c08 <__crc_of_fdt_unflatten_tree+0x7778264b>
     4c8:	2b0e0000 	blcs	3804d0 <unflatten_and_copy_device_tree+0x37f65c>
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4cc:	00000057 	andeq	r0, r0, r7, asr r0
     4d0:	2aa80f04 	bcs	fea03c18 <__crc_of_fdt_unflatten_tree+0x77cc265b>
		if (new_format) {
     4d4:	2c0e0000 	stccs	0, cr0, [lr], {-0}
	node->fwnode.type = FWNODE_OF;
     4d8:	00000057 	andeq	r0, r0, r7, asr r0
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4dc:	507e0f08 	rsbspl	r0, lr, r8, lsl #30
     4e0:	2d0e0000 	stccs	0, cr0, [lr, #-0]
		if (new_format) {
     4e4:	000000d4 	ldrdeq	r0, [r0], -r4
			/* rebuild full path for new format */
			if (dad && dad->parent) {
     4e8:	25be0f0c 	ldrcs	r0, [lr, #3852]!	; 0xf0c
     4ec:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
     4f0:	000000d4 	ldrdeq	r0, [r0], -r4
     4f4:	d7160010 			; <UNDEFINED> instruction: 0xd7160010
     4f8:	08000061 	stmdaeq	r0, {r0, r5, r6}
				strcpy(fn, dad->full_name);
     4fc:	0004f604 	andeq	pc, r4, r4, lsl #12
     500:	0e201700 	cdpeq	7, 2, cr1, cr0, cr0, {0}
     504:	00052b15 	andeq	r2, r5, r5, lsl fp
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
     508:	4ce71800 	stclmi	8, cr1, [r7]
     50c:	1e0e0000 	cdpne	0, 0, cr0, cr14, cr0, {0}
     510:	00000402 	andeq	r0, r0, r2, lsl #8
			}
			*(fn++) = '/';
     514:	00066d18 	andeq	r6, r6, r8, lsl sp
     518:	59270e00 	stmdbpl	r7!, {r9, sl, fp}
     51c:	18000004 	stmdane	r0, {r2}
		}
		memcpy(fn, pathp, l);
     520:	00000f37 	andeq	r0, r0, r7, lsr pc
     524:	04b12f0e 	ldrteq	r2, [r1], #3854	; 0xf0e
     528:	10000000 	andne	r0, r0, r0

		prev_pp = &np->properties;
     52c:	00000292 	muleq	r0, r2, r2
     530:	49130e28 	ldmdbmi	r3, {r3, r5, r9, sl, fp}
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
     534:	14000005 	strne	r0, [r0], #-5

		prev_pp = &np->properties;
		if (dad != NULL) {
     538:	0e006e66 	cdpeq	14, 0, cr6, cr0, cr6, {3}
			np->parent = dad;
     53c:	00055e14 	andeq	r5, r5, r4, lsl lr
			np->sibling = dad->child;
     540:	01190000 	tsteq	r9, r0
     544:	08000005 	stmdaeq	r0, {r0, r2}
			dad->child = np;
     548:	01331500 	teqeq	r3, r0, lsl #10
     54c:	05580000 	ldrbeq	r0, [r8, #-0]
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
     550:	580d0000 	stmdapl	sp, {}	; <UNPREDICTABLE>

	if (nodepp)
		*nodepp = np;

	return mem;
}
     554:	00000005 	andeq	r0, r0, r5
     558:	052b0408 	streq	r0, [fp, #-1032]!	; 0xfffffbf8
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     55c:	04080000 	streq	r0, [r8], #-0
     560:	00000549 	andeq	r0, r0, r9, asr #10
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     564:	056a0408 	strbeq	r0, [sl, #-1032]!	; 0xfffffbf8
     568:	35100000 	ldrcc	r0, [r0, #-0]
     56c:	2400002b 	strcs	r0, [r0], #-43	; 0xffffffd5
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
     570:	05a72c10 	streq	r2, [r7, #3088]!	; 0xc10
     574:	6a0f0000 	bvs	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
     578:	10000059 	andne	r0, r0, r9, asr r0
     57c:	0000d42e 	andeq	sp, r0, lr, lsr #8
     580:	35190000 	ldrcc	r0, [r9, #-0]
			break;
     584:	04000020 	streq	r0, [r0], #-32	; 0xffffffe0
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
     588:	0021d619 	eoreq	sp, r1, r9, lsl r6
     58c:	45190800 	ldrmi	r0, [r9, #-2048]	; 0xfffff800
     590:	14000022 	strne	r0, [r0], #-34	; 0xffffffde
     594:	00226e19 	eoreq	r6, r2, r9, lsl lr
     598:	950f1c00 	strls	r1, [pc, #-3072]	; fffff408 <__crc_of_fdt_unflatten_tree+0x792bde4b>
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     59c:	1000000e 	andne	r0, r0, lr
     5a0:	00229dc0 	eoreq	r9, r2, r0, asr #27
     5a4:	08002000 	stmdaeq	r0, {sp}
     5a8:	0005ad04 	andeq	sl, r5, r4, lsl #26
     5ac:	30d31a00 	sbcscc	r1, r3, r0, lsl #20
     5b0:	10600000 	rsbne	r0, r0, r0
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5b4:	06980129 	ldreq	r0, [r8], r9, lsr #2
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     5b8:	b71b0000 	ldrlt	r0, [fp, -r0]
     5bc:	10000053 	andne	r0, r0, r3, asr r0
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5c0:	00d4012c 	sbcseq	r0, r4, ip, lsr #2
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
     5c4:	1b000000 	blne	5cc <.debug_info+0x5cc>
     5c8:	000028e7 	andeq	r2, r0, r7, ror #17
     5cc:	d4012d10 	strle	r2, [r1], #-3344	; 0xfffff2f0
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5d0:	04000000 	streq	r0, [r0], #-0
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5d4:	005b021b 	subseq	r0, fp, fp, lsl r2
     5d8:	01311000 	teqeq	r1, r0
     5dc:	000005a7 	andeq	r0, r0, r7, lsr #11
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5e0:	1e1f1b08 	vnmlsne.f64	d1, d15, d8
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5e4:	31100000 	tstcc	r0, r0
     5e8:	0005a701 	andeq	sl, r5, r1, lsl #14
     5ec:	fa1b0c00 	blx	6c3008 <unflatten_and_copy_device_tree+0x6c2194>
     5f0:	10000003 	andne	r0, r0, r3
     5f4:	1a6b0133 	bne	1ac0ac8 <unflatten_and_copy_device_tree+0x1abfc54>
     5f8:	1b100000 	blne	400600 <unflatten_and_copy_device_tree+0x3ff78c>
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     5fc:	00001cd1 	ldrdeq	r1, [r0], -r1	; <UNPREDICTABLE>
     600:	d4013b10 	strle	r3, [r1], #-2832	; 0xfffff4f0
     604:	1c000000 	stcne	0, cr0, [r0], {-0}
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
     608:	0067551b 	rsbeq	r5, r7, fp, lsl r5
     60c:	013f1000 	teqeq	pc, r0

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     610:	00001bae 	andeq	r1, r0, lr, lsr #23
     614:	006f1b20 	rsbeq	r1, pc, r0, lsr #22
	memset(mem, 0, size);
     618:	40100000 	andsmi	r0, r0, r0
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     61c:	0006da01 	andeq	sp, r6, r1, lsl #20
	memset(mem, 0, size);
     620:	611b2800 	tstvs	fp, r0, lsl #16

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     624:	10000062 	andne	r0, r0, r2, rrx
     628:	00d40141 	sbcseq	r0, r4, r1, asr #2

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     62c:	1b300000 	blne	c00634 <unflatten_and_copy_device_tree+0xbff7c0>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     630:	0000141b 	andeq	r1, r0, fp, lsl r4

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     634:	db014a10 	blle	52e7c <unflatten_and_copy_device_tree+0x52008>
     638:	34000023 	strcc	r0, [r0], #-35	; 0xffffffdd

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     63c:	00279f1b 	eoreq	r9, r7, fp, lsl pc
     640:	01521000 	cmpeq	r2, r0
     644:	000002c7 	andeq	r0, r0, r7, asr #5
     648:	37401b44 	strbcc	r1, [r0, -r4, asr #22]
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     64c:	54100000 	ldrpl	r0, [r0], #-0
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     650:	00240301 	eoreq	r0, r4, r1, lsl #6
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     654:	b11b4c00 	tstlt	fp, r0, lsl #24
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     658:	1000005c 	andne	r0, r0, ip, asr r0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
     65c:	24a20157 	strtcs	r0, [r2], #343	; 0x157
     660:	1b500000 	blne	1400668 <unflatten_and_copy_device_tree+0x13ff7f4>
     664:	00003a76 	andeq	r3, r0, r6, ror sl
     668:	d4015a10 	strle	r5, [r1], #-2576	; 0xfffff5f0
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
     66c:	54000000 	strpl	r0, [r0], #-0
     670:	0018321b 	andseq	r3, r8, fp, lsl r2

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
     674:	015c1000 	cmpeq	ip, r0
     678:	000023cc 	andeq	r2, r0, ip, asr #7

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     67c:	3b731b58 	blcc	1cc6d68 <unflatten_and_copy_device_tree+0x1cc5ef4>
     680:	5d100000 	ldcpl	0, cr0, [r0, #-0]

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     684:	00037801 	andeq	r7, r3, r1, lsl #16

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     688:	fd1b5c00 	ldc2	12, cr5, [fp, #-0]

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     68c:	1000003d 	andne	r0, r0, sp, lsr r0
     690:	23d20165 	bicscs	r0, r2, #1073741849	; 0x40000019

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     694:	00600000 	rsbeq	r0, r0, r0
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     698:	000af403 	andeq	pc, sl, r3, lsl #8
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     69c:	c9191100 	ldmdbgt	r9, {r8, ip}
     6a0:	03000000 	movweq	r0, #0
     6a4:	000027ae 	andeq	r2, r0, lr, lsr #15
     6a8:	00c91a11 	sbceq	r1, r9, r1, lsl sl
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     6ac:	84030000 	strhi	r0, [r3], #-0
     6b0:	1100005c 	qaddne	r0, ip, r0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
     6b4:	0000c91b 	andeq	ip, r0, fp, lsl r9
     6b8:	1d8e0300 	stcne	3, cr0, [lr]
     6bc:	35110000 	ldrcc	r0, [r1, #-0]
     6c0:	00000698 	muleq	r0, r8, r6
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
     6c4:	00499a03 	subeq	r9, r9, r3, lsl #20
     6c8:	a3361100 	teqge	r6, #0, 2
     6cc:	03000006 	movweq	r0, #6
		return;
     6d0:	0000278e 	andeq	r2, r0, lr, lsl #15
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6d4:	06ae3711 	ssateq	r3, #15, r1, lsl #14
     6d8:	18030000 	stmdane	r3, {}	; <UNPREDICTABLE>
     6dc:	11000031 	tstne	r0, r1, lsr r0
     6e0:	00069838 	andeq	r9, r6, r8, lsr r8
     6e4:	005e0600 	subseq	r0, lr, r0, lsl #12
	mutex_lock(&of_fdt_unflatten_mutex);
     6e8:	06f50000 	ldrbteq	r0, [r5], r0
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6ec:	eb070000 	bl	1c06f4 <unflatten_and_copy_device_tree+0x1bf880>
     6f0:	01000000 	mrseq	r0, (UNDEF: 0)
	mutex_lock(&of_fdt_unflatten_mutex);
     6f4:	5bff1c00 	blpl	fffc7008 <__crc_of_fdt_unflatten_tree+0x79285a4b>
     6f8:	06300000 	ldrteq	r0, [r0], -r0
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
     6fc:	27056c12 	smladcs	r5, r2, ip, r6
     700:	1b000010 	blne	748 <.debug_info+0x748>
     704:	00004ad0 	ldrdeq	r4, [r0], -r0
     708:	4c056d12 	stcmi	13, cr6, [r5], {18}
     70c:	0000004e 	andeq	r0, r0, lr, asr #32
	mutex_unlock(&of_fdt_unflatten_mutex);
     710:	003b2d1b 	eorseq	r2, fp, fp, lsl sp
     714:	056e1200 	strbeq	r1, [lr, #-512]!	; 0xfffffe00
     718:	00000378 	andeq	r0, r0, r8, ror r3
     71c:	15351b04 	ldrne	r1, [r5, #-2820]!	; 0xfffff4fc
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     720:	6f120000 	svcvs	0x00120000
     724:	0002bc05 	andeq	fp, r2, r5, lsl #24
     728:	6a1b0800 	bvs	6c2008 <unflatten_and_copy_device_tree+0x6c1194>
     72c:	12000059 	andne	r0, r0, #89	; 0x59
     730:	00690570 	rsbeq	r0, r9, r0, ror r5
     734:	1b0c0000 	blne	30073c <unflatten_and_copy_device_tree+0x2ff8c8>
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     738:	000064d4 	ldrdeq	r6, [r0], -r4
     73c:	69057112 	stmdbvs	r5, {r1, r4, r8, ip, sp, lr}
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     740:	10000000 	andne	r0, r0, r0
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     744:	0040171b 	subeq	r1, r0, fp, lsl r7
     748:	05741200 	ldrbeq	r1, [r4, #-512]!	; 0xfffffe00
     74c:	00001b4f 	andeq	r1, r0, pc, asr #22
     750:	1efb1b14 	vmovne.u8	r1, d11[4]
	if (root_offset < 0)
     754:	75120000 	ldrvc	r0, [r2, #-0]
     758:	00005705 	andeq	r5, r0, r5, lsl #14
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
     75c:	a31b1800 	tstge	fp, #0, 16
     760:	12000017 	andne	r0, r0, #23
     764:	00690576 	rsbeq	r0, r9, r6, ror r5
     768:	1b1c0000 	blne	700770 <unflatten_and_copy_device_tree+0x6ff8fc>
     76c:	0000522f 	andeq	r5, r0, pc, lsr #4
     770:	d4057712 	strle	r7, [r5], #-1810	; 0xfffff8ee
				"#address-cells", NULL);
	if (addr_prop)
     774:	20000000 	andcs	r0, r0, r0
     778:	004f0c1b 	subeq	r0, pc, fp, lsl ip	; <UNPREDICTABLE>
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     77c:	05781200 	ldrbeq	r1, [r8, #-512]!	; 0xfffffe00
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     780:	00001027 	andeq	r1, r0, r7, lsr #32
     784:	46df1b24 	ldrbmi	r1, [pc], r4, lsr #22
     788:	7a120000 	bvc	480790 <unflatten_and_copy_device_tree+0x47f91c>
     78c:	00005705 	andeq	r5, r0, r5, lsl #14
     790:	251b2800 	ldrcs	r2, [fp, #-2048]	; 0xfffff800
     794:	12000047 	andne	r0, r0, #71	; 0x47
     798:	0057057c 	subseq	r0, r7, ip, ror r5
				"#size-cells", NULL);
	if (size_prop)
     79c:	1b2c0000 	blne	b007a4 <unflatten_and_copy_device_tree+0xaff930>
     7a0:	00005069 	andeq	r5, r0, r9, rrx
     7a4:	57057e12 	smladpl	r5, r2, lr, r7
     7a8:	30000000 	andcc	r0, r0, r0
		nr_size_cells = fdt32_to_cpu(*size_prop);
     7ac:	000a011b 	andeq	r0, sl, fp, lsl r1
     7b0:	057e1200 	ldrbeq	r1, [lr, #-512]!	; 0xfffffe00
     7b4:	00000057 	andeq	r0, r0, r7, asr r0
     7b8:	3e3b1b34 	vmovcc.s16	r1, d11[2]

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
     7bc:	7e120000 	cdpvc	0, 1, cr0, cr2, cr0, {0}
     7c0:	00005705 	andeq	r5, r0, r5, lsl #14
     7c4:	9c1b3800 	ldcls	8, cr3, [fp], {-0}
     7c8:	12000004 	andne	r0, r0, #4
	if (memory > 0) {
     7cc:	0069057f 	rsbeq	r0, r9, pc, ror r5
     7d0:	1b3c0000 	blne	f007d8 <unflatten_and_copy_device_tree+0xeff964>
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
     7d4:	00003f28 	andeq	r3, r0, r8, lsr #30
     7d8:	56058012 			; <UNDEFINED> instruction: 0x56058012
     7dc:	4000004e 	andmi	r0, r0, lr, asr #32
     7e0:	0065731d 	rsbeq	r7, r5, sp, lsl r3
     7e4:	ce058112 	mcrgt	1, 0, r8, cr5, cr2, {0}
     7e8:	4800004b 	stmdami	r0, {r0, r1, r3, r6}
		if (len > limit*cell_size) {
     7ec:	0074721e 	rsbseq	r7, r4, lr, lsl r2
     7f0:	b6058212 			; <UNDEFINED> instruction: 0xb6058212
     7f4:	9800004c 	stmdals	r0, {r2, r3, r6}
     7f8:	2b651f01 	blcs	1947c0c <unflatten_and_copy_device_tree+0x1946d98>
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
     7fc:	84120000 	ldrhi	r0, [r2], #-0
     800:	004e6605 	subeq	r6, lr, r5, lsl #12
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
     804:	1e01b000 	cdpne	0, 0, cr11, cr1, cr0, {0}
     808:	12006c64 	andne	r6, r0, #100, 24	; 0x6400
     80c:	4d0b0586 	cfstr32mi	mvfx0, [fp, #-536]	; 0xfffffde8
     810:	01b80000 			; <UNDEFINED> instruction: 0x01b80000
     814:	00275e1f 	eoreq	r5, r7, pc, lsl lr
     818:	058e1200 	streq	r1, [lr, #512]	; 0x200
     81c:	00000069 	andeq	r0, r0, r9, rrx

	memory = fdt_path_offset(initial_boot_params, "/memory");
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
     820:	361f0240 	ldrcc	r0, [pc], -r0, asr #4
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
     824:	1200001e 	andne	r0, r0, #30
					len);
		}
	}
}
     828:	00690591 	mlseq	r9, r1, r5, r0
     82c:	02440000 	subeq	r0, r4, #0
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     830:	003bd51f 	eorseq	sp, fp, pc, lsl r5
     834:	05921200 	ldreq	r1, [r2, #512]	; 0x200
     838:	00000057 	andeq	r0, r0, r7, asr r0
     83c:	c91f0248 	ldmdbgt	pc, {r3, r6, r9}	; <UNPREDICTABLE>
     840:	1200005c 	andne	r0, r0, #92	; 0x5c
				"#size-cells", NULL);
	if (size_prop)
     844:	19eb0593 	stmibne	fp!, {r0, r1, r4, r7, r8, sl}^
     848:	024c0000 	subeq	r0, ip, #0
     84c:	00032a1f 	andeq	r2, r3, pc, lsl sl
		nr_size_cells = fdt32_to_cpu(*size_prop);
     850:	05961200 	ldreq	r1, [r6, #512]	; 0x200
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     854:	00000057 	andeq	r0, r0, r7, asr r0
     858:	811f0250 	tsthi	pc, r0, asr r2	; <UNPREDICTABLE>
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
     85c:	12000062 	andne	r0, r0, #98	; 0x62
     860:	4e000597 	mcrmi	5, 0, r0, cr0, cr7, {4}
     864:	02540000 	subseq	r0, r4, #0
     868:	005f591f 	subseq	r5, pc, pc, lsl r9	; <UNPREDICTABLE>
     86c:	05981200 	ldreq	r1, [r8, #512]	; 0x200
     870:	000002c7 	andeq	r0, r0, r7, asr #5
     874:	d71f0258 			; <UNDEFINED> instruction: 0xd71f0258
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
     878:	12000025 	andne	r0, r0, #37	; 0x25
     87c:	4e710599 	mrcmi	5, 3, r0, cr1, cr9, {4}
     880:	02600000 	rsbeq	r0, r0, #0
     884:	000c191f 	andeq	r1, ip, pc, lsl r9
	if (cp == NULL)
     888:	05a31200 	streq	r1, [r3, #512]!	; 0x200
     88c:	00004945 	andeq	r4, r0, r5, asr #18
		return 0;
	while (cplen > 0) {
     890:	b51f0268 	ldrlt	r0, [pc, #-616]	; fffffda0 <__crc_of_fdt_unflatten_tree+0x792be7e3>
     894:	12000000 	andne	r0, r0, #0
     898:	02c705a6 	sbceq	r0, r7, #696254464	; 0x29800000
     89c:	02880000 	addeq	r0, r8, #0
     8a0:	0016941f 	andseq	r9, r6, pc, lsl r4
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
     8a4:	05a81200 	streq	r1, [r8, #512]!	; 0x200
     8a8:	000027f1 	strdeq	r2, [r0], -r1
		cp += l;
		cplen -= l;
     8ac:	f71f0290 			; <UNDEFINED> instruction: 0xf71f0290
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
     8b0:	12000008 	andne	r0, r0, #8
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8b4:	1a6b05a9 	bne	1ac1f60 <unflatten_and_copy_device_tree+0x1ac10ec>
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
     8b8:	02a40000 	adceq	r0, r4, #0
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8bc:	006d6d1e 	rsbeq	r6, sp, lr, lsl sp
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8c0:	ae05ac12 	mcrge	12, 0, sl, cr5, cr2, {0}
     8c4:	b000001b 	andlt	r0, r0, fp, lsl r0
     8c8:	0cfd1f02 	ldcleq	15, cr1, [sp], #8

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
     8cc:	ac120000 	ldcge	0, cr0, [r2], {-0}
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8d0:	001bae05 	andseq	sl, fp, r5, lsl #28
			return score;
		l = strlen(cp) + 1;
     8d4:	1f02b400 	svcne	0x0002b400
	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8d8:	00005a18 	andeq	r5, r0, r8, lsl sl
			return score;
     8dc:	b305ae12 	movwlt	sl, #24082	; 0x5e12
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8e0:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
     8e4:	214e1f02 	cmpcs	lr, r2, lsl #30
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
     8e8:	af120000 	svcge	0x00120000
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8ec:	004e7705 	subeq	r7, lr, r5, lsl #14
     8f0:	1f02bc00 	svcne	0x0002bc00
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
     8f4:	00000517 	andeq	r0, r0, r7, lsl r5
     8f8:	5705b412 	smladpl	r5, r2, r4, fp
     8fc:	cc000000 	stcgt	0, cr0, [r0], {-0}
     900:	3fbf1f02 	svccc	0x00bf1f02
     904:	b5120000 	ldrlt	r0, [r2, #-0]
	if (fdt_getprop(blob, node, "big-endian", NULL))
     908:	00005705 	andeq	r5, r0, r5, lsl #14
     90c:	1f02d000 	svcne	0x0002d000
     910:	000058d1 	ldrdeq	r5, [r0], -r1
     914:	5705b512 	smladpl	r5, r2, r5, fp
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
     918:	d4000000 	strle	r0, [r0], #-0
     91c:	1f021f02 	svcne	0x00021f02
     920:	b6120000 	ldrlt	r0, [r2], -r0
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     924:	00005705 	andeq	r5, r0, r5, lsl #14
     928:	1f02d800 	svcne	0x0002d800
     92c:	000008f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     930:	d405b712 	strle	fp, [r5], #-1810	; 0xfffff8ee
     934:	dc000000 	stcle	0, cr0, [r0], {-0}
	unsigned int tmp, score = 0;

	if (!compat)
     938:	01a71f02 			; <UNDEFINED> instruction: 0x01a71f02
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     93c:	ba120000 	blt	480944 <unflatten_and_copy_device_tree+0x47fad0>
     940:	00006905 	andeq	r6, r0, r5, lsl #18
	unsigned int tmp, score = 0;

	if (!compat)
     944:	2002e000 	andcs	lr, r2, r0
		return 0;

	while (*compat) {
     948:	00000773 	andeq	r0, r0, r3, ror r7
     94c:	6905bd12 	stmdbvs	r5, {r1, r4, r8, sl, fp, ip, sp, pc}
     950:	04000000 	streq	r0, [r0], #-0
     954:	02e41f01 	rsceq	r1, r4, #1, 30
		tmp = of_fdt_is_compatible(blob, node, *compat);
     958:	00438620 	subeq	r8, r3, r0, lsr #12
     95c:	05be1200 	ldreq	r1, [lr, #512]!	; 0x200
     960:	00000069 	andeq	r0, r0, r9, rrx
		if (tmp && (score == 0 || (tmp < score)))
     964:	e41e0104 	ldr	r0, [lr], #-260	; 0xfffffefc
     968:	48092002 	stmdami	r9, {r1, sp}
     96c:	bf120000 	svclt	0x00120000
     970:	00006905 	andeq	r6, r0, r5, lsl #18
     974:	1d010400 	cfstrsne	mvf0, [r1, #-0]
     978:	ee2002e4 	cdp	2, 2, cr0, cr0, cr4, {7}
     97c:	12000035 	andne	r0, r0, #53	; 0x35
     980:	006905c3 	rsbeq	r0, r9, r3, asr #11
     984:	01040000 	mrseq	r0, (UNDEF: 4)
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     988:	2002e81f 	andcs	lr, r2, pc, lsl r8
     98c:	00000cae 	andeq	r0, r0, lr, lsr #25
     990:	6905c412 	stmdbvs	r5, {r1, r4, sl, lr, pc}
     994:	04000000 	streq	r0, [r0], #-0
     998:	02e81e01 	rsceq	r1, r8, #1, 28
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
     99c:	00225220 	eoreq	r5, r2, r0, lsr #4
			score = tmp;
		compat++;
	}

	return score;
}
     9a0:	05c61200 	strbeq	r1, [r6, #512]	; 0x200
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     9a4:	00000069 	andeq	r0, r0, r9, rrx
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
     9a8:	e81d0104 	ldmda	sp, {r2, r8}
	}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
     9ac:	56cc2002 	strbpl	r2, [ip], r2
     9b0:	c9120000 	ldmdbgt	r2, {}	; <UNPREDICTABLE>
     9b4:	00006905 	andeq	r6, r0, r5, lsl #18
     9b8:	1c010400 	cfstrsne	mvf0, [r1], {-0}
	if (buf)
     9bc:	372002e8 	strcc	r0, [r0, -r8, ror #5]!
		return 0;
     9c0:	1200000a 	andne	r0, r0, #10
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
	if (buf)
     9c4:	006905cc 	rsbeq	r0, r9, ip, asr #11
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9c8:	01040000 	mrseq	r0, (UNDEF: 4)
     9cc:	1f02e81b 	svcne	0x0002e81b

	offset = fdt_path_offset(fdt, "/chosen");
     9d0:	00000e05 	andeq	r0, r0, r5, lsl #28
     9d4:	d405cf12 	strle	ip, [r5], #-3858	; 0xfffff0ee
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9d8:	ec000000 	stc	0, cr0, [r0], {-0}

	offset = fdt_path_offset(fdt, "/chosen");
     9dc:	02921f02 	addseq	r1, r2, #2, 30
     9e0:	d1120000 	tstle	r2, r0
	if (offset < 0)
     9e4:	00052b05 	andeq	r2, r5, r5, lsl #22
     9e8:	1e02f000 	cdpne	0, 0, cr15, cr2, cr0, {0}
		offset = fdt_path_offset(fdt, "/chosen@0");
     9ec:	00646970 	rsbeq	r6, r4, r0, ror r9
     9f0:	e505d312 	str	sp, [r5, #-786]	; 0xfffffcee
     9f4:	18000001 	stmdane	r0, {r0}
     9f8:	19821f03 	stmibne	r2, {r0, r1, r8, r9, sl, fp, ip}
	if (offset < 0)
     9fc:	d4120000 	ldrle	r0, [r2], #-0
     a00:	0001e505 	andeq	lr, r1, r5, lsl #10
		return -ENOENT;
     a04:	1f031c00 	svcne	0x00031c00
     a08:	00005681 	andeq	r5, r0, r1, lsl #13

	p = fdt_getprop(fdt, offset, "stdout-path", &l);
     a0c:	2705df12 	smladcs	r5, r2, pc, sp	; <UNPREDICTABLE>
     a10:	20000010 	andcs	r0, r0, r0, lsl r0
     a14:	23221f03 			; <UNDEFINED> instruction: 0x23221f03
     a18:	e0120000 	ands	r0, r2, r0
     a1c:	00102705 	andseq	r2, r0, r5, lsl #14
     a20:	1f032400 	svcne	0x00032400
	if (!p)
     a24:	00004fb7 			; <UNDEFINED> instruction: 0x00004fb7
     a28:	c705e412 	smladgt	r5, r2, r4, lr
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
     a2c:	28000002 	stmdacs	r0, {r1}
     a30:	02a01f03 	adceq	r1, r0, #3, 30
     a34:	e5120000 	ldr	r0, [r2, #-0]
     a38:	0002c705 	andeq	ip, r2, r5, lsl #14
     a3c:	1f033000 	svcne	0x00033000
     a40:	00002406 	andeq	r2, r0, r6, lsl #8
	if (!p || !l)
     a44:	2705e612 	smladcs	r5, r2, r6, lr
     a48:	38000010 	stmdacc	r0, {r4}
     a4c:	5ce61f03 	stclpl	15, cr1, [r6], #12
     a50:	ed120000 	ldc	0, cr0, [r2, #-0]
     a54:	0002c705 	andeq	ip, r2, r5, lsl #14
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a58:	1f033c00 	svcne	0x00033c00
     a5c:	00001ece 	andeq	r1, r0, lr, asr #29
     a60:	c705ee12 	smladgt	r5, r2, lr, lr

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a64:	44000002 	strmi	r0, [r0], #-2
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a68:	53351f03 	teqpl	r5, #3, 30

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a6c:	f1120000 			; <UNDEFINED> instruction: 0xf1120000
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a70:	004e8705 	subeq	r8, lr, r5, lsl #14

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a74:	1f034c00 	svcne	0x00034c00
	if (offset < 0)
     a78:	00004718 	andeq	r4, r0, r8, lsl r7
     a7c:	c705f212 	smuadgt	r5, r2, r2
     a80:	70000002 	andvc	r0, r0, r2
     a84:	3f631f03 	svccc	0x00631f03
		return -ENODEV;
     a88:	f3120000 	vhadd.u16	d0, d2, d0
     a8c:	0002c705 	andeq	ip, r2, r5, lsl #14

	while (match->compatible[0]) {
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     a90:	1f037800 	svcne	0x00037800
     a94:	000016e2 	andeq	r1, r0, r2, ror #13
     a98:	c705f512 	smuadgt	r5, r2, r5
			match++;
     a9c:	8000001a 	andhi	r0, r0, sl, lsl r0
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     aa0:	18621f03 	stmdane	r2!, {r0, r1, r8, r9, sl, fp, ip}^
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     aa4:	f6120000 			; <UNDEFINED> instruction: 0xf6120000
     aa8:	001abb05 	andseq	fp, sl, r5, lsl #22
     aac:	1f038400 	svcne	0x00038400
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     ab0:	0000268c 	andeq	r2, r0, ip, lsl #13
     ab4:	bb05f712 	bllt	17e704 <unflatten_and_copy_device_tree+0x17d890>
     ab8:	8800001a 	stmdahi	r0, {r1, r3, r4}
		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
     abc:	23be1f03 			; <UNDEFINED> instruction: 0x23be1f03
     ac0:	f9120000 			; <UNDEFINED> instruction: 0xf9120000
     ac4:	00282205 	eoreq	r2, r8, r5, lsl #4
		if (addr == OF_BAD_ADDR)
     ac8:	1f038c00 	svcne	0x00038c00
     acc:	00000580 	andeq	r0, r0, r0, lsl #11
     ad0:	2205f912 	andcs	pc, r5, #294912	; 0x48000
     ad4:	90000028 	andls	r0, r0, r8, lsr #32
			return -ENXIO;
     ad8:	5bce1f03 	blpl	ff387c14 <__crc_of_fdt_unflatten_tree+0x78646657>
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
		if (addr == OF_BAD_ADDR)
     adc:	f9120000 			; <UNDEFINED> instruction: 0xf9120000
			return -ENXIO;

		of_setup_earlycon(addr, match->data);
     ae0:	00282205 	eoreq	r2, r8, r5, lsl #4
     ae4:	1f039400 	svcne	0x00039400
{
	if (buf)
		return 0;

	return early_init_dt_scan_chosen_serial();
}
     ae8:	00001d4e 	andeq	r1, r0, lr, asr #26
     aec:	2205f912 	andcs	pc, r5, #294912	; 0x48000
     af0:	98000028 	stmdals	r0, {r3, r5}
/*
 * called from unflatten_device_tree() to bootstrap devicetree itself
 * Architectures can override this definition if memblock isn't used
 */
void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
{
     af4:	158b1f03 	strne	r1, [fp, #3843]	; 0xf03
     af8:	fa120000 	blx	480b00 <unflatten_and_copy_device_tree+0x47fc8c>
     afc:	00282205 	eoreq	r2, r8, r5, lsl #4
	return __va(memblock_alloc(size, align));
     b00:	1f039c00 	svcne	0x00039c00
     b04:	000039ca 	andeq	r3, r0, sl, asr #19
}
     b08:	9c05fb12 	stcls	11, cr15, [r5], {18}
	memcpy(buf, initial_boot_params + off, count);
	return count;
}

static int __init of_fdt_raw_init(void)
{
     b0c:	a0000042 	andge	r0, r0, r2, asr #32
     b10:	308f1f03 	addcc	r1, pc, r3, lsl #30
     b14:	05120000 	ldreq	r0, [r2, #-0]
	static struct bin_attribute of_fdt_raw_attr =
		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);

	if (!initial_boot_params)
     b18:	0000d406 	andeq	sp, r0, r6, lsl #8
     b1c:	1f03ac00 	svcne	0x0003ac00
     b20:	00005052 	andeq	r5, r0, r2, asr r0
     b24:	d4060512 	strle	r0, [r6], #-1298	; 0xfffffaee
     b28:	b0000000 	andlt	r0, r0, r0
     b2c:	180a1f03 	stmdane	sl, {r0, r1, r8, r9, sl, fp, ip}
		return 0;

	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
     b30:	06120000 	ldreq	r0, [r2], -r0
     b34:	0000c906 	andeq	ip, r0, r6, lsl #18
     b38:	1f03b800 	svcne	0x0003b800
     b3c:	00004c66 	andeq	r4, r0, r6, ror #24
     b40:	c9060712 	stmdbgt	r6, {r1, r4, r8, r9, sl}
     b44:	c0000000 	andgt	r0, r0, r0
     b48:	25a31f03 	strcs	r1, [r3, #3843]!	; 0xf03
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
     b4c:	09120000 	ldmdbeq	r2, {}	; <UNPREDICTABLE>
     b50:	0000d406 	andeq	sp, r0, r6, lsl #8
     b54:	1f03c800 	svcne	0x0003c800
		return 0;
     b58:	00001c05 	andeq	r1, r0, r5, lsl #24
     b5c:	d4060912 	strle	r0, [r6], #-2322	; 0xfffff6ee
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b60:	cc000000 	stcgt	0, cr0, [r0], {-0}
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b64:	5cd61f03 	ldclpl	15, cr1, [r6], {3}
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b68:	0b120000 	bleq	480b70 <unflatten_and_copy_device_tree+0x47fcfc>
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b6c:	0042d106 	subeq	sp, r2, r6, lsl #2
     b70:	1f03d000 	svcne	0x0003d000
     b74:	00002e0e 	andeq	r2, r0, lr, lsl #28
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b78:	13060c12 	movwne	r0, #27666	; 0x6c12
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b7c:	e0000017 	and	r0, r0, r7, lsl r0
     b80:	146a1f03 	strbtne	r1, [sl], #-3843	; 0xfffff0fd
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     b84:	0f120000 	svceq	0x00120000
     b88:	004e9706 	subeq	r9, lr, r6, lsl #14
     b8c:	1f03f800 	svcne	0x0003f800
     b90:	00003690 	muleq	r0, r0, r6
	const void *blob = initial_boot_params;
     b94:	97061012 	smladls	r6, r2, r0, r1
     b98:	fc00004e 	stc2	0, cr0, [r0], {78}	; 0x4e
	const char *pathp;
	int offset, rc = 0, depth = -1;
     b9c:	277d1f03 	ldrbcs	r1, [sp, -r3, lsl #30]!
     ba0:	12120000 	andsne	r0, r2, #0
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     ba4:	004e9706 	subeq	r9, lr, r6, lsl #14
	const void *blob = initial_boot_params;
     ba8:	1f040000 	svcne	0x00040000
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     bac:	0000548c 	andeq	r5, r0, ip, lsl #9
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bb0:	a2061412 	andge	r1, r6, #301989888	; 0x12000000

        for (offset = fdt_next_node(blob, -1, &depth);
     bb4:	0400004e 	streq	r0, [r0], #-78	; 0xffffffb2
     bb8:	44791f04 	ldrbtmi	r1, [r9], #-3844	; 0xfffff0fc
				     void *data),
			   void *data)
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bbc:	19120000 	ldmdbne	r2, {}	; <UNPREDICTABLE>

        for (offset = fdt_next_node(blob, -1, &depth);
     bc0:	004eb706 	subeq	fp, lr, r6, lsl #14
     bc4:	1f041400 	svcne	0x00041400
     bc8:	00001854 	andeq	r1, r0, r4, asr r8
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bcc:	6d061c12 	stcvs	12, cr1, [r6, #-72]	; 0xffffffb8
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bd0:	18000028 	stmdane	r0, {r3, r5}
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bd4:	1ab41f04 	bne	fed07c18 <__crc_of_fdt_unflatten_tree+0x77fc665b>
     bd8:	1d120000 	ldcne	0, cr0, [r2, #-0]
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bdc:	00296806 	eoreq	r6, r9, r6, lsl #16
             offset >= 0 && depth >= 0 && !rc;
     be0:	1e041c00 	cdpne	12, 0, cr1, cr4, cr0, {0}
     be4:	12007366 	andne	r7, r0, #-1744830463	; 0x98000001
     be8:	4ec20624 	cdpmi	6, 12, cr0, cr2, cr4, {1}
     bec:	04240000 	strteq	r0, [r4], #-0
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf0:	004b851f 	subeq	r8, fp, pc, lsl r5
		if (*pathp == '/')
     bf4:	06261200 	strteq	r1, [r6], -r0, lsl #4

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf8:	00004ecd 	andeq	r4, r0, sp, asr #29
		if (*pathp == '/')
     bfc:	f41f0428 			; <UNDEFINED> instruction: 0xf41f0428
     c00:	12000028 	andne	r0, r0, #40	; 0x28
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
	const char *tail = strrchr(path, '/');
     c04:	1acd0628 	bne	ff3424ac <__crc_of_fdt_unflatten_tree+0x78600eef>
	return tail ? tail + 1 : path;
     c08:	042c0000 	strteq	r0, [ip], #-0
     c0c:	002aeb1f 	eoreq	lr, sl, pc, lsl fp
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c10:	062a1200 	strteq	r1, [sl], -r0, lsl #4
     c14:	00004ed3 	ldrdeq	r4, [r0], -r3
     c18:	aa1f0430 	bge	7c10c8 <unflatten_and_copy_device_tree+0x7c0254>
     c1c:	12000035 	andne	r0, r0, #53	; 0x35
     c20:	4ed9062b 	cdpmi	6, 13, cr0, cr9, cr11, {1}
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c24:	04340000 	ldrteq	r0, [r4], #-0
     c28:	0062991f 	rsbeq	r9, r2, pc, lsl r9

		pathp = fdt_get_name(blob, offset, NULL);
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c2c:	062d1200 	strteq	r1, [sp], -r0, lsl #4
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c30:	000029ce 	andeq	r2, r0, lr, asr #19
     c34:	e71f0438 			; <UNDEFINED> instruction: 0xe71f0438
     c38:	1200001e 	andne	r0, r0, #30
     c3c:	29ce062d 	stmibcs	lr, {r0, r2, r3, r5, r9, sl}^
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
	}
	return rc;
}
     c40:	04400000 	strbeq	r0, [r0], #-0
     c44:	005ec11f 	subseq	ip, lr, pc, lsl r1
     c48:	062e1200 	strteq	r1, [lr], -r0, lsl #4

/**
 * of_get_flat_dt_root - find the root node in the flat blob
 */
unsigned long __init of_get_flat_dt_root(void)
{
     c4c:	000029ce 	andeq	r2, r0, lr, asr #19
     c50:	801f0448 	andshi	r0, pc, r8, asr #8
     c54:	1200000c 	andne	r0, r0, #12
	return 0;
}
     c58:	2c43062f 	mcrrcs	6, 2, r0, r3, cr15
     c5c:	04500000 	ldrbeq	r0, [r0], #-0

/**
 * of_get_flat_dt_size - Return the total size of the FDT
 */
int __init of_get_flat_dt_size(void)
{
     c60:	0035681f 	eorseq	r6, r5, pc, lsl r8
     c64:	06311200 	ldrteq	r1, [r1], -r0, lsl #4
     c68:	000000d4 	ldrdeq	r0, [r0], -r4
	return fdt_totalsize(initial_boot_params);
     c6c:	f01f0460 			; <UNDEFINED> instruction: 0xf01f0460
     c70:	12000046 	andne	r0, r0, #70	; 0x46
     c74:	022e0632 	eoreq	r0, lr, #52428800	; 0x3200000
     c78:	04640000 	strbteq	r0, [r4], #-0
}
     c7c:	0050c41f 	subseq	ip, r0, pc, lsl r4
     c80:	06341200 	ldrteq	r1, [r4], -r0, lsl #4
 * This function can be used within scan_flattened_dt callback to get
 * access to properties
 */
const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
				       int *size)
{
     c84:	00000361 	andeq	r0, r0, r1, ror #6
     c88:	321f0468 	andscc	r0, pc, #104, 8	; 0x68000000
     c8c:	12000000 	andne	r0, r0, #0
	return fdt_getprop(initial_boot_params, node, name, size);
     c90:	4ee40636 	mcrmi	6, 7, r0, cr4, cr6, {1}
     c94:	046c0000 	strbteq	r0, [ip], #-0
     c98:	004d391f 	subeq	r3, sp, pc, lsl r9
     c9c:	063b1200 	ldrteq	r1, [fp], -r0, lsl #4
     ca0:	00002dfe 	strdeq	r2, [r0], -lr
     ca4:	3d1f0470 	cfldrscc	mvf0, [pc, #-448]	; fffffe48 <__crc_of_fdt_unflatten_tree+0x792be88b>
     ca8:	12000029 	andne	r0, r0, #41	; 0x29
}
     cac:	00b3063e 	adcseq	r0, r3, lr, lsr r6
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cb0:	04780000 	ldrbteq	r0, [r8], #-0
     cb4:	00054e1f 	andeq	r4, r5, pc, lsl lr
     cb8:	063f1200 	ldrteq	r1, [pc], -r0, lsl #4
	const __be32 *prop;

	if (depth != 0)
     cbc:	000000b3 	strheq	r0, [r0], -r3
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cc0:	801f047c 	andshi	r0, pc, ip, ror r4	; <UNPREDICTABLE>
	const __be32 *prop;

	if (depth != 0)
     cc4:	12000015 	andne	r0, r0, #21
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cc8:	10ff0642 	rscsne	r0, pc, r2, asr #12
     ccc:	04800000 	streq	r0, [r0], #0
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     cd0:	00014e1f 	andeq	r4, r1, pc, lsl lr
     cd4:	06451200 	strbeq	r1, [r5], -r0, lsl #4
	const __be32 *prop;

	if (depth != 0)
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cd8:	000010cd 	andeq	r1, r0, sp, asr #1
     cdc:	e81f0484 	ldmda	pc, {r2, r7, sl}	; <UNPREDICTABLE>
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     ce0:	12000025 	andne	r0, r0, #37	; 0x25

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     ce4:	49b10647 	ldmibmi	r1!, {r0, r1, r2, r6, r9, sl}
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     ce8:	04880000 	streq	r0, [r8], #0
     cec:	0024131f 	eoreq	r1, r4, pc, lsl r3
     cf0:	064b1200 	strbeq	r1, [fp], -r0, lsl #4

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
     cf4:	00001aa2 	andeq	r1, r0, r2, lsr #21
     cf8:	8b1f048c 	blhi	7c1238 <unflatten_and_copy_device_tree+0x7c03c4>
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     cfc:	1200005e 	andne	r0, r0, #94	; 0x5e
     d00:	1a9c064c 	bne	fe702638 <__crc_of_fdt_unflatten_tree+0x779c107b>
	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
     d04:	04900000 	ldreq	r0, [r0], #0
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     d08:	004fc01f 	subeq	ip, pc, pc, lsl r0	; <UNPREDICTABLE>
	if (prop)
     d0c:	064e1200 	strbeq	r1, [lr], -r0, lsl #4
     d10:	00004eef 	andeq	r4, r0, pc, ror #29
     d14:	031f0494 	tsteq	pc, #148, 8	; 0x94000000
		dt_root_addr_cells = be32_to_cpup(prop);
     d18:	1200002a 	andne	r0, r0, #42	; 0x2a
     d1c:	00690656 	rsbeq	r0, r9, r6, asr r6
     d20:	04980000 	ldreq	r0, [r8], #0
     d24:	0018771f 	andseq	r7, r8, pc, lsl r7
				   int depth, void *data)
{
	const __be32 *prop;

	if (depth != 0)
		return 0;
     d28:	06571200 	ldrbeq	r1, [r7], -r0, lsl #4
     d2c:	000000d4 	ldrdeq	r0, [r0], -r4
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (prop)
     d30:	2f1f049c 	svccs	0x001f049c
		dt_root_addr_cells = be32_to_cpup(prop);
	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);

	/* break now */
	return 1;
}
     d34:	12000045 	andne	r0, r0, #69	; 0x45
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d38:	00d40658 	sbcseq	r0, r4, r8, asr r6
     d3c:	04a00000 	strteq	r0, [r0], #0
     d40:	004e791f 	subeq	r7, lr, pc, lsl r9
     d44:	06591200 	ldrbeq	r1, [r9], -r0, lsl #4
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d48:	00000069 	andeq	r0, r0, r9, rrx
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d4c:	a11f04a4 	tstge	pc, r4, lsr #9
     d50:	12000006 	andne	r0, r0, #6
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d54:	0069065a 	rsbeq	r0, r9, sl, asr r6
     d58:	04a80000 	strteq	r0, [r8], #0
     d5c:	002da51f 	eoreq	sl, sp, pc, lsl r5
     d60:	065b1200 	ldrbeq	r1, [fp], -r0, lsl #4
     d64:	00000057 	andeq	r0, r0, r7, asr r0
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
		return 0;
     d68:	b31f04ac 	tstlt	pc, #172, 8	; 0xac000000
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d6c:	12000063 	andne	r0, r0, #99	; 0x63
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d70:	0057065c 	subseq	r0, r7, ip, asr r6
     d74:	04b00000 	ldrteq	r0, [r0], #0
     d78:	0058441f 	subseq	r4, r8, pc, lsl r4
     d7c:	065d1200 	ldrbeq	r1, [sp], -r0, lsl #4
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d80:	000000d4 	ldrdeq	r0, [r0], -r4
     d84:	861f04b4 			; <UNDEFINED> instruction: 0x861f04b4
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d88:	12000037 	andne	r0, r0, #55	; 0x37
     d8c:	00d4065e 	sbcseq	r0, r4, lr, asr r6
     d90:	04b80000 	ldrteq	r0, [r8], #0
     d94:	0038bb1f 	eorseq	fp, r8, pc, lsl fp
     d98:	065f1200 	ldrbeq	r1, [pc], -r0, lsl #4
		return 0;
     d9c:	00000069 	andeq	r0, r0, r9, rrx
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     da0:	aa1f04bc 	bge	7c12f8 <unflatten_and_copy_device_tree+0x7c0484>
	int len;
	const __be32 *prop;

	pr_debug("Looking for initrd properties... ");

	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
     da4:	12000043 	andne	r0, r0, #67	; 0x43
     da8:	00690660 	rsbeq	r0, r9, r0, ror #12
     dac:	04c00000 	strbeq	r0, [r0], #0
     db0:	000a5f1f 	andeq	r5, sl, pc, lsl pc
     db4:	06611200 	strbteq	r1, [r1], -r0, lsl #4
	if (!prop)
     db8:	00000057 	andeq	r0, r0, r7, asr r0
     dbc:	6d1f04c4 	cfldrsvs	mvf0, [pc, #-784]	; fffffcf8 <__crc_of_fdt_unflatten_tree+0x792be73b>
		return;
	start = of_read_number(prop, len/4);
     dc0:	12000008 	andne	r0, r0, #8
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     dc4:	00570662 	subseq	r0, r7, r2, ror #12
     dc8:	04c80000 	strbeq	r0, [r8], #0
     dcc:	0025861f 	eoreq	r8, r5, pc, lsl r6
     dd0:	066e1200 	strbteq	r1, [lr], -r0, lsl #4
     dd4:	00000378 	andeq	r0, r0, r8, ror r3
	while (size--)
     dd8:	9a1f04cc 	bls	7c1338 <unflatten_and_copy_device_tree+0x7c04c4>
		r = (r << 32) | be32_to_cpu(*(cell++));
     ddc:	12000015 	andne	r0, r0, #21

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     de0:	4efa0671 	mrcmi	6, 7, r0, cr10, cr1, {3}
     de4:	04d00000 	ldrbeq	r0, [r0], #0
     de8:	003b331f 	eorseq	r3, fp, pc, lsl r3
		r = (r << 32) | be32_to_cpu(*(cell++));
     dec:	06751200 	ldrbteq	r1, [r5], -r0, lsl #4
     df0:	00004f05 	andeq	r4, r0, r5, lsl #30

	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
     df4:	2c1f04d4 	cfldrscs	mvf0, [pc], {212}	; 0xd4
     df8:	1200004e 	andne	r0, r0, #78	; 0x4e
     dfc:	4f100679 	svcmi	0x00100679
     e00:	04d80000 	ldrbeq	r0, [r8], #0
     e04:	000ae31f 	andeq	lr, sl, pc, lsl r3
	if (!prop)
     e08:	067b1200 	ldrbteq	r1, [fp], -r0, lsl #4
     e0c:	00004f1b 	andeq	r4, r0, fp, lsl pc
		return;
	end = of_read_number(prop, len/4);
     e10:	951f04dc 	ldrls	r0, [pc, #-1244]	; fffffb2c <__crc_of_fdt_unflatten_tree+0x792be56f>
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     e14:	12000046 	andne	r0, r0, #70	; 0x46
     e18:	4f26067d 	svcmi	0x0026067d
     e1c:	04e00000 	strbteq	r0, [r0], #0
     e20:	003e261f 	eorseq	r2, lr, pc, lsl r6
     e24:	067f1200 	ldrbteq	r1, [pc], -r0, lsl #4
	while (size--)
     e28:	000000d4 	ldrdeq	r0, [r0], -r4
		r = (r << 32) | be32_to_cpu(*(cell++));
     e2c:	ad1f04e4 	cfldrsge	mvf0, [pc, #-912]	; fffffc78 <__crc_of_fdt_unflatten_tree+0x792be6bb>

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e30:	12000011 	andne	r0, r0, #17
		r = (r << 32) | be32_to_cpu(*(cell++));
     e34:	4f2c0680 	svcmi	0x002c0680
     e38:	04e80000 	strbteq	r0, [r8], #0

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e3c:	0003251f 	andeq	r2, r3, pc, lsl r5
     e40:	06811200 	streq	r1, [r1], r0, lsl #4
		r = (r << 32) | be32_to_cpu(*(cell++));
     e44:	000030a4 	andeq	r3, r0, r4, lsr #1
     e48:	271f04ec 	ldrcs	r0, [pc, -ip, ror #9]
     e4c:	12000024 	andne	r0, r0, #36	; 0x24
     e50:	126f0688 	rsbne	r0, pc, #136, 12	; 0x8800000
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e54:	04ec0000 	strbteq	r0, [ip], #0
	initrd_end = (unsigned long)__va(end);
     e58:	0040b21f 	subeq	fp, r0, pc, lsl r2
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e5c:	06891200 	streq	r1, [r9], r0, lsl #4
	initrd_end = (unsigned long)__va(end);
     e60:	0000120f 	andeq	r1, r0, pc, lsl #4
	initrd_below_start_ok = 1;
     e64:	5b1f04f0 	blpl	7c13c8 <unflatten_and_copy_device_tree+0x7c0554>
     e68:	1200002a 	andne	r0, r0, #42	; 0x2a
     e6c:	0057068a 	subseq	r0, r7, sl, lsl #13
     e70:	04f40000 	ldrbteq	r0, [r4], #0
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e74:	000e5f1f 	andeq	r5, lr, pc, lsl pc
	initrd_end = (unsigned long)__va(end);
	initrd_below_start_ok = 1;
     e78:	068b1200 	streq	r1, [fp], r0, lsl #4
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
	initrd_end = (unsigned long)__va(end);
     e7c:	00000057 	andeq	r0, r0, r7, asr r0
	initrd_below_start_ok = 1;
     e80:	631f04f8 	tstvs	pc, #248, 8	; 0xf8000000
		return 0;

	early_init_dt_check_for_initrd(node);

	/* Retrieve command line */
	p = of_get_flat_dt_prop(node, "bootargs", &l);
     e84:	12000063 	andne	r0, r0, #99	; 0x63
     e88:	3c21068f 	stccc	6, cr0, [r1], #-572	; 0xfffffdc4
     e8c:	04fc0000 	ldrbteq	r0, [ip], #0
     e90:	0023961f 	eoreq	r9, r3, pc, lsl r6
     e94:	06911200 	ldreq	r1, [r1], r0, lsl #4
	if (p != NULL && l > 0)
     e98:	000002c7 	andeq	r0, r0, r7, asr #5
     e9c:	a61f0500 	ldrge	r0, [pc], -r0, lsl #10
     ea0:	1200004f 	andne	r0, r0, #79	; 0x4f
     ea4:	4f370694 	svcmi	0x00370694
     ea8:	05080000 	streq	r0, [r8, #-0]
		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
     eac:	00094a1f 	andeq	r4, r9, pc, lsl sl
     eb0:	06981200 	ldreq	r1, [r8], r0, lsl #4
     eb4:	000002c7 	andeq	r0, r0, r7, asr #5
     eb8:	9a1f050c 	bls	7c1438 <unflatten_and_copy_device_tree+0x7c05c4>
	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE
	 * is set in which case we override whatever was found earlier.
	 */
#ifdef CONFIG_CMDLINE
#ifndef CONFIG_CMDLINE_FORCE
	if (!((char *)data)[0])
     ebc:	12000036 	andne	r0, r0, #54	; 0x36
     ec0:	4f420699 	svcmi	0x00420699
     ec4:	05140000 	ldreq	r0, [r4, #-0]
#endif
		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
     ec8:	000f651f 	andeq	r6, pc, pc, lsl r5	; <UNPREDICTABLE>
     ecc:	069c1200 	ldreq	r1, [ip], r0, lsl #4
     ed0:	00004f48 	andeq	r4, r0, r8, asr #30
     ed4:	f41f0518 			; <UNDEFINED> instruction: 0xf41f0518
     ed8:	12000006 	andne	r0, r0, #6
     edc:	1940069d 	stmdbne	r0, {r0, r2, r3, r4, r7, r9, sl}^

	pr_debug("Command line is: %s\n", (char*)data);

	/* break now */
	return 1;
}
     ee0:	05200000 	streq	r0, [r0, #-0]!
     ee4:	00380f1f 	eorseq	r0, r8, pc, lsl pc
 * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
 * @node: node to test
 * @compat: compatible string to compare with compatible list.
 */
int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
{
     ee8:	069e1200 	ldreq	r1, [lr], r0, lsl #4
     eec:	000002c7 	andeq	r0, r0, r7, asr #5
     ef0:	721e0538 	andsvc	r0, lr, #56, 10	; 0xe000000
	return of_fdt_is_compatible(initial_boot_params, node, compat);
     ef4:	12007563 	andne	r7, r0, #415236096	; 0x18c00000
     ef8:	033c06d6 	teqeq	ip, #224395264	; 0xd600000
     efc:	05400000 	strbeq	r0, [r0, #-0]
     f00:	0044a81f 	subeq	sl, r4, pc, lsl r8
     f04:	06db1200 	ldrbeq	r1, [fp], r0, lsl #4
     f08:	00004f68 	andeq	r4, r0, r8, ror #30
}
     f0c:	071f0548 	ldreq	r0, [pc, -r8, asr #10]

/**
 * of_flat_dt_match - Return true if node matches a list of compatible values
 */
int __init of_flat_dt_match(unsigned long node, const char *const *compat)
{
     f10:	12000035 	andne	r0, r0, #53	; 0x35
     f14:	22a306dd 	adccs	r0, r3, #231735296	; 0xdd00000
     f18:	054c0000 	strbeq	r0, [ip, #-0]
	return of_fdt_match(initial_boot_params, node, compat);
     f1c:	0005341f 	andeq	r3, r5, pc, lsl r4
     f20:	06e91200 	strbteq	r1, [r9], r0, lsl #4
     f24:	00000057 	andeq	r0, r0, r7, asr r0
     f28:	d81f0554 	ldmdale	pc, {r2, r4, r6, r8, sl}	; <UNPREDICTABLE>
     f2c:	12000008 	andne	r0, r0, #8
     f30:	005706ea 	subseq	r0, r7, sl, ror #13
}
     f34:	05580000 	ldrbeq	r0, [r8, #-0]
	int (*iterator)(unsigned long node, const char *uname, int depth, void *data);
	void *data;
};

const char * __init of_flat_dt_get_machine_name(void)
{
     f38:	0055c01f 	subseq	ip, r5, pc, lsl r0
     f3c:	06eb1200 	strbteq	r1, [fp], r0, lsl #4
     f40:	000000d4 	ldrdeq	r0, [r0], -r4
	const char *name;
	unsigned long dt_root = of_get_flat_dt_root();

	name = of_get_flat_dt_prop(dt_root, "model", NULL);
     f44:	cf1f055c 	svcgt	0x001f055c
     f48:	12000047 	andne	r0, r0, #71	; 0x47
     f4c:	00d406f5 	ldrsheq	r0, [r4], #101	; 0x65
     f50:	05600000 	strbeq	r0, [r0, #-0]!
     f54:	0030521f 	eorseq	r5, r0, pc, lsl r2
	if (!name)
     f58:	06f61200 	ldrbteq	r1, [r6], r0, lsl #4
     f5c:	000000d4 	ldrdeq	r0, [r0], -r4
		name = of_get_flat_dt_prop(dt_root, "compatible", NULL);
     f60:	361f0564 	ldrcc	r0, [pc], -r4, ror #10
     f64:	12000032 	andne	r0, r0, #50	; 0x32
     f68:	005706fd 	ldrsheq	r0, [r7], #-109	; 0xffffff93
     f6c:	05680000 	strbeq	r0, [r8, #-0]!
	return name;
}
     f70:	0054821f 	subseq	r8, r4, pc, lsl r2
     f74:	06ff1200 	ldrbteq	r1, [pc], r0, lsl #4
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f78:	00004f73 	andeq	r4, r0, r3, ror pc
     f7c:	771f056c 	ldrvc	r0, [pc, -ip, ror #10]
     f80:	12000014 	andne	r0, r0, #20
     f84:	00820701 	addeq	r0, r2, r1, lsl #14
	const void *data = NULL;
	const void *best_data = default_match;
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;
     f88:	05700000 	ldrbeq	r0, [r0, #-0]!
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f8c:	0029ab1f 	eoreq	sl, r9, pc, lsl fp
     f90:	07061200 	streq	r1, [r6, -r0, lsl #4]
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;

	dt_root = of_get_flat_dt_root();
	while ((data = get_next_compat(&compat))) {
     f94:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
     f98:	d81f0578 	ldmdale	pc, {r3, r4, r5, r6, r8, sl}	; <UNPREDICTABLE>
     f9c:	1200000d 	andne	r0, r0, #13
     fa0:	02bc0708 	adcseq	r0, ip, #8, 14	; 0x200000
		score = of_flat_dt_match(dt_root, compat);
     fa4:	057c0000 	ldrbeq	r0, [ip, #-0]!
     fa8:	001e5a1f 	andseq	r5, lr, pc, lsl sl
     fac:	070c1200 	streq	r1, [ip, -r0, lsl #4]
		if (score > 0 && score < best_score) {
     fb0:	000000d4 	ldrdeq	r0, [r0], -r4
     fb4:	c81f0580 	ldmdagt	pc, {r7, r8, sl}	; <UNPREDICTABLE>
     fb8:	12000015 	andne	r0, r0, #21
     fbc:	00d4070e 	sbcseq	r0, r4, lr, lsl #14
     fc0:	05840000 	streq	r0, [r4]
     fc4:	0051931f 	subseq	r9, r1, pc, lsl r3
     fc8:	07111200 	ldreq	r1, [r1, -r0, lsl #4]
     fcc:	0000229d 	muleq	r0, sp, r2
     fd0:	3f1f0588 	svccc	0x001f0588
			best_data = data;
			best_score = score;
		}
	}
	if (!best_data) {
     fd4:	12000026 	andne	r0, r0, #38	; 0x26
     fd8:	027b0712 	rsbseq	r0, fp, #4718592	; 0x480000
		const char *prop;
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");
     fdc:	058c0000 	streq	r0, [ip]
     fe0:	000ba51f 	andeq	sl, fp, pc, lsl r5
     fe4:	07131200 	ldreq	r1, [r3, -r0, lsl #4]

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
     fe8:	00000057 	andeq	r0, r0, r7, asr r0
     fec:	e31f0590 	tst	pc, #144, 10	; 0x24000000
     ff0:	1200003f 	andne	r0, r0, #63	; 0x3f
     ff4:	00690716 	rsbeq	r0, r9, r6, lsl r7
     ff8:	05940000 	ldreq	r0, [r4]
		if (prop) {
     ffc:	0001dd1f 	andeq	sp, r1, pc, lsl sp
			while (size > 0) {
				printk("'%s' ", prop);
    1000:	07191200 	ldreq	r1, [r9, -r0, lsl #4]
    1004:	00004f79 	andeq	r4, r0, r9, ror pc
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
    1008:	c21f0598 	andsgt	r0, pc, #152, 10	; 0x26000000
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
				prop += strlen(prop) + 1;
			}
		}
		printk("]\n\n");
    100c:	1200001b 	andne	r0, r0, #27
    1010:	00570722 	subseq	r0, r7, r2, lsr #14
    1014:	059c0000 	ldreq	r0, [ip]
		return NULL;
    1018:	003a091f 	eorseq	r0, sl, pc, lsl r9
    101c:	07241200 	streq	r1, [r4, -r0, lsl #4]!

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
    1020:	0000115e 	andeq	r1, r0, lr, asr r1
    1024:	080005a0 	stmdaeq	r0, {r5, r7, r8, sl}
    1028:	0006f504 	andeq	pc, r6, r4, lsl #10
				printk("'%s' ", prop);
    102c:	5e641000 	cdppl	0, 6, cr1, cr4, cr0, {0}
    1030:	13040000 	movwne	r0, #16384	; 0x4000
    1034:	0010520d 	andseq	r5, r0, sp, lsl #4
				size -= strlen(prop) + 1;
    1038:	1c270f00 	stcne	15, cr0, [r7], #-0
    103c:	12130000 	andsne	r0, r3, #0
    1040:	0000009d 	muleq	r0, sp, r0
    1044:	22220f00 	eorcs	r0, r2, #0, 30
    1048:	13130000 	tstne	r3, #0
				prop += strlen(prop) + 1;
    104c:	0000009d 	muleq	r0, sp, r0

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
    1050:	04170002 	ldreq	r0, [r7], #-2
				prop += strlen(prop) + 1;
    1054:	10710b13 	rsbsne	r0, r1, r3, lsl fp
    1058:	7e180000 	cdpvc	0, 1, cr0, cr8, cr0, {0}
    105c:	13000032 	movwne	r0, #50	; 0x32
    1060:	0000b30c 	andeq	fp, r0, ip, lsl #6
		}
		printk("]\n\n");
		return NULL;
	}

	pr_info("Machine model: %s\n", of_flat_dt_get_machine_name());
    1064:	18901800 	ldmne	r0, {fp, ip}
    1068:	15130000 	ldrne	r0, [r3, #-0]
    106c:	0000102d 	andeq	r1, r0, sp, lsr #32
    1070:	13040e00 	movwne	r0, #19968	; 0x4e00
    1074:	0010800a 	andseq	r8, r0, sl

	return best_data;
    1078:	10521900 	subsne	r1, r2, r0, lsl #18
}
    107c:	00000000 	andeq	r0, r0, r0
    1080:	003cb003 	eorseq	fp, ip, r3
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1084:	71171300 	tstvc	r7, r0, lsl #6
    1088:	0e000010 	mcreq	0, 0, r0, cr0, cr0, {0}
    108c:	a01b1304 	andsge	r1, fp, r4, lsl #6
	const __be32 *p = *cellp;
    1090:	0f000010 	svceq	0x00000010
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1094:	0000155a 	andeq	r1, r0, sl, asr r5
    1098:	00b31c13 	adcseq	r1, r3, r3, lsl ip
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
    109c:	00000000 	andeq	r0, r0, r0
    10a0:	003dab03 	eorseq	sl, sp, r3, lsl #22
	const __be32 *p = *cellp;

	*cellp = p + s;
    10a4:	8b1d1300 	blhi	745cac <unflatten_and_copy_device_tree+0x744e38>
    10a8:	21000010 	tstcs	r0, r0, lsl r0
	while (size--)
    10ac:	00002afc 	strdeq	r2, [r0], -ip
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b0:	01a52c00 			; <UNDEFINED> instruction: 0x01a52c00

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10b4:	0062ab10 	rsbeq	sl, r2, r0, lsl fp
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b8:	14140400 	ldrne	r0, [r4], #-1024	; 0xfffffc00

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10bc:	000010cd 	andeq	r1, r0, sp, asr #1
    10c0:	00600e0f 	rsbeq	r0, r0, pc, lsl #28
		r = (r << 32) | be32_to_cpu(*(cell++));
    10c4:	80151400 	andshi	r1, r5, r0, lsl #8
    10c8:	00000010 	andeq	r0, r0, r0, lsl r0
    10cc:	60640300 	rsbvs	r0, r4, r0, lsl #6
    10d0:	20140000 	andscs	r0, r4, r0
	return of_read_number(p, s);
}
    10d4:	000010b4 	strheq	r1, [r0], -r4
#ifndef MAX_MEMBLOCK_ADDR
#define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)
#endif

void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
{
    10d8:	41140417 	tstmi	r4, r7, lsl r4
    10dc:	000010ec 	andeq	r1, r0, ip, ror #1
    10e0:	00236318 	eoreq	r6, r3, r8, lsl r3
    10e4:	b4421400 	strblt	r1, [r2], #-1024	; 0xfffffc00
    10e8:	00000010 	andeq	r0, r0, r0, lsl r0
    10ec:	0059e710 	subseq	lr, r9, r0, lsl r7
    10f0:	40140400 	andsmi	r0, r4, r0, lsl #8
    10f4:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
	phys_addr_t t;

	if (sizeof(phys_addr_t) == 4) {
		__pv_stub(x, t, "add", __PV_BITS_31_24);
	} else {
		__pv_stub_mov_hi(t);
    10f8:	0010d819 	andseq	sp, r0, r9, lsl r8
		__pv_add_carry_stub(x, t);
    10fc:	03000000 	movweq	r0, #0
    1100:	000058ac 	andeq	r5, r0, ip, lsr #17
    1104:	10ec4c14 	rscne	r4, ip, r4, lsl ip
	const u64 phys_offset = MIN_MEMBLOCK_ADDR;
	printk("lwg:%s:%d:phys_offset = %llx\n", __func__, __LINE__, phys_offset);
    1108:	040e0000 	streq	r0, [lr], #-0
    110c:	111f0b15 	tstne	pc, r5, lsl fp	; <UNPREDICTABLE>
    1110:	0e0f0000 	cdpeq	0, 0, cr0, cr15, cr0, {0}
    1114:	15000060 	strne	r0, [r0, #-96]	; 0xffffffa0
    1118:	0010a00c 	andseq	sl, r0, ip
    111c:	03000000 	movweq	r0, #0
    1120:	0000283b 	andeq	r2, r0, fp, lsr r8

	if (!PAGE_ALIGNED(base)) {
    1124:	110a1715 	tstne	sl, r5, lsl r7
    1128:	5d100000 	ldcpl	0, cr0, [r0, #-0]
    112c:	80000035 	andhi	r0, r0, r5, lsr r0
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
    1130:	11432116 	cmpne	r3, r6, lsl r1
    1134:	68140000 	ldmdavs	r4, {}	; <UNPREDICTABLE>
    1138:	16007062 	strne	r7, [r0], -r2, rrx
    113c:	00114323 	andseq	r4, r1, r3, lsr #6
    1140:	06000000 	streq	r0, [r0], -r0
    1144:	00001153 	andeq	r1, r0, r3, asr r1
    1148:	00001153 	andeq	r1, r0, r3, asr r1
    114c:	0000eb07 	andeq	lr, r0, r7, lsl #22
    1150:	08001f00 	stmdaeq	r0, {r8, r9, sl, fp, ip}
    1154:	00115904 	andseq	r5, r1, r4, lsl #18
    1158:	3a4b1600 	bcc	12c5808 <unflatten_and_copy_device_tree+0x12c4994>
    115c:	65100000 	ldrvs	r0, [r0, #-0]
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
    1160:	8c000007 	stchi	0, cr0, [r0], {7}
    1164:	119b2716 	orrsne	r2, fp, r6, lsl r7
    1168:	7c0f0000 	stcvc	0, cr0, [pc], {-0}
    116c:	1600002f 	strne	r0, [r0], -pc, lsr #32
    1170:	0000d429 	andeq	sp, r0, r9, lsr #8
    1174:	c00f0000 	andgt	r0, pc, r0
    1178:	16000064 	strne	r0, [r0], -r4, rrx
    117c:	0000d42a 	andeq	sp, r0, sl, lsr #8
				base, base + size);
			return;
    1180:	bf0f0400 	svclt	0x000f0400
    1184:	16000045 	strne	r0, [r0], -r5, asr #32
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    1188:	0000d42b 	andeq	sp, r0, fp, lsr #8
    118c:	220f0800 	andcs	r0, pc, #0, 16
		base = PAGE_ALIGN(base);
    1190:	16000014 			; <UNDEFINED> instruction: 0x16000014
    1194:	00112a2d 	andseq	r2, r1, sp, lsr #20
    1198:	0e000c00 	cdpeq	12, 0, cr0, cr0, cr0, {0}
    119c:	b0dc1708 	sbcslt	r1, ip, r8, lsl #14
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11a0:	0f000011 	svceq	0x00000011
		base = PAGE_ALIGN(base);
    11a4:	00003b5c 	andeq	r3, r0, ip, asr fp
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11a8:	0070dd17 	rsbseq	sp, r0, r7, lsl sp
		base = PAGE_ALIGN(base);
    11ac:	00000000 	andeq	r0, r0, r0
    11b0:	00506e03 	subseq	r6, r0, r3, lsl #28
    11b4:	9bde1700 	blls	ff786dbc <__crc_of_fdt_unflatten_tree+0x78a457ff>
    11b8:	03000011 	movweq	r0, #17
    11bc:	00004644 	andeq	r4, r0, r4, asr #12
    11c0:	02bc1e18 	adcseq	r1, ip, #24, 28	; 0x180
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11c4:	4b100000 	blmi	400008 <unflatten_and_copy_device_tree+0x3ff194>
    11c8:	0c000057 	stceq	0, cr0, [r0], {87}	; 0x57
		base = PAGE_ALIGN(base);
	}
	size &= PAGE_MASK;
    11cc:	11eb2719 	mvnne	r2, r9, lsl r7
    11d0:	5a0f0000 	bpl	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    11d4:	19000015 	stmdbne	r0, {r0, r2, r4}
    11d8:	0010ff28 	andseq	pc, r0, r8, lsr #30
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
		size = MAX_MEMBLOCK_ADDR - base + 1;
	}

	if (base + size < phys_offset) {
    11dc:	1f0f0000 	svcne	0x000f0000
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
		base = PAGE_ALIGN(base);
	}
	size &= PAGE_MASK;
    11e0:	19000006 	stmdbne	r0, {r1, r2}
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
		size = MAX_MEMBLOCK_ADDR - base + 1;
	}

	if (base + size < phys_offset) {
    11e4:	0002c729 	andeq	ip, r2, r9, lsr #14
    11e8:	03000400 	movweq	r0, #1024	; 0x400
    11ec:	00002177 	andeq	r2, r0, r7, ror r1
    11f0:	11c62b19 	bicne	r2, r6, r9, lsl fp
		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
    11f4:	92100000 	andsls	r0, r0, #0
    11f8:	0400000f 	streq	r0, [r0], #-15
    11fc:	120f2f1a 	andne	r2, pc, #26, 30	; 0x68
    1200:	e80f0000 	stmda	pc, {}	; <UNPREDICTABLE>
    1204:	1a000053 	bne	1358 <.debug_info+0x1358>
    1208:	00006930 	andeq	r6, r0, r0, lsr r9
			   base, base + size);
		return;
    120c:	03000000 	movweq	r0, #0
	}
	if (base < phys_offset) {
    1210:	000016ed 	andeq	r1, r0, sp, ror #13
    1214:	11f6341a 	mvnsne	r3, sl, lsl r4
    1218:	08220000 	stmdaeq	r2!, {}	; <UNPREDICTABLE>
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
    121c:	3e01911a 	mcrcc	1, 0, r9, cr1, cr10, {0}
    1220:	1b000012 	blne	1270 <.debug_info+0x1270>
    1224:	00000f92 	muleq	r0, r2, pc	; <UNPREDICTABLE>
    1228:	f601921a 			; <UNDEFINED> instruction: 0xf601921a
    122c:	00000011 	andeq	r0, r0, r1, lsl r0
    1230:	00155a1b 	andseq	r5, r5, fp, lsl sl
			   base, phys_offset);
		size -= phys_offset - base;
    1234:	01931a00 	orrseq	r1, r3, r0, lsl #20
    1238:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    123c:	2a230004 	bcs	8c0018 <unflatten_and_copy_device_tree+0x8bf1a4>
    1240:	1a000010 	bne	1288 <.debug_info+0x1288>
    1244:	121a0194 	andsne	r0, sl, #148, 2	; 0x25
    1248:	040e0000 	streq	r0, [lr], #-0
		base = phys_offset;
	}
	memblock_add(base, size);
    124c:	125f5f1b 	subsne	r5, pc, #27, 30	; 0x6c
    1250:	ea0f0000 	b	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    1254:	1b000044 	blne	136c <.debug_info+0x136c>
    1258:	00125f5f 	andseq	r5, r2, pc, asr pc
    125c:	06000000 	streq	r0, [r0], -r0
}
    1260:	000000d4 	ldrdeq	r0, [r0], -r4
    1264:	0000126f 	andeq	r1, r0, pc, ror #4
/**
 * early_init_dt_scan_memory - Look for an parse memory nodes
 */
int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
				     int depth, void *data)
{
    1268:	0000eb07 	andeq	lr, r0, r7, lsl #22
    126c:	03000000 	movweq	r0, #0
    1270:	000007d4 	ldrdeq	r0, [r0], -r4
    1274:	124a5f1b 	subne	r5, sl, #27, 30	; 0x6c
	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
    1278:	8d240000 	stchi	0, cr0, [r4, #-0]
    127c:	0400003b 	streq	r0, [r0], #-59	; 0xffffffc5
    1280:	00000069 	andeq	r0, r0, r9, rrx
/**
 * early_init_dt_scan_memory - Look for an parse memory nodes
 */
int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
				     int depth, void *data)
{
    1284:	b601741b 			; <UNDEFINED> instruction: 0xb601741b
	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
    1288:	0b000012 	bleq	12d8 <.debug_info+0x12d8>
	const __be32 *reg, *endp;
	int l;

	/* We are scanning "memory" nodes only */
	if (type == NULL) {
    128c:	000040a2 	andeq	r4, r0, r2, lsr #1
    1290:	0c300b00 	ldceq	11, cr0, [r0], #-0
		 * The longtrail doesn't have a device_type on the
		 * /memory node, so look for the node called /memory@0.
		 */
		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
			return 0;
	} else if (strcmp(type, "memory") != 0)
    1294:	0b010000 	bleq	4129c <unflatten_and_copy_device_tree+0x40428>
    1298:	000014a9 	andeq	r1, r0, r9, lsr #9
    129c:	2bbe0b02 	blcs	fef82c10 <__crc_of_fdt_unflatten_tree+0x78241653>
    12a0:	0b030000 	bleq	c12a8 <unflatten_and_copy_device_tree+0xc0434>
    12a4:	00000f03 	andeq	r0, r0, r3, lsl #30
		return 0;

	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
    12a8:	14ea0b03 	strbtne	r0, [sl], #2819	; 0xb03
    12ac:	0b040000 	bleq	1012b4 <unflatten_and_copy_device_tree+0x100440>
    12b0:	00004967 	andeq	r4, r0, r7, ror #18
    12b4:	040a0005 	streq	r0, [sl], #-5
    12b8:	00000069 	andeq	r0, r0, r9, rrx
	if (reg == NULL)
    12bc:	12f3261d 	rscsne	r2, r3, #30408704	; 0x1d00000
		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
			return 0;
	} else if (strcmp(type, "memory") != 0)
		return 0;

	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
    12c0:	9c0b0000 	stcls	0, cr0, [fp], {-0}
	if (reg == NULL)
    12c4:	00000039 	andeq	r0, r0, r9, lsr r0
		reg = of_get_flat_dt_prop(node, "reg", &l);
    12c8:	0034690b 	eorseq	r6, r4, fp, lsl #18
    12cc:	600b0100 	andvs	r0, fp, r0, lsl #2
    12d0:	0200001e 	andeq	r0, r0, #30
    12d4:	001c670b 	andseq	r6, ip, fp, lsl #14
    12d8:	a30b0300 	movwge	r0, #45824	; 0xb300
    12dc:	03000020 	movweq	r0, #32
	if (reg == NULL)
    12e0:	003de40b 	eorseq	lr, sp, fp, lsl #8
    12e4:	580b0400 	stmdapl	fp, {sl}
    12e8:	0500002d 	streq	r0, [r0, #-45]	; 0xffffffd3
		return 0;

	endp = reg + (l / sizeof(__be32));
    12ec:	000f290b 	andeq	r2, pc, fp, lsl #18

	pr_debug("memory scan node %s, reg size %d,\n", uname, l);

	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
    12f0:	10000600 	andne	r0, r0, r0, lsl #12
    12f4:	00001ad5 	ldrdeq	r1, [r0], -r5
	if (reg == NULL)
		reg = of_get_flat_dt_prop(node, "reg", &l);
	if (reg == NULL)
		return 0;

	endp = reg + (l / sizeof(__be32));
    12f8:	185e1d34 	ldmdane	lr, {r2, r4, r5, r8, sl, fp, ip}^
    12fc:	0f000013 	svceq	0x00000013

	pr_debug("memory scan node %s, reg size %d,\n", uname, l);

	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
    1300:	0000230f 	andeq	r2, r0, pc, lsl #6
    1304:	13185f1d 	tstne	r8, #29, 30	; 0x74
    1308:	0f000000 	svceq	0x00000000
    130c:	0000229a 	muleq	r0, sl, r2
    1310:	00d4601d 	sbcseq	r6, r4, sp, lsl r0
    1314:	00300000 	eorseq	r0, r0, r0
    1318:	0002c706 	andeq	ip, r2, r6, lsl #14
		u64 base, size;

		base = dt_mem_next_cell(dt_root_addr_cells, &reg);
    131c:	00132800 	andseq	r2, r3, r0, lsl #16
    1320:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    1324:	00050000 	andeq	r0, r5, r0
    1328:	00386610 	eorseq	r6, r8, r0, lsl r6
		size = dt_mem_next_cell(dt_root_size_cells, &reg);
    132c:	6c1d0000 	ldcvs	0, cr0, [sp], {-0}
    1330:	0000133f 	andeq	r1, r0, pc, lsr r3
    1334:	1d007814 	stcne	8, cr7, [r0, #-80]	; 0xffffffb0
    1338:	00133f6d 	andseq	r3, r3, sp, ror #30
    133c:	06000000 	streq	r0, [r0], -r0

		if (size == 0)
    1340:	000000f8 	strdeq	r0, [r0], -r8
    1344:	0000134e 	andeq	r1, r0, lr, asr #6
			continue;
		pr_debug(" - %llx ,  %llx\n", (unsigned long long)base,
		    (unsigned long long)size);

		early_init_dt_add_memory_arch(base, size);
    1348:	0000eb25 	andeq	lr, r0, r5, lsr #22
    134c:	51260000 			; <UNDEFINED> instruction: 0x51260000
    1350:	04000000 	streq	r0, [r0], #-0
    1354:	00000069 	andeq	r0, r0, r9, rrx
	}

	return 0;
}
    1358:	1431741d 	ldrtne	r7, [r1], #-1053	; 0xfffffbe3
    135c:	ec0b0000 	stc	0, cr0, [fp], {-0}
    1360:	0000004d 	andeq	r0, r0, sp, asr #32
	memblock_add(base, size);
}

int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
					phys_addr_t size, bool nomap)
{
    1364:	0014470b 	andseq	r4, r4, fp, lsl #14
    1368:	1a0b0100 	bne	2c0408 <unflatten_and_copy_device_tree+0x2bf594>
    136c:	0200003e 	andeq	r0, r0, #62	; 0x3e
    1370:	0053580b 	subseq	r5, r3, fp, lsl #16
	if (nomap)
    1374:	fa0b0200 	blx	2c0808 <unflatten_and_copy_device_tree+0x2bf994>
    1378:	0300004d 	movweq	r0, #77	; 0x4d
		return memblock_remove(base, size);
    137c:	001a8f0b 	andseq	r8, sl, fp, lsl #30
    1380:	7f0b0400 	svcvc	0x000b0400
	return memblock_reserve(base, size);
    1384:	0500003a 	streq	r0, [r0, #-58]	; 0xffffffc6
}
    1388:	004b6c0b 	subeq	r6, fp, fp, lsl #24
 * This function grabs memory from early allocator for device exclusive use
 * defined in device tree structures. It should be called by arch specific code
 * once the early allocator (i.e. memblock) has been fully activated.
 */
void __init early_init_fdt_scan_reserved_mem(void)
{
    138c:	dd0b0600 	stcle	6, cr0, [fp, #-0]
    1390:	0700001b 	smladeq	r0, fp, r0, r0
    1394:	0044110b 	subeq	r1, r4, fp, lsl #2
    1398:	8d0b0800 	stchi	8, cr0, [fp, #-0]
	int n;
	u64 base, size;

	if (!initial_boot_params)
    139c:	09000039 	stmdbeq	r0, {r0, r3, r4, r5}
    13a0:	002b570b 	eoreq	r5, fp, fp, lsl #14
    13a4:	770b0a00 	strvc	r0, [fp, -r0, lsl #20]
    13a8:	0b000006 	bleq	13c8 <.debug_info+0x13c8>
    13ac:	0054000b 	subseq	r0, r4, fp
    13b0:	510b0c00 	tstpl	fp, r0, lsl #24
    13b4:	0d00000f 	stceq	0, cr0, [r0, #-60]	; 0xffffffc4
		return;

	/* Process header /memreserve/ fields */
	for (n = 0; ; n++) {
		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
    13b8:	0047b90b 	subeq	fp, r7, fp, lsl #18
    13bc:	080b0e00 	stmdaeq	fp, {r9, sl, fp}
    13c0:	0f000065 	svceq	0x00000065
    13c4:	00012e0b 	andeq	r2, r1, fp, lsl #28
    13c8:	650b1000 	strvs	r1, [fp, #-0]
		if (!size)
    13cc:	11000025 	tstne	r0, r5, lsr #32
    13d0:	0012790b 	andseq	r7, r2, fp, lsl #18
    13d4:	c60b1200 	strgt	r1, [fp], -r0, lsl #4
			break;
		early_init_dt_reserve_memory_arch(base, size, 0);
    13d8:	1300002e 	movwne	r0, #46	; 0x2e
    13dc:	00482b0b 	subeq	r2, r8, fp, lsl #22
    13e0:	290b1400 	stmdbcs	fp, {sl, ip}

	if (!initial_boot_params)
		return;

	/* Process header /memreserve/ fields */
	for (n = 0; ; n++) {
    13e4:	15000006 	strne	r0, [r0, #-6]
		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
		if (!size)
			break;
		early_init_dt_reserve_memory_arch(base, size, 0);
    13e8:	0014000b 	andseq	r0, r4, fp
	}
    13ec:	020b1600 	andeq	r1, fp, #0, 12

	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
    13f0:	17000002 	strne	r0, [r0, -r2]
    13f4:	0018e70b 	andseq	lr, r8, fp, lsl #14
    13f8:	930b1800 	movwls	r1, #47104	; 0xb800
    13fc:	19000053 	stmdbne	r0, {r0, r1, r4, r6}
	fdt_init_reserved_mem();
    1400:	00411d0b 	subeq	r1, r1, fp, lsl #26
}
    1404:	460b1a00 	strmi	r1, [fp], -r0, lsl #20
    1408:	1b00000a 	blne	1438 <.debug_info+0x1438>
/**
 * fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
 */
static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
					  int depth, void *data)
{
    140c:	00634a0b 	rsbeq	r4, r3, fp, lsl #20
    1410:	d40b1c00 	strle	r1, [fp], #-3072	; 0xfffff400
    1414:	1d000063 	stcne	0, cr0, [r0, #-396]	; 0xfffffe74
    1418:	002fe00b 	eoreq	lr, pc, fp
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    141c:	9c0b1e00 	stcls	14, cr1, [fp], {-0}
    1420:	1f000061 	svcne	0x00000061
/**
 * fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
 */
static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
					  int depth, void *data)
{
    1424:	004a490b 	subeq	r4, sl, fp, lsl #18
    1428:	ce0b2000 	cdpgt	0, 0, cr2, cr11, cr0, {0}
    142c:	2100003d 	tstcs	r0, sp, lsr r0
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    1430:	07052600 	streq	r2, [r5, -r0, lsl #12]
    1434:	69040000 	stmdbvs	r4, {}	; <UNPREDICTABLE>
    1438:	1d000000 	stcne	0, cr0, [r0, #-0]
    143c:	001466b1 			; <UNDEFINED> instruction: 0x001466b1
    1440:	37a60b00 	strcc	r0, [r6, r0, lsl #22]!
		found = 1;
		/* scan next node */
		return 0;
	} else if (!found) {
		/* scan next node */
		return 0;
    1444:	0b000000 	bleq	144c <.debug_info+0x144c>
    1448:	000003dc 	ldrdeq	r0, [r0], -ip
{
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    144c:	25530b01 	ldrbcs	r0, [r3, #-2817]	; 0xfffff4ff
    1450:	0b020000 	bleq	81458 <unflatten_and_copy_device_tree+0x805e4>
    1454:	000058c1 	andeq	r5, r0, r1, asr #17
    1458:	013e0b03 	teqeq	lr, r3, lsl #22
    145c:	0b040000 	bleq	101464 <unflatten_and_copy_device_tree+0x1005f0>
    1460:	000057dc 	ldrdeq	r5, [r0], -ip
 */
static int __init __reserved_mem_check_root(unsigned long node)
{
	const __be32 *prop;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
    1464:	07100005 	ldreq	r0, [r0, -r5]
    1468:	1000000d 	andne	r0, r0, sp
    146c:	148bcd1d 	strne	ip, [fp], #3357	; 0xd1d
    1470:	700f0000 	andvc	r0, pc, r0
    1474:	1d000028 	stcne	0, cr0, [r0, #-160]	; 0xffffff60
	if (!prop || be32_to_cpup(prop) != dt_root_size_cells)
    1478:	0000dbd6 	ldrdeq	sp, [r0], -r6
    147c:	3d0f0000 	stccc	0, cr0, [pc, #-0]	; 8 <.debug_info+0x8>
    1480:	1d000049 	stcne	0, cr0, [r0, #-292]	; 0xfffffedc
    1484:	0000dbd7 	ldrdeq	sp, [r0], -r7
    1488:	10000800 	andne	r0, r0, r0, lsl #16
    148c:	00000b4a 	andeq	r0, r0, sl, asr #22
    1490:	bcda1d3c 	ldcllt	13, cr1, [sl], {60}	; 0x3c
    1494:	0f000014 	svceq	0x00000014
    1498:	00003e35 	andeq	r3, r0, r5, lsr lr
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
    149c:	14bcdb1d 	ldrtne	sp, [ip], #2845	; 0xb1d
    14a0:	0f000000 	svceq	0x00000000
    14a4:	00000829 	andeq	r0, r0, r9, lsr #16
    14a8:	1466dc1d 	strbtne	sp, [r6], #-3101	; 0xfffff3e3
    14ac:	0f280000 	svceq	0x00280000
	if (!prop || be32_to_cpup(prop) != dt_root_addr_cells)
    14b0:	0000230a 	andeq	r2, r0, sl, lsl #6
    14b4:	16a4de1d 	ssatne	sp, #5, sp, lsl #28
    14b8:	00380000 	eorseq	r0, r8, r0
    14bc:	0002c706 	andeq	ip, r2, r6, lsl #14
    14c0:	0014cc00 	andseq	ip, r4, r0, lsl #24
    14c4:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    14c8:	00040000 	andeq	r0, r4, r0
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "ranges", NULL);
    14cc:	00230a1c 	eoreq	r0, r3, ip, lsl sl
    14d0:	1d044000 	stcne	0, cr4, [r4, #-0]
    14d4:	16a4014d 	strtne	r0, [r4], sp, asr #2
    14d8:	e81b0000 	ldmda	fp, {}	; <UNPREDICTABLE>
    14dc:	1d000039 	stcne	0, cr0, [r0, #-228]	; 0xffffff1c
	if (!prop)
    14e0:	17980151 			; <UNDEFINED> instruction: 0x17980151
		if (__reserved_mem_check_root(node) != 0) {
			pr_err("Reserved memory: unsupported node format, ignoring\n");
			/* break scan */
			return 1;
		}
		found = 1;
    14e4:	1b000000 	blne	14ec <.debug_info+0x14ec>
	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (!prop || be32_to_cpup(prop) != dt_root_addr_cells)
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "ranges", NULL);
	if (!prop)
    14e8:	000041d7 	ldrdeq	r4, [r0], -r7
    14ec:	d401531d 	strle	r5, [r1], #-797	; 0xfffffce3
		/* scan next node */
		return 0;
	} else if (!found) {
		/* scan next node */
		return 0;
	} else if (found && depth < 2) {
    14f0:	0c000000 	stceq	0, cr0, [r0], {-0}
    14f4:	0001751b 	andeq	r7, r1, fp, lsl r5
		/* scanning of /reserved-memory has been finished */
		return 1;
	}

	status = of_get_flat_dt_prop(node, "status", NULL);
    14f8:	015e1d00 	cmpeq	lr, r0, lsl #26
    14fc:	000017a8 	andeq	r1, r0, r8, lsr #15
    1500:	113f1b10 	teqne	pc, r0, lsl fp	; <UNPREDICTABLE>
    1504:	681d0000 	ldmdavs	sp, {}	; <UNPREDICTABLE>
	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
    1508:	00006901 	andeq	r6, r0, r1, lsl #18
    150c:	281b2000 	ldmdacs	fp, {sp}
    1510:	1d000050 	stcne	0, cr0, [r0, #-320]	; 0xfffffec0
    1514:	187c016a 	ldmdane	ip!, {r1, r3, r5, r6, r8}^
    1518:	1b240000 	blne	901520 <unflatten_and_copy_device_tree+0x9006ac>
    151c:	00005f01 	andeq	r5, r0, r1, lsl #30
    1520:	82016b1d 	andhi	r6, r1, #29696	; 0x7400
    1524:	28000018 	stmdacs	r0, {r3, r4}
    1528:	0014ce1b 	andseq	ip, r4, fp, lsl lr
    152c:	01711d00 	cmneq	r1, r0, lsl #26
    1530:	000000d4 	ldrdeq	r0, [r0], -r4
    1534:	55531b2c 	ldrbpl	r1, [r3, #-2860]	; 0xfffff4d4
    1538:	781d0000 	ldmdavc	sp, {}	; <UNPREDICTABLE>
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    153c:	00188801 	andseq	r8, r8, r1, lsl #16
    1540:	c81b3000 	ldmdagt	fp, {ip, sp}
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1544:	1d000019 	stcne	0, cr0, [r0, #-100]	; 0xffffff9c
    1548:	00d40184 	sbcseq	r0, r4, r4, lsl #3
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    154c:	1b340000 	blne	d01554 <unflatten_and_copy_device_tree+0xd006e0>
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1550:	00006529 	andeq	r6, r0, r9, lsr #10
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    1554:	d401af1d 	strle	sl, [r1], #-3869	; 0xfffff0e3
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1558:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    155c:	003ed21b 	eorseq	sp, lr, fp, lsl r2
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1560:	01b01d00 	lslseq	r1, r0, #26
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    1564:	000000d4 	ldrdeq	r0, [r0], -r4
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
	if (!prop)
    1568:	37b81b3c 			; <UNDEFINED> instruction: 0x37b81b3c
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    156c:	b11d0000 	tstlt	sp, r0
    1570:	0000d401 	andeq	sp, r0, r1, lsl #8
	if (!prop)
    1574:	9b1b4000 	blls	6d0008 <unflatten_and_copy_device_tree+0x6cf194>
		return -ENOENT;

	if (len && len % t_len != 0) {
    1578:	1d000005 	stcne	0, cr0, [r0, #-20]	; 0xffffffec
    157c:	00f201b3 	ldrhteq	r0, [r2], #19
    1580:	1b440000 	blne	1101588 <unflatten_and_copy_device_tree+0x1100714>
    1584:	0000303d 	andeq	r3, r0, sp, lsr r0
    1588:	d401bb1d 	strle	fp, [r1], #-2845	; 0xfffff4e3
    158c:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    1590:	0056601b 	subseq	r6, r6, fp, lsl r0
		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
    1594:	01db1d00 	bicseq	r1, fp, r0, lsl #26
    1598:	0000188e 	andeq	r1, r0, lr, lsl #17
    159c:	319e1b4c 	orrscc	r1, lr, ip, asr #22
    15a0:	dc1d0000 	ldcle	0, cr0, [sp], {-0}
    15a4:	0000d401 	andeq	sp, r0, r1, lsl #8
		       uname);
		return -EINVAL;
	}

	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
    15a8:	f11b5000 			; <UNDEFINED> instruction: 0xf11b5000
    15ac:	1d000024 	stcne	0, cr0, [r0, #-144]	; 0xffffff70
    15b0:	00d401dd 	ldrsbeq	r0, [r4], #29
    15b4:	1b540000 	blne	15015bc <unflatten_and_copy_device_tree+0x1500748>
    15b8:	000008b2 			; <UNDEFINED> instruction: 0x000008b2
		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    15bc:	2801df1d 	stmdacs	r1, {r0, r2, r3, r4, r8, r9, sl, fp, ip, lr, pc}
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;
    15c0:	80000013 	andhi	r0, r0, r3, lsl r0
		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    15c4:	001ad51b 	andseq	sp, sl, fp, lsl r5
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;
    15c8:	01e11d00 	mvneq	r1, r0, lsl #26
		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
		       uname);
		return -EINVAL;
	}

	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
    15cc:	00001894 	muleq	r0, r4, r8
    15d0:	596a1f80 	stmdbpl	sl!, {r7, r8, r9, sl, fp, ip}^
    15d4:	e41d0000 	ldr	r0, [sp], #-0

	while (len >= t_len) {
    15d8:	0000d401 	andeq	sp, r0, r1, lsl #8
    15dc:	1f02bc00 	svcne	0x0002bc00
    15e0:	0000155a 	andeq	r1, r0, sl, asr r5
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
    15e4:	ff01e71d 			; <UNDEFINED> instruction: 0xff01e71d
    15e8:	c0000010 	andgt	r0, r0, r0, lsl r0
    15ec:	09371f02 	ldmdbeq	r7!, {r1, r8, r9, sl, fp, ip}
    15f0:	e91d0000 	ldmdb	sp, {}	; <UNPREDICTABLE>
		size = dt_mem_next_cell(dt_root_size_cells, &prop);
    15f4:	00132801 	andseq	r2, r3, r1, lsl #16
    15f8:	1f030000 	svcne	0x00030000
    15fc:	000016d0 	ldrdeq	r1, [r0], -r0
    1600:	ff01ee1d 			; <UNDEFINED> instruction: 0xff01ee1d
    1604:	00000010 	andeq	r0, r0, r0, lsl r0

		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1608:	0b4a1f03 	bleq	1287c14 <unflatten_and_copy_device_tree+0x1286da0>

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    160c:	ef1d0000 	svc	0x001d0000
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1610:	00148b01 	andseq	r8, r4, r1, lsl #22

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    1614:	1f030400 	svcne	0x00030400
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    1618:	00001dca 	andeq	r1, r0, sl, asr #27
    161c:	bb01f21d 	bllt	7de98 <unflatten_and_copy_device_tree+0x7d024>
    1620:	40000011 	andmi	r0, r0, r1, lsl r0
    1624:	62f91f03 	rscsvs	r1, r9, #3, 30
    1628:	f91d0000 			; <UNDEFINED> instruction: 0xf91d0000
    162c:	0000d401 	andeq	sp, r0, r1, lsl #8
	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1630:	1f034400 	svcne	0x00034400
    1634:	00002c4c 	andeq	r2, r0, ip, asr #24
    1638:	d401fd1d 	strle	pc, [r1], #-3357	; 0xfffff2e3
    163c:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    1640:	010a1f03 	tsteq	sl, r3, lsl #30
    1644:	ff1d0000 			; <UNDEFINED> instruction: 0xff1d0000
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
		if (first) {
    1648:	0000db01 	andeq	sp, r0, r1, lsl #22
    164c:	1f034c00 	svcne	0x00034c00
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
    1650:	000027b7 			; <UNDEFINED> instruction: 0x000027b7
    1654:	6902081d 	stmdbvs	r2, {r0, r2, r3, r4, fp}
    1658:	54000000 	strpl	r0, [r0], #-0
		if (first) {
    165c:	2f141f03 	svccs	0x00141f03
			fdt_reserved_mem_save_node(node, uname, base, size);
    1660:	091d0000 	ldmdbeq	sp, {}	; <UNPREDICTABLE>
    1664:	00006902 	andeq	r6, r0, r2, lsl #18
    1668:	1f035800 	svcne	0x00035800
    166c:	00004928 	andeq	r4, r0, r8, lsr #18
			first = 0;
    1670:	57020a1d 	smladpl	r2, sp, sl, r0
    1674:	5c000000 	stcpl	0, cr0, [r0], {-0}
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
		if (first) {
			fdt_reserved_mem_save_node(node, uname, base, size);
    1678:	0cd21f03 	ldcleq	15, cr1, [r2], {3}
    167c:	0f1d0000 	svceq	0x001d0000
	status = of_get_flat_dt_prop(node, "status", NULL);
	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
		return 0;

	err = __reserved_mem_reserve_reg(node, uname);
	if (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))
    1680:	0001fb02 	andeq	pc, r1, r2, lsl #22
    1684:	1f036000 	svcne	0x00036000
    1688:	000009dc 	ldrdeq	r0, [r0], -ip
    168c:	2802121d 	stmdacs	r2, {r0, r2, r3, r4, r9, ip}
    1690:	80000013 	andhi	r0, r0, r3, lsl r0
    1694:	33bd1f03 			; <UNDEFINED> instruction: 0x33bd1f03
    1698:	141d0000 	ldrne	r0, [sp], #-0
		fdt_reserved_mem_save_node(node, uname, 0, 0);
    169c:	0018a402 	andseq	sl, r8, r2, lsl #8
    16a0:	00038000 	andeq	r8, r3, r0
    16a4:	14cc0408 	strbne	r0, [ip], #1032	; 0x408
    16a8:	be260000 	cdplt	0, 2, cr0, cr6, cr0, {0}
    16ac:	04000014 	streq	r0, [r0], #-20	; 0xffffffec
    16b0:	00000069 	andeq	r0, r0, r9, rrx
    16b4:	16d3f31d 			; <UNDEFINED> instruction: 0x16d3f31d
    16b8:	880b0000 	stmdahi	fp, {}	; <UNPREDICTABLE>
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
		if (__reserved_mem_check_root(node) != 0) {
			pr_err("Reserved memory: unsupported node format, ignoring\n");
    16bc:	0000000a 	andeq	r0, r0, sl
    16c0:	003e100b 	eorseq	r1, lr, fp
    16c4:	920b0100 	andls	r0, fp, #0, 2
			/* break scan */
			return 1;
    16c8:	0200005f 	andeq	r0, r0, #95	; 0x5f
	if (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))
		fdt_reserved_mem_save_node(node, uname, 0, 0);

	/* scan next node */
	return 0;
}
    16cc:	00636b0b 	rsbeq	r6, r3, fp, lsl #22
    16d0:	10000300 	andne	r0, r0, r0, lsl #6
    16d4:	00002cc0 	andeq	r2, r0, r0, asr #25

/**
 * early_init_fdt_reserve_self() - reserve the memory used by the FDT blob
 */
void __init early_init_fdt_reserve_self(void)
{
    16d8:	13fe1d24 	mvnsne	r1, #36, 26	; 0x900
    16dc:	0f000017 	svceq	0x00000017
    16e0:	00003ba1 	andeq	r3, r0, r1, lsr #23
    16e4:	0057ff1d 	subseq	pc, r7, sp, lsl pc	; <UNPREDICTABLE>
	if (!initial_boot_params)
    16e8:	1b000000 	blne	16f0 <.debug_info+0x16f0>
    16ec:	000007f2 	strdeq	r0, [r0], -r2
    16f0:	5701001d 	smladpl	r1, sp, r0, r0
    16f4:	04000000 	streq	r0, [r0], #-0
    16f8:	004bb01b 	subeq	fp, fp, fp, lsl r0
	phys_addr_t t;

	if (sizeof(phys_addr_t) == 4) {
		__pv_stub(x, t, "add", __PV_BITS_31_24);
	} else {
		__pv_stub_mov_hi(t);
    16fc:	01011d00 	tsteq	r1, r0, lsl #26
		__pv_add_carry_stub(x, t);
    1700:	00000057 	andeq	r0, r0, r7, asr r0
    1704:	3e351b08 	vaddcc.f64	d1, d5, d8
    1708:	041d0000 	ldreq	r0, [sp], #-0
		return;

	/* Reserve the dtb region */
	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
    170c:	00171301 	andseq	r1, r7, r1, lsl #6
    1710:	06000c00 	streq	r0, [r0], -r0, lsl #24
    1714:	000002c7 	andeq	r0, r0, r7, asr #5
    1718:	00001723 	andeq	r1, r0, r3, lsr #14
					  fdt_totalsize(initial_boot_params),
					  0);
}
    171c:	0000eb07 	andeq	lr, r0, r7, lsl #22
    1720:	1a000200 	bne	1f28 <.debug_info+0x1f28>
	return NULL;
}
#endif

bool __init early_init_dt_verify(void *params)
{
    1724:	00000745 	andeq	r0, r0, r5, asr #14
    1728:	01071d48 	tsteq	r7, r8, asr #26
    172c:	00001758 	andeq	r1, r0, r8, asr r7
	if (!params)
    1730:	7063701d 	rsbvc	r7, r3, sp, lsl r0
    1734:	01081d00 	tsteq	r8, r0, lsl #26
		return false;
    1738:	000016d3 	ldrdeq	r1, [r0], -r3
    173c:	11db1b00 	bicsne	r1, fp, r0, lsl #22

	/* check device tree validity */
	if (fdt_check_header(params))
    1740:	0d1d0000 	ldceq	0, cr0, [sp, #-0]
    1744:	00008901 	andeq	r8, r0, r1, lsl #18
    1748:	941b2400 	ldrls	r2, [fp], #-1024	; 0xfffffc00
    174c:	1d000000 	stcne	0, cr0, [r0, #-0]
		return false;

	/* Setup flat device-tree pointer */
	initial_boot_params = params;
    1750:	1758010e 	ldrbne	r0, [r8, -lr, lsl #2]
    1754:	00250000 	eoreq	r0, r5, r0
	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
    1758:	00008906 	andeq	r8, r0, r6, lsl #18
    175c:	00176800 	andseq	r6, r7, r0, lsl #16
    1760:	00eb0700 	rsceq	r0, fp, r0, lsl #14
	/* check device tree validity */
	if (fdt_check_header(params))
		return false;

	/* Setup flat device-tree pointer */
	initial_boot_params = params;
    1764:	00200000 	eoreq	r0, r0, r0
	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
    1768:	003a5624 	eorseq	r5, sl, r4, lsr #12
    176c:	00690400 	rsbeq	r0, r9, r0, lsl #8
    1770:	141d0000 	ldrne	r0, [sp], #-0
				fdt_totalsize(initial_boot_params));
	return true;
}
    1774:	00179801 	andseq	r9, r7, r1, lsl #16
    1778:	675b0b00 	ldrbvs	r0, [fp, -r0, lsl #22]


void __init early_init_dt_scan_nodes(void)
{
    177c:	0b000000 	bleq	1784 <.debug_info+0x1784>
    1780:	00004f4c 	andeq	r4, r0, ip, asr #30
    1784:	2e6b0b01 	vmulcs.f64	d16, d11, d1
	/* Retrieve various information from the /chosen node */
	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
    1788:	0b020000 	bleq	81790 <unflatten_and_copy_device_tree+0x8091c>
    178c:	00001679 	andeq	r1, r0, r9, ror r6
    1790:	64910b03 	ldrvs	r0, [r1], #2819	; 0xb03
    1794:	00040000 	andeq	r0, r4, r0
    1798:	0000d406 	andeq	sp, r0, r6, lsl #8

	/* Initialize {size,address}-cells info */
	of_scan_flat_dt(early_init_dt_scan_root, NULL);
    179c:	0017a800 	andseq	sl, r7, r0, lsl #16
    17a0:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    17a4:	00020000 	andeq	r0, r2, r0
    17a8:	00013306 	andeq	r3, r1, r6, lsl #6

	/* Setup memory, calling early_init_dt_add_memory_arch */
	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
    17ac:	0017b800 	andseq	fp, r7, r0, lsl #16
    17b0:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    17b4:	00030000 	andeq	r0, r3, r0
    17b8:	0030f11c 	eorseq	pc, r0, ip, lsl r1	; <UNPREDICTABLE>
    17bc:	1d118000 	ldcne	0, cr8, [r1, #-0]
}

bool __init early_init_dt_scan(void *params)
{
    17c0:	187c027f 	ldmdane	ip!, {r0, r1, r2, r3, r4, r5, r6, r9}^
    17c4:	5d1b0000 	ldcpl	0, cr0, [fp, #-0]
    17c8:	1d000024 	stcne	0, cr0, [r0, #-144]	; 0xffffff70
	bool status;

	status = early_init_dt_verify(params);
    17cc:	19070280 	stmdbne	r7, {r7, r9}
	if (!status)
    17d0:	1f000000 	svcne	0x00000000
    17d4:	00004edd 	ldrdeq	r4, [r0], -sp
		return false;

	early_init_dt_scan_nodes();
    17d8:	1702811d 	smladne	r2, sp, r1, r8
	return true;
    17dc:	00000019 	andeq	r0, r0, r9, lsl r0
}
    17e0:	461f1f11 	sadd16mi	r1, pc, r1	; <UNPREDICTABLE>
 * tree of struct device_node. It also fills the "name" and "type"
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void __init unflatten_device_tree(void)
{
    17e4:	821d0000 	andshi	r0, sp, #0
    17e8:	00005702 	andeq	r5, r0, r2, lsl #14
    17ec:	1f112800 	svcne	0x00112800
	__unflatten_device_tree(initial_boot_params, &of_root,
    17f0:	0000478e 	andeq	r4, r0, lr, lsl #15
    17f4:	6402841d 	strvs	r8, [r2], #-1053	; 0xfffffbe3
    17f8:	2c000005 	stccs	0, cr0, [r0], {5}
    17fc:	4bed1f11 	blmi	ffb47c4c <__crc_of_fdt_unflatten_tree+0x78e0668f>
    1800:	991d0000 	ldmdbls	sp, {}	; <UNPREDICTABLE>
    1804:	0000d402 	andeq	sp, r0, r2, lsl #8
    1808:	1f113000 	svcne	0x00113000
    180c:	00005d72 	andeq	r5, r0, r2, ror sp
    1810:	d4029a1d 	strle	r9, [r2], #-2589	; 0xfffff5e3
				early_init_dt_alloc_memory_arch);

	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
	of_alias_scan(early_init_dt_alloc_memory_arch);
    1814:	34000000 	strcc	r0, [r0], #-0
    1818:	64081f11 	strvs	r1, [r8], #-3857	; 0xfffff0ef
    181c:	9b1d0000 	blls	741824 <unflatten_and_copy_device_tree+0x7409b0>
 * reserved such is the case when the FDT is built-in to the kernel init
 * section. If the FDT memory is reserved already then unflatten_device_tree
 * should be used instead.
 */
void __init unflatten_and_copy_device_tree(void)
{
    1820:	0000d402 	andeq	sp, r0, r2, lsl #8
    1824:	1f113800 	svcne	0x00113800
    1828:	00000846 	andeq	r0, r0, r6, asr #16
	int size;
	void *dt;

	if (!initial_boot_params) {
    182c:	57029d1d 	smladpl	r2, sp, sp, r9
    1830:	3c000000 	stccc	0, cr0, [r0], {-0}
    1834:	34791f11 	ldrbtcc	r1, [r9], #-3857	; 0xfffff0ef
    1838:	9e1d0000 	cdpls	0, 1, cr0, cr13, cr0, {0}
    183c:	0011eb02 	andseq	lr, r1, r2, lsl #22
		pr_warn("No valid device tree found, continuing without\n");
    1840:	1f114000 	svcne	0x00114000
    1844:	00002a23 	andeq	r2, r0, r3, lsr #20
    1848:	eb029f1d 	bl	a94c4 <unflatten_and_copy_device_tree+0xa8650>
		return;
    184c:	4c000011 	stcmi	0, cr0, [r0], {17}
    1850:	62d51f11 	sbcsvs	r1, r5, #17, 30	; 0x44
	}

	size = fdt_totalsize(initial_boot_params);
	dt = early_init_dt_alloc_memory_arch(size,
    1854:	a01d0000 	andsge	r0, sp, r0
    1858:	00102702 	andseq	r2, r0, r2, lsl #14
    185c:	1f115800 	svcne	0x00115800
    1860:	0000626a 	andeq	r6, r0, sl, ror #4
    1864:	5702a21d 	smladpl	r2, sp, r2, sl
    1868:	5c000000 	stcpl	0, cr0, [r0], {-0}
					     roundup_pow_of_two(FDT_V17_SIZE));

	if (dt) {
    186c:	5f111f11 	svcpl	0x00111f11
    1870:	a31d0000 	tstge	sp, #0
		memcpy(dt, initial_boot_params, size);
    1874:	00176802 	andseq	r6, r7, r2, lsl #16
    1878:	00116000 	andseq	r6, r1, r0
    187c:	17b80408 	ldrne	r0, [r8, r8, lsl #8]!
		initial_boot_params = dt;
    1880:	04080000 	streq	r0, [r8], #-0
	}
	unflatten_device_tree();
    1884:	00001723 	andeq	r1, r0, r3, lsr #14
    1888:	00d40408 	sbcseq	r0, r4, r8, lsl #8
    188c:	04080000 	streq	r0, [r8], #-0
    1890:	000011eb 	andeq	r1, r0, fp, ror #3
    1894:	0012f306 	andseq	pc, r2, r6, lsl #6
    1898:	0018a400 	andseq	sl, r8, r0, lsl #8
    189c:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    18a0:	000a0000 	andeq	r0, sl, r0
    18a4:	0011bb06 	andseq	fp, r1, r6, lsl #22
    18a8:	0018b400 	andseq	fp, r8, r0, lsl #8
    18ac:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    18b0:	00200000 	eoreq	r0, r0, r0
    18b4:	0063741a 	rsbeq	r7, r3, sl, lsl r4
    18b8:	571d0800 	ldrpl	r0, [sp, -r0, lsl #16]
    18bc:	0018dc02 	andseq	sp, r8, r2, lsl #24
    18c0:	230a1b00 	movwcs	r1, #43776	; 0xab00
    18c4:	581d0000 	ldmdapl	sp, {}	; <UNPREDICTABLE>
    18c8:	0016a402 	andseq	sl, r6, r2, lsl #8
    18cc:	7b1b0000 	blvc	6c0008 <unflatten_and_copy_device_tree+0x6bf194>
    18d0:	1d00002b 	stcne	0, cr0, [r0, #-172]	; 0xffffff54
    18d4:	00570259 	subseq	r0, r7, r9, asr r2
    18d8:	00040000 	andeq	r0, r4, r0
    18dc:	0048591a 	subeq	r5, r8, sl, lsl r9
    18e0:	6a1d2800 	bvs	74b8e8 <unflatten_and_copy_device_tree+0x74aa74>
    18e4:	0018f702 	andseq	pc, r8, r2, lsl #14
    18e8:	3c2e1b00 	stccc	11, cr1, [lr], #-0
    18ec:	6b1d0000 	blvs	7418f4 <unflatten_and_copy_device_tree+0x740a80>
    18f0:	0018f702 	andseq	pc, r8, r2, lsl #14
    18f4:	06000000 	streq	r0, [r0], -r0
    18f8:	000018b4 			; <UNDEFINED> instruction: 0x000018b4
    18fc:	00001907 	andeq	r1, r0, r7, lsl #18
    1900:	0000eb07 	andeq	lr, r0, r7, lsl #22
    1904:	06000400 	streq	r0, [r0], -r0, lsl #8
    1908:	000014cc 	andeq	r1, r0, ip, asr #9
    190c:	00001917 	andeq	r1, r0, r7, lsl r9
    1910:	0000eb07 	andeq	lr, r0, r7, lsl #22
    1914:	06000300 	streq	r0, [r0], -r0, lsl #6
    1918:	000018dc 	ldrdeq	r1, [r0], -ip
    191c:	00001927 	andeq	r1, r0, r7, lsr #18
    1920:	0000eb07 	andeq	lr, r0, r7, lsl #22
    1924:	10000000 	andne	r0, r0, r0
    1928:	00004a03 	andeq	r4, r0, r3, lsl #20
    192c:	400e1e04 	andmi	r1, lr, r4, lsl #28
    1930:	0f000019 	svceq	0x00000019
    1934:	00002157 	andeq	r2, r0, r7, asr r1
    1938:	02bc131e 	adcseq	r1, ip, #2013265920	; 0x78000000
    193c:	00000000 	andeq	r0, r0, r0
    1940:	00545310 	subseq	r5, r4, r0, lsl r3
    1944:	321f1800 	andscc	r1, pc, #0, 16
    1948:	00001989 	andeq	r1, r0, r9, lsl #19
    194c:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    1950:	bc341f00 	ldclt	15, cr1, [r4], #-0
    1954:	00000002 	andeq	r0, r0, r2
    1958:	0009d20f 	andeq	sp, r9, pc, lsl #4
    195c:	ff351f00 			; <UNDEFINED> instruction: 0xff351f00
    1960:	04000010 	streq	r0, [r0], #-16
    1964:	005f700f 	subseq	r7, pc, pc
    1968:	c7361f00 	ldrgt	r1, [r6, -r0, lsl #30]!
    196c:	08000002 	stmdaeq	r0, {r1}
    1970:	001c270f 	andseq	r2, ip, pc, lsl #14
    1974:	27381f00 	ldrcs	r1, [r8, -r0, lsl #30]!
    1978:	10000010 	andne	r0, r0, r0, lsl r0
    197c:	71736f14 	cmnvc	r3, r4, lsl pc
    1980:	273b1f00 	ldrcs	r1, [fp, -r0, lsl #30]!
    1984:	14000019 	strne	r0, [r0], #-25	; 0xffffffe7
    1988:	2a461000 	bcs	1184008 <unflatten_and_copy_device_tree+0x1183194>
    198c:	20180000 	andscs	r0, r8, r0
    1990:	0019d21b 	andseq	sp, r9, fp, lsl r2
    1994:	3ba10f00 	blcc	fe843c08 <__crc_of_fdt_unflatten_tree+0x77b0264b>
    1998:	1c200000 	stcne	0, cr0, [r0], #-0
    199c:	00000133 	andeq	r0, r0, r3, lsr r1
    19a0:	5f700f00 	svcpl	0x00700f00
    19a4:	1d200000 	stcne	0, cr0, [r0, #-0]
    19a8:	000002c7 	andeq	r0, r0, r7, asr #5
    19ac:	09d20f04 	ldmibeq	r2, {r2, r8, r9, sl, fp}^
    19b0:	1e200000 	cdpne	0, 2, cr0, cr0, cr0, {0}
    19b4:	000010cd 	andeq	r1, r0, sp, asr #1
    19b8:	736f140c 	cmnvc	pc, #12, 8	; 0xc000000
    19bc:	20200071 	eorcs	r0, r0, r1, ror r0
    19c0:	00001927 	andeq	r1, r0, r7, lsr #18
    19c4:	1c270f10 	stcne	15, cr0, [r7], #-64	; 0xffffffc0
    19c8:	25200000 	strcs	r0, [r0, #-0]!
    19cc:	00001027 	andeq	r1, r0, r7, lsr #32
    19d0:	3b100014 	blcc	400058 <unflatten_and_copy_device_tree+0x3ff1e4>
    19d4:	0400005a 	streq	r0, [r0], #-90	; 0xffffffa6
    19d8:	19eb0f21 	stmibne	fp!, {r0, r5, r8, r9, sl, fp}^
    19dc:	ea0f0000 	b	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    19e0:	21000044 	tstcs	r0, r4, asr #32
    19e4:	00125f0f 	andseq	r5, r2, pc, lsl #30
    19e8:	03000000 	movweq	r0, #0
    19ec:	000063ca 	andeq	r6, r0, sl, asr #7
    19f0:	19d20f21 	ldmibne	r2, {r0, r5, r8, r9, sl, fp}^
    19f4:	0a230000 	beq	8c0008 <unflatten_and_copy_device_tree+0x8bf194>
    19f8:	21000010 	tstcs	r0, r0, lsl r0
    19fc:	1a020299 	bne	82468 <unflatten_and_copy_device_tree+0x815f4>
    1a00:	d2060000 	andle	r0, r6, #0
    1a04:	12000019 	andne	r0, r0, #25
    1a08:	0700001a 	smladeq	r0, sl, r0, r0
    1a0c:	000000eb 	andeq	r0, r0, fp, ror #1
    1a10:	b4100000 	ldrlt	r0, [r0], #-0
    1a14:	10000030 	andne	r0, r0, r0, lsr r0
    1a18:	1a371922 	bne	dc7ea8 <unflatten_and_copy_device_tree+0xdc7034>
    1a1c:	eb0f0000 	bl	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    1a20:	22000036 	andcs	r0, r0, #54	; 0x36
    1a24:	0000691a 	andeq	r6, r0, sl, lsl r9
    1a28:	db0f0000 	blle	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    1a2c:	2200002f 	andcs	r0, r0, #47	; 0x2f
    1a30:	0011eb1b 	andseq	lr, r1, fp, lsl fp
    1a34:	27000400 	strcs	r0, [r0, -r0, lsl #8]
    1a38:	0000552c 	andeq	r5, r0, ip, lsr #10
    1a3c:	4f252308 	svcmi	0x00252308
    1a40:	1800001a 	stmdane	r0, {r1, r3, r4}
    1a44:	0000289f 	muleq	r0, pc, r8	; <UNPREDICTABLE>
    1a48:	00be2623 	adcseq	r2, lr, r3, lsr #12
    1a4c:	03000000 	movweq	r0, #0
    1a50:	00004034 	andeq	r4, r0, r4, lsr r0
    1a54:	1a372923 	bne	dcbee8 <unflatten_and_copy_device_tree+0xdcb074>
    1a58:	650c0000 	strvs	r0, [ip, #-0]
    1a5c:	0d00001a 	stceq	0, cr0, [r0, #-104]	; 0xffffff98
    1a60:	000000d4 	ldrdeq	r0, [r0], -r4
    1a64:	5a040800 	bpl	103a6c <unflatten_and_copy_device_tree+0x102bf8>
    1a68:	1000001a 	andne	r0, r0, sl, lsl r0
    1a6c:	00000a70 	andeq	r0, r0, r0, ror sl
    1a70:	9c24240c 	cfstrsls	mvf2, [r4], #-48	; 0xffffffd0
    1a74:	0f00001a 	svceq	0x0000001a
    1a78:	0000328a 	andeq	r3, r0, sl, lsl #5
    1a7c:	00d42524 	sbcseq	r2, r4, r4, lsr #10
    1a80:	0f000000 	svceq	0x00000000
    1a84:	00005298 	muleq	r0, r8, r2
    1a88:	1a9c2624 	bne	fe70b320 <__crc_of_fdt_unflatten_tree+0x779c9d63>
    1a8c:	0f040000 	svceq	0x00040000
    1a90:	00001568 	andeq	r1, r0, r8, ror #10
    1a94:	1a9c2724 	bne	fe70b72c <__crc_of_fdt_unflatten_tree+0x779ca16f>
    1a98:	00080000 	andeq	r0, r8, r0
    1a9c:	1a6b0408 	bne	1ac2ac4 <unflatten_and_copy_device_tree+0x1ac1c50>
    1aa0:	c4100000 	ldrgt	r0, [r0], #-0
    1aa4:	04000007 	streq	r0, [r0], #-7
    1aa8:	1abb2b24 	bne	feecc740 <__crc_of_fdt_unflatten_tree+0x7818b183>
    1aac:	700f0000 	andvc	r0, pc, r0
    1ab0:	2400000a 	strcs	r0, [r0], #-10
    1ab4:	001a9c2c 	andseq	r9, sl, ip, lsr #24
    1ab8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1abc:	00005704 	andeq	r5, r0, r4, lsl #14
    1ac0:	23040800 	movwcs	r0, #18432	; 0x4800
    1ac4:	08000002 	stmdaeq	r0, {r1}
    1ac8:	001a1204 	andseq	r1, sl, r4, lsl #4
    1acc:	d3040800 	movwle	r0, #18432	; 0x4800
    1ad0:	1600001a 			; <UNDEFINED> instruction: 0x1600001a
    1ad4:	000028f4 	strdeq	r2, [r0], -r4
    1ad8:	0050e603 	subseq	lr, r0, r3, lsl #12
    1adc:	e3132500 	tst	r3, #0, 10
    1ae0:	0800001a 	stmdaeq	r0, {r1, r3, r4}
    1ae4:	001ae904 	andseq	lr, sl, r4, lsl #18
    1ae8:	1af40c00 	bne	ffd04af0 <__crc_of_fdt_unflatten_tree+0x78fc3533>
    1aec:	f40d0000 	vst4.8	{d0-d3}, [sp], r0
    1af0:	0000001a 	andeq	r0, r0, sl, lsl r0
    1af4:	1afa0408 	bne	ffe82b1c <__crc_of_fdt_unflatten_tree+0x7914155f>
    1af8:	6d100000 	ldcvs	0, cr0, [r0, #-0]
    1afc:	1000002d 	andne	r0, r0, sp, lsr #32
    1b00:	1b2b6425 	blne	adab9c <unflatten_and_copy_device_tree+0xad9d28>
    1b04:	ca0f0000 	bgt	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    1b08:	2500005d 	strcs	r0, [r0, #-93]	; 0xffffffa3
    1b0c:	0011bb65 	andseq	fp, r1, r5, ror #22
    1b10:	730f0000 	movwvc	r0, #61440	; 0xf000
    1b14:	25000044 	strcs	r0, [r0, #-68]	; 0xffffffbc
    1b18:	0002c766 	andeq	ip, r2, r6, ror #14
    1b1c:	f20f0400 	vshl.s8	d0, d0, d15
    1b20:	2500001b 	strcs	r0, [r0, #-27]	; 0xffffffe5
    1b24:	001ad867 	andseq	sp, sl, r7, ror #16
    1b28:	16000c00 	strne	r0, [r0], -r0, lsl #24
    1b2c:	00003531 	andeq	r3, r0, r1, lsr r5
    1b30:	1b2b0408 	blne	ac2b58 <unflatten_and_copy_device_tree+0xac1ce4>
    1b34:	7f100000 	svcvc	0x00100000
    1b38:	0400000e 	streq	r0, [r0], #-14
    1b3c:	1b4f3d26 	blne	13d0fdc <unflatten_and_copy_device_tree+0x13d0168>
    1b40:	b80f0000 	stmdalt	pc, {}	; <UNPREDICTABLE>
    1b44:	2600000c 	strcs	r0, [r0], -ip
    1b48:	001b683e 	andseq	r6, fp, lr, lsr r8
    1b4c:	10000000 	andne	r0, r0, r0
    1b50:	0000623c 	andeq	r6, r0, ip, lsr r2
    1b54:	68412604 	stmdavs	r1, {r2, r9, sl, sp}^
    1b58:	0f00001b 	svceq	0x0000001b
    1b5c:	00002222 	andeq	r2, r0, r2, lsr #4
    1b60:	1b684226 	blne	1a12400 <unflatten_and_copy_device_tree+0x1a1158c>
    1b64:	00000000 	andeq	r0, r0, r0
    1b68:	1b4f0408 	blne	13c2b90 <unflatten_and_copy_device_tree+0x13c1d1c>
    1b6c:	04080000 	streq	r0, [r8], #-0
    1b70:	00001b74 	andeq	r1, r0, r4, ror fp
    1b74:	001b7f0c 	andseq	r7, fp, ip, lsl #30
    1b78:	03780d00 	cmneq	r8, #0, 26
    1b7c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1b80:	00006904 	andeq	r6, r0, r4, lsl #18
    1b84:	30872600 	addcc	r2, r7, r0, lsl #12
    1b88:	69040000 	stmdbvs	r4, {}	; <UNPREDICTABLE>
    1b8c:	27000000 	strcs	r0, [r0, -r0]
    1b90:	001bae4f 	andseq	sl, fp, pc, asr #28
    1b94:	14560b00 	ldrbne	r0, [r6], #-2816	; 0xfffff500
    1b98:	0b000000 	bleq	1ba0 <.debug_info+0x1ba0>
    1b9c:	00002ce4 	andeq	r2, r0, r4, ror #25
    1ba0:	5c8d0b01 	fstmiaxpl	sp, {d0-d-1}	;@ Deprecated
    1ba4:	0b020000 	bleq	81bac <unflatten_and_copy_device_tree+0x80d38>
    1ba8:	000040fc 	strdeq	r4, [r0], -ip
    1bac:	04080003 	streq	r0, [r8], #-3
    1bb0:	00001bb4 			; <UNDEFINED> instruction: 0x00001bb4
    1bb4:	0036e11c 	eorseq	lr, r6, ip, lsl r1
    1bb8:	1001a800 	andne	sl, r1, r0, lsl #16
    1bbc:	1e670188 	powned	f0, f7, #0.0
    1bc0:	e31b0000 	tst	fp, #0
    1bc4:	10000053 	andne	r0, r0, r3, asr r0
    1bc8:	05a70189 	streq	r0, [r7, #393]!	; 0x189
    1bcc:	1b000000 	blne	1bd4 <.debug_info+0x1bd4>
    1bd0:	00004483 	andeq	r4, r0, r3, lsl #9
    1bd4:	a2018a10 	andge	r8, r1, #16, 20	; 0x10000
    1bd8:	0400001a 	streq	r0, [r0], #-26	; 0xffffffe6
    1bdc:	005a181b 	subseq	r1, sl, fp, lsl r8
    1be0:	018b1000 	orreq	r1, fp, r0
    1be4:	000000b3 	strheq	r0, [r0], -r3
    1be8:	3a8e1b08 	bcc	fe386c28 <__crc_of_fdt_unflatten_tree+0x7764566b>
    1bec:	8d100000 	ldchi	0, cr0, [r0, #-0]
    1bf0:	00258401 	eoreq	r8, r5, r1, lsl #8
    1bf4:	881b0c00 	ldmdahi	fp, {sl, fp}
    1bf8:	10000002 	andne	r0, r0, r2
    1bfc:	00d40191 	smullseq	r0, r4, r1, r1
    1c00:	1b100000 	blne	401c08 <unflatten_and_copy_device_tree+0x400d94>
    1c04:	000018ad 	andeq	r1, r0, sp, lsr #17
    1c08:	d4019210 	strle	r9, [r1], #-528	; 0xfffffdf0
    1c0c:	14000000 	strne	r0, [r0], #-0
    1c10:	000db01b 	andeq	fp, sp, fp, lsl r0
    1c14:	01931000 	orrseq	r1, r3, r0
    1c18:	000000d4 	ldrdeq	r0, [r0], -r4
    1c1c:	09f21b18 	ldmibeq	r2!, {r3, r4, r8, r9, fp, ip}^
    1c20:	94100000 	ldrls	r0, [r0], #-0
    1c24:	0000d401 	andeq	sp, r0, r1, lsl #8
    1c28:	701d1c00 	andsvc	r1, sp, r0, lsl #24
    1c2c:	10006467 	andne	r6, r0, r7, ror #8
    1c30:	258a0195 	strcs	r0, [sl, #405]	; 0x195
    1c34:	1b200000 	blne	801c3c <unflatten_and_copy_device_tree+0x800dc8>
    1c38:	000054be 			; <UNDEFINED> instruction: 0x000054be
    1c3c:	bc019610 	stclt	6, cr9, [r1], {16}
    1c40:	24000002 	strcs	r0, [r0], #-2
    1c44:	000ee71b 	andeq	lr, lr, fp, lsl r7
    1c48:	01971000 	orrseq	r1, r7, r0
    1c4c:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    1c50:	40441b28 	submi	r1, r4, r8, lsr #22
    1c54:	98100000 	ldmdals	r0, {}	; <UNPREDICTABLE>
    1c58:	0011bb01 	andseq	fp, r1, r1, lsl #22
    1c5c:	2c1b2c00 	ldccs	12, cr2, [fp], {-0}
    1c60:	10000051 	andne	r0, r0, r1, asr r0
    1c64:	11bb019a 			; <UNDEFINED> instruction: 0x11bb019a
    1c68:	1b300000 	blne	c01c70 <unflatten_and_copy_device_tree+0xc00dfc>
    1c6c:	00000213 	andeq	r0, r0, r3, lsl r2
    1c70:	57019c10 	smladpl	r1, r0, ip, r9
    1c74:	34000000 	strcc	r0, [r0], #-0
    1c78:	003b0d1b 	eorseq	r0, fp, fp, lsl sp
    1c7c:	019e1000 	orrseq	r1, lr, r0
    1c80:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    1c84:	0ff61b38 	svceq	0x00f61b38
    1c88:	9f100000 	svcls	0x00100000
    1c8c:	00198901 	andseq	r8, r9, r1, lsl #18
    1c90:	bd1b3c00 	ldclt	12, cr3, [fp, #-0]
    1c94:	10000012 	andne	r0, r0, r2, lsl r0
    1c98:	02c701a1 	sbceq	r0, r7, #1073741864	; 0x40000028
    1c9c:	1b540000 	blne	1501ca4 <unflatten_and_copy_device_tree+0x1500e30>
    1ca0:	00004f23 	andeq	r4, r0, r3, lsr #30
    1ca4:	d401a710 	strle	sl, [r1], #-1808	; 0xfffff8f0
    1ca8:	5c000000 	stcpl	0, cr0, [r0], {-0}
    1cac:	000f0c1b 	andeq	r0, pc, fp, lsl ip	; <UNPREDICTABLE>
    1cb0:	01a81000 			; <UNDEFINED> instruction: 0x01a81000
    1cb4:	000000d4 	ldrdeq	r0, [r0], -r4
    1cb8:	05fd1b60 	ldrbeq	r1, [sp, #2912]!	; 0xb60
    1cbc:	aa100000 	bge	401cc4 <unflatten_and_copy_device_tree+0x400e50>
    1cc0:	0000d401 	andeq	sp, r0, r1, lsl #8
    1cc4:	ee1b6400 	cfmuls	mvf6, mvf11, mvf0
    1cc8:	10000056 	andne	r0, r0, r6, asr r0
    1ccc:	00d401ab 	sbcseq	r0, r4, fp, lsr #3
    1cd0:	1b680000 	blne	1a01cd8 <unflatten_and_copy_device_tree+0x1a00e64>
    1cd4:	0000495d 	andeq	r4, r0, sp, asr r9
    1cd8:	d401ac10 	strle	sl, [r1], #-3088	; 0xfffff3f0
    1cdc:	6c000000 	stcvs	0, cr0, [r0], {-0}
    1ce0:	00008a1b 	andeq	r8, r0, fp, lsl sl
    1ce4:	01ad1000 			; <UNDEFINED> instruction: 0x01ad1000
    1ce8:	000000d4 	ldrdeq	r0, [r0], -r4
    1cec:	301c1b70 	andscc	r1, ip, r0, ror fp
    1cf0:	ae100000 	cdpge	0, 1, cr0, cr0, cr0, {0}
    1cf4:	0000d401 	andeq	sp, r0, r1, lsl #8
    1cf8:	bb1b7400 	bllt	6dd008 <unflatten_and_copy_device_tree+0x6dc194>
    1cfc:	10000000 	andne	r0, r0, r0
    1d00:	00d401af 	sbcseq	r0, r4, pc, lsr #3
    1d04:	1b780000 	blne	1e01d0c <unflatten_and_copy_device_tree+0x1e00e98>
    1d08:	00003cde 	ldrdeq	r3, [r0], -lr
    1d0c:	d401b010 	strle	fp, [r1], #-16
    1d10:	7c000000 	stcvc	0, cr0, [r0], {-0}
    1d14:	00178b1b 	andseq	r8, r7, fp, lsl fp
    1d18:	01b11000 			; <UNDEFINED> instruction: 0x01b11000
    1d1c:	000000d4 	ldrdeq	r0, [r0], -r4
    1d20:	592c1b80 	stmdbpl	ip!, {r7, r8, r9, fp, ip}
    1d24:	b1100000 	tstlt	r0, r0
    1d28:	0000d401 	andeq	sp, r0, r1, lsl #8
    1d2c:	e71b8400 	ldr	r8, [fp, -r0, lsl #8]
    1d30:	10000027 	andne	r0, r0, r7, lsr #32
    1d34:	00d401b1 	ldrheq	r0, [r4], #17
    1d38:	1b880000 	blne	fe201d40 <__crc_of_fdt_unflatten_tree+0x774c0783>
    1d3c:	00000afd 	strdeq	r0, [r0], -sp
    1d40:	d401b110 	strle	fp, [r1], #-272	; 0xfffffef0
    1d44:	8c000000 	stchi	0, cr0, [r0], {-0}
    1d48:	00416c1b 	subeq	r6, r1, fp, lsl ip
    1d4c:	01b21000 			; <UNDEFINED> instruction: 0x01b21000
    1d50:	000000d4 	ldrdeq	r0, [r0], -r4
    1d54:	72621d90 	rsbvc	r1, r2, #144, 26	; 0x2400
    1d58:	b210006b 	andslt	r0, r0, #107	; 0x6b
    1d5c:	0000d401 	andeq	sp, r0, r1, lsl #8
    1d60:	bc1b9400 	cfldrslt	mvf9, [fp], {-0}
    1d64:	1000005f 	andne	r0, r0, pc, asr r0
    1d68:	00d401b2 	ldrheq	r0, [r4], #18
    1d6c:	1b980000 	blne	fe601d74 <__crc_of_fdt_unflatten_tree+0x778c07b7>
    1d70:	00004900 	andeq	r4, r0, r0, lsl #18
    1d74:	d401b310 	strle	fp, [r1], #-784	; 0xfffffcf0
    1d78:	9c000000 	stcls	0, cr0, [r0], {-0}
    1d7c:	003d5f1b 	eorseq	r5, sp, fp, lsl pc
    1d80:	01b31000 			; <UNDEFINED> instruction: 0x01b31000
    1d84:	000000d4 	ldrdeq	r0, [r0], -r4
    1d88:	21f81ba0 	mvnscs	r1, r0, lsr #23
    1d8c:	b3100000 	tstlt	r0, #0
    1d90:	0000d401 	andeq	sp, r0, r1, lsl #8
    1d94:	5c1ba400 	cfldrspl	mvf10, [fp], {-0}
    1d98:	10000021 	andne	r0, r0, r1, lsr #32
    1d9c:	00d401b3 	ldrheq	r0, [r4], #19
    1da0:	1ba80000 	blne	fea01da8 <__crc_of_fdt_unflatten_tree+0x77cc07eb>
    1da4:	00002652 	andeq	r2, r0, r2, asr r6
    1da8:	9001b510 	andls	fp, r1, r0, lsl r5
    1dac:	ac000025 	stcge	0, cr0, [r0], {37}	; 0x25
    1db0:	005d5a1f 	subseq	r5, sp, pc, lsl sl
    1db4:	01bb1000 			; <UNDEFINED> instruction: 0x01bb1000
    1db8:	00002536 	andeq	r2, r0, r6, lsr r5
    1dbc:	751f0154 	ldrvc	r0, [pc, #-340]	; fffffeb4 <__crc_of_fdt_unflatten_tree+0x792be8f7>
    1dc0:	10000059 	andne	r0, r0, r9, asr r0
    1dc4:	25a501bd 	strcs	r0, [r5, #445]!	; 0x1bd
    1dc8:	01600000 	cmneq	r0, r0
    1dcc:	00510f1f 	subseq	r0, r1, pc, lsl pc
    1dd0:	01bf1000 			; <UNDEFINED> instruction: 0x01bf1000
    1dd4:	000019f6 	strdeq	r1, [r0], -r6
    1dd8:	c81f0164 	ldmdagt	pc, {r2, r5, r6, r8}	; <UNPREDICTABLE>
    1ddc:	1000004e 	andne	r0, r0, lr, asr #32
    1de0:	202a01c2 	eorcs	r0, sl, r2, asr #3
    1de4:	01680000 	cmneq	r8, r0
    1de8:	00596a1f 	subseq	r6, r9, pc, lsl sl
    1dec:	01c41000 	biceq	r1, r4, r0
    1df0:	000000d4 	ldrdeq	r0, [r0], -r4
    1df4:	da1f0180 	ble	7c0608 <unflatten_and_copy_device_tree+0x7bf794>
    1df8:	10000038 	andne	r0, r0, r8, lsr r0
    1dfc:	25ab01c6 	strcs	r0, [fp, #454]!	; 0x1c6
    1e00:	01840000 	orreq	r0, r4, r0
    1e04:	0027271f 	eoreq	r2, r7, pc, lsl r7
    1e08:	01c81000 	biceq	r1, r8, r0
    1e0c:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    1e10:	6a1f0188 	bvs	7c0628 <unflatten_and_copy_device_tree+0x7bf7b4>
    1e14:	1000003a 	andne	r0, r0, sl, lsr r0
    1e18:	25b601c9 	ldrcs	r0, [r6, #457]!	; 0x1c9
    1e1c:	018c0000 	orreq	r0, ip, r0
    1e20:	001c271f 	andseq	r2, ip, pc, lsl r7
    1e24:	01d61000 	bicseq	r1, r6, r0
    1e28:	00001027 	andeq	r1, r0, r7, lsr #32
    1e2c:	3a1f0190 	bcc	7c0648 <unflatten_and_copy_device_tree+0x7bf7d4>
    1e30:	1000001c 	andne	r0, r0, ip, lsl r0
    1e34:	25c101d8 	strbcs	r0, [r1, #472]	; 0x1d8
    1e38:	01940000 	orrseq	r0, r4, r0
    1e3c:	001af51f 	andseq	pc, sl, pc, lsl r5	; <UNPREDICTABLE>
    1e40:	01db1000 	bicseq	r1, fp, r0
    1e44:	000023cc 	andeq	r2, r0, ip, asr #7
    1e48:	d91f0198 	ldmdble	pc, {r3, r4, r7, r8}	; <UNPREDICTABLE>
    1e4c:	10000032 	andne	r0, r0, r2, lsr r0
    1e50:	01fb01f9 	ldrsheq	r0, [fp, #25]!
    1e54:	019c0000 	orrseq	r0, ip, r0
    1e58:	0013191f 	andseq	r1, r3, pc, lsl r9
    1e5c:	01fb1000 	mvnseq	r1, r0
    1e60:	00001fce 	andeq	r1, r0, lr, asr #31
    1e64:	150001a0 	strne	r0, [r0, #-416]	; 0xfffffe60
    1e68:	000000d4 	ldrdeq	r0, [r0], -r4
    1e6c:	00001e76 	andeq	r1, r0, r6, ror lr
    1e70:	0000d40d 	andeq	sp, r0, sp, lsl #8
    1e74:	3f100000 	svccc	0x00100000
    1e78:	08000048 	stmdaeq	r0, {r3, r6}
    1e7c:	1e9b1928 	cdpne	9, 9, cr1, cr11, cr8, {1}
    1e80:	710f0000 	mrsvc	r0, CPSR
    1e84:	28000036 	stmdacs	r0, {r1, r2, r4, r5}
    1e88:	0000b31a 	andeq	fp, r0, sl, lsl r3
    1e8c:	050f0000 	streq	r0, [pc, #-0]	; 8 <.debug_info+0x8>
    1e90:	2800001d 	stmdacs	r0, {r0, r2, r3, r4}
    1e94:	0000d41b 	andeq	sp, r0, fp, lsl r4
    1e98:	26000400 	strcs	r0, [r0], -r0, lsl #8
    1e9c:	00003847 	andeq	r3, r0, r7, asr #16
    1ea0:	00006904 	andeq	r6, r0, r4, lsl #18
    1ea4:	c43f2900 	ldrtgt	r2, [pc], #-2304	; 1eac <.debug_info+0x1eac>
    1ea8:	0b00001e 	bleq	1f28 <.debug_info+0x1f28>
    1eac:	000049b5 			; <UNDEFINED> instruction: 0x000049b5
    1eb0:	2a3a0b00 	bcs	e82c08 <unflatten_and_copy_device_tree+0xe81d94>
    1eb4:	0b010000 	bleq	41ebc <unflatten_and_copy_device_tree+0x41048>
    1eb8:	0000569b 	muleq	r0, fp, r6
    1ebc:	1b0f0b02 	blne	3c2c10 <unflatten_and_copy_device_tree+0x3c1d9c>
    1ec0:	00030000 	andeq	r0, r3, r0
    1ec4:	4d290c0e 	stcmi	12, cr0, [r9, #-56]!	; 0xffffffc8
    1ec8:	00001ee5 	andeq	r1, r0, r5, ror #29
    1ecc:	00035b0f 	andeq	r5, r3, pc, lsl #22
    1ed0:	764e2900 	strbvc	r2, [lr], -r0, lsl #18
    1ed4:	0000001e 	andeq	r0, r0, lr, lsl r0
    1ed8:	005f320f 	subseq	r3, pc, pc, lsl #4
    1edc:	d44f2900 	strble	r2, [pc], #-2304	; 1ee4 <.debug_info+0x1ee4>
    1ee0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1ee4:	290c0e00 	stmdbcs	ip, {r9, sl, fp}
    1ee8:	001f0652 	andseq	r0, pc, r2, asr r6	; <UNPREDICTABLE>
    1eec:	3f1b0f00 	svccc	0x001b0f00
    1ef0:	53290000 			; <UNDEFINED> instruction: 0x53290000
    1ef4:	0000033c 	andeq	r0, r0, ip, lsr r3
    1ef8:	44f80f00 	ldrbtmi	r0, [r8], #3840	; 0xf00
    1efc:	54290000 	strtpl	r0, [r9], #-0
    1f00:	000000d4 	ldrdeq	r0, [r0], -r4
    1f04:	0c170008 	ldceq	0, cr0, [r7], {8}
    1f08:	1f194c29 	svcne	0x00194c29
    1f0c:	c4280000 	strtgt	r0, [r8], #-0
    1f10:	2800001e 	stmdacs	r0, {r1, r2, r3, r4}
    1f14:	00001ee5 	andeq	r1, r0, r5, ror #29
    1f18:	62e31000 	rscvs	r1, r3, #0
    1f1c:	29200000 	stmdbcs	r0!, {}	; <UNPREDICTABLE>
    1f20:	001f6849 	andseq	r6, pc, r9, asr #16
    1f24:	4ad00f00 	bmi	ff403c08 <__crc_of_fdt_unflatten_tree+0x786c264b>
    1f28:	4a290000 	bmi	a41f30 <unflatten_and_copy_device_tree+0xa410bc>
    1f2c:	00001e9b 	muleq	r0, fp, lr
    1f30:	1f061900 	svcne	0x00061900
    1f34:	0f040000 	svceq	0x00040000
    1f38:	00004b03 	andeq	r4, r0, r3, lsl #22
    1f3c:	1f6d5829 	svcne	0x006d5829
    1f40:	0f100000 	svceq	0x00100000
    1f44:	00000fd6 	ldrdeq	r0, [r0], -r6
    1f48:	00d45929 	sbcseq	r5, r4, r9, lsr #18
    1f4c:	0f140000 	svceq	0x00140000
    1f50:	000016fd 	strdeq	r1, [r0], -sp
    1f54:	1fc85b29 	svcne	0x00c85b29
    1f58:	0f180000 	svceq	0x00180000
    1f5c:	0000581b 	andeq	r5, r0, fp, lsl r8
    1f60:	00695c29 	rsbeq	r5, r9, r9, lsr #24
    1f64:	001c0000 	andseq	r0, ip, r0
    1f68:	003cff16 	eorseq	pc, ip, r6, lsl pc	; <UNPREDICTABLE>
    1f6c:	68040800 	stmdavs	r4, {fp}
    1f70:	1000001f 	andne	r0, r0, pc, lsl r0
    1f74:	00000f82 	andeq	r0, r0, r2, lsl #31
    1f78:	c85f2918 	ldmdagt	pc, {r3, r4, r8, fp, sp}^	; <UNPREDICTABLE>
    1f7c:	0f00001f 	svceq	0x0000001f
    1f80:	00003cff 	strdeq	r3, [r0], -pc	; <UNPREDICTABLE>
    1f84:	1f6d6029 	svcne	0x006d6029
    1f88:	0f000000 	svceq	0x00000000
    1f8c:	00001bf2 	strdeq	r1, [r0], -r2
    1f90:	00d46129 	sbcseq	r6, r4, r9, lsr #2
    1f94:	0f040000 	svceq	0x00040000
    1f98:	00003b2d 	andeq	r3, r0, sp, lsr #22
    1f9c:	00d46229 	sbcseq	r6, r4, r9, lsr #4
    1fa0:	0f080000 	svceq	0x00080000
    1fa4:	000000ec 	andeq	r0, r0, ip, ror #1
    1fa8:	00d46329 	sbcseq	r6, r4, r9, lsr #6
    1fac:	0f0c0000 	svceq	0x000c0000
    1fb0:	00002aa0 	andeq	r2, r0, r0, lsr #21
    1fb4:	01fb6429 	mvnseq	r6, r9, lsr #8
    1fb8:	0f100000 	svceq	0x00100000
    1fbc:	00002222 	andeq	r2, r0, r2, lsr #4
    1fc0:	1fc86629 	svcne	0x00c86629
    1fc4:	00140000 	andseq	r0, r4, r0
    1fc8:	1f730408 	svcne	0x00730408
    1fcc:	19100000 	ldmdbne	r0, {}	; <UNPREDICTABLE>
    1fd0:	04000013 	streq	r0, [r0], #-19	; 0xffffffed
    1fd4:	1fe77129 	svcne	0x00e77129
    1fd8:	ec0f0000 	stc	0, cr0, [pc], {-0}
    1fdc:	29000049 	stmdbcs	r0, {r0, r3, r6}
    1fe0:	001fec72 	andseq	lr, pc, r2, ror ip	; <UNPREDICTABLE>
    1fe4:	16000000 	strne	r0, [r0], -r0
    1fe8:	000049ec 	andeq	r4, r0, ip, ror #19
    1fec:	1fe70408 	svcne	0x00e70408
    1ff0:	180e0000 	stmdane	lr, {}	; <UNPREDICTABLE>
    1ff4:	202a062a 	eorcs	r0, sl, sl, lsr #12
    1ff8:	69140000 	ldmdbvs	r4, {}	; <UNPREDICTABLE>
    1ffc:	082a0064 	stmdaeq	sl!, {r2, r5, r6}
    2000:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
    2004:	15a30f00 	strne	r0, [r3, #3840]!	; 0xf00
    2008:	0c2a0000 	stceq	0, cr0, [sl], #-0
    200c:	00000069 	andeq	r0, r0, r9, rrx
    2010:	17f60f08 	ldrbne	r0, [r6, r8, lsl #30]!
    2014:	0d2a0000 	stceq	0, cr0, [sl, #-0]
    2018:	000000d4 	ldrdeq	r0, [r0], -r4
    201c:	30bf0f0c 	adcscc	r0, pc, ip, lsl #30
    2020:	0f2a0000 	svceq	0x002a0000
    2024:	000000d4 	ldrdeq	r0, [r0], -r4
    2028:	ec030010 	stc	0, cr0, [r3], {16}
    202c:	2a00004e 	bcs	216c <.debug_info+0x216c>
    2030:	001ff211 	andseq	pc, pc, r1, lsl r2	; <UNPREDICTABLE>
    2034:	10041700 	andne	r1, r4, r0, lsl #14
    2038:	00205430 	eoreq	r5, r0, r0, lsr r4
    203c:	07bc1800 	ldreq	r1, [ip, r0, lsl #16]!
    2040:	31100000 	tstcc	r0, r0
    2044:	00002118 	andeq	r2, r0, r8, lsl r1
    2048:	00151918 	andseq	r1, r5, r8, lsl r9
    204c:	78381000 	ldmdavc	r8!, {ip}
    2050:	00000003 	andeq	r0, r0, r3
    2054:	0049de1a 	subeq	sp, r9, sl, lsl lr
    2058:	bd2b5800 	stclt	8, cr5, [fp, #-0]
    205c:	00211801 	eoreq	r1, r1, r1, lsl #16
    2060:	2df91b00 	ldclcs	11, cr1, [r9]
    2064:	be2b0000 	cdplt	0, 2, cr0, cr11, cr0, {0}
    2068:	0060f201 	rsbeq	pc, r0, r1, lsl #4
    206c:	3b1b0000 	blcc	6c0008 <unflatten_and_copy_device_tree+0x6bf194>
    2070:	2b00000e 	blcs	20b0 <.debug_info+0x20b0>
    2074:	675a01bf 			; <UNDEFINED> instruction: 0x675a01bf
    2078:	1b040000 	blne	102080 <unflatten_and_copy_device_tree+0x10120c>
    207c:	00001576 	andeq	r1, r0, r6, ror r5
    2080:	ff01c02b 			; <UNDEFINED> instruction: 0xff01c02b
    2084:	10000010 	andne	r0, r0, r0, lsl r0
    2088:	00575d1b 	subseq	r5, r7, fp, lsl sp
    208c:	01c12b00 	biceq	r2, r1, r0, lsl #22
    2090:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    2094:	36241b14 			; <UNDEFINED> instruction: 0x36241b14
    2098:	c22b0000 	eorgt	r0, fp, #0
    209c:	001aa201 	andseq	sl, sl, r1, lsl #4
    20a0:	131b1800 	tstne	fp, #0, 16
    20a4:	2b000020 	blcs	212c <.debug_info+0x212c>
    20a8:	198901c3 	stmibne	r9, {r0, r1, r6, r7, r8}
    20ac:	1b1c0000 	blne	7020b4 <unflatten_and_copy_device_tree+0x701240>
    20b0:	00002244 	andeq	r2, r0, r4, asr #4
    20b4:	d401c52b 	strle	ip, [r1], #-1323	; 0xfffffad5
    20b8:	34000000 	strcc	r0, [r0], #-0
    20bc:	0017441b 	andseq	r4, r7, fp, lsl r4
    20c0:	01c62b00 	biceq	r2, r6, r0, lsl #22
    20c4:	000000d4 	ldrdeq	r0, [r0], -r4
    20c8:	4fdd1b38 	svcmi	0x00dd1b38
    20cc:	c72b0000 	strgt	r0, [fp, -r0]!
    20d0:	0000d401 	andeq	sp, r0, r1, lsl #8
    20d4:	3d1b3c00 	ldccc	12, cr3, [fp, #-0]
    20d8:	2b00001e 	blcs	2158 <.debug_info+0x2158>
    20dc:	763001c8 	ldrtvc	r0, [r0], -r8, asr #3
    20e0:	1b400000 	blne	10020e8 <unflatten_and_copy_device_tree+0x1001274>
    20e4:	0000596a 	andeq	r5, r0, sl, ror #18
    20e8:	d401c92b 	strle	ip, [r1], #-2347	; 0xfffff6d5
    20ec:	44000000 	strmi	r0, [r0], #-0
    20f0:	001fe81b 	andseq	lr, pc, fp, lsl r8	; <UNPREDICTABLE>
    20f4:	01ca2b00 	biceq	r2, sl, r0, lsl #22
    20f8:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    20fc:	1f101b48 	svcne	0x00101b48
    2100:	cb2b0000 	blgt	ac2108 <unflatten_and_copy_device_tree+0xac1294>
    2104:	0002c701 	andeq	ip, r2, r1, lsl #14
    2108:	ba1b4c00 	blt	6d3008 <unflatten_and_copy_device_tree+0x6d2194>
    210c:	2b000011 	blcs	2158 <.debug_info+0x2158>
    2110:	037801cc 	cmneq	r8, #204, 2	; 0x33
    2114:	00540000 	subseq	r0, r4, r0
    2118:	20540408 	subscs	r0, r4, r8, lsl #8
    211c:	04170000 	ldreq	r0, [r7], #-0
    2120:	213d3d10 	teqcs	sp, r0, lsl sp
    2124:	ca180000 	bgt	600008 <unflatten_and_copy_device_tree+0x5ff194>
    2128:	10000027 	andne	r0, r0, r7, lsr #32
    212c:	0000d43e 	andeq	sp, r0, lr, lsr r4
    2130:	22f91800 	rscscs	r1, r9, #0, 16
    2134:	3f100000 	svccc	0x00100000
    2138:	00000378 	andeq	r0, r0, r8, ror r3
    213c:	10040e00 	andne	r0, r4, r0, lsl #28
    2140:	00217365 	eoreq	r7, r1, r5, ror #6
    2144:	55922900 	ldrpl	r2, [r2, #2304]	; 0x900
    2148:	66100000 	ldrvs	r0, [r0], -r0
    214c:	00000069 	andeq	r0, r0, r9, rrx
    2150:	00101004 	andseq	r1, r0, r4
    2154:	000dc829 	andeq	ip, sp, r9, lsr #16
    2158:	69671000 	stmdbvs	r7!, {ip}^
    215c:	04000000 	streq	r0, [r0], #-0
    2160:	2900010f 	stmdbcs	r0, {r0, r1, r2, r3, r8}
    2164:	00000bf8 	strdeq	r0, [r0], -r8
    2168:	00696810 	rsbeq	r6, r9, r0, lsl r8
    216c:	01040000 	mrseq	r0, (UNDEF: 4)
    2170:	17000000 	strne	r0, [r0, -r0]
    2174:	97521004 	ldrbls	r1, [r2, -r4]
    2178:	18000021 	stmdane	r0, {r0, r5}
    217c:	00001546 	andeq	r1, r0, r6, asr #10
    2180:	02bc6310 	adcseq	r6, ip, #16, 6	; 0x40000000
    2184:	3d280000 	stccc	0, cr0, [r8, #-0]
    2188:	18000021 	stmdane	r0, {r0, r5}
    218c:	00003aa0 	andeq	r3, r0, r0, lsr #21
    2190:	00576a10 	subseq	r6, r7, r0, lsl sl
    2194:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    2198:	b2501008 	subslt	r1, r0, #8
    219c:	19000021 	stmdbne	r0, {r0, r5}
    21a0:	00002173 	andeq	r2, r0, r3, ror r1
    21a4:	61d00f00 	bicsvs	r0, r0, r0, lsl #30
    21a8:	6c100000 	ldcvs	0, cr0, [r0], {-0}
    21ac:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    21b0:	08170004 	ldmdaeq	r7, {r2}
    21b4:	21d64210 	bicscs	r4, r6, r0, lsl r2
    21b8:	af180000 	svcge	0x00180000
    21bc:	10000048 	andne	r0, r0, r8, asr #32
    21c0:	0000694d 	andeq	r6, r0, sp, asr #18
    21c4:	21972800 	orrscs	r2, r7, r0, lsl #16
    21c8:	96180000 	ldrls	r0, [r8], -r0
    21cc:	10000045 	andne	r0, r0, r5, asr #32
    21d0:	0000696e 	andeq	r6, r0, lr, ror #18
    21d4:	0c0e0000 	stceq	0, cr0, [lr], {-0}
    21d8:	21eb3c10 	mvncs	r3, r0, lsl ip
    21dc:	1e190000 	cdpne	0, 1, cr0, cr9, cr0, {0}
    21e0:	00000021 	andeq	r0, r0, r1, lsr #32
    21e4:	0021b219 	eoreq	fp, r1, r9, lsl r2
    21e8:	0e000400 	cfcpyseq	mvf0, mvf0
    21ec:	187f1008 	ldmdane	pc!, {r3, ip}^	; <UNPREDICTABLE>
    21f0:	0f000022 	svceq	0x00000022
    21f4:	00002222 	andeq	r2, r0, r2, lsr #4
    21f8:	05648010 	strbeq	r8, [r4, #-16]!
    21fc:	0f000000 	svceq	0x00000000
    2200:	000050be 	strheq	r5, [r0], -lr
    2204:	00338510 	eorseq	r8, r3, r0, lsl r5
    2208:	0f040000 	svceq	0x00040000
    220c:	000058e9 	andeq	r5, r0, r9, ror #17
    2210:	00338610 	eorseq	r8, r3, r0, lsl r6
    2214:	00060000 	andeq	r0, r6, r0
    2218:	8e10080e 	cdphi	8, 1, cr0, cr0, cr14, {0}
    221c:	00002245 	andeq	r2, r0, r5, asr #4
    2220:	005b0a0f 	subseq	r0, fp, pc, lsl #20
    2224:	d48f1000 	strle	r1, [pc], #0	; 222c <.debug_info+0x222c>
    2228:	00000000 	andeq	r0, r0, r0
    222c:	0023490f 	eoreq	r4, r3, pc, lsl #18
    2230:	459c1000 	ldrmi	r1, [ip]
    2234:	04000000 	streq	r0, [r0], #-0
    2238:	001ce00f 	andseq	lr, ip, pc
    223c:	459d1000 	ldrmi	r1, [sp]
    2240:	06000000 	streq	r0, [r0], -r0
    2244:	10081700 	andne	r1, r8, r0, lsl #14
    2248:	00226e79 	eoreq	r6, r2, r9, ror lr
    224c:	726c2a00 	rsbvc	r2, ip, #0, 20
    2250:	7a100075 	bvc	40242c <unflatten_and_copy_device_tree+0x4015b8>
    2254:	000002c7 	andeq	r0, r0, r7, asr #5
    2258:	0021eb28 	eoreq	lr, r1, r8, lsr #22
    225c:	10f31800 	rscsne	r1, r3, r0, lsl #16
    2260:	8a100000 	bhi	402268 <unflatten_and_copy_device_tree+0x4013f4>
    2264:	0000033c 	andeq	r0, r0, ip, lsr r3
    2268:	00221828 	eoreq	r1, r2, r8, lsr #16
    226c:	04170000 	ldreq	r0, [r7], #-0
    2270:	228dad10 	addcs	sl, sp, #16, 26	; 0x400
    2274:	6d180000 	ldcvs	0, cr0, [r8, #-0]
    2278:	10000001 	andne	r0, r0, r1
    227c:	0000d4ae 	andeq	sp, r0, lr, lsr #9
    2280:	28a41800 	stmiacs	r4!, {fp, ip}
    2284:	bc100000 	ldclt	0, cr0, [r0], {-0}
    2288:	00002292 	muleq	r0, r2, r2
    228c:	45601600 	strbmi	r1, [r0, #-1536]!	; 0xfffffa00
    2290:	04080000 	streq	r0, [r8], #-0
    2294:	0000228d 	andeq	r2, r0, sp, lsl #5
    2298:	000e9516 	andeq	r9, lr, r6, lsl r5
    229c:	98040800 	stmdals	r4, {fp}
    22a0:	10000022 	andne	r0, r0, r2, lsr #32
    22a4:	000005a0 	andeq	r0, r0, r0, lsr #11
    22a8:	d4e71008 	strbtle	r1, [r7], #8
    22ac:	0f000022 	svceq	0x00000022
    22b0:	00002b35 	andeq	r2, r0, r5, lsr fp
    22b4:	0564e810 	strbeq	lr, [r4, #-2064]!	; 0xfffff7f0
    22b8:	0f000000 	svceq	0x00000000
    22bc:	000050cf 	andeq	r5, r0, pc, asr #1
    22c0:	003aed10 	eorseq	lr, sl, r0, lsl sp
    22c4:	0f040000 	svceq	0x00040000
    22c8:	00000c6b 	andeq	r0, r0, fp, ror #24
    22cc:	003aee10 	eorseq	lr, sl, r0, lsl lr
    22d0:	00060000 	andeq	r0, r6, r0
    22d4:	0045d41a 	subeq	sp, r5, sl, lsl r4
    22d8:	732ba800 			; <UNDEFINED> instruction: 0x732ba800
    22dc:	0023cc03 	eoreq	ip, r3, r3, lsl #24
    22e0:	5f661d00 	svcpl	0x00661d00
    22e4:	772b0075 			; <UNDEFINED> instruction: 0x772b0075
    22e8:	007b3303 	rsbseq	r3, fp, r3, lsl #6
    22ec:	271b0000 	ldrcs	r0, [fp, -r0]
    22f0:	2b000022 	blcs	2380 <.debug_info+0x2380>
    22f4:	65750378 	ldrbvs	r0, [r5, #-888]!	; 0xfffffc88
    22f8:	1b080000 	blne	202300 <unflatten_and_copy_device_tree+0x20148c>
    22fc:	00004cda 	ldrdeq	r4, [r0], -sl
    2300:	f203792b 	vmla.i8	d7, d3, d27
    2304:	10000060 	andne	r0, r0, r0, rrx
    2308:	0016f81b 	andseq	pc, r6, fp, lsl r8	; <UNPREDICTABLE>
    230c:	037a2b00 	cmneq	sl, #0, 22
    2310:	00007a28 	andeq	r7, r0, r8, lsr #20
    2314:	67151b14 			; <UNDEFINED> instruction: 0x67151b14
    2318:	802b0000 	eorhi	r0, fp, r0
    231c:	0010ff03 	andseq	pc, r0, r3, lsl #30
    2320:	271b1800 	ldrcs	r1, [fp, -r0, lsl #16]
    2324:	2b00005c 	blcs	249c <.debug_info+0x249c>
    2328:	11bb0381 			; <UNDEFINED> instruction: 0x11bb0381
    232c:	1b1c0000 	blne	702334 <unflatten_and_copy_device_tree+0x7014c0>
    2330:	000013a0 	andeq	r1, r0, r0, lsr #7
    2334:	6903822b 	stmdbvs	r3, {r0, r1, r3, r5, r9, pc}
    2338:	20000000 	andcs	r0, r0, r0
    233c:	004b161b 	subeq	r1, fp, fp, lsl r6
    2340:	03832b00 	orreq	r2, r3, #0, 22
    2344:	00000286 	andeq	r0, r0, r6, lsl #5
    2348:	2c0e1b24 	stccs	11, cr1, [lr], {36}	; 0x24
    234c:	842b0000 	strthi	r0, [fp], #-0
    2350:	00194003 	andseq	r4, r9, r3
    2354:	3a1b2800 	bcc	6ca008 <unflatten_and_copy_device_tree+0x6c9194>
    2358:	2b000054 	blcs	24b0 <.debug_info+0x24b0>
    235c:	02230385 	eoreq	r0, r3, #335544322	; 0x14000002
    2360:	1b400000 	blne	1002368 <unflatten_and_copy_device_tree+0x10014f4>
    2364:	00003c16 	andeq	r3, r0, r6, lsl ip
    2368:	7b03862b 	blvc	e3c1c <unflatten_and_copy_device_tree+0xe2da8>
    236c:	4800007a 	stmdami	r0, {r1, r3, r4, r5, r6}
    2370:	00133d1b 	andseq	r3, r3, fp, lsl sp
    2374:	03872b00 	orreq	r2, r7, #0, 22
    2378:	00004e97 	muleq	r0, r7, lr
    237c:	19911b60 	ldmibne	r1, {r5, r6, r8, r9, fp, ip}
    2380:	882b0000 	stmdahi	fp!, {}	; <UNPREDICTABLE>
    2384:	007ad703 	rsbseq	sp, sl, r3, lsl #14
    2388:	f51b6800 			; <UNDEFINED> instruction: 0xf51b6800
    238c:	2b00003c 	blcs	2484 <.debug_info+0x2484>
    2390:	00c9038a 	sbceq	r0, r9, sl, lsl #7
    2394:	1b880000 	blne	fe20239c <__crc_of_fdt_unflatten_tree+0x774c0ddf>
    2398:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
    239c:	78038f2b 	stmdavc	r3, {r0, r1, r3, r5, r8, r9, sl, fp, pc}
    23a0:	90000003 	andls	r0, r0, r3
    23a4:	002e3f1b 	eoreq	r3, lr, fp, lsl pc
    23a8:	03932b00 	orrseq	r2, r3, #0, 22
    23ac:	000002c7 	andeq	r0, r0, r7, asr #5
    23b0:	15fe1b94 	ldrbne	r1, [lr, #2964]!	; 0xb94
    23b4:	942b0000 	strtls	r0, [fp], #-0
    23b8:	0002c703 	andeq	ip, r2, r3, lsl #14
    23bc:	c51b9c00 	ldrgt	r9, [fp, #-3072]	; 0xfffff400
    23c0:	2b000042 	blcs	24d0 <.debug_info+0x24d0>
    23c4:	21180396 			; <UNDEFINED> instruction: 0x21180396
    23c8:	00a40000 	adceq	r0, r4, r0
    23cc:	22d40408 	sbcscs	r0, r4, #8, 8	; 0x8000000
    23d0:	fd210000 	stc2	0, cr0, [r1, #-0]
    23d4:	0000003d 	andeq	r0, r0, sp, lsr r0
    23d8:	22012010 	andcs	r2, r1, #16
    23dc:	01471010 	cmpeq	r7, r0, lsl r0
    23e0:	000023fe 	strdeq	r2, [r0], -lr
    23e4:	0062721d 	rsbeq	r7, r2, sp, lsl r2
    23e8:	6b014810 	blvs	54430 <unflatten_and_copy_device_tree+0x535bc>
    23ec:	0000001a 	andeq	r0, r0, sl, lsl r0
    23f0:	001f291b 	andseq	r2, pc, fp, lsl r9	; <UNPREDICTABLE>
    23f4:	01491000 	mrseq	r1, (UNDEF: 73)
    23f8:	000000d4 	ldrdeq	r0, [r0], -r4
    23fc:	4016000c 	andsmi	r0, r6, ip
    2400:	08000037 	stmdaeq	r0, {r0, r1, r2, r4, r5}
    2404:	0023fe04 	eoreq	pc, r3, r4, lsl #28
    2408:	5b911000 	blpl	fe444008 <__crc_of_fdt_unflatten_tree+0x77702a4b>
    240c:	2d2c0000 	stccs	0, cr0, [ip, #-0]
    2410:	0024a2fc 	strdeq	sl, [r4], -ip	; <UNPREDICTABLE>
    2414:	5e2a0f00 	cdppl	15, 2, cr0, cr10, cr0, {0}
    2418:	fd2d0000 	stc2	0, cr0, [sp, #-0]
    241c:	0000504d 	andeq	r5, r0, sp, asr #32
    2420:	12830f00 	addne	r0, r3, #0, 30
    2424:	fe2d0000 	cdp2	0, 2, cr0, cr13, cr0, {0}
    2428:	0000504d 	andeq	r5, r0, sp, asr #32
    242c:	62350f04 	eorsvs	r0, r5, #4, 30
    2430:	ff2d0000 			; <UNDEFINED> instruction: 0xff2d0000
    2434:	00005062 	andeq	r5, r0, r2, rrx
    2438:	627b1b08 	rsbsvs	r1, fp, #8, 22	; 0x2000
    243c:	002d0000 	eoreq	r0, sp, r0
    2440:	00508201 	subseq	r8, r0, r1, lsl #4
    2444:	c81b0c00 	ldmdagt	fp, {sl, fp}
    2448:	2d00005f 	stccs	0, cr0, [r0, #-380]	; 0xfffffe84
    244c:	50ac0101 	adcpl	r0, ip, r1, lsl #2
    2450:	1b100000 	blne	402458 <unflatten_and_copy_device_tree+0x4015e4>
    2454:	00001621 	andeq	r1, r0, r1, lsr #12
    2458:	c201032d 	andgt	r0, r1, #-1275068416	; 0xb4000000
    245c:	14000050 	strne	r0, [r0], #-80	; 0xffffffb0
    2460:	0032cc1b 	eorseq	ip, r2, fp, lsl ip
    2464:	01072d00 	tsteq	r7, r0, lsl #26
    2468:	00005082 	andeq	r5, r0, r2, lsl #1
    246c:	0ad71b18 	beq	ff5c6c68 <__crc_of_fdt_unflatten_tree+0x788856ab>
    2470:	0a2d0000 	beq	b42478 <unflatten_and_copy_device_tree+0xb41604>
    2474:	00508201 	subseq	r8, r0, r1, lsl #4
    2478:	c91b1c00 	ldmdbgt	fp, {sl, fp, ip}
    247c:	2d000018 	stccs	0, cr0, [r0, #-96]	; 0xffffffa0
    2480:	50eb010f 	rscpl	r0, fp, pc, lsl #2
    2484:	1b200000 	blne	80248c <unflatten_and_copy_device_tree+0x801618>
    2488:	0000059b 	muleq	r0, fp, r5
    248c:	0001152d 	andeq	r1, r1, sp, lsr #10
    2490:	24000051 	strcs	r0, [r0], #-81	; 0xffffffaf
    2494:	0045791b 	subeq	r7, r5, fp, lsl r9
    2498:	01332d00 	teqeq	r3, r0, lsl #26
    249c:	0000511a 	andeq	r5, r0, sl, lsl r1
    24a0:	04080028 	streq	r0, [r8], #-40	; 0xffffffd8
    24a4:	000024a8 	andeq	r2, r0, r8, lsr #9
    24a8:	00240909 	eoreq	r0, r4, r9, lsl #18
    24ac:	21d21a00 	bicscs	r1, r2, r0, lsl #20
    24b0:	10080000 	andne	r0, r8, r0
    24b4:	24d50168 	ldrbcs	r0, [r5], #360	; 0x168
    24b8:	2d1b0000 	ldccs	0, cr0, [fp, #-0]
    24bc:	10000028 	andne	r0, r0, r8, lsr #32
    24c0:	10270169 	eorne	r0, r7, r9, ror #2
    24c4:	1b000000 	blne	24cc <.debug_info+0x24cc>
    24c8:	00002222 	andeq	r2, r0, r2, lsr #4
    24cc:	d5016a10 	strle	r6, [r1, #-2576]	; 0xfffff5f0
    24d0:	04000024 	streq	r0, [r0], #-36	; 0xffffffdc
    24d4:	ad040800 	stcge	8, cr0, [r4, #-0]
    24d8:	1a000024 	bne	2570 <.debug_info+0x2570>
    24dc:	000038da 	ldrdeq	r3, [r0], -sl
    24e0:	016d101c 	cmneq	sp, ip, lsl r0
    24e4:	00002510 	andeq	r2, r0, r0, lsl r5
    24e8:	0013c11b 	andseq	ip, r3, fp, lsl r1
    24ec:	016e1000 	cmneq	lr, r0
    24f0:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    24f4:	055b1b00 	ldrbeq	r1, [fp, #-2816]	; 0xfffff500
    24f8:	6f100000 	svcvs	0x00100000
    24fc:	0024ad01 	eoreq	sl, r4, r1, lsl #26
    2500:	4c1b0400 	cfldrsmi	mvf0, [fp], {-0}
    2504:	10000049 	andne	r0, r0, r9, asr #32
    2508:	1a120170 	bne	482ad0 <unflatten_and_copy_device_tree+0x481c5c>
    250c:	000c0000 	andeq	r0, ip, r0
    2510:	0069042b 	rsbeq	r0, r9, fp, lsr #8
    2514:	73100000 	tstvc	r0, #0
    2518:	00253601 	eoreq	r3, r5, r1, lsl #12
    251c:	3d7e0b00 	vldmdbcc	lr!, {d16-d15}
    2520:	0b000000 	bleq	2528 <.debug_info+0x2528>
    2524:	0000315c 	andeq	r3, r0, ip, asr r1
    2528:	09800b01 	stmibeq	r0, {r0, r8, r9, fp}
    252c:	0b020000 	bleq	82534 <unflatten_and_copy_device_tree+0x816c0>
    2530:	000059ad 	andeq	r5, r0, sp, lsr #19
    2534:	f81a0003 			; <UNDEFINED> instruction: 0xf81a0003
    2538:	0c000041 	stceq	0, cr0, [r0], {65}	; 0x41
    253c:	51018310 	tstpl	r1, r0, lsl r3
    2540:	1b000025 	blne	25dc <.debug_info+0x25dc>
    2544:	00003ba1 	andeq	r3, r0, r1, lsr #23
    2548:	51018410 	tstpl	r1, r0, lsl r4
    254c:	00000025 	andeq	r0, r0, r5, lsr #32
    2550:	11bb0600 			; <UNDEFINED> instruction: 0x11bb0600
    2554:	25610000 	strbcs	r0, [r1, #-0]!
    2558:	eb070000 	bl	1c2560 <unflatten_and_copy_device_tree+0x1c16ec>
    255c:	02000000 	andeq	r0, r0, #0
    2560:	00d41500 	sbcseq	r1, r4, r0, lsl #10
    2564:	25840000 	strcs	r0, [r4]
    2568:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    256c:	0d000023 	stceq	0, cr0, [r0, #-140]	; 0xffffff74
    2570:	000000d4 	ldrdeq	r0, [r0], -r4
    2574:	0000d40d 	andeq	sp, r0, sp, lsl #8
    2578:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    257c:	d40d0000 	strle	r0, [sp], #-0
    2580:	00000000 	andeq	r0, r0, r0
    2584:	25610408 	strbcs	r0, [r1, #-1032]!	; 0xfffffbf8
    2588:	04080000 	streq	r0, [r8], #-0
    258c:	000006cf 	andeq	r0, r0, pc, asr #13
    2590:	0000d406 	andeq	sp, r0, r6, lsl #8
    2594:	0025a000 	eoreq	sl, r5, r0
    2598:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    259c:	00290000 	eoreq	r0, r9, r0
    25a0:	003a2516 	eorseq	r2, sl, r6, lsl r5
    25a4:	a0040800 	andge	r0, r4, r0, lsl #16
    25a8:	08000025 	stmdaeq	r0, {r0, r2, r5}
    25ac:	0024db04 	eoreq	sp, r4, r4, lsl #22
    25b0:	5a911600 	bpl	fe445808 <__crc_of_fdt_unflatten_tree+0x7770424b>
    25b4:	04080000 	streq	r0, [r8], #-0
    25b8:	000025b1 			; <UNDEFINED> instruction: 0x000025b1
    25bc:	00110116 	andseq	r0, r1, r6, lsl r1
    25c0:	bc040800 	stclt	8, cr0, [r4], {-0}
    25c4:	08000025 	stmdaeq	r0, {r0, r2, r5}
    25c8:	00056404 	andeq	r6, r5, r4, lsl #8
    25cc:	48b81000 	ldmmi	r8!, {ip}
    25d0:	2e100000 	cdpcs	0, 1, cr0, cr0, cr0, {0}
    25d4:	00260a0b 	eoreq	r0, r6, fp, lsl #20
    25d8:	30fd0f00 	rscscc	r0, sp, r0, lsl #30
    25dc:	0c2e0000 	stceq	0, cr0, [lr], #-0
    25e0:	0000027b 	andeq	r0, r0, fp, ror r2
    25e4:	3bca0f00 	blcc	ff283c08 <__crc_of_fdt_unflatten_tree+0x7854264b>
    25e8:	132e0000 			; <UNDEFINED> instruction: 0x132e0000
    25ec:	000000d4 	ldrdeq	r0, [r0], -r4
    25f0:	696e1404 	stmdbvs	lr!, {r2, sl, ip}^
    25f4:	162e0064 	strtne	r0, [lr], -r4, rrx
    25f8:	00000057 	andeq	r0, r0, r7, asr r0
    25fc:	2df30f08 	ldclcs	15, cr0, [r3, #32]!
    2600:	192e0000 	stmdbne	lr!, {}	; <UNPREDICTABLE>
    2604:	0000229d 	muleq	r0, sp, r2
    2608:	0510000c 	ldreq	r0, [r0, #-12]
    260c:	20000059 	andcs	r0, r0, r9, asr r0
    2610:	266b312e 	strbtcs	r3, [fp], -lr, lsr #2
    2614:	3f0f0000 	svccc	0x000f0000
    2618:	2e000044 	cdpcs	0, 0, cr0, cr0, cr4, {2}
    261c:	00268b32 	eoreq	r8, r6, r2, lsr fp
    2620:	730f0000 	movwvc	r0, #61440	; 0xf000
    2624:	2e00001d 	mcrcs	0, 0, r0, cr0, cr13, {0}
    2628:	00268b34 	eoreq	r8, r6, r4, lsr fp
    262c:	b70f0400 	strlt	r0, [pc, -r0, lsl #8]
    2630:	2e000006 	cdpcs	0, 0, cr0, cr0, cr6, {0}
    2634:	00005737 	andeq	r5, r0, r7, lsr r7
    2638:	b00f0800 	andlt	r0, pc, r0, lsl #16
    263c:	2e00004b 	cdpcs	0, 0, cr0, cr0, cr11, {2}
    2640:	00013338 	andeq	r3, r1, r8, lsr r3
    2644:	6a0f0c00 	bvs	3c3008 <unflatten_and_copy_device_tree+0x3c2194>
    2648:	2e000059 	mcrcs	0, 0, r0, cr0, cr9, {2}
    264c:	0000d439 	andeq	sp, r0, r9, lsr r4
    2650:	8e0f1000 	cdphi	0, 0, cr1, cr15, cr0, {0}
    2654:	2e000005 	cdpcs	0, 0, cr0, cr0, cr5, {0}
    2658:	0002c73c 	andeq	ip, r2, ip, lsr r7
    265c:	240f1400 	strcs	r1, [pc], #-1024	; 8 <.debug_info+0x8>
    2660:	2e000025 	cdpcs	0, 0, cr0, cr0, cr5, {1}
    2664:	0026913e 	eoreq	r9, r6, lr, lsr r1
    2668:	15001c00 	strne	r1, [r0, #-3072]	; 0xfffff400
    266c:	000000d4 	ldrdeq	r0, [r0], -r4
    2670:	0000267f 	andeq	r2, r0, pc, ror r6
    2674:	00267f0d 	eoreq	r7, r6, sp, lsl #30
    2678:	26850d00 	strcs	r0, [r5], r0, lsl #26
    267c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    2680:	00260a04 	eoreq	r0, r6, r4, lsl #20
    2684:	cd040800 	stcgt	8, cr0, [r4, #-0]
    2688:	08000025 	stmdaeq	r0, {r0, r2, r5}
    268c:	00266b04 	eoreq	r6, r6, r4, lsl #22
    2690:	bb040800 	bllt	104698 <unflatten_and_copy_device_tree+0x103824>
    2694:	10000011 	andne	r0, r0, r1, lsl r0
    2698:	00003652 	andeq	r3, r0, r2, asr r6
    269c:	bc2a2f08 	stclt	15, cr2, [sl], #-32	; 0xffffffe0
    26a0:	0f000026 	svceq	0x00000026
    26a4:	00000125 	andeq	r0, r0, r5, lsr #2
    26a8:	013a2b2f 	teqeq	sl, pc, lsr #22
    26ac:	0f000000 	svceq	0x00000000
    26b0:	0000220c 	andeq	r2, r0, ip, lsl #4
    26b4:	013a2c2f 	teqeq	sl, pc, lsr #24
    26b8:	00040000 	andeq	r0, r4, r0
    26bc:	0001fb12 	andeq	pc, r1, r2, lsl fp	; <UNPREDICTABLE>
    26c0:	bc040800 	stclt	8, cr0, [r4], {-0}
    26c4:	10000026 	andne	r0, r0, r6, lsr #32
    26c8:	000022b5 			; <UNDEFINED> instruction: 0x000022b5
    26cc:	641a3030 	ldrvs	r3, [sl], #-48	; 0xffffffd0
    26d0:	0f000027 	svceq	0x00000027
    26d4:	00002ba2 	andeq	r2, r0, r2, lsr #23
    26d8:	1a651e30 	bne	1949fa0 <unflatten_and_copy_device_tree+0x194912c>
    26dc:	0f000000 	svceq	0x00000000
    26e0:	0000060f 	andeq	r0, r0, pc, lsl #12
    26e4:	27642230 			; <UNDEFINED> instruction: 0x27642230
    26e8:	0f040000 	svceq	0x00040000
    26ec:	00001a84 	andeq	r1, r0, r4, lsl #21
    26f0:	03b52630 			; <UNDEFINED> instruction: 0x03b52630
    26f4:	0f080000 	svceq	0x00080000
    26f8:	0000325c 	andeq	r3, r0, ip, asr r2
    26fc:	03b52a30 			; <UNDEFINED> instruction: 0x03b52a30
    2700:	0f0c0000 	svceq	0x000c0000
    2704:	00003557 	andeq	r3, r0, r7, asr r5
    2708:	277a2e30 			; <UNDEFINED> instruction: 0x277a2e30
    270c:	0f100000 	svceq	0x00100000
    2710:	00005812 	andeq	r5, r0, r2, lsl r8
    2714:	03aa3230 			; <UNDEFINED> instruction: 0x03aa3230
    2718:	0f140000 	svceq	0x00140000
    271c:	00005bed 	andeq	r5, r0, sp, ror #23
    2720:	27953a30 			; <UNDEFINED> instruction: 0x27953a30
    2724:	0f180000 	svceq	0x00180000
    2728:	00003963 	andeq	r3, r0, r3, ror #18
    272c:	27ab3f30 			; <UNDEFINED> instruction: 0x27ab3f30
    2730:	0f1c0000 	svceq	0x001c0000
    2734:	00000fca 	andeq	r0, r0, sl, asr #31
    2738:	27c74530 			; <UNDEFINED> instruction: 0x27c74530
    273c:	0f200000 	svceq	0x00200000
    2740:	00005b68 	andeq	r5, r0, r8, ror #22
    2744:	00694b30 	rsbeq	r4, r9, r0, lsr fp
    2748:	0f240000 	svceq	0x00240000
    274c:	0000391f 	andeq	r3, r0, pc, lsl r9
    2750:	1b6e4c30 	blne	1b95818 <unflatten_and_copy_device_tree+0x1b949a4>
    2754:	0f280000 	svceq	0x00280000
    2758:	00004f9c 	muleq	r0, ip, pc	; <UNPREDICTABLE>
    275c:	1b6e4d30 	blne	1b95c24 <unflatten_and_copy_device_tree+0x1b94db0>
    2760:	002c0000 	eoreq	r0, ip, r0
    2764:	1e670408 	cdpne	4, 6, cr0, cr7, cr8, {0}
    2768:	7a0c0000 	bvc	302770 <unflatten_and_copy_device_tree+0x3018fc>
    276c:	0d000027 	stceq	0, cr0, [r0, #-156]	; 0xffffff64
    2770:	000000d4 	ldrdeq	r0, [r0], -r4
    2774:	0001fb0d 	andeq	pc, r1, sp, lsl #22
    2778:	04080000 	streq	r0, [r8], #-0
    277c:	00002780 	andeq	r2, r0, r0, lsl #15
    2780:	00276a2c 	eoreq	r6, r7, ip, lsr #20
    2784:	27950c00 	ldrcs	r0, [r5, r0, lsl #24]
    2788:	780d0000 	stmdavc	sp, {}	; <UNPREDICTABLE>
    278c:	0d000003 	stceq	0, cr0, [r0, #-12]
    2790:	00000057 	andeq	r0, r0, r7, asr r0
    2794:	85040800 	strhi	r0, [r4, #-2048]	; 0xfffff800
    2798:	0c000027 	stceq	0, cr0, [r0], {39}	; 0x27
    279c:	000027ab 	andeq	r2, r0, fp, lsr #15
    27a0:	00029c0d 	andeq	r9, r2, sp, lsl #24
    27a4:	1bae0d00 	blne	feb85bac <__crc_of_fdt_unflatten_tree+0x77e445ef>
    27a8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    27ac:	00279b04 	eoreq	r9, r7, r4, lsl #22
    27b0:	27c10c00 	strbcs	r0, [r1, r0, lsl #24]
    27b4:	c10d0000 	mrsgt	r0, (UNDEF: 13)
    27b8:	0d000027 	stceq	0, cr0, [r0, #-156]	; 0xffffff64
    27bc:	000006b9 			; <UNDEFINED> instruction: 0x000006b9
    27c0:	b9040800 	stmdblt	r4, {fp}
    27c4:	08000006 	stmdaeq	r0, {r1, r2}
    27c8:	0027b104 	eoreq	fp, r7, r4, lsl #2
    27cc:	05b91000 	ldreq	r1, [r9, #0]!
    27d0:	31080000 	mrscc	r0, (UNDEF: 8)
    27d4:	0027e617 	eoreq	lr, r7, r7, lsl r6
    27d8:	61631400 	cmnvs	r3, r0, lsl #8
    27dc:	18310070 	ldmdane	r1!, {r4, r5, r6}
    27e0:	000006e5 	andeq	r0, r0, r5, ror #13
    27e4:	57030000 	strpl	r0, [r3, -r0]
    27e8:	31000058 	qaddcc	r0, r8, r0
    27ec:	0027cd19 	eoreq	ip, r7, r9, lsl sp
    27f0:	0b791000 	bleq	1e44008 <unflatten_and_copy_device_tree+0x1e43194>
    27f4:	32140000 	andscc	r0, r4, #0
    27f8:	00282255 	eoreq	r2, r8, r5, asr r2
    27fc:	50690f00 	rsbpl	r0, r9, r0, lsl #30
    2800:	56320000 	ldrtpl	r0, [r2], -r0
    2804:	00000057 	andeq	r0, r0, r7, asr r0
    2808:	15500f00 	ldrbne	r0, [r0, #-3840]	; 0xfffff100
    280c:	57320000 	ldrpl	r0, [r2, -r0]!
    2810:	000002c7 	andeq	r0, r0, r7, asr #5
    2814:	58b70f04 	ldmpl	r7!, {r2, r8, r9, sl, fp}
    2818:	58320000 	ldmdapl	r2!, {}	; <UNPREDICTABLE>
    281c:	000002c7 	andeq	r0, r0, r7, asr #5
    2820:	1203000c 	andne	r0, r3, #12
    2824:	33000052 	movwcc	r0, #82	; 0x52
    2828:	0000d404 	andeq	sp, r0, r4, lsl #8
    282c:	34040e00 	strcc	r0, [r4], #-3584	; 0xfffff200
    2830:	00284214 	eoreq	r4, r8, r4, lsl r2
    2834:	61761400 	cmnvs	r6, r0, lsl #8
    2838:	1534006c 	ldrne	r0, [r4, #-108]!	; 0xffffff94
    283c:	0000020d 	andeq	r0, r0, sp, lsl #4
    2840:	29030000 	stmdbcs	r3, {}	; <UNPREDICTABLE>
    2844:	3400004b 	strcc	r0, [r0], #-75	; 0xffffffb5
    2848:	00282d16 	eoreq	r2, r8, r6, lsl sp
    284c:	34040e00 	strcc	r0, [r4], #-3584	; 0xfffff200
    2850:	00286219 	eoreq	r6, r8, r9, lsl r2
    2854:	61761400 	cmnvs	r6, r0, lsl #8
    2858:	1a34006c 	bne	d02a10 <unflatten_and_copy_device_tree+0xd01b9c>
    285c:	00000218 	andeq	r0, r0, r8, lsl r2
    2860:	e1030000 	mrs	r0, (UNDEF: 3)
    2864:	34000039 	strcc	r0, [r0], #-57	; 0xffffffc7
    2868:	00284d1b 	eoreq	r4, r8, fp, lsl sp
    286c:	216e1000 	cmncs	lr, r0
    2870:	35040000 	strcc	r0, [r4, #-0]
    2874:	0028861d 	eoreq	r8, r8, sp, lsl r6
    2878:	678f0f00 	strvs	r0, [pc, r0, lsl #30]
    287c:	1e350000 	cdpne	0, 3, cr0, cr5, cr0, {0}
    2880:	0000288b 	andeq	r2, r0, fp, lsl #17
    2884:	e3160000 	tst	r6, #0
    2888:	08000005 	stmdaeq	r0, {r0, r2}
    288c:	00288604 	eoreq	r8, r8, r4, lsl #12
    2890:	3fb31a00 	svccc	0x00b31a00
    2894:	12400000 	subne	r0, r0, #0
    2898:	29620331 	stmdbcs	r2!, {r0, r4, r5, r8, r9}^
    289c:	d11b0000 	tstle	fp, r0
    28a0:	12000031 	andne	r0, r0, #49	; 0x31
    28a4:	02bc0332 	adcseq	r0, ip, #-939524096	; 0xc8000000
    28a8:	1b000000 	blne	28b0 <.debug_info+0x28b0>
    28ac:	00001b52 	andeq	r1, r0, r2, asr fp
    28b0:	bc033312 	stclt	3, cr3, [r3], {18}
    28b4:	04000002 	streq	r0, [r0], #-2
    28b8:	0048851b 	subeq	r8, r8, fp, lsl r5
    28bc:	03341200 	teqeq	r4, #0, 4
    28c0:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    28c4:	2e221b08 	vmulcs.f64	d1, d2, d8
    28c8:	36120000 	ldrcc	r0, [r2], -r0
    28cc:	0002bc03 	andeq	fp, r2, r3, lsl #24
    28d0:	921b0c00 	andsls	r0, fp, #0, 24
    28d4:	12000028 	andne	r0, r0, #40	; 0x28
    28d8:	02bc0337 	adcseq	r0, ip, #-603979776	; 0xdc000000
    28dc:	1b100000 	blne	4028e4 <unflatten_and_copy_device_tree+0x401a70>
    28e0:	00003be5 	andeq	r3, r0, r5, ror #23
    28e4:	bb033d12 	bllt	d1d34 <unflatten_and_copy_device_tree+0xd0ec0>
    28e8:	14000011 	strne	r0, [r0], #-17	; 0xffffffef
    28ec:	001caa1b 	andseq	sl, ip, fp, lsl sl
    28f0:	03411200 	movteq	r1, #4608	; 0x1200
    28f4:	000000d4 	ldrdeq	r0, [r0], -r4
    28f8:	4ef91b18 	vmovmi.u8	r1, d9[4]
    28fc:	43120000 	tstmi	r2, #0
    2900:	0000d403 	andeq	sp, r0, r3, lsl #8
    2904:	241b1c00 	ldrcs	r1, [fp], #-3072	; 0xfffff400
    2908:	12000030 	andne	r0, r0, #48	; 0x30
    290c:	00d40344 	sbcseq	r0, r4, r4, asr #6
    2910:	1b200000 	blne	802918 <unflatten_and_copy_device_tree+0x801aa4>
    2914:	00005644 	andeq	r5, r0, r4, asr #12
    2918:	bb034512 	bllt	d3d68 <unflatten_and_copy_device_tree+0xd2ef4>
    291c:	24000011 	strcs	r0, [r0], #-17	; 0xffffffef
    2920:	0067641b 	rsbeq	r6, r7, fp, lsl r4
    2924:	03481200 	movteq	r1, #33280	; 0x8200
    2928:	00003480 	andeq	r3, r0, r0, lsl #9
    292c:	39ae1b28 	stmibcc	lr!, {r3, r5, r8, r9, fp, ip}
    2930:	49120000 	ldmdbmi	r2, {}	; <UNPREDICTABLE>
    2934:	00348003 	eorseq	r8, r4, r3
    2938:	561b2c00 	ldrpl	r2, [fp], -r0, lsl #24
    293c:	12000008 	andne	r0, r0, #8
    2940:	030b034d 	movweq	r0, #45901	; 0xb34d
    2944:	1d300000 	ldcne	0, cr0, [r0, #-0]
    2948:	00646975 	rsbeq	r6, r4, r5, ror r9
    294c:	42034e12 	andmi	r4, r3, #288	; 0x120
    2950:	38000028 	stmdacc	r0, {r3, r5}
    2954:	0056ee1b 	subseq	lr, r6, fp, lsl lr
    2958:	03511200 	cmpeq	r1, #0, 4
    295c:	000011bb 			; <UNDEFINED> instruction: 0x000011bb
    2960:	0408003c 	streq	r0, [r8], #-60	; 0xffffffc4
    2964:	00002891 	muleq	r0, r1, r8
    2968:	00231910 	eoreq	r1, r3, r0, lsl r9
    296c:	31360800 	teqcc	r6, r0, lsl #16
    2970:	00002981 	andeq	r2, r0, r1, lsl #19
    2974:	0061690f 	rsbeq	r6, r1, pc, lsl #18
    2978:	c7323600 	ldrgt	r3, [r2, -r0, lsl #12]!
    297c:	00000002 	andeq	r0, r0, r2
    2980:	511f0300 	tstpl	pc, r0, lsl #6
    2984:	11370000 	teqne	r7, r0
    2988:	0000011d 	andeq	r0, r0, sp, lsl r1
    298c:	00349d03 	eorseq	r9, r4, r3, lsl #26
    2990:	97123700 	ldrls	r3, [r2, -r0, lsl #14]
    2994:	08000029 	stmdaeq	r0, {r0, r3, r5}
    2998:	00298104 	eoreq	r8, r9, r4, lsl #2
    299c:	5eae0300 	cdppl	3, 10, cr0, cr14, cr0, {0}
    29a0:	14370000 	ldrtne	r0, [r7], #-0
    29a4:	000003bb 			; <UNDEFINED> instruction: 0x000003bb
    29a8:	00602003 	rsbeq	r2, r0, r3
    29ac:	b3153700 	tstlt	r5, #0, 14
    29b0:	08000029 	stmdaeq	r0, {r0, r3, r5}
    29b4:	00299d04 	eoreq	r9, r9, r4, lsl #26
    29b8:	38080e00 	stmdacc	r8, {r9, sl, fp}
    29bc:	0029ce0f 	eoreq	ip, r9, pc, lsl #28
    29c0:	69731400 	ldmdbvs	r3!, {sl, ip}^
    29c4:	10380067 	eorsne	r0, r8, r7, rrx
    29c8:	000000db 	ldrdeq	r0, [r0], -fp
    29cc:	74030000 	strvc	r0, [r3], #-0
    29d0:	3800001e 	stmdacc	r0, {r1, r2, r3, r4}
    29d4:	0029b911 	eoreq	fp, r9, r1, lsl r9
    29d8:	54d12700 	ldrbpl	r2, [r1], #1792	; 0x700
    29dc:	39040000 	stmdbcc	r4, {}	; <UNPREDICTABLE>
    29e0:	0029fc07 	eoreq	pc, r9, r7, lsl #24
    29e4:	08ce1800 	stmiaeq	lr, {fp, ip}^
    29e8:	08390000 	ldmdaeq	r9!, {}	; <UNPREDICTABLE>
    29ec:	00000057 	andeq	r0, r0, r7, asr r0
    29f0:	0062a118 	rsbeq	sl, r2, r8, lsl r1
    29f4:	78093900 	stmdavc	r9, {r8, fp, ip, sp}
    29f8:	00000003 	andeq	r0, r0, r3
    29fc:	00320703 	eorseq	r0, r2, r3, lsl #14
    2a00:	d90a3900 	stmdble	sl, {r8, fp, ip, sp}
    2a04:	0e000029 	cdpeq	0, 0, cr0, cr0, cr9, {1}
    2a08:	28393908 	ldmdacs	r9!, {r3, r8, fp, ip, sp}
    2a0c:	0f00002a 	svceq	0x0000002a
    2a10:	00002d68 	andeq	r2, r0, r8, ror #26
    2a14:	01453a39 	cmpeq	r5, r9, lsr sl
    2a18:	0f000000 	svceq	0x00000000
    2a1c:	000014b9 			; <UNDEFINED> instruction: 0x000014b9
    2a20:	01503b39 	cmpeq	r0, r9, lsr fp
    2a24:	00040000 	andeq	r0, r4, r0
    2a28:	3f39100e 	svccc	0x0039100e
    2a2c:	00002a6d 	andeq	r2, r0, sp, ror #20
    2a30:	0043420f 	subeq	r4, r3, pc, lsl #4
    2a34:	9d403900 	stclls	9, cr3, [r0, #-0]
    2a38:	00000001 	andeq	r0, r0, r1
    2a3c:	0019470f 	andseq	r4, r9, pc, lsl #14
    2a40:	57413900 	strbpl	r3, [r1, -r0, lsl #18]
    2a44:	04000000 	streq	r0, [r0], #-0
    2a48:	0027320f 	eoreq	r3, r7, pc, lsl #4
    2a4c:	6d423900 	stclvs	9, cr3, [r2, #-0]
    2a50:	0800002a 	stmdaeq	r0, {r1, r3, r5}
    2a54:	0023e00f 	eoreq	lr, r3, pc
    2a58:	fc433900 	mcrr2	9, 0, r3, r3, cr0
    2a5c:	08000029 	stmdaeq	r0, {r0, r3, r5}
    2a60:	004f620f 	subeq	r6, pc, pc, lsl #4
    2a64:	57443900 	strbpl	r3, [r4, -r0, lsl #18]
    2a68:	0c000000 	stceq	0, cr0, [r0], {-0}
    2a6c:	00f80600 	rscseq	r0, r8, r0, lsl #12
    2a70:	2a7c0000 	bcs	1f02a78 <unflatten_and_copy_device_tree+0x1f01c04>
    2a74:	eb250000 	bl	942a7c <unflatten_and_copy_device_tree+0x941c08>
    2a78:	00000000 	andeq	r0, r0, r0
    2a7c:	48390c0e 	ldmdami	r9!, {r1, r2, r3, sl, fp}
    2a80:	00002aa9 	andeq	r2, r0, r9, lsr #21
    2a84:	002d680f 	eoreq	r6, sp, pc, lsl #16
    2a88:	45493900 	strbmi	r3, [r9, #-2304]	; 0xfffff700
    2a8c:	00000001 	andeq	r0, r0, r1
    2a90:	0014b90f 	andseq	fp, r4, pc, lsl #18
    2a94:	504a3900 	subpl	r3, sl, r0, lsl #18
    2a98:	04000001 	streq	r0, [r0], #-1
    2a9c:	0023e00f 	eoreq	lr, r3, pc
    2aa0:	fc4b3900 	mcrr2	9, 0, r3, fp, cr0
    2aa4:	08000029 	stmdaeq	r0, {r0, r3, r5}
    2aa8:	39140e00 	ldmdbcc	r4, {r9, sl, fp}
    2aac:	002aee4f 	eoreq	lr, sl, pc, asr #28
    2ab0:	2d680f00 	stclcs	15, cr0, [r8, #-0]
    2ab4:	50390000 	eorspl	r0, r9, r0
    2ab8:	00000145 	andeq	r0, r0, r5, asr #2
    2abc:	14b90f00 	ldrtne	r0, [r9], #3840	; 0xf00
    2ac0:	51390000 	teqpl	r9, r0
    2ac4:	00000150 	andeq	r0, r0, r0, asr r1
    2ac8:	0be50f04 	bleq	ff943c18 <__crc_of_fdt_unflatten_tree+0x78c0265b>
    2acc:	52390000 	eorspl	r0, r9, #0
    2ad0:	00000057 	andeq	r0, r0, r7, asr r0
    2ad4:	4d180f08 	ldcmi	15, cr0, [r8, #-32]	; 0xffffffe0
    2ad8:	53390000 	teqpl	r9, #0
    2adc:	00000192 	muleq	r0, r2, r1
    2ae0:	2a330f0c 	bcs	cc3c38 <unflatten_and_copy_device_tree+0xcc2dc4>
    2ae4:	54390000 	ldrtpl	r0, [r9], #-0
    2ae8:	00000192 	muleq	r0, r2, r1
    2aec:	080e0010 	stmdaeq	lr, {r4}
    2af0:	2b0f5e39 	blcs	3da3dc <unflatten_and_copy_device_tree+0x3d9568>
    2af4:	970f0000 	strls	r0, [pc, -r0]
    2af8:	39000024 	stmdbcc	r0, {r2, r5}
    2afc:	0003785f 	andeq	r7, r3, pc, asr r8
    2b00:	520f0000 	andpl	r0, pc, #0
    2b04:	39000041 	stmdbcc	r0, {r0, r6}
    2b08:	00037860 	andeq	r7, r3, r0, ror #16
    2b0c:	0e000400 	cfcpyseq	mvf0, mvf0
    2b10:	3c583910 	mrrccc	9, 1, r3, r8, cr0
    2b14:	0f00002b 	svceq	0x0000002b
    2b18:	00000b89 	andeq	r0, r0, r9, lsl #23
    2b1c:	03785939 	cmneq	r8, #933888	; 0xe4000
    2b20:	0f000000 	svceq	0x00000000
    2b24:	000054c7 	andeq	r5, r0, r7, asr #9
    2b28:	00335d39 	eorseq	r5, r3, r9, lsr sp
    2b2c:	0f040000 	svceq	0x00040000
    2b30:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    2b34:	2aee6139 	bcs	ffb9b020 <__crc_of_fdt_unflatten_tree+0x78e59a63>
    2b38:	00080000 	andeq	r0, r8, r0
    2b3c:	6539080e 	ldrvs	r0, [r9, #-2062]!	; 0xfffff7f2
    2b40:	00002b5d 	andeq	r2, r0, sp, asr fp
    2b44:	0044e40f 	subeq	lr, r4, pc, lsl #8
    2b48:	33663900 	cmncc	r6, #0, 18
    2b4c:	00000001 	andeq	r0, r0, r1
    2b50:	64665f14 	strbtvs	r5, [r6], #-3860	; 0xfffff0ec
    2b54:	57673900 	strbpl	r3, [r7, -r0, lsl #18]!
    2b58:	04000000 	streq	r0, [r0], #-0
    2b5c:	390c0e00 	stmdbcc	ip, {r9, sl, fp}
    2b60:	002b8a6b 	eoreq	r8, fp, fp, ror #20
    2b64:	09180f00 	ldmdbeq	r8, {r8, r9, sl, fp}
    2b68:	6c390000 	ldcvs	0, cr0, [r9], #-0
    2b6c:	00000378 	andeq	r0, r0, r8, ror r3
    2b70:	55020f00 	strpl	r0, [r2, #-3840]	; 0xfffff100
    2b74:	6d390000 	ldcvs	0, cr0, [r9, #-0]
    2b78:	00000057 	andeq	r0, r0, r7, asr r0
    2b7c:	11670f04 	cmnne	r7, r4, lsl #30
    2b80:	6e390000 	cdpvs	0, 3, cr0, cr9, cr0, {0}
    2b84:	00000069 	andeq	r0, r0, r9, rrx
    2b88:	74170008 	ldrvc	r0, [r7], #-8
    2b8c:	2beb3539 	blcs	ffad0078 <__crc_of_fdt_unflatten_tree+0x78d8eabb>
    2b90:	32180000 	andscc	r0, r8, #0
    2b94:	39000027 	stmdbcc	r0, {r0, r1, r2, r5}
    2b98:	002beb36 	eoreq	lr, fp, r6, lsr fp
    2b9c:	31f91800 	mvnscc	r1, r0, lsl #16
    2ba0:	3c390000 	ldccc	0, cr0, [r9], #-0
    2ba4:	00002a07 	andeq	r2, r0, r7, lsl #20
    2ba8:	0053b018 	subseq	fp, r3, r8, lsl r0
    2bac:	28453900 	stmdacs	r5, {r8, fp, ip, sp}^
    2bb0:	2a00002a 	bcs	2c60 <.debug_info+0x2c60>
    2bb4:	0074725f 	rsbseq	r7, r4, pc, asr r2
    2bb8:	2a7c4c39 	bcs	1f15ca4 <unflatten_and_copy_device_tree+0x1f14e30>
    2bbc:	59180000 	ldmdbpl	r8, {}	; <UNPREDICTABLE>
    2bc0:	39000054 	stmdbcc	r0, {r2, r4, r6}
    2bc4:	002aa955 	eoreq	sl, sl, r5, asr r9
    2bc8:	4db41800 	ldcmi	8, cr1, [r4]
    2bcc:	62390000 	eorsvs	r0, r9, #0
    2bd0:	00002b0f 	andeq	r2, r0, pc, lsl #22
    2bd4:	00517d18 	subseq	r7, r1, r8, lsl sp
    2bd8:	3c683900 	stclcc	9, cr3, [r8], #-0
    2bdc:	1800002b 	stmdane	r0, {r0, r1, r3, r5}
    2be0:	00005cb8 			; <UNDEFINED> instruction: 0x00005cb8
    2be4:	2b5d6f39 	blcs	175e8d0 <unflatten_and_copy_device_tree+0x175da5c>
    2be8:	06000000 	streq	r0, [r0], -r0
    2bec:	00000057 	andeq	r0, r0, r7, asr r0
    2bf0:	00002bfb 	strdeq	r2, [r0], -fp
    2bf4:	0000eb07 	andeq	lr, r0, r7, lsl #22
    2bf8:	10001c00 	andne	r1, r0, r0, lsl #24
    2bfc:	00002073 	andeq	r2, r0, r3, ror r0
    2c00:	38303980 	ldmdacc	r0!, {r7, r8, fp, ip, sp}
    2c04:	0f00002c 	svceq	0x0000002c
    2c08:	000060c5 	andeq	r6, r0, r5, asr #1
    2c0c:	00573139 	subseq	r3, r7, r9, lsr r1
    2c10:	0f000000 	svceq	0x00000000
    2c14:	000000ac 	andeq	r0, r0, ip, lsr #1
    2c18:	00573239 	subseq	r3, r7, r9, lsr r2
    2c1c:	0f040000 	svceq	0x00040000
    2c20:	000036bf 			; <UNDEFINED> instruction: 0x000036bf
    2c24:	00573339 	subseq	r3, r7, r9, lsr r3
    2c28:	0f080000 	svceq	0x00080000
    2c2c:	00005002 	andeq	r5, r0, r2
    2c30:	2b8a7039 	blcs	fe29ed1c <__crc_of_fdt_unflatten_tree+0x7755d75f>
    2c34:	000c0000 	andeq	r0, ip, r0
    2c38:	0024ba03 	eoreq	fp, r4, r3, lsl #20
    2c3c:	fb713900 	blx	1c51046 <unflatten_and_copy_device_tree+0x1c501d2>
    2c40:	1000002b 	andne	r0, r0, fp, lsr #32
    2c44:	00004885 	andeq	r4, r0, r5, lsl #17
    2c48:	681a3a10 	ldmdavs	sl, {r4, r9, fp, ip, sp}
    2c4c:	0f00002c 	svceq	0x0000002c
    2c50:	0000058e 	andeq	r0, r0, lr, lsl #11
    2c54:	02c71b3a 	sbceq	r1, r7, #59392	; 0xe800
    2c58:	0f000000 	svceq	0x00000000
    2c5c:	00002aeb 	andeq	r2, r0, fp, ror #21
    2c60:	29ce1c3a 	stmibcs	lr, {r1, r3, r4, r5, sl, fp, ip}^
    2c64:	00080000 	andeq	r0, r8, r0
    2c68:	0008891a 	andeq	r8, r8, sl, lsl r9
    2c6c:	023a1400 	eorseq	r1, sl, #0, 8
    2c70:	002caa01 	eoreq	sl, ip, r1, lsl #20
    2c74:	19f71b00 	ldmibne	r7!, {r8, r9, fp, ip}^
    2c78:	043a0000 	ldrteq	r0, [sl], #-0
    2c7c:	00298c01 	eoreq	r8, r9, r1, lsl #24
    2c80:	cb1b0000 	blgt	6c0008 <unflatten_and_copy_device_tree+0x6bf194>
    2c84:	3a000010 	bcc	2ccc <.debug_info+0x2ccc>
    2c88:	00d40105 	sbcseq	r0, r4, r5, lsl #2
    2c8c:	1b040000 	blne	102c94 <unflatten_and_copy_device_tree+0x101e20>
    2c90:	00000800 	andeq	r0, r0, r0, lsl #16
    2c94:	a8010b3a 	stmdage	r1, {r1, r3, r4, r5, r8, r9, fp}
    2c98:	08000029 	stmdaeq	r0, {r0, r3, r5}
    2c9c:	002b1e1b 	eoreq	r1, fp, fp, lsl lr
    2ca0:	010d3a00 	tsteq	sp, r0, lsl #20
    2ca4:	000029ce 	andeq	r2, r0, lr, asr #19
    2ca8:	f11a000c 			; <UNDEFINED> instruction: 0xf11a000c
    2cac:	14000005 	strne	r0, [r0], #-5
    2cb0:	c401103a 	strgt	r1, [r1], #-58	; 0xffffffc6
    2cb4:	1d00002c 	stcne	0, cr0, [r0, #-176]	; 0xffffff50
    2cb8:	3a006173 	bcc	1b28c <unflatten_and_copy_device_tree+0x1a418>
    2cbc:	2c680111 	stfcse	f0, [r8], #-68	; 0xffffffbc
    2cc0:	00000000 	andeq	r0, r0, r0
    2cc4:	000b6726 	andeq	r6, fp, r6, lsr #14
    2cc8:	00690400 	rsbeq	r0, r9, r0, lsl #8
    2ccc:	063b0000 	ldrteq	r0, [fp], -r0
    2cd0:	00002ced 	andeq	r2, r0, sp, ror #25
    2cd4:	0043bf0b 	subeq	fp, r3, fp, lsl #30
    2cd8:	060b0000 	streq	r0, [fp], -r0
    2cdc:	01000020 	tsteq	r0, r0, lsr #32
    2ce0:	0013550b 	andseq	r5, r3, fp, lsl #10
    2ce4:	de0b0200 	cdple	2, 0, cr0, cr11, cr0, {0}
    2ce8:	0300005f 	movweq	r0, #95	; 0x5f
    2cec:	1b2c1000 	blne	b04008 <unflatten_and_copy_device_tree+0xb03194>
    2cf0:	3b100000 	blcc	402cf8 <unflatten_and_copy_device_tree+0x401e84>
    2cf4:	002d1c32 	eoreq	r1, sp, r2, lsr ip
    2cf8:	726e1400 	rsbvc	r1, lr, #0, 8
    2cfc:	57343b00 	ldrpl	r3, [r4, -r0, lsl #22]!
    2d00:	00000000 	andeq	r0, r0, r0
    2d04:	00736e14 	rsbseq	r6, r3, r4, lsl lr
    2d08:	2d21353b 	cfstr32cs	mvfx3, [r1, #-236]!	; 0xffffff14
    2d0c:	0f040000 	svceq	0x00040000
    2d10:	00002ab4 			; <UNDEFINED> instruction: 0x00002ab4
    2d14:	030b363b 	movweq	r3, #46651	; 0xb63b
    2d18:	00080000 	andeq	r0, r8, r0
    2d1c:	0044b416 	subeq	fp, r4, r6, lsl r4
    2d20:	1c040800 	stcne	8, cr0, [r4], {-0}
    2d24:	2d00002d 	stccs	0, cr0, [r0, #-180]	; 0xffffff4c
    2d28:	00646970 	rsbeq	r6, r4, r0, ror r9
    2d2c:	70393b2c 	eorsvc	r3, r9, ip, lsr #22
    2d30:	0f00002d 	svceq	0x0000002d
    2d34:	00003ba1 	andeq	r3, r0, r1, lsr #23
    2d38:	02bc3b3b 	adcseq	r3, ip, #60416	; 0xec00
    2d3c:	0f000000 	svceq	0x00000000
    2d40:	00001abc 			; <UNDEFINED> instruction: 0x00001abc
    2d44:	00693c3b 	rsbeq	r3, r9, fp, lsr ip
    2d48:	0f040000 	svceq	0x00040000
    2d4c:	000000b5 	strheq	r0, [r0], -r5
    2d50:	2d703e3b 	ldclcs	14, cr3, [r0, #-236]!	; 0xffffff14
    2d54:	14080000 	strne	r0, [r8], #-0
    2d58:	00756372 	rsbseq	r6, r5, r2, ror r3
    2d5c:	033c3f3b 	teqeq	ip, #59, 30	; 0xec
    2d60:	0f140000 	svceq	0x00140000
    2d64:	000036b7 			; <UNDEFINED> instruction: 0x000036b7
    2d68:	2d80403b 	stccs	0, cr4, [r0, #236]	; 0xec
    2d6c:	001c0000 	andseq	r0, ip, r0
    2d70:	0002f206 	andeq	pc, r2, r6, lsl #4
    2d74:	002d8000 	eoreq	r8, sp, r0
    2d78:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    2d7c:	00020000 	andeq	r0, r2, r0
    2d80:	002ced06 	eoreq	lr, ip, r6, lsl #26
    2d84:	002d9000 	eoreq	r9, sp, r0
    2d88:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    2d8c:	00000000 	andeq	r0, r0, r0
    2d90:	003b0410 	eorseq	r0, fp, r0, lsl r4
    2d94:	453b0c00 	ldrmi	r0, [fp, #-3072]!	; 0xfffff400
    2d98:	00002db5 			; <UNDEFINED> instruction: 0x00002db5
    2d9c:	00433d0f 	subeq	r3, r3, pc, lsl #26
    2da0:	0b473b00 	bleq	11d19a8 <unflatten_and_copy_device_tree+0x11d0b34>
    2da4:	00000003 	andeq	r0, r0, r3
    2da8:	64697014 	strbtvs	r7, [r9], #-20	; 0xffffffec
    2dac:	b5483b00 	strblt	r3, [r8, #-2816]	; 0xfffff500
    2db0:	0800002d 	stmdaeq	r0, {r0, r2, r3, r5}
    2db4:	27040800 	strcs	r0, [r4, -r0, lsl #16]
    2db8:	1000002d 	andne	r0, r0, sp, lsr #32
    2dbc:	00003681 	andeq	r3, r0, r1, lsl #13
    2dc0:	f8133c20 			; <UNDEFINED> instruction: 0xf8133c20
    2dc4:	0f00002d 	svceq	0x0000002d
    2dc8:	0000155a 	andeq	r1, r0, sl, asr r5
    2dcc:	10cd143c 	sbcne	r1, sp, ip, lsr r4
    2dd0:	0f000000 	svceq	0x00000000
    2dd4:	00003ba1 	andeq	r3, r0, r1, lsr #23
    2dd8:	00be153c 	adcseq	r1, lr, ip, lsr r5
    2ddc:	0f080000 	svceq	0x00080000
    2de0:	0000058e 	andeq	r0, r0, lr, lsl #11
    2de4:	02c7173c 	sbceq	r1, r7, #60, 14	; 0xf00000
    2de8:	0f100000 	svceq	0x00100000
    2dec:	000048af 	andeq	r4, r0, pc, lsr #17
    2df0:	2df8193c 	ldclcs	9, cr1, [r8, #240]!	; 0xf0
    2df4:	00180000 	andseq	r0, r8, r0
    2df8:	00a80408 	adceq	r0, r8, r8, lsl #8
    2dfc:	39100000 	ldmdbcc	r0, {}	; <UNPREDICTABLE>
    2e00:	0800004d 	stmdaeq	r0, {r0, r2, r3, r6}
    2e04:	2e23193d 	mcrcs	9, 1, r1, cr3, cr13, {1}
    2e08:	bc0f0000 	stclt	0, cr0, [pc], {-0}
    2e0c:	3d00005e 	stccc	0, cr0, [r0, #-376]	; 0xfffffe88
    2e10:	0000571a 	andeq	r5, r0, sl, lsl r7
    2e14:	fc0f0000 	stc2	0, cr0, [pc], {-0}
    2e18:	3d00001d 	stccc	0, cr0, [r0, #-116]	; 0xffffff8c
    2e1c:	002e281b 	eoreq	r2, lr, fp, lsl r8
    2e20:	16000400 	strne	r0, [r0], -r0, lsl #8
    2e24:	000004d1 	ldrdeq	r0, [r0], -r1
    2e28:	2e230408 	cdpcs	4, 2, cr0, cr3, cr8, {0}
    2e2c:	1e100000 	cdpne	0, 1, cr0, cr0, cr0, {0}
    2e30:	1800003c 	stmdane	r0, {r2, r3, r4, r5}
    2e34:	2e53083e 	mrccs	8, 2, r0, cr3, cr14, {1}
    2e38:	3d0f0000 	stccc	0, cr0, [pc, #-0]	; 8 <.debug_info+0x8>
    2e3c:	3e000043 	cdpcc	0, 0, cr0, cr0, cr3, {2}
    2e40:	001a6b09 	andseq	r6, sl, r9, lsl #22
    2e44:	940f0000 	strls	r0, [pc], #-0	; 8 <.debug_info+0x8>
    2e48:	3e00004f 	cdpcc	0, 0, cr0, cr0, cr15, {2}
    2e4c:	001a4f0a 	andseq	r4, sl, sl, lsl #30
    2e50:	10001000 	andne	r1, r0, r0
    2e54:	00005059 	andeq	r5, r0, r9, asr r0
    2e58:	780d3e08 	stmdavc	sp, {r3, r9, sl, fp, ip, sp}
    2e5c:	0f00002e 	svceq	0x0000002e
    2e60:	000055d2 	ldrdeq	r5, [r0], -r2
    2e64:	1aa20e3e 	bne	fe886764 <__crc_of_fdt_unflatten_tree+0x77b451a7>
    2e68:	0f000000 	svceq	0x00000000
    2e6c:	00002222 	andeq	r2, r0, r2, lsr #4
    2e70:	2e780f3e 	mrccs	15, 3, r0, cr8, cr14, {1}
    2e74:	00040000 	andeq	r0, r4, r0
    2e78:	2e2e0408 	cdpcs	4, 2, cr0, cr14, cr8, {0}
    2e7c:	5a260000 	bpl	980008 <unflatten_and_copy_device_tree+0x97f194>
    2e80:	0400001d 	streq	r0, [r0], #-29	; 0xffffffe3
    2e84:	00000069 	andeq	r0, r0, r9, rrx
    2e88:	2e9bef3f 	mrccs	15, 4, lr, cr11, cr15, {1}
    2e8c:	210b0000 	mrscs	r0, (UNDEF: 11)
    2e90:	0000005b 	andeq	r0, r0, fp, asr r0
    2e94:	001d940b 	andseq	r9, sp, fp, lsl #8
    2e98:	10000100 	andne	r0, r0, r0, lsl #2
    2e9c:	00003379 	andeq	r3, r0, r9, ror r3
    2ea0:	f0644030 			; <UNDEFINED> instruction: 0xf0644030
    2ea4:	0f00002e 	svceq	0x0000002e
    2ea8:	0000433d 	andeq	r4, r0, sp, lsr r3
    2eac:	2e2e6540 	cfsh64cs	mvdx6, mvdx14, #32
    2eb0:	0f000000 	svceq	0x00000000
    2eb4:	00000958 	andeq	r0, r0, r8, asr r9
    2eb8:	1a4f6640 	bne	13dc7c0 <unflatten_and_copy_device_tree+0x13db94c>
    2ebc:	0f180000 	svceq	0x00180000
    2ec0:	00001fd6 	ldrdeq	r1, [r0], -r6
    2ec4:	2f056740 	svccs	0x00056740
    2ec8:	0f200000 	svceq	0x00200000
    2ecc:	00002f72 	andeq	r2, r0, r2, ror pc
    2ed0:	2f606840 	svccs	0x00606840
    2ed4:	0f240000 	svceq	0x00240000
    2ed8:	00004ad0 	ldrdeq	r4, [r0], -r0
    2edc:	00936940 	addseq	r6, r3, r0, asr #18
    2ee0:	0f280000 	svceq	0x00280000
    2ee4:	000021bb 			; <UNDEFINED> instruction: 0x000021bb
    2ee8:	00936a40 	addseq	r6, r3, r0, asr #20
    2eec:	00290000 	eoreq	r0, r9, r0
    2ef0:	002e7e15 	eoreq	r7, lr, r5, lsl lr
    2ef4:	002eff00 	eoreq	pc, lr, r0, lsl #30
    2ef8:	2eff0d00 	cdpcs	13, 15, cr0, cr15, cr0, {0}
    2efc:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    2f00:	002e9b04 	eoreq	r9, lr, r4, lsl #22
    2f04:	f0040800 			; <UNDEFINED> instruction: 0xf0040800
    2f08:	1000002e 	andne	r0, r0, lr, lsr #32
    2f0c:	00001815 	andeq	r1, r0, r5, lsl r8
    2f10:	608e4020 	addvs	r4, lr, r0, lsr #32
    2f14:	0f00002f 	svceq	0x0000002f
    2f18:	00001344 	andeq	r1, r0, r4, asr #6
    2f1c:	30548f40 	subscc	r8, r4, r0, asr #30
    2f20:	0f000000 	svceq	0x00000000
    2f24:	000027ca 	andeq	r2, r0, sl, asr #15
    2f28:	00579040 	subseq	r9, r7, r0, asr #32
    2f2c:	0f040000 	svceq	0x00040000
    2f30:	00005d52 	andeq	r5, r0, r2, asr sp
    2f34:	01f09140 	mvnseq	r9, r0, asr #2
    2f38:	0f080000 	svceq	0x00080000
    2f3c:	00004596 	muleq	r0, r6, r5
    2f40:	2e539240 	cdpcs	2, 5, cr9, cr3, cr0, {2}
    2f44:	0f0c0000 	svceq	0x000c0000
    2f48:	00001397 	muleq	r0, r7, r3
    2f4c:	305f9340 	subscc	r9, pc, r0, asr #6
    2f50:	0f140000 	svceq	0x00140000
    2f54:	000050cf 	andeq	r5, r0, pc, asr #1
    2f58:	1a4f9440 	bne	13e8060 <unflatten_and_copy_device_tree+0x13e71ec>
    2f5c:	00180000 	andseq	r0, r8, r0
    2f60:	2f0b0408 	svccs	0x000b0408
    2f64:	75100000 	ldrvc	r0, [r0, #-0]
    2f68:	c0000025 	andgt	r0, r0, r5, lsr #32
    2f6c:	3054ba40 	subscc	fp, r4, r0, asr #20
    2f70:	5a0f0000 	bpl	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    2f74:	40000015 	andmi	r0, r0, r5, lsl r0
    2f78:	0010cdbb 			; <UNDEFINED> instruction: 0x0010cdbb
    2f7c:	73140000 	tstvc	r4, #0
    2f80:	40007165 	andmi	r7, r0, r5, ror #2
    2f84:	00120fbc 			; <UNDEFINED> instruction: 0x00120fbc
    2f88:	870f0400 	strhi	r0, [pc, -r0, lsl #8]
    2f8c:	4000000d 	andmi	r0, r0, sp
    2f90:	002effbd 	strhteq	pc, [lr], -sp	; <UNPREDICTABLE>
    2f94:	63140800 	tstvs	r4, #0, 16
    2f98:	40007570 	andmi	r7, r0, r0, ror r5
    2f9c:	000069be 			; <UNDEFINED> instruction: 0x000069be
    2fa0:	f20f0c00 			; <UNDEFINED> instruction: 0xf20f0c00
    2fa4:	4000002c 	andmi	r0, r0, ip, lsr #32
    2fa8:	000069bf 			; <UNDEFINED> instruction: 0x000069bf
    2fac:	730f1000 	movwvc	r1, #61440	; 0xf000
    2fb0:	40000048 	andmi	r0, r0, r8, asr #32
    2fb4:	000069c0 	andeq	r6, r0, r0, asr #19
    2fb8:	860f1400 	strhi	r1, [pc], -r0, lsl #8
    2fbc:	40000057 	andmi	r0, r0, r7, asr r0
    2fc0:	0001fbc1 	andeq	pc, r1, r1, asr #23
    2fc4:	630f1800 	movwvs	r1, #63488	; 0xf800
    2fc8:	40000033 	andmi	r0, r0, r3, lsr r0
    2fcc:	0001fbc2 	andeq	pc, r1, r2, asr #23
    2fd0:	f9291900 			; <UNDEFINED> instruction: 0xf9291900
    2fd4:	4000003b 	andmi	r0, r0, fp, lsr r0
    2fd8:	000069c4 	andeq	r6, r0, r4, asr #19
    2fdc:	0f010400 	svceq	0x00010400
    2fe0:	26052918 			; <UNDEFINED> instruction: 0x26052918
    2fe4:	c5400000 	strbgt	r0, [r0, #-0]
    2fe8:	00000069 	andeq	r0, r0, r9, rrx
    2fec:	180e0104 	stmdane	lr, {r2, r8}
    2ff0:	0056ff29 	subseq	pc, r6, r9, lsr #30
    2ff4:	69c64000 	stmibvs	r6, {lr}^
    2ff8:	04000000 	streq	r0, [r0], #-0
    2ffc:	0f180d01 	svceq	0x00180d01
    3000:	00004b3b 	andeq	r4, r0, fp, lsr fp
    3004:	1a4fc740 	bne	13f4d0c <unflatten_and_copy_device_tree+0x13f3e98>
    3008:	0f200000 	svceq	0x00200000
    300c:	00004b30 	andeq	r4, r0, r0, lsr fp
    3010:	2effc840 	cdpcs	8, 15, cr12, cr15, cr0, {2}
    3014:	0f280000 	svceq	0x00280000
    3018:	00002509 	andeq	r2, r0, r9, lsl #10
    301c:	0069c940 	rsbeq	ip, r9, r0, asr #18
    3020:	0f2c0000 	svceq	0x002c0000
    3024:	00002ebb 			; <UNDEFINED> instruction: 0x00002ebb
    3028:	0069ca40 	rsbeq	ip, r9, r0, asr #20
    302c:	0f300000 	svceq	0x00300000
    3030:	00005877 	andeq	r5, r0, r7, ror r8
    3034:	0069cb40 	rsbeq	ip, r9, r0, asr #22
    3038:	0f340000 	svceq	0x00340000
    303c:	00004268 	andeq	r4, r0, r8, ror #4
    3040:	0069cc40 	rsbeq	ip, r9, r0, asr #24
    3044:	0f380000 	svceq	0x00380000
    3048:	000027d0 	ldrdeq	r2, [r0], -r0
    304c:	3094ce40 	addscc	ip, r4, r0, asr #28
    3050:	00400000 	subeq	r0, r0, r0
    3054:	2f660408 	svccs	0x00660408
    3058:	4f120000 	svcmi	0x00120000
    305c:	0800001a 	stmdaeq	r0, {r1, r3, r4}
    3060:	00305a04 	eorseq	r5, r0, r4, lsl #20
    3064:	1b632600 	blne	18c9808 <unflatten_and_copy_device_tree+0x18c8994>
    3068:	69040000 	stmdbvs	r4, {}	; <UNPREDICTABLE>
    306c:	40000000 	andmi	r0, r0, r0
    3070:	00309497 	mlaseq	r0, r7, r4, r9
    3074:	11f30b00 	mvnsne	r0, r0, lsl #22
    3078:	0b000000 	bleq	3080 <.debug_info+0x3080>
    307c:	00003f05 	andeq	r3, r0, r5, lsl #30
    3080:	61de0b01 	bicsvs	r0, lr, r1, lsl #22
    3084:	0b020000 	bleq	8308c <unflatten_and_copy_device_tree+0x82218>
    3088:	00004091 	muleq	r0, r1, r0
    308c:	05cb0b03 	strbeq	r0, [fp, #2819]	; 0xb03
    3090:	00040000 	andeq	r0, r4, r0
    3094:	002f0b06 	eoreq	r0, pc, r6, lsl #22
    3098:	0030a400 	eorseq	sl, r0, r0, lsl #8
    309c:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    30a0:	00030000 	andeq	r0, r3, r0
    30a4:	0062222e 	rsbeq	r2, r2, lr, lsr #4
    30a8:	0b410000 	bleq	10430b0 <unflatten_and_copy_device_tree+0x104223c>
    30ac:	00118810 	andseq	r8, r1, r0, lsl r8
    30b0:	1a420800 	bne	10850b8 <unflatten_and_copy_device_tree+0x1084244>
    30b4:	000030d1 	ldrdeq	r3, [r0], -r1
    30b8:	003df80f 	eorseq	pc, sp, pc, lsl #16
    30bc:	d61b4200 	ldrle	r4, [fp], -r0, lsl #4
    30c0:	00000030 	andeq	r0, r0, r0, lsr r0
    30c4:	001a500f 	andseq	r5, sl, pc
    30c8:	d41c4200 	ldrle	r4, [ip], #-512	; 0xfffffe00
    30cc:	04000000 	streq	r0, [r0], #-0
    30d0:	3d671600 	stclcc	6, cr1, [r7, #-0]
    30d4:	04080000 	streq	r0, [r8], #-0
    30d8:	000030d1 	ldrdeq	r3, [r0], -r1
    30dc:	30e20408 	rsccc	r0, r2, r8, lsl #8
    30e0:	032f0000 			; <UNDEFINED> instruction: 0x032f0000
    30e4:	0000598b 	andeq	r5, r0, fp, lsl #19
    30e8:	024f1f43 	subeq	r1, pc, #268	; 0x10c
    30ec:	7a030000 	bvc	c0008 <unflatten_and_copy_device_tree+0xbf194>
    30f0:	43000022 	movwmi	r0, #34	; 0x22
    30f4:	00025a22 	andeq	r5, r2, r2, lsr #20
    30f8:	42b31000 	adcsmi	r1, r3, #0
    30fc:	430c0000 	movwmi	r0, #49152	; 0xc000
    3100:	00312a56 	eorseq	r2, r1, r6, asr sl
    3104:	357e0f00 	ldrbcc	r0, [lr, #-3840]!	; 0xfffff100
    3108:	57430000 	strbpl	r0, [r3, -r0]
    310c:	0000312f 	andeq	r3, r0, pc, lsr #2
    3110:	35e20f00 	strbcc	r0, [r2, #3840]!	; 0xf00
    3114:	58430000 	stmdapl	r3, {}^	; <UNPREDICTABLE>
    3118:	000000f2 	strdeq	r0, [r0], -r2
    311c:	0c990f04 	ldceq	15, cr0, [r9], {4}
    3120:	59430000 	stmdbpl	r3, {}^	; <UNPREDICTABLE>
    3124:	0000022e 	andeq	r0, r0, lr, lsr #4
    3128:	95160008 	ldrls	r0, [r6, #-8]
    312c:	08000042 	stmdaeq	r0, {r1, r6}
    3130:	00312a04 	eorseq	r2, r1, r4, lsl #20
    3134:	34202700 	strtcc	r2, [r0], #-1792	; 0xfffff900
    3138:	43100000 	tstmi	r0, #0
    313c:	0031585c 	eorseq	r5, r1, ip, asr r8
    3140:	3e941800 	cdpcc	8, 9, cr1, cr4, cr0, {0}
    3144:	5d430000 	stclpl	0, cr0, [r3, #-0]
    3148:	00000378 	andeq	r0, r0, r8, ror r3
    314c:	005dca18 	subseq	ip, sp, r8, lsl sl
    3150:	585e4300 	ldmdapl	lr, {r8, r9, lr}^
    3154:	00000031 	andeq	r0, r0, r1, lsr r0
    3158:	00037806 	andeq	r7, r3, r6, lsl #16
    315c:	00316800 	eorseq	r6, r1, r0, lsl #16
    3160:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    3164:	00030000 	andeq	r0, r3, r0
    3168:	8c430c17 	mcrrhi	12, 1, r0, r3, cr7
    316c:	00003187 	andeq	r3, r0, r7, lsl #3
    3170:	00149a18 	andseq	r9, r4, r8, lsl sl
    3174:	c78d4300 	strgt	r4, [sp, r0, lsl #6]
    3178:	18000002 	stmdane	r0, {r1}
    317c:	00000522 	andeq	r0, r0, r2, lsr #10
    3180:	1a6b8e43 	bne	1ae6a94 <unflatten_and_copy_device_tree+0x1ae5c20>
    3184:	17000000 	strne	r0, [r0, -r0]
    3188:	a6934304 	ldrge	r4, [r3], r4, lsl #6
    318c:	18000031 	stmdane	r0, {r0, r4, r5}
    3190:	00001940 	andeq	r1, r0, r0, asr #18
    3194:	02449443 	subeq	r9, r4, #1124073472	; 0x43000000
    3198:	5d180000 	ldcpl	0, cr0, [r8, #-0]
    319c:	4300005b 	movwmi	r0, #91	; 0x5b
    31a0:	00024495 	muleq	r2, r5, r4
    31a4:	080e0000 	stmdaeq	lr, {}	; <UNPREDICTABLE>
    31a8:	31c7bc43 	biccc	fp, r7, r3, asr #24
    31ac:	7e0f0000 	cdpvc	0, 0, cr0, cr15, cr0, {0}
    31b0:	43000035 	movwmi	r0, #53	; 0x35
    31b4:	00312fbd 	ldrhteq	r2, [r1], -sp
    31b8:	e20f0000 	and	r0, pc, #0
    31bc:	43000035 	movwmi	r0, #53	; 0x35
    31c0:	0001b3be 			; <UNDEFINED> instruction: 0x0001b3be
    31c4:	17000400 	strne	r0, [r0, -r0, lsl #8]
    31c8:	e0ba430c 	adcs	r4, sl, ip, lsl #6
    31cc:	18000031 	stmdane	r0, {r0, r4, r5}
    31d0:	00000464 	andeq	r0, r0, r4, ror #8
    31d4:	30f9bb43 	rscscc	fp, r9, r3, asr #22
    31d8:	a6280000 	strtge	r0, [r8], -r0
    31dc:	00000031 	andeq	r0, r0, r1, lsr r0
    31e0:	c843100e 	stmdagt	r3, {r1, r2, r3, ip}^
    31e4:	00003201 	andeq	r3, r0, r1, lsl #4
    31e8:	00160c0f 	andseq	r0, r6, pc, lsl #24
    31ec:	c7ca4300 	strbgt	r4, [sl, r0, lsl #6]
    31f0:	00000002 	andeq	r0, r0, r2
    31f4:	0013140f 	andseq	r1, r3, pc, lsl #8
    31f8:	accb4300 	stclge	3, cr4, [fp], {0}
    31fc:	08000030 	stmdaeq	r0, {r4, r5}
    3200:	43101700 	tstmi	r0, #0, 14
    3204:	003225c6 	eorseq	r2, r2, r6, asr #11
    3208:	33151800 	tstcc	r5, #0, 16
    320c:	c7430000 	strbgt	r0, [r3, -r0]
    3210:	00003135 	andeq	r3, r0, r5, lsr r1
    3214:	0031e028 	eorseq	lr, r1, r8, lsr #32
    3218:	576d1800 	strbpl	r1, [sp, -r0, lsl #16]!
    321c:	cd430000 	stclgt	0, cr0, [r3, #-0]
    3220:	00000057 	andeq	r0, r0, r7, asr r0
    3224:	656b2d00 	strbvs	r2, [fp, #-3328]!	; 0xfffff300
    3228:	436c0079 	cmnmi	ip, #121	; 0x79
    322c:	0032da89 	eorseq	sp, r2, r9, lsl #21
    3230:	15350f00 	ldrne	r0, [r5, #-3840]!	; 0xfffff100
    3234:	8a430000 	bhi	10c323c <unflatten_and_copy_device_tree+0x10c23c8>
    3238:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    323c:	64700f00 	ldrbtvs	r0, [r0], #-3840	; 0xfffff100
    3240:	8b430000 	blhi	10c3248 <unflatten_and_copy_device_tree+0x10c23d4>
    3244:	000030e3 	andeq	r3, r0, r3, ror #1
    3248:	31681904 	cmncc	r8, r4, lsl #18
    324c:	14080000 	strne	r0, [r8], #-0
    3250:	006d6573 	rsbeq	r6, sp, r3, ror r5
    3254:	19899043 	stmibne	r9, {r0, r1, r6, ip, pc}
    3258:	0f140000 	svceq	0x00140000
    325c:	000059a1 	andeq	r5, r0, r1, lsr #19
    3260:	32df9143 	sbcscc	r9, pc, #-1073741808	; 0xc0000010
    3264:	0f2c0000 	svceq	0x002c0000
    3268:	000012d0 	ldrdeq	r1, [r0], -r0
    326c:	03789243 	cmneq	r8, #805306372	; 0x30000004
    3270:	19300000 	ldmdbne	r0!, {}	; <UNPREDICTABLE>
    3274:	00003187 	andeq	r3, r0, r7, lsl #3
    3278:	62060f34 	andvs	r0, r6, #52, 30	; 0xd0
    327c:	97430000 	strbls	r0, [r3, -r0]
    3280:	00000244 	andeq	r0, r0, r4, asr #4
    3284:	69751438 	ldmdbvs	r5!, {r3, r4, r5, sl, ip}^
    3288:	98430064 	stmdals	r3, {r2, r5, r6}^
    328c:	00002842 	andeq	r2, r0, r2, asr #16
    3290:	6967143c 	stmdbvs	r7!, {r2, r3, r4, r5, sl, ip}^
    3294:	99430064 	stmdbls	r3, {r2, r5, r6}^
    3298:	00002862 	andeq	r2, r0, r2, ror #16
    329c:	4b110f40 	blmi	443d08 <unflatten_and_copy_device_tree+0x442e94>
    32a0:	9a430000 	bls	10c32a8 <unflatten_and_copy_device_tree+0x10c2434>
    32a4:	000030ee 	andeq	r3, r0, lr, ror #1
    32a8:	10710f44 	rsbsne	r0, r1, r4, asr #30
    32ac:	9b430000 	blls	10c32b4 <unflatten_and_copy_device_tree+0x10c2440>
    32b0:	00000045 	andeq	r0, r0, r5, asr #32
    32b4:	195a0f48 	ldmdbne	sl, {r3, r6, r8, r9, sl, fp}^
    32b8:	9c430000 	marls	acc0, r0, r3
    32bc:	00000045 	andeq	r0, r0, r5, asr #32
    32c0:	596a0f4a 	stmdbpl	sl!, {r1, r3, r6, r8, r9, sl, fp}^
    32c4:	a7430000 	strbge	r0, [r3, -r0]
    32c8:	000000d4 	ldrdeq	r0, [r0], -r4
    32cc:	31c7194c 	biccc	r1, r7, ip, asr #18
    32d0:	19500000 	ldmdbne	r0, {}^	; <UNPREDICTABLE>
    32d4:	00003201 	andeq	r3, r0, r1, lsl #4
    32d8:	5716005c 			; <UNDEFINED> instruction: 0x5716005c
    32dc:	08000064 	stmdaeq	r0, {r2, r5, r6}
    32e0:	0032da04 	eorseq	sp, r2, r4, lsl #20
    32e4:	07df1000 	ldrbeq	r1, [pc, r0]
    32e8:	448c0000 	strmi	r0, [ip], #0
    32ec:	00332e20 	eorseq	r2, r3, r0, lsr #28
    32f0:	15350f00 	ldrne	r0, [r5, #-3840]!	; 0xfffff100
    32f4:	21440000 	mrscs	r0, (UNDEF: 68)
    32f8:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    32fc:	04c90f00 	strbeq	r0, [r9], #3840	; 0xf00
    3300:	22440000 	subcs	r0, r4, #0
    3304:	00000057 	andeq	r0, r0, r7, asr r0
    3308:	43220f04 			; <UNDEFINED> instruction: 0x43220f04
    330c:	23440000 	movtcs	r0, #16384	; 0x4000
    3310:	00000057 	andeq	r0, r0, r7, asr r0
    3314:	1c1b0f08 	ldcne	15, cr0, [fp], {8}
    3318:	24440000 	strbcs	r0, [r4], #-0
    331c:	0000332e 	andeq	r3, r0, lr, lsr #6
    3320:	27470f0c 	strbcs	r0, [r7, -ip, lsl #30]
    3324:	25440000 	strbcs	r0, [r4, #-0]
    3328:	0000333e 	andeq	r3, r0, lr, lsr r3
    332c:	6206008c 	andvs	r0, r6, #140	; 0x8c
    3330:	3e000028 	cdpcc	0, 0, cr0, cr0, cr8, {1}
    3334:	07000033 	smladxeq	r0, r3, r0, r0
    3338:	000000eb 	andeq	r0, r0, fp, ror #1
    333c:	4d06001f 	stcmi	0, cr0, [r6, #-124]	; 0xffffff84
    3340:	4d000033 	stcmi	0, cr0, [r0, #-204]	; 0xffffff34
    3344:	25000033 	strcs	r0, [r0, #-51]	; 0xffffffcd
    3348:	000000eb 	andeq	r0, r0, fp, ror #1
    334c:	62040800 	andvs	r0, r4, #0, 16
    3350:	10000028 	andne	r0, r0, r8, lsr #32
    3354:	0000277d 	andeq	r2, r0, sp, ror r7
    3358:	80764478 	rsbshi	r4, r6, r8, ror r4
    335c:	0f000034 	svceq	0x00000034
    3360:	00001535 	andeq	r1, r0, r5, lsr r5
    3364:	02bc7744 	adcseq	r7, ip, #68, 14	; 0x1100000
    3368:	14000000 	strne	r0, [r0], #-0
    336c:	00646975 	rsbeq	r6, r4, r5, ror r9
    3370:	28427f44 	stmdacs	r2, {r2, r6, r8, r9, sl, fp, ip, sp, lr}^
    3374:	14040000 	strne	r0, [r4], #-0
    3378:	00646967 	rsbeq	r6, r4, r7, ror #18
    337c:	28628044 	stmdacs	r2!, {r2, r6, pc}^
    3380:	0f080000 	svceq	0x00080000
    3384:	0000395e 	andeq	r3, r0, lr, asr r9
    3388:	28428144 	stmdacs	r2, {r2, r6, r8, pc}^
    338c:	0f0c0000 	svceq	0x000c0000
    3390:	00005b4c 	andeq	r5, r0, ip, asr #22
    3394:	28628244 	stmdacs	r2!, {r2, r6, r9, pc}^
    3398:	0f100000 	svceq	0x00100000
    339c:	0000334b 	andeq	r3, r0, fp, asr #6
    33a0:	28428344 	stmdacs	r2, {r2, r6, r8, r9, pc}^
    33a4:	0f140000 	svceq	0x00140000
    33a8:	0000561e 	andeq	r5, r0, lr, lsl r6
    33ac:	28628444 	stmdacs	r2!, {r2, r6, sl, pc}^
    33b0:	0f180000 	svceq	0x00180000
    33b4:	000059fa 	strdeq	r5, [r0], -sl
    33b8:	28428544 	stmdacs	r2, {r2, r6, r8, sl, pc}^
    33bc:	0f1c0000 	svceq	0x001c0000
    33c0:	00001570 	andeq	r1, r0, r0, ror r5
    33c4:	28628644 	stmdacs	r2!, {r2, r6, r9, sl, pc}^
    33c8:	0f200000 	svceq	0x00200000
    33cc:	000055d7 	ldrdeq	r5, [r0], -r7
    33d0:	00698744 	rsbeq	r8, r9, r4, asr #14
    33d4:	0f240000 	svceq	0x00240000
    33d8:	00003438 	andeq	r3, r0, r8, lsr r4
    33dc:	27e68844 	strbcs	r8, [r6, r4, asr #16]!
    33e0:	0f280000 	svceq	0x00280000
    33e4:	00001648 	andeq	r1, r0, r8, asr #12
    33e8:	27e68944 	strbcs	r8, [r6, r4, asr #18]!
    33ec:	0f300000 	svceq	0x00300000
    33f0:	0000080c 	andeq	r0, r0, ip, lsl #16
    33f4:	27e68a44 	strbcs	r8, [r6, r4, asr #20]!
    33f8:	0f380000 	svceq	0x00380000
    33fc:	0000239e 	muleq	r0, lr, r3
    3400:	27e68b44 	strbcs	r8, [r6, r4, asr #22]!
    3404:	0f400000 	svceq	0x00400000
    3408:	00001428 	andeq	r1, r0, r8, lsr #8
    340c:	27e68c44 	strbcs	r8, [r6, r4, asr #24]!
    3410:	0f480000 	svceq	0x00480000
    3414:	00000c88 	andeq	r0, r0, r8, lsl #25
    3418:	002c8e44 	eoreq	r8, ip, r4, asr #28
    341c:	0f500000 	svceq	0x00500000
    3420:	000039ae 	andeq	r3, r0, lr, lsr #19
    3424:	34809044 	strcc	r9, [r0], #68	; 0x44
    3428:	0f540000 	svceq	0x00540000
    342c:	00004307 	andeq	r4, r0, r7, lsl #6
    3430:	34809144 	strcc	r9, [r0], #324	; 0x144
    3434:	0f580000 	svceq	0x00580000
    3438:	0000321b 	andeq	r3, r0, fp, lsl r2
    343c:	34809244 	strcc	r9, [r0], #580	; 0x244
    3440:	0f5c0000 	svceq	0x005c0000
    3444:	000046c2 	andeq	r4, r0, r2, asr #13
    3448:	34809344 	strcc	r9, [r0], #836	; 0x344
    344c:	0f600000 	svceq	0x00600000
    3450:	000059a1 	andeq	r5, r0, r1, lsr #19
    3454:	29629844 	stmdbcs	r2!, {r2, r6, fp, ip, pc}^
    3458:	0f640000 	svceq	0x00640000
    345c:	00001c3a 	andeq	r1, r0, sl, lsr ip
    3460:	25c19944 	strbcs	r9, [r1, #2372]	; 0x944
    3464:	0f680000 	svceq	0x00680000
    3468:	000007df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    346c:	34869a44 	strcc	r9, [r6], #2628	; 0xa44
    3470:	146c0000 	strbtne	r0, [ip], #-0
    3474:	00756372 	rsbseq	r6, r5, r2, ror r3
    3478:	033c9b44 	teqeq	ip, #68, 22	; 0x11000
    347c:	00700000 	rsbseq	r0, r0, r0
    3480:	32250408 	eorcc	r0, r5, #8, 8	; 0x8000000
    3484:	04080000 	streq	r0, [r8], #-0
    3488:	000032e5 	andeq	r3, r0, r5, ror #5
    348c:	23452017 	movtcs	r2, #20503	; 0x5017
    3490:	000034ab 	andeq	r3, r0, fp, lsr #9
    3494:	005df618 	subseq	pc, sp, r8, lsl r6	; <UNPREDICTABLE>
    3498:	ab254500 	blge	9548a0 <unflatten_and_copy_device_tree+0x953a2c>
    349c:	18000034 	stmdane	r0, {r2, r4, r5}
    34a0:	000010f3 	strdeq	r1, [r0], -r3
    34a4:	033c2645 	teqeq	ip, #72351744	; 0x4500000
    34a8:	06000000 	streq	r0, [r0], -r0
    34ac:	000000d4 	ldrdeq	r0, [r0], -r4
    34b0:	000034bb 			; <UNDEFINED> instruction: 0x000034bb
    34b4:	0000eb07 	andeq	lr, r0, r7, lsl #22
    34b8:	30000700 	andcc	r0, r0, r0, lsl #14
    34bc:	00003126 	andeq	r3, r0, r6, lsr #2
    34c0:	1e45042c 	cdpne	4, 4, cr0, cr5, cr12, {1}
    34c4:	00003501 	andeq	r3, r0, r1, lsl #10
    34c8:	000cbe0f 	andeq	fp, ip, pc, lsl #28
    34cc:	571f4500 	ldrpl	r4, [pc, -r0, lsl #10]
    34d0:	00000000 	andeq	r0, r0, r0
    34d4:	0002c80f 	andeq	ip, r2, pc, lsl #16
    34d8:	57204500 	strpl	r4, [r0, -r0, lsl #10]!
    34dc:	04000000 	streq	r0, [r0], #-0
    34e0:	79726114 	ldmdbvc	r2!, {r2, r4, r8, sp, lr}^
    34e4:	01214500 			; <UNDEFINED> instruction: 0x01214500
    34e8:	08000035 	stmdaeq	r0, {r0, r2, r4, r5}
    34ec:	003ba131 	eorseq	sl, fp, r1, lsr r1
    34f0:	57224500 	strpl	r4, [r2, -r0, lsl #10]!
    34f4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    34f8:	348c3204 	strcc	r3, [ip], #516	; 0x204
    34fc:	040c0000 	streq	r0, [ip], #-0
    3500:	35110600 	ldrcc	r0, [r1, #-1536]	; 0xfffffa00
    3504:	35110000 	ldrcc	r0, [r1, #-0]
    3508:	eb070000 	bl	1c3510 <unflatten_and_copy_device_tree+0x1c269c>
    350c:	ff000000 			; <UNDEFINED> instruction: 0xff000000
    3510:	bb040800 	bllt	105518 <unflatten_and_copy_device_tree+0x1046a4>
    3514:	2d000034 	stccs	0, cr0, [r0, #-208]	; 0xffffff30
    3518:	00726469 	rsbseq	r6, r2, r9, ror #8
    351c:	782a451c 	stmdavc	sl!, {r2, r3, r4, r8, sl, lr}
    3520:	0f000035 	svceq	0x00000035
    3524:	00001976 	andeq	r1, r0, r6, ror r9
    3528:	35112b45 	ldrcc	r2, [r1, #-2885]	; 0xfffff4bb
    352c:	14000000 	strne	r0, [r0], #-0
    3530:	00706f74 	rsbseq	r6, r0, r4, ror pc
    3534:	35112c45 	ldrcc	r2, [r1, #-3141]	; 0xfffff3bb
    3538:	0f040000 	svceq	0x00040000
    353c:	0000106a 	andeq	r1, r0, sl, rrx
    3540:	00572d45 	subseq	r2, r7, r5, asr #26
    3544:	14080000 	strne	r0, [r8], #-0
    3548:	00727563 	rsbseq	r7, r2, r3, ror #10
    354c:	00572e45 	subseq	r2, r7, r5, asr #28
    3550:	0f0c0000 	svceq	0x000c0000
    3554:	0000155a 	andeq	r1, r0, sl, asr r5
    3558:	10ff2f45 	rscsne	r2, pc, r5, asr #30
    355c:	0f100000 	svceq	0x00100000
    3560:	00000d19 	andeq	r0, r0, r9, lsl sp
    3564:	00573045 	subseq	r3, r7, r5, asr #32
    3568:	0f140000 	svceq	0x00140000
    356c:	000027f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    3570:	35113145 	ldrcc	r3, [r1, #-325]	; 0xfffffebb
    3574:	00180000 	andseq	r0, r8, r0
    3578:	002eec10 	eoreq	lr, lr, r0, lsl ip
    357c:	95458000 	strbls	r8, [r5, #-0]
    3580:	0000359d 	muleq	r0, sp, r5
    3584:	000dd00f 	andeq	sp, sp, pc
    3588:	33964500 	orrscc	r4, r6, #0, 10
    358c:	00000001 	andeq	r0, r0, r1
    3590:	005df60f 	subseq	pc, sp, pc, lsl #12
    3594:	9d974500 	cfldr32ls	mvfx4, [r7]
    3598:	04000035 	streq	r0, [r0], #-53	; 0xffffffcb
    359c:	00d40600 	sbcseq	r0, r4, r0, lsl #12
    35a0:	35ad0000 	strcc	r0, [sp, #0]!
    35a4:	eb070000 	bl	1c35ac <unflatten_and_copy_device_tree+0x1c2738>
    35a8:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    35ac:	64692d00 	strbtvs	r2, [r9], #-3328	; 0xfffff300
    35b0:	45200061 	strmi	r0, [r0, #-97]!	; 0xffffff9f
    35b4:	0035d29a 	mlaseq	r5, sl, r2, sp
    35b8:	64691400 	strbtvs	r1, [r9], #-1024	; 0xfffffc00
    35bc:	9b450072 	blls	114378c <unflatten_and_copy_device_tree+0x1142918>
    35c0:	00003517 	andeq	r3, r0, r7, lsl r5
    35c4:	12960f00 	addsne	r0, r6, #0, 30
    35c8:	9c450000 	marls	acc0, r0, r5
    35cc:	000035d2 	ldrdeq	r3, [r0], -r2
    35d0:	0408001c 	streq	r0, [r8], #-28	; 0xffffffe4
    35d4:	00003578 	andeq	r3, r0, r8, ror r5
    35d8:	00104403 	andseq	r4, r0, r3, lsl #8
    35dc:	e3374600 	teq	r7, #0, 12
    35e0:	0c000035 	stceq	0, cr0, [r0], {53}	; 0x35
    35e4:	000035ee 	andeq	r3, r0, lr, ror #11
    35e8:	0035ee0d 	eorseq	lr, r5, sp, lsl #28
    35ec:	04080000 	streq	r0, [r8], #-0
    35f0:	000035f4 	strdeq	r3, [r0], -r4
    35f4:	000b3f10 	andeq	r3, fp, r0, lsl pc
    35f8:	53461c00 	movtpl	r1, #27648	; 0x6c00
    35fc:	0000364c 	andeq	r3, r0, ip, asr #12
    3600:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    3604:	bb544600 	bllt	1514e0c <unflatten_and_copy_device_tree+0x1513f98>
    3608:	00000011 	andeq	r0, r0, r1, lsl r0
    360c:	0042230f 	subeq	r2, r2, pc, lsl #6
    3610:	d4594600 	ldrble	r4, [r9], #-1536	; 0xfffffa00
    3614:	04000000 	streq	r0, [r0], #-0
    3618:	00026a0f 	andeq	r6, r2, pc, lsl #20
    361c:	4c5a4600 	mrrcmi	6, 0, r4, sl, cr0
    3620:	08000036 	stmdaeq	r0, {r1, r2, r4, r5}
    3624:	00500c0f 	subseq	r0, r0, pc, lsl #24
    3628:	4c5b4600 	mrrcmi	6, 0, r4, fp, cr0
    362c:	0c000036 	stceq	0, cr0, [r0], {54}	; 0x36
    3630:	0018da29 	andseq	sp, r8, r9, lsr #20
    3634:	fb5c4600 	blx	1714e3e <unflatten_and_copy_device_tree+0x1713fca>
    3638:	01000001 	tsteq	r0, r1
    363c:	14100701 	ldrne	r0, [r0], #-1793	; 0xfffff8ff
    3640:	00756372 	rsbseq	r6, r5, r2, ror r3
    3644:	033c5d46 	teqeq	ip, #4480	; 0x1180
    3648:	00140000 	andseq	r0, r4, r0
    364c:	35d80408 	ldrbcc	r0, [r8, #1032]	; 0x408
    3650:	ba260000 	blt	980008 <unflatten_and_copy_device_tree+0x97f194>
    3654:	04000019 	streq	r0, [r0], #-25	; 0xffffffe7
    3658:	00000069 	andeq	r0, r0, r9, rrx
    365c:	36751d47 	ldrbtcc	r1, [r5], -r7, asr #26
    3660:	1e0b0000 	cdpne	0, 0, cr0, cr11, cr0, {0}
    3664:	0000005c 	andeq	r0, r0, ip, asr r0
    3668:	004fce0b 	subeq	ip, pc, fp, lsl #28
    366c:	1d0b0100 	stfnes	f0, [fp, #-0]
    3670:	0200001f 	andeq	r0, r0, #31
    3674:	4e541000 	cdpmi	0, 5, cr1, cr4, cr0, {0}
    3678:	47240000 	strmi	r0, [r4, -r0]!
    367c:	0036ca20 	eorseq	ip, r6, r0, lsr #20
    3680:	2b3a0f00 	blcs	e83c08 <unflatten_and_copy_device_tree+0xe82d94>
    3684:	21470000 	mrscs	r0, (UNDEF: 71)
    3688:	00000057 	andeq	r0, r0, r7, asr r0
    368c:	1e490f00 	cdpne	15, 4, cr0, cr9, cr0, {0}
    3690:	22470000 	subcs	r0, r7, #0
    3694:	00000057 	andeq	r0, r0, r7, asr r0
    3698:	1afe0f04 	bne	fff83c18 <__crc_of_fdt_unflatten_tree+0x7924265b>
    369c:	23470000 	movtcs	r0, #28672	; 0x7000
    36a0:	000011eb 	andeq	r1, r0, fp, ror #3
    36a4:	0ac80f08 	beq	ff203c28 <__crc_of_fdt_unflatten_tree+0x784c266b>
    36a8:	25470000 	strbcs	r0, [r7, #-0]
    36ac:	00000057 	andeq	r0, r0, r7, asr r0
    36b0:	3a100f14 	bcc	403c58 <unflatten_and_copy_device_tree+0x402de4>
    36b4:	26470000 	strbcs	r0, [r7], -r0
    36b8:	0000033c 	andeq	r0, r0, ip, lsr r3
    36bc:	20340f18 	eorscs	r0, r4, r8, lsl pc
    36c0:	28470000 	stmdacs	r7, {}^	; <UNPREDICTABLE>
    36c4:	00003652 	andeq	r3, r0, r2, asr r6
    36c8:	61100020 	tstvs	r0, r0, lsr #32
    36cc:	50000013 	andpl	r0, r0, r3, lsl r0
    36d0:	37130b48 	ldrcc	r0, [r3, -r8, asr #22]
    36d4:	72140000 	andsvc	r0, r4, #0
    36d8:	48007373 	stmdami	r0, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}
    36dc:	0036750c 	eorseq	r7, r6, ip, lsl #10
    36e0:	980f0000 	stmdals	pc, {}	; <UNPREDICTABLE>
    36e4:	48000037 	stmdami	r0, {r0, r1, r2, r4, r5}
    36e8:	001b7f0d 	andseq	r7, fp, sp, lsl #30
    36ec:	f40f2400 	vst3.8	{d2-d4}, [pc], r0
    36f0:	4800001e 	stmdami	r0, {r1, r2, r3, r4}
    36f4:	0019890e 	andseq	r8, r9, lr, lsl #18
    36f8:	f50f2800 			; <UNDEFINED> instruction: 0xf50f2800
    36fc:	48000049 	stmdami	r0, {r0, r3, r6}
    3700:	0002bc0f 	andeq	fp, r2, pc, lsl #24
    3704:	6d0f4000 	stcvs	0, cr4, [pc, #-0]	; 8 <.debug_info+0x8>
    3708:	48000012 	stmdami	r0, {r1, r4}
    370c:	0011eb10 	andseq	lr, r1, r0, lsl fp
    3710:	26004400 	strcs	r4, [r0], -r0, lsl #8
    3714:	0000451e 	andeq	r4, r0, lr, lsl r5
    3718:	00006904 	andeq	r6, r0, r4, lsl #18
    371c:	78274900 	stmdavc	r7!, {r8, fp, lr}
    3720:	0b000037 	bleq	3804 <.debug_info+0x3804>
    3724:	00004c76 	andeq	r4, r0, r6, ror ip
    3728:	45a60b00 	strmi	r0, [r6, #2816]!	; 0xb00
    372c:	0b010000 	bleq	43734 <unflatten_and_copy_device_tree+0x428c0>
    3730:	00005570 	andeq	r5, r0, r0, ror r5
    3734:	344f0b02 	strbcc	r0, [pc], #-2818	; 8 <.debug_info+0x8>
    3738:	0b030000 	bleq	c3740 <unflatten_and_copy_device_tree+0xc28cc>
    373c:	0000025b 	andeq	r0, r0, fp, asr r2
    3740:	2bae0b04 	blcs	feb82c18 <__crc_of_fdt_unflatten_tree+0x77e4165b>
    3744:	0b050000 	bleq	14374c <unflatten_and_copy_device_tree+0x1428d8>
    3748:	00001034 	andeq	r1, r0, r4, lsr r0
    374c:	514e0b06 	cmppl	lr, r6, lsl #22
    3750:	0b070000 	bleq	1c3758 <unflatten_and_copy_device_tree+0x1c28e4>
    3754:	000035b2 			; <UNDEFINED> instruction: 0x000035b2
    3758:	32b10b08 	adcscc	r0, r1, #8, 22	; 0x2000
    375c:	0b070000 	bleq	1c3764 <unflatten_and_copy_device_tree+0x1c28f0>
    3760:	000040ef 	andeq	r4, r0, pc, ror #1
    3764:	5c3b0b08 	ldcpl	11, cr0, [fp], #-32	; 0xffffffe0
    3768:	0b090000 	bleq	243770 <unflatten_and_copy_device_tree+0x2428fc>
    376c:	000013cc 	andeq	r1, r0, ip, asr #7
    3770:	65150b08 	ldrvs	r0, [r5, #-2824]	; 0xfffff4f8
    3774:	00090000 	andeq	r0, r9, r0
    3778:	005d0210 	subseq	r0, sp, r0, lsl r2
    377c:	5a490400 	bpl	1244784 <unflatten_and_copy_device_tree+0x1243910>
    3780:	00003790 	muleq	r0, r0, r7
    3784:	006e6b14 	rsbeq	r6, lr, r4, lsl fp
    3788:	38315c49 	ldmdacc	r1!, {r0, r3, r6, sl, fp, ip, lr}
    378c:	00000000 	andeq	r0, r0, r0
    3790:	004aa910 	subeq	sl, sl, r0, lsl r9
    3794:	6a4a5000 	bvs	129779c <unflatten_and_copy_device_tree+0x1296928>
    3798:	00003831 	andeq	r3, r0, r1, lsr r8
    379c:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    37a0:	bc6b4a00 	stcllt	10, cr4, [fp], #-0
    37a4:	00000002 	andeq	r0, r0, r2
    37a8:	0045960f 	subeq	r9, r5, pc, lsl #12
    37ac:	bc6c4a00 	stcllt	10, cr4, [ip], #-0
    37b0:	04000002 	streq	r0, [r0], #-2
    37b4:	0023220f 	eoreq	r2, r3, pc, lsl #4
    37b8:	31764a00 	cmncc	r6, r0, lsl #20
    37bc:	08000038 	stmdaeq	r0, {r3, r4, r5}
    37c0:	00059b0f 	andeq	r9, r5, pc, lsl #22
    37c4:	f2774a00 	vpmax.s<illegal width 64>	d20, d7, d0
    37c8:	0c000000 	stceq	0, cr0, [r0], {-0}
    37cc:	00627214 	rsbeq	r7, r2, r4, lsl r2
    37d0:	1a6b794a 	bne	1ae1d00 <unflatten_and_copy_device_tree+0x1ae0e8c>
    37d4:	14100000 	ldrne	r0, [r0], #-0
    37d8:	4a00736e 	bmi	20598 <unflatten_and_copy_device_tree+0x1f724>
    37dc:	0030dc7b 	eorseq	sp, r0, fp, ror ip
    37e0:	dd0f1c00 	stcle	12, cr1, [pc, #-0]	; 8 <.debug_info+0x8>
    37e4:	4a000051 	bmi	3930 <.debug_info+0x3930>
    37e8:	0000697c 	andeq	r6, r0, ip, ror r9
    37ec:	88192000 	ldmdahi	r9, {sp}
    37f0:	28000053 	stmdacs	r0, {r0, r1, r4, r6}
    37f4:	0050790f 	subseq	r7, r0, pc, lsl #18
    37f8:	78834a00 	stmvc	r3, {r9, fp, lr}
    37fc:	40000003 	andmi	r0, r0, r3
    3800:	00596a0f 	subseq	r6, r9, pc, lsl #20
    3804:	45854a00 	strmi	r4, [r5, #2560]	; 0xa00
    3808:	44000000 	strmi	r0, [r0], #-0
    380c:	005ebc0f 	subseq	fp, lr, pc, lsl #24
    3810:	da864a00 	ble	fe196018 <__crc_of_fdt_unflatten_tree+0x77454a5b>
    3814:	46000001 	strmi	r0, [r0], -r1
    3818:	6f6e6914 	svcvs	0x006e6914
    381c:	69874a00 	stmibvs	r7, {r9, fp, lr}
    3820:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    3824:	0000460f 	andeq	r4, r0, pc, lsl #12
    3828:	b7884a00 	strlt	r4, [r8, r0, lsl #20]
    382c:	4c000053 	stcmi	0, cr0, [r0], {83}	; 0x53
    3830:	90040800 	andls	r0, r4, r0, lsl #16
    3834:	10000037 	andne	r0, r0, r7, lsr r0
    3838:	00004003 	andeq	r4, r0, r3
    383c:	d2664968 	rsble	r4, r6, #104, 18	; 0x1a0000
    3840:	0f000038 	svceq	0x00000038
    3844:	00004eb8 			; <UNDEFINED> instruction: 0x00004eb8
    3848:	39b86849 	ldmibcc	r8!, {r0, r3, r6, fp, sp, lr}
    384c:	14000000 	strne	r0, [r0], #-0
    3850:	49007373 	stmdbmi	r0, {r0, r1, r4, r5, r6, r8, r9, ip, sp, lr}
    3854:	003b446b 	eorseq	r4, fp, fp, ror #8
    3858:	0e0f0400 	cfcpyseq	mvf0, mvf15
    385c:	49000059 	stmdbmi	r0, {r0, r3, r4, r6}
    3860:	0035f46e 	eorseq	pc, r5, lr, ror #8
    3864:	220f0800 	andcs	r0, pc, #0, 16
    3868:	49000023 	stmdbmi	r0, {r0, r1, r5}
    386c:	003b4a71 	eorseq	r4, fp, r1, ror sl
    3870:	a00f2400 	andge	r2, pc, r0, lsl #8
    3874:	49000002 	stmdbmi	r0, {r1}
    3878:	0002c774 	andeq	ip, r2, r4, ror r7
    387c:	b70f2800 	strlt	r2, [pc, -r0, lsl #16]
    3880:	4900004f 	stmdbmi	r0, {r0, r1, r2, r3, r6}
    3884:	0002c775 	andeq	ip, r2, r5, ror r7
    3888:	69143000 	ldmdbvs	r4, {ip, sp}
    388c:	7b490064 	blvc	1243a24 <unflatten_and_copy_device_tree+0x1242bb0>
    3890:	00000057 	andeq	r0, r0, r7, asr r0
    3894:	596a0f38 	stmdbpl	sl!, {r3, r4, r5, r8, r9, sl, fp}^
    3898:	7d490000 	stclvc	0, cr0, [r9, #-0]
    389c:	00000069 	andeq	r0, r0, r9, rrx
    38a0:	64e10f3c 	strbtvs	r0, [r1], #3900	; 0xf3c
    38a4:	85490000 	strbhi	r0, [r9, #-0]
    38a8:	000000c9 	andeq	r0, r0, r9, asr #1
    38ac:	09af0f40 	stmibeq	pc!, {r6, r8, r9, sl, fp}	; <UNPREDICTABLE>
    38b0:	8b490000 	blhi	12438b8 <unflatten_and_copy_device_tree+0x1242a44>
    38b4:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    38b8:	10f30f48 	rscsne	r0, r3, r8, asr #30
    38bc:	8e490000 	cdphi	0, 4, cr0, cr9, cr0, {0}
    38c0:	0000033c 	andeq	r0, r0, ip, lsr r3
    38c4:	34cd0f4c 	strbcc	r0, [sp], #3916	; 0xf4c
    38c8:	8f490000 	svchi	0x00490000
    38cc:	00001afa 	strdeq	r1, [r0], -sl
    38d0:	b8300054 	ldmdalt	r0!, {r2, r4, r6}
    38d4:	4000004e 	andmi	r0, r0, lr, asr #32
    38d8:	b8e14901 	stmialt	r1!, {r0, r8, fp, lr}^
    38dc:	0f000039 	svceq	0x00000039
    38e0:	000043d3 	ldrdeq	r4, [r0], -r3
    38e4:	3837e349 	ldmdacc	r7!, {r0, r3, r6, r8, r9, sp, lr, pc}
    38e8:	0f000000 	svceq	0x00000000
    38ec:	0000596a 	andeq	r5, r0, sl, ror #18
    38f0:	00d4e549 	sbcseq	lr, r4, r9, asr #10
    38f4:	14680000 	strbtne	r0, [r8], #-0
    38f8:	49006469 	stmdbmi	r0, {r0, r3, r5, r6, sl, sp, lr}
    38fc:	000057ef 	andeq	r5, r0, pc, ror #15
    3900:	5d0f6c00 	stcpl	12, cr6, [pc, #-0]	; 8 <.debug_info+0x8>
    3904:	4900002e 	stmdbmi	r0, {r1, r2, r3, r5}
    3908:	000057f7 	strdeq	r5, [r0], -r7
    390c:	6b147000 	blvs	51f914 <unflatten_and_copy_device_tree+0x51eaa0>
    3910:	f949006e 			; <UNDEFINED> instruction: 0xf949006e
    3914:	00003831 	andeq	r3, r0, r1, lsr r8
    3918:	0e8a0f74 	mcreq	15, 4, r0, cr10, cr4, {3}
    391c:	fa490000 	blx	1243924 <unflatten_and_copy_device_tree+0x1242ab0>
    3920:	00003778 	andeq	r3, r0, r8, ror r7
    3924:	1f520f78 	svcne	0x00520f78
    3928:	fb490000 	blx	1243932 <unflatten_and_copy_device_tree+0x1242abe>
    392c:	00003778 	andeq	r3, r0, r8, ror r7
    3930:	28af1b7c 	stmiacs	pc!, {r2, r3, r4, r5, r6, r8, r9, fp, ip}	; <UNPREDICTABLE>
    3934:	05490000 	strbeq	r0, [r9, #-0]
    3938:	00006901 	andeq	r6, r0, r1, lsl #18
    393c:	f01b8000 			; <UNDEFINED> instruction: 0xf01b8000
    3940:	49000054 	stmdbmi	r0, {r2, r4, r6}
    3944:	00690106 	rsbeq	r0, r9, r6, lsl #2
    3948:	1b840000 	blne	fe103950 <__crc_of_fdt_unflatten_tree+0x773c2393>
    394c:	0000404c 	andeq	r4, r0, ip, asr #32
    3950:	11010949 	tstne	r1, r9, asr #18
    3954:	8800003c 	stmdahi	r0, {r2, r3, r4, r5}
    3958:	003df81b 	eorseq	pc, sp, fp, lsl r8	; <UNPREDICTABLE>
    395c:	010b4900 	tsteq	fp, r0, lsl #18
    3960:	00003cce 	andeq	r3, r0, lr, asr #25
    3964:	39141bac 	ldmdbcc	r4, {r2, r3, r5, r7, r8, r9, fp, ip}
    3968:	11490000 	mrsne	r0, (UNDEF: 73)
    396c:	0002c701 	andeq	ip, r2, r1, lsl #14
    3970:	ec1bb000 	ldc	0, cr11, [fp], {-0}
    3974:	4900000d 	stmdbmi	r0, {r0, r2, r3}
    3978:	3c27011a 	stfccs	f0, [r7], #-104	; 0xffffff98
    397c:	1fb80000 	svcne	0x00b80000
    3980:	00006129 	andeq	r6, r0, r9, lsr #2
    3984:	c7012049 	strgt	r2, [r1, -r9, asr #32]
    3988:	00000002 	andeq	r0, r0, r2
    398c:	4cff1f01 	ldclmi	15, cr1, [pc], #4	; c <.debug_info+0xc>
    3990:	21490000 	mrscs	r0, (UNDEF: 73)
    3994:	00194001 	andseq	r4, r9, r1
    3998:	1f010800 	svcne	0x00010800
    399c:	00003718 	andeq	r3, r0, r8, lsl r7
    39a0:	eb012449 	bl	4cacc <unflatten_and_copy_device_tree+0x4bc58>
    39a4:	20000011 	andcs	r0, r0, r1, lsl r0
    39a8:	58f21f01 	ldmpl	r2!, {r0, r8, r9, sl, fp, ip}^
    39ac:	27490000 	strbcs	r0, [r9, -r0]
    39b0:	001afa01 	andseq	pc, sl, r1, lsl #20
    39b4:	00012c00 	andeq	r2, r1, r0, lsl #24
    39b8:	38d20408 	ldmcc	r2, {r3, sl}^
    39bc:	af1a0000 	svcge	0x001a0000
    39c0:	8c000015 	stchi	0, cr0, [r0], {21}
    39c4:	4401a849 	strmi	sl, [r1], #-2121	; 0xfffff7b7
    39c8:	1b00003b 	blne	3abc <.debug_info+0x3abc>
    39cc:	00001411 	andeq	r1, r0, r1, lsl r4
    39d0:	f801a949 			; <UNDEFINED> instruction: 0xf801a949
    39d4:	00000040 	andeq	r0, r0, r0, asr #32
    39d8:	00516d1b 	subseq	r6, r1, fp, lsl sp
    39dc:	01aa4900 			; <UNDEFINED> instruction: 0x01aa4900
    39e0:	0000410d 	andeq	r4, r0, sp, lsl #2
    39e4:	13081b04 	movwne	r1, #35588	; 0x8b04
    39e8:	ab490000 	blge	12439f0 <unflatten_and_copy_device_tree+0x1242b7c>
    39ec:	00411e01 	subeq	r1, r1, r1, lsl #28
    39f0:	f41b0800 			; <UNDEFINED> instruction: 0xf41b0800
    39f4:	49000043 	stmdbmi	r0, {r0, r1, r6}
    39f8:	411e01ac 	tstmi	lr, ip, lsr #3
    39fc:	1b0c0000 	blne	303a04 <unflatten_and_copy_device_tree+0x302b90>
    3a00:	00002675 	andeq	r2, r0, r5, ror r6
    3a04:	1e01ad49 	cdpne	13, 0, cr10, cr1, cr9, {2}
    3a08:	10000041 	andne	r0, r0, r1, asr #32
    3a0c:	003c7e1b 	eorseq	r7, ip, fp, lsl lr
    3a10:	01ae4900 			; <UNDEFINED> instruction: 0x01ae4900
    3a14:	0000411e 	andeq	r4, r0, lr, lsl r1
    3a18:	3aa61b14 	bcc	fe986c58 <__crc_of_fdt_unflatten_tree+0x77c4569b>
    3a1c:	af490000 	svcge	0x00490000
    3a20:	00411e01 	subeq	r1, r1, r1, lsl #28
    3a24:	a61b1800 	ldrge	r1, [fp], -r0, lsl #16
    3a28:	4900005c 	stmdbmi	r0, {r2, r3, r4, r6}
    3a2c:	413e01b1 	teqmi	lr, r1	; <illegal shifter operand>
    3a30:	1b1c0000 	blne	703a38 <unflatten_and_copy_device_tree+0x702bc4>
    3a34:	00002236 	andeq	r2, r0, r6, lsr r2
    3a38:	4f01b249 	svcmi	0x0001b249
    3a3c:	20000041 	andcs	r0, r0, r1, asr #32
    3a40:	004e091b 	subeq	r0, lr, fp, lsl r9
    3a44:	01b34900 			; <UNDEFINED> instruction: 0x01b34900
    3a48:	0000414f 	andeq	r4, r0, pc, asr #2
    3a4c:	036d1b24 	cmneq	sp, #36, 22	; 0x9000
    3a50:	b4490000 	strblt	r0, [r9], #-0
    3a54:	0003b501 	andeq	fp, r3, r1, lsl #10
    3a58:	4a1b2800 	bmi	6ca008 <unflatten_and_copy_device_tree+0x6c9194>
    3a5c:	49000055 	stmdbmi	r0, {r0, r2, r4, r6}
    3a60:	416f01b5 	strhmi	r0, [pc, #-21]	; 3a53 <.debug_info+0x3a53>
    3a64:	1b2c0000 	blne	b03a6c <unflatten_and_copy_device_tree+0xb02bf8>
    3a68:	00004b1d 	andeq	r4, r0, sp, lsl fp
    3a6c:	8501b649 	strhi	fp, [r1, #-1609]	; 0xfffff9b7
    3a70:	30000041 	andcc	r0, r0, r1, asr #32
    3a74:	0064eb1b 	rsbeq	lr, r4, fp, lsl fp
    3a78:	01b74900 			; <UNDEFINED> instruction: 0x01b74900
    3a7c:	00004185 	andeq	r4, r0, r5, lsl #3
    3a80:	0f9b1b34 	svceq	0x009b1b34
    3a84:	b8490000 	stmdalt	r9, {}^	; <UNPREDICTABLE>
    3a88:	00419601 	subeq	r9, r1, r1, lsl #12
    3a8c:	ee1b3800 	cdp	8, 1, cr3, cr11, cr0, {0}
    3a90:	49000037 	stmdbmi	r0, {r0, r1, r2, r4, r5}
    3a94:	419601b9 			; <UNDEFINED> instruction: 0x419601b9
    3a98:	1b3c0000 	blne	f03aa0 <unflatten_and_copy_device_tree+0xf02c2c>
    3a9c:	00005491 	muleq	r0, r1, r4
    3aa0:	1e01ba49 	vmlsne.f32	s22, s2, s18
    3aa4:	40000041 	andmi	r0, r0, r1, asr #32
    3aa8:	0063fd1b 	rsbeq	pc, r3, fp, lsl sp	; <UNPREDICTABLE>
    3aac:	01bc4900 			; <UNDEFINED> instruction: 0x01bc4900
    3ab0:	00000057 	andeq	r0, r0, r7, asr r0
    3ab4:	3a321b44 	bcc	c86d18 <unflatten_and_copy_device_tree+0xc85ea4>
    3ab8:	ca490000 	bgt	1243ac0 <unflatten_and_copy_device_tree+0x1242c4c>
    3abc:	0001fb01 	andeq	pc, r1, r1, lsl #22
    3ac0:	c41b4800 	ldrgt	r4, [fp], #-2048	; 0xfffff800
    3ac4:	49000057 	stmdbmi	r0, {r0, r1, r2, r4, r6}
    3ac8:	01fb01cb 	mvnseq	r0, fp, asr #3
    3acc:	1d490000 	stclne	0, cr0, [r9, #-0]
    3ad0:	49006469 	stmdbmi	r0, {r0, r3, r5, r6, sl, sp, lr}
    3ad4:	005701ce 	subseq	r0, r7, lr, asr #3
    3ad8:	1b4c0000 	blne	1303ae0 <unflatten_and_copy_device_tree+0x1302c6c>
    3adc:	0000059b 	muleq	r0, fp, r5
    3ae0:	f201cf49 	vmax.f32	q6, <illegal reg q0.5>, <illegal reg q4.5>
    3ae4:	50000000 	andpl	r0, r0, r0
    3ae8:	00322a1b 	eorseq	r2, r2, fp, lsl sl
    3aec:	01d24900 	bicseq	r4, r2, r0, lsl #18
    3af0:	000000f2 	strdeq	r0, [r0], -r2
    3af4:	3df81b54 	ldclcc	11, cr1, [r8, #336]!	; 0x150
    3af8:	d5490000 	strble	r0, [r9, #-0]
    3afc:	003cce01 	eorseq	ip, ip, r1, lsl #28
    3b00:	761b5800 	ldrvc	r5, [fp], -r0, lsl #16
    3b04:	49000049 	stmdbmi	r0, {r0, r3, r6}
    3b08:	351701d8 	ldrcc	r0, [r7, #-472]	; 0xfffffe28
    3b0c:	1b5c0000 	blne	1703b14 <unflatten_and_copy_device_tree+0x1702ca0>
    3b10:	00005fa7 	andeq	r5, r0, r7, lsr #31
    3b14:	c701de49 	strgt	sp, [r1, -r9, asr #28]
    3b18:	78000002 	stmdavc	r0, {r1}
    3b1c:	0012c41b 	andseq	ip, r2, fp, lsl r4
    3b20:	01e44900 	mvneq	r4, r0, lsl #18
    3b24:	00003ecc 	andeq	r3, r0, ip, asr #29
    3b28:	22d91b80 	sbcscs	r1, r9, #128, 22	; 0x20000
    3b2c:	e5490000 	strb	r0, [r9, #-0]
    3b30:	003ecc01 	eorseq	ip, lr, r1, lsl #24
    3b34:	da1b8400 	ble	6e1008 <unflatten_and_copy_device_tree+0x6e0194>
    3b38:	49000034 	stmdbmi	r0, {r2, r4, r5}
    3b3c:	006901ee 	rsbeq	r0, r9, lr, ror #3
    3b40:	00880000 	addeq	r0, r8, r0
    3b44:	39be0408 	ldmibcc	lr!, {r3, sl}
    3b48:	04080000 	streq	r0, [r8], #-0
    3b4c:	00003837 	andeq	r3, r0, r7, lsr r8
    3b50:	0050b610 	subseq	fp, r0, r0, lsl r6
    3b54:	9949c000 	stmdbls	r9, {lr, pc}^
    3b58:	00003c11 	andeq	r3, r0, r1, lsl ip
    3b5c:	002c800f 	eoreq	r8, ip, pc
    3b60:	bc9b4900 	ldclt	9, cr4, [fp], {0}
    3b64:	00000002 	andeq	r0, r0, r2
    3b68:	0044de0f 	subeq	sp, r4, pc, lsl #28
    3b6c:	0ba14900 	bleq	fe855f74 <__crc_of_fdt_unflatten_tree+0x77b149b7>
    3b70:	04000003 	streq	r0, [r0], #-3
    3b74:	0000b50f 	andeq	fp, r0, pc, lsl #10
    3b78:	c7aa4900 	strgt	r4, [sl, r0, lsl #18]!
    3b7c:	0c000002 	stceq	0, cr0, [r0], {2}
    3b80:	000ec10f 	andeq	ip, lr, pc, lsl #2
    3b84:	c7ab4900 	strgt	r4, [fp, r0, lsl #18]!
    3b88:	14000002 	strne	r0, [r0], #-2
    3b8c:	002a0e0f 	eoreq	r0, sl, pc, lsl #28
    3b90:	c7b14900 	ldrgt	r4, [r1, r0, lsl #18]!
    3b94:	1c000002 	stcne	0, cr0, [r0], {2}
    3b98:	00459d0f 	subeq	r9, r5, pc, lsl #26
    3b9c:	b8b44900 	ldmlt	r4!, {r8, fp, lr}
    3ba0:	24000039 	strcs	r0, [r0], #-57	; 0xffffffc7
    3ba4:	00404c0f 	subeq	r4, r0, pc, lsl #24
    3ba8:	11bb4900 			; <UNDEFINED> instruction: 0x11bb4900
    3bac:	2800003c 	stmdacs	r0, {r2, r3, r4, r5}
    3bb0:	003b1d0f 	eorseq	r1, fp, pc, lsl #26
    3bb4:	c7c14900 	strbgt	r4, [r1, r0, lsl #18]
    3bb8:	4c000002 	stcmi	0, cr0, [r0], {2}
    3bbc:	00098c0f 	andeq	r8, r9, pc, lsl #24
    3bc0:	c7c24900 	strbgt	r4, [r2, r0, lsl #18]
    3bc4:	54000002 	strpl	r0, [r0], #-2
    3bc8:	0023570f 	eoreq	r5, r3, pc, lsl #14
    3bcc:	b8cb4900 	stmialt	fp, {r8, fp, lr}^
    3bd0:	5c000039 	stcpl	0, cr0, [r0], {57}	; 0x39
    3bd4:	005d9d0f 	subseq	r9, sp, pc, lsl #26
    3bd8:	21cc4900 	biccs	r4, ip, r0, lsl #18
    3bdc:	6000003c 	andvs	r0, r0, ip, lsr r0
    3be0:	0053690f 	subseq	r6, r3, pc, lsl #18
    3be4:	27d54900 	ldrbcs	r4, [r5, r0, lsl #18]
    3be8:	6400003c 	strvs	r0, [r0], #-60	; 0xffffffc4
    3bec:	000fbf0f 	andeq	fp, pc, pc, lsl #30
    3bf0:	c7d84900 	ldrbgt	r4, [r8, r0, lsl #18]
    3bf4:	ac000002 	stcge	0, cr0, [r0], {2}
    3bf8:	0061500f 	rsbeq	r5, r1, pc
    3bfc:	fbdb4900 	blx	ff6d6006 <__crc_of_fdt_unflatten_tree+0x78994a49>
    3c00:	b4000001 	strlt	r0, [r0], #-1
    3c04:	0010f30f 	andseq	pc, r0, pc, lsl #6
    3c08:	3cde4900 	ldclcc	9, cr4, [lr], {0}
    3c0c:	b8000003 	stmdalt	r0, {r0, r1}
    3c10:	3b4a0600 	blcc	1285418 <unflatten_and_copy_device_tree+0x12845a4>
    3c14:	3c210000 	stccc	0, cr0, [r1], #-0
    3c18:	eb070000 	bl	1c3c20 <unflatten_and_copy_device_tree+0x1c2dac>
    3c1c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    3c20:	50040800 	andpl	r0, r4, r0, lsl #16
    3c24:	0600003b 			; <UNDEFINED> instruction: 0x0600003b
    3c28:	000002c7 	andeq	r0, r0, r7, asr #5
    3c2c:	00003c37 	andeq	r3, r0, r7, lsr ip
    3c30:	0000eb07 	andeq	lr, r0, r7, lsl #22
    3c34:	1c000800 	stcne	8, cr0, [r0], {-0}
    3c38:	0000577a 	andeq	r5, r0, sl, ror r7
    3c3c:	2f4911c0 	svccs	0x004911c0
    3c40:	003cce01 	eorseq	ip, ip, r1, lsl #28
    3c44:	5d8c1b00 	vstrpl	d1, [ip]
    3c48:	30490000 	subcc	r0, r9, r0
    3c4c:	003d2801 	eorseq	r2, sp, r1, lsl #16
    3c50:	171b0000 	ldrne	r0, [fp, -r0]
    3c54:	4900004f 	stmdbmi	r0, {r0, r1, r2, r3, r6}
    3c58:	00690133 	rsbeq	r0, r9, r3, lsr r1
    3c5c:	1b040000 	blne	103c64 <unflatten_and_copy_device_tree+0x102df0>
    3c60:	0000372b 	andeq	r3, r0, fp, lsr #14
    3c64:	57013649 	strpl	r3, [r1, -r9, asr #12]
    3c68:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    3c6c:	002f771b 	eoreq	r7, pc, fp, lsl r7	; <UNPREDICTABLE>
    3c70:	01394900 	teqeq	r9, r0, lsl #18
    3c74:	000038d2 	ldrdeq	r3, [r0], -r2
    3c78:	46841f10 	pkhbtmi	r1, r4, r0, lsl #30
    3c7c:	3c490000 	marcc	acc0, r0, r9
    3c80:	0002bc01 	andeq	fp, r2, r1, lsl #24
    3c84:	1f015000 	svcne	0x00015000
    3c88:	00001918 	andeq	r1, r0, r8, lsl r9
    3c8c:	c7013f49 	strgt	r3, [r1, -r9, asr #30]
    3c90:	54000002 	strpl	r0, [r0], #-2
    3c94:	596a1f01 	stmdbpl	sl!, {r0, r8, r9, sl, fp, ip}^
    3c98:	42490000 	submi	r0, r9, #0
    3c9c:	00006901 	andeq	r6, r0, r1, lsl #18
    3ca0:	1f015c00 	svcne	0x00015c00
    3ca4:	000000a1 	andeq	r0, r0, r1, lsr #1
    3ca8:	17014549 	strne	r4, [r1, -r9, asr #10]
    3cac:	60000035 	andvs	r0, r0, r5, lsr r0
    3cb0:	03c91f01 	biceq	r1, r9, #1, 30
    3cb4:	48490000 	stmdami	r9, {}^	; <UNPREDICTABLE>
    3cb8:	003d2e01 	eorseq	r2, sp, r1, lsl #28
    3cbc:	1f017c00 	svcne	0x00017c00
    3cc0:	0000059b 	muleq	r0, fp, r5
    3cc4:	3f014b49 	svccc	0x00014b49
    3cc8:	7c00003d 	stcvc	0, cr0, [r0], {61}	; 0x3d
    3ccc:	04080011 	streq	r0, [r8], #-17	; 0xffffffef
    3cd0:	00003c37 	andeq	r3, r0, r7, lsr ip
    3cd4:	0046d310 	subeq	sp, r6, r0, lsl r3
    3cd8:	9d4a4000 	stclls	0, cr4, [sl, #-0]
    3cdc:	00003d28 	andeq	r3, r0, r8, lsr #26
    3ce0:	006e6b14 	rsbeq	r6, lr, r4, lsl fp
    3ce4:	38319f4a 	ldmdacc	r1!, {r1, r3, r6, r8, r9, sl, fp, ip, pc}
    3ce8:	0f000000 	svceq	0x00000000
    3cec:	0000596a 	andeq	r5, r0, sl, ror #18
    3cf0:	0069a04a 	rsbeq	sl, r9, sl, asr #32
    3cf4:	0f040000 	svceq	0x00040000
    3cf8:	00000102 	andeq	r0, r0, r2, lsl #2
    3cfc:	35ada34a 	strcc	sl, [sp, #842]!	; 0x34a
    3d00:	0f080000 	svceq	0x00080000
    3d04:	00005b51 	andeq	r5, r0, r1, asr fp
    3d08:	5492a44a 	ldrpl	sl, [r2], #1098	; 0x44a
    3d0c:	0f280000 	svceq	0x00280000
    3d10:	000061ba 			; <UNDEFINED> instruction: 0x000061ba
    3d14:	02c7a74a 	sbceq	sl, r7, #19398656	; 0x1280000
    3d18:	0f2c0000 	svceq	0x002c0000
    3d1c:	00002385 	andeq	r2, r0, r5, lsl #7
    3d20:	11eba94a 	mvnne	sl, sl, asr #18
    3d24:	00340000 	eorseq	r0, r4, r0
    3d28:	3cd40408 	cfldrdcc	mvd0, [r4], {8}
    3d2c:	f8060000 			; <UNDEFINED> instruction: 0xf8060000
    3d30:	3f000000 	svccc	0x00000000
    3d34:	3300003d 	movwcc	r0, #61	; 0x3d
    3d38:	000000eb 	andeq	r0, r0, fp, ror #1
    3d3c:	06000fff 			; <UNDEFINED> instruction: 0x06000fff
    3d40:	000000f8 	strdeq	r0, [r0], -r8
    3d44:	00003d4f 	andeq	r3, r0, pc, asr #26
    3d48:	0000eb07 	andeq	lr, r0, r7, lsl #22
    3d4c:	1a003f00 	bne	13954 <unflatten_and_copy_device_tree+0x12ae0>
    3d50:	00002f40 	andeq	r2, r0, r0, asr #30
    3d54:	01554984 	cmpeq	r5, r4, lsl #19
    3d58:	00003e39 	andeq	r3, r0, r9, lsr lr
    3d5c:	00059b1b 	andeq	r9, r5, fp, lsl fp
    3d60:	015b4900 	cmpeq	fp, r0, lsl #18
    3d64:	00003d3f 	andeq	r3, r0, pc, lsr sp
    3d68:	016d1b00 	cmneq	sp, r0, lsl #22
    3d6c:	5c490000 	marpl	acc0, r0, r9
    3d70:	0000d401 	andeq	sp, r0, r1, lsl #8
    3d74:	c01b4000 	andsgt	r4, fp, r0
    3d78:	49000020 	stmdbmi	r0, {r5}
    3d7c:	022e0162 	eoreq	r0, lr, #-2147483624	; 0x80000018
    3d80:	1b440000 	blne	1103d88 <unflatten_and_copy_device_tree+0x1102f14>
    3d84:	0000596a 	andeq	r5, r0, sl, ror #18
    3d88:	69016549 	stmdbvs	r1, {r0, r3, r6, r8, sl, sp, lr}
    3d8c:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    3d90:	001dd71b 	andseq	sp, sp, fp, lsl r7
    3d94:	016d4900 	cmneq	sp, r0, lsl #18
    3d98:	00000069 	andeq	r0, r0, r9, rrx
    3d9c:	73731d4c 	cmnvc	r3, #76, 26	; 0x1300
    3da0:	01734900 	cmneq	r3, r0, lsl #18
    3da4:	00003b44 	andeq	r3, r0, r4, asr #22
    3da8:	433d1b50 	teqmi	sp, #80, 22	; 0x14000
    3dac:	74490000 	strbvc	r0, [r9], #-0
    3db0:	0002c701 	andeq	ip, r2, r1, lsl #14
    3db4:	761b5400 	ldrvc	r5, [fp], -r0, lsl #8
    3db8:	49000027 	stmdbmi	r0, {r0, r1, r2, r5}
    3dbc:	3eb20175 	mrccc	1, 5, r0, cr2, cr5, {3}
    3dc0:	1b5c0000 	blne	1703dc8 <unflatten_and_copy_device_tree+0x1702f54>
    3dc4:	000007f7 	strdeq	r0, [r0], -r7
    3dc8:	d2017b49 	andle	r7, r1, #74752	; 0x12400
    3dcc:	6000003e 	andvs	r0, r0, lr, lsr r0
    3dd0:	00637c1b 	rsbeq	r7, r3, fp, lsl ip
    3dd4:	017f4900 	cmneq	pc, r0, lsl #18
    3dd8:	00003eec 	andeq	r3, r0, ip, ror #29
    3ddc:	1e971b64 	vfnmane.f64	d1, d7, d20
    3de0:	82490000 	subhi	r0, r9, #0
    3de4:	003fa801 	eorseq	sl, pc, r1, lsl #16
    3de8:	511b6800 	tstpl	fp, r0, lsl #16
    3dec:	4900003e 	stmdbmi	r0, {r1, r2, r3, r4, r5}
    3df0:	3fc20185 	svccc	0x00c20185
    3df4:	1b6c0000 	blne	1b03dfc <unflatten_and_copy_device_tree+0x1b02f88>
    3df8:	00000d33 	andeq	r0, r0, r3, lsr sp
    3dfc:	e1018649 	tst	r1, r9, asr #12
    3e00:	7000003f 	andvc	r0, r0, pc, lsr r0
    3e04:	0059981b 	subseq	r9, r9, fp, lsl r8
    3e08:	01874900 	orreq	r4, r7, r0, lsl #18
    3e0c:	00003ff7 	strdeq	r3, [r0], -r7
    3e10:	1b481b74 	blne	1206dd8 <unflatten_and_copy_device_tree+0x1205f64>
    3e14:	8e490000 	cdphi	0, 4, cr0, cr9, cr0, {0}
    3e18:	00401601 	subeq	r1, r0, r1, lsl #12
    3e1c:	b91b7800 	ldmdblt	fp, {fp, ip, sp, lr}
    3e20:	49000010 	stmdbmi	r0, {r4}
    3e24:	40350193 	mlasmi	r5, r3, r1, r0
    3e28:	1b7c0000 	blne	1f03e30 <unflatten_and_copy_device_tree+0x1f02fbc>
    3e2c:	00001d13 	andeq	r1, r0, r3, lsl sp
    3e30:	e3019c49 	movw	r9, #7241	; 0x1c49
    3e34:	80000040 	andhi	r0, r0, r0, asr #32
    3e38:	4e3a1000 	cdpmi	0, 3, cr1, cr10, cr0, {0}
    3e3c:	4a240000 	bmi	903e44 <unflatten_and_copy_device_tree+0x902fd0>
    3e40:	003eb2bd 	ldrhteq	fp, [lr], -sp
    3e44:	1e970f00 	cdpne	15, 9, cr0, cr7, cr0, {0}
    3e48:	c94a0000 	stmdbgt	sl, {}^	; <UNPREDICTABLE>
    3e4c:	00003fa8 	andeq	r3, r0, r8, lsr #31
    3e50:	3e510f00 	cdpcc	15, 5, cr0, cr1, cr0, {0}
    3e54:	cb4a0000 	blgt	1283e5c <unflatten_and_copy_device_tree+0x1282fe8>
    3e58:	00003fc2 	andeq	r3, r0, r2, asr #31
    3e5c:	0d330f04 	ldceq	15, cr0, [r3, #-16]!
    3e60:	cc4a0000 	margt	acc0, r0, sl
    3e64:	00003fe1 	andeq	r3, r0, r1, ror #31
    3e68:	59980f08 	ldmibpl	r8, {r3, r8, r9, sl, fp}
    3e6c:	cd4a0000 	stclgt	0, cr0, [sl, #-0]
    3e70:	00003ff7 	strdeq	r3, [r0], -r7
    3e74:	02f20f0c 	rscseq	r0, r2, #12, 30	; 0x30
    3e78:	cf4a0000 	svcgt	0x004a0000
    3e7c:	000040e3 	andeq	r4, r0, r3, ror #1
    3e80:	2ed60f10 	mrccs	15, 6, r0, cr6, cr0, {0}
    3e84:	d94a0000 	stmdble	sl, {}^	; <UNPREDICTABLE>
    3e88:	0000022e 	andeq	r0, r0, lr, lsr #4
    3e8c:	1b060f14 	blne	183c58 <unflatten_and_copy_device_tree+0x182de4>
    3e90:	e04a0000 	sub	r0, sl, r0
    3e94:	000001fb 	strdeq	r0, [r0], -fp
    3e98:	1d130f18 	ldcne	15, cr0, [r3, #-96]	; 0xffffffa0
    3e9c:	e14a0000 	mrs	r0, (UNDEF: 74)
    3ea0:	000040e3 	andeq	r4, r0, r3, ror #1
    3ea4:	53e30f1c 	mvnpl	r0, #28, 30	; 0x70
    3ea8:	e44a0000 	strb	r0, [sl], #-0
    3eac:	000054ac 	andeq	r5, r0, ip, lsr #9
    3eb0:	04080020 	streq	r0, [r8], #-32	; 0xffffffe0
    3eb4:	00003e39 	andeq	r3, r0, r9, lsr lr
    3eb8:	0000c915 	andeq	ip, r0, r5, lsl r9
    3ebc:	003ecc00 	eorseq	ip, lr, r0, lsl #24
    3ec0:	3b4a0d00 	blcc	12872c8 <unflatten_and_copy_device_tree+0x1286454>
    3ec4:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    3ec8:	0000003e 	andeq	r0, r0, lr, lsr r0
    3ecc:	3d4f0408 	cfstrdcc	mvd0, [pc, #-32]	; 3eb4 <.debug_info+0x3eb4>
    3ed0:	04080000 	streq	r0, [r8], #-0
    3ed4:	00003eb8 			; <UNDEFINED> instruction: 0x00003eb8
    3ed8:	0000be15 	andeq	fp, r0, r5, lsl lr
    3edc:	003eec00 	eorseq	lr, lr, r0, lsl #24
    3ee0:	3b4a0d00 	blcc	12872e8 <unflatten_and_copy_device_tree+0x1286474>
    3ee4:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    3ee8:	0000003e 	andeq	r0, r0, lr, lsr r0
    3eec:	3ed80408 	cdpcc	4, 13, cr0, cr8, cr8, {0}
    3ef0:	57150000 	ldrpl	r0, [r5, -r0]
    3ef4:	06000000 	streq	r0, [r0], -r0
    3ef8:	0d00003f 	stceq	0, cr0, [r0, #-252]	; 0xffffff04
    3efc:	00003f06 	andeq	r3, r0, r6, lsl #30
    3f00:	0003780d 	andeq	r7, r3, sp, lsl #16
    3f04:	04080000 	streq	r0, [r8], #-0
    3f08:	00003f0c 	andeq	r3, r0, ip, lsl #30
    3f0c:	002f8e10 	eoreq	r8, pc, r0, lsl lr	; <UNPREDICTABLE>
    3f10:	124b5800 	subne	r5, fp, #0, 16
    3f14:	00003fa8 	andeq	r3, r0, r8, lsr #31
    3f18:	66756214 			; <UNDEFINED> instruction: 0x66756214
    3f1c:	b3134b00 	tstlt	r3, #0, 22
    3f20:	00000001 	andeq	r0, r0, r1
    3f24:	000c6b0f 	andeq	r6, ip, pc, lsl #22
    3f28:	2e144b00 	vnmlscs.f64	d4, d4, d0
    3f2c:	04000002 	streq	r0, [r0], #-2
    3f30:	0041180f 	subeq	r1, r1, pc, lsl #16
    3f34:	2e154b00 	vnmlscs.f64	d4, d5, d0
    3f38:	08000002 	stmdaeq	r0, {r1}
    3f3c:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    3f40:	2e164b00 	vnmlscs.f64	d4, d6, d0
    3f44:	0c000002 	stceq	0, cr0, [r0], {2}
    3f48:	0062ef0f 	rsbeq	lr, r2, pc, lsl #30
    3f4c:	2e174b00 	vnmlscs.f64	d4, d7, d0
    3f50:	10000002 	andne	r0, r0, r2
    3f54:	0027ca0f 	eoreq	ip, r7, pc, lsl #20
    3f58:	23184b00 	tstcs	r8, #0, 22
    3f5c:	18000002 	stmdane	r0, {r1}
    3f60:	004a5b0f 	subeq	r5, sl, pc, lsl #22
    3f64:	23194b00 	tstcs	r9, #0, 22
    3f68:	20000002 	andcs	r0, r0, r2
    3f6c:	0002490f 	andeq	r4, r2, pc, lsl #18
    3f70:	c91a4b00 	ldmdbgt	sl, {r8, r9, fp, lr}
    3f74:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    3f78:	00155a0f 	andseq	r5, r5, pc, lsl #20
    3f7c:	401b4b00 	andsmi	r4, fp, r0, lsl #22
    3f80:	30000019 	andcc	r0, r0, r9, lsl r0
    3f84:	00706f14 	rsbseq	r6, r0, r4, lsl pc
    3f88:	89f71c4b 	ldmibhi	r7!, {r0, r1, r3, r6, sl, fp, ip}^
    3f8c:	0f480000 	svceq	0x00480000
    3f90:	00003032 	andeq	r3, r0, r2, lsr r0
    3f94:	00571d4b 	subseq	r1, r7, fp, asr #26
    3f98:	0f4c0000 	svceq	0x004c0000
    3f9c:	0000016d 	andeq	r0, r0, sp, ror #2
    3fa0:	0378214b 	cmneq	r8, #-1073741806	; 0xc0000012
    3fa4:	00500000 	subseq	r0, r0, r0
    3fa8:	3ef20408 	cdpcc	4, 15, cr0, cr2, cr8, {0}
    3fac:	78150000 	ldmdavc	r5, {}	; <UNPREDICTABLE>
    3fb0:	c2000003 	andgt	r0, r0, #3
    3fb4:	0d00003f 	stceq	0, cr0, [r0, #-252]	; 0xffffff04
    3fb8:	00003f06 	andeq	r3, r0, r6, lsl #30
    3fbc:	001ac10d 	andseq	ip, sl, sp, lsl #2
    3fc0:	04080000 	streq	r0, [r8], #-0
    3fc4:	00003fae 	andeq	r3, r0, lr, lsr #31
    3fc8:	00037815 	andeq	r7, r3, r5, lsl r8
    3fcc:	003fe100 	eorseq	lr, pc, r0, lsl #2
    3fd0:	3f060d00 	svccc	0x00060d00
    3fd4:	780d0000 	stmdavc	sp, {}	; <UNPREDICTABLE>
    3fd8:	0d000003 	stceq	0, cr0, [r0, #-12]
    3fdc:	00001ac1 	andeq	r1, r0, r1, asr #21
    3fe0:	c8040800 	stmdagt	r4, {fp}
    3fe4:	0c00003f 	stceq	0, cr0, [r0], {63}	; 0x3f
    3fe8:	00003ff7 	strdeq	r3, [r0], -r7
    3fec:	003f060d 	eorseq	r0, pc, sp, lsl #12
    3ff0:	03780d00 	cmneq	r8, #0, 26
    3ff4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    3ff8:	003fe704 	eorseq	lr, pc, r4, lsl #14
    3ffc:	00571500 	subseq	r1, r7, r0, lsl #10
    4000:	40160000 	andsmi	r0, r6, r0
    4004:	4a0d0000 	bmi	34400c <unflatten_and_copy_device_tree+0x343198>
    4008:	0d00003b 	stceq	0, cr0, [r0, #-236]	; 0xffffff14
    400c:	00003ecc 	andeq	r3, r0, ip, asr #29
    4010:	0000c90d 	andeq	ip, r0, sp, lsl #18
    4014:	04080000 	streq	r0, [r8], #-0
    4018:	00003ffd 	strdeq	r3, [r0], -sp
    401c:	00005715 	andeq	r5, r0, r5, lsl r7
    4020:	00403500 	subeq	r3, r0, r0, lsl #10
    4024:	3b4a0d00 	blcc	128742c <unflatten_and_copy_device_tree+0x12865b8>
    4028:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    402c:	0d00003e 	stceq	0, cr0, [r0, #-248]	; 0xffffff08
    4030:	000000be 	strheq	r0, [r0], -lr
    4034:	1c040800 	stcne	8, cr0, [r4], {-0}
    4038:	15000040 	strne	r0, [r0, #-64]	; 0xffffffc0
    403c:	00000239 	andeq	r0, r0, r9, lsr r2
    4040:	00004059 	andeq	r4, r0, r9, asr r0
    4044:	0040590d 	subeq	r5, r0, sp, lsl #18
    4048:	01b30d00 			; <UNDEFINED> instruction: 0x01b30d00
    404c:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    4050:	0d000002 	stceq	0, cr0, [r0, #-8]
    4054:	00000223 	andeq	r0, r0, r3, lsr #4
    4058:	5f040800 	svcpl	0x00040800
    405c:	10000040 	andne	r0, r0, r0, asr #32
    4060:	00001db0 			; <UNDEFINED> instruction: 0x00001db0
    4064:	e3ac4a40 			; <UNDEFINED> instruction: 0xe3ac4a40
    4068:	14000040 	strne	r0, [r0], #-64	; 0xffffffc0
    406c:	4a006e6b 	bmi	1fa20 <unflatten_and_copy_device_tree+0x1ebac>
    4070:	003831ae 	eorseq	r3, r8, lr, lsr #3
    4074:	d40f0000 	strle	r0, [pc], #-0	; 8 <.debug_info+0x8>
    4078:	4a000045 	bmi	4194 <.debug_info+0x4194>
    407c:	0023ccaf 	eoreq	ip, r3, pc, lsr #25
    4080:	790f0400 	stmdbvc	pc, {sl}	; <UNPREDICTABLE>
    4084:	4a000050 	bmi	41cc <.debug_info+0x41cc>
    4088:	000378b0 			; <UNDEFINED> instruction: 0x000378b0
    408c:	530f0800 	movwpl	r0, #63488	; 0xf800
    4090:	4a000054 	bmi	41e8 <.debug_info+0x41e8>
    4094:	001940b3 	ldrheq	r4, [r9], -r3
    4098:	750f0c00 	strvc	r0, [pc, #-3072]	; fffff408 <__crc_of_fdt_unflatten_tree+0x792bde4b>
    409c:	4a00000f 	bmi	40e0 <.debug_info+0x40e0>
    40a0:	000057b4 			; <UNDEFINED> instruction: 0x000057b4
    40a4:	8e0f2400 	cfcpyshi	mvf2, mvf15
    40a8:	4a000005 	bmi	40c4 <.debug_info+0x40c4>
    40ac:	0002c7b5 			; <UNDEFINED> instruction: 0x0002c7b5
    40b0:	ca0f2800 	bgt	3ca008 <unflatten_and_copy_device_tree+0x3c9194>
    40b4:	4a000059 	bmi	4220 <.debug_info+0x4220>
    40b8:	0001b3b6 			; <UNDEFINED> instruction: 0x0001b3b6
    40bc:	d60f3000 	strle	r3, [pc], -r0
    40c0:	4a00002e 	bmi	4180 <.debug_info+0x4180>
    40c4:	00022eb8 			; <UNDEFINED> instruction: 0x00022eb8
    40c8:	d50f3400 	strle	r3, [pc, #-1024]	; fffffc08 <__crc_of_fdt_unflatten_tree+0x792be64b>
    40cc:	4a00001b 	bmi	4140 <.debug_info+0x4140>
    40d0:	0001fbb9 			; <UNDEFINED> instruction: 0x0001fbb9
    40d4:	b10f3800 	tstlt	pc, r0, lsl #16
    40d8:	4a00005c 	bmi	4250 <.debug_info+0x4250>
    40dc:	0024a2ba 	strhteq	sl, [r4], -sl
    40e0:	08003c00 	stmdaeq	r0, {sl, fp, ip, sp}
    40e4:	00403b04 	subeq	r3, r0, r4, lsl #22
    40e8:	3b4a1500 	blcc	12894f0 <unflatten_and_copy_device_tree+0x128867c>
    40ec:	40f80000 	rscsmi	r0, r8, r0
    40f0:	4a0d0000 	bmi	3440f8 <unflatten_and_copy_device_tree+0x343284>
    40f4:	0000003b 	andeq	r0, r0, fp, lsr r0
    40f8:	40e90408 	rscmi	r0, r9, r8, lsl #8
    40fc:	57150000 	ldrpl	r0, [r5, -r0]
    4100:	0d000000 	stceq	0, cr0, [r0, #-0]
    4104:	0d000041 	stceq	0, cr0, [r0, #-260]	; 0xfffffefc
    4108:	00003b4a 	andeq	r3, r0, sl, asr #22
    410c:	fe040800 	cdp2	8, 0, cr0, cr4, cr0, {0}
    4110:	0c000040 	stceq	0, cr0, [r0], {64}	; 0x40
    4114:	0000411e 	andeq	r4, r0, lr, lsl r1
    4118:	003b4a0d 	eorseq	r4, fp, sp, lsl #20
    411c:	04080000 	streq	r0, [r8], #-0
    4120:	00004113 	andeq	r4, r0, r3, lsl r1
    4124:	00005715 	andeq	r5, r0, r5, lsl r7
    4128:	00413300 	subeq	r3, r1, r0, lsl #6
    412c:	41330d00 	teqmi	r3, r0, lsl #26
    4130:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4134:	00413904 	subeq	r3, r1, r4, lsl #18
    4138:	3b431600 	blcc	10c5808 <unflatten_and_copy_device_tree+0x10c4994>
    413c:	04080000 	streq	r0, [r8], #-0
    4140:	00004124 	andeq	r4, r0, r4, lsr #2
    4144:	00414f0c 	subeq	r4, r1, ip, lsl #30
    4148:	41330d00 	teqmi	r3, r0, lsl #26
    414c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4150:	00414404 	subeq	r4, r1, r4, lsl #8
    4154:	00571500 	subseq	r1, r7, r0, lsl #10
    4158:	41690000 	cmnmi	r9, r0
    415c:	270d0000 	strcs	r0, [sp, -r0]
    4160:	0d000010 	stceq	0, cr0, [r0, #-64]	; 0xffffffc0
    4164:	00004169 	andeq	r4, r0, r9, ror #2
    4168:	78040800 	stmdavc	r4, {fp}
    416c:	08000003 	stmdaeq	r0, {r0, r1}
    4170:	00415504 	subeq	r5, r1, r4, lsl #10
    4174:	41850c00 	orrmi	r0, r5, r0, lsl #24
    4178:	270d0000 	strcs	r0, [sp, -r0]
    417c:	0d000010 	stceq	0, cr0, [r0, #-64]	; 0xffffffc0
    4180:	00000378 	andeq	r0, r0, r8, ror r3
    4184:	75040800 	strvc	r0, [r4, #-2048]	; 0xfffff800
    4188:	0c000041 	stceq	0, cr0, [r0], {65}	; 0x41
    418c:	00004196 	muleq	r0, r6, r1
    4190:	0010270d 	andseq	r2, r0, sp, lsl #14
    4194:	04080000 	streq	r0, [r8], #-0
    4198:	0000418b 	andeq	r4, r0, fp, lsl #3
    419c:	001a621c 	andseq	r6, sl, ip, lsl r2
    41a0:	12051400 	andne	r1, r5, #0, 8
    41a4:	41e10204 	mvnmi	r0, r4, lsl #4
    41a8:	a11b0000 	tstge	fp, r0
    41ac:	1200003b 	andne	r0, r0, #59	; 0x3b
    41b0:	02bc0205 	adcseq	r0, ip, #1342177280	; 0x50000000
    41b4:	1b000000 	blne	41bc <.debug_info+0x41bc>
    41b8:	00003e9e 	muleq	r0, lr, lr
    41bc:	e1020612 	tst	r2, r2, lsl r6
    41c0:	04000041 	streq	r0, [r0], #-65	; 0xffffffbf
    41c4:	00544b1f 	subseq	r4, r4, pc, lsl fp
    41c8:	02071200 	andeq	r1, r7, #0, 4
    41cc:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    41d0:	871f0504 	ldrhi	r0, [pc, -r4, lsl #10]
    41d4:	1200003e 	andne	r0, r0, #62	; 0x3e
    41d8:	11eb0208 	mvnne	r0, r8, lsl #4
    41dc:	05080000 	streq	r0, [r8, #-0]
    41e0:	2caa0600 	stccs	6, cr0, [sl]
    41e4:	41f10000 	mvnsmi	r0, r0
    41e8:	eb070000 	bl	1c41f0 <unflatten_and_copy_device_tree+0x1c337c>
    41ec:	3f000000 	svccc	0x00000000
    41f0:	1c2d1a00 	stcne	10, cr1, [sp], #-0
    41f4:	121c0000 	andsne	r0, ip, #0
    41f8:	425a020b 	subsmi	r0, sl, #-1342177280	; 0xb0000000
    41fc:	0b1b0000 	bleq	6c0008 <unflatten_and_copy_device_tree+0x6bf194>
    4200:	1200002d 	andne	r0, r0, #45	; 0x2d
    4204:	0057020c 	subseq	r0, r7, ip, lsl #4
    4208:	1b000000 	blne	4210 <.debug_info+0x4210>
    420c:	00003491 	muleq	r0, r1, r4
    4210:	33020d12 	movwcc	r0, #11538	; 0x2d12
    4214:	04000001 	streq	r0, [r0], #-1
    4218:	00618c1b 	rsbeq	r8, r1, fp, lsl ip
    421c:	020e1200 	andeq	r1, lr, #0, 4
    4220:	000000d4 	ldrdeq	r0, [r0], -r4
    4224:	36781b08 	ldrbtcc	r1, [r8], -r8, lsl #22
    4228:	0f120000 	svceq	0x00120000
    422c:	00282202 	eoreq	r2, r8, r2, lsl #4
    4230:	e21b0c00 	ands	r0, fp, #0, 24
    4234:	12000051 	andne	r0, r0, #81	; 0x51
    4238:	2822020f 	stmdacs	r2!, {r0, r1, r2, r3, r9}
    423c:	1b100000 	blne	404244 <unflatten_and_copy_device_tree+0x4033d0>
    4240:	00002fbf 			; <UNDEFINED> instruction: 0x00002fbf
    4244:	d4021012 	strle	r1, [r2], #-18	; 0xffffffee
    4248:	14000000 	strne	r0, [r0], #-0
    424c:	0024d31b 	eoreq	sp, r4, fp, lsl r3
    4250:	02101200 	andseq	r1, r0, #0, 4
    4254:	000000d4 	ldrdeq	r0, [r0], -r4
    4258:	ed1a0018 	ldc	0, cr0, [sl, #-96]	; 0xffffffa0
    425c:	1000000b 	andne	r0, r0, fp
    4260:	9c021312 	stcls	3, cr1, [r2], {18}
    4264:	1b000042 	blne	4374 <.debug_info+0x4374>
    4268:	00004f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
    426c:	22021412 	andcs	r1, r2, #301989888	; 0x12000000
    4270:	00000028 	andeq	r0, r0, r8, lsr #32
    4274:	0032101b 	eorseq	r1, r2, fp, lsl r0
    4278:	02151200 	andseq	r1, r5, #0, 4
    427c:	00002822 	andeq	r2, r0, r2, lsr #16
    4280:	28ee1b04 	stmiacs	lr!, {r2, r8, r9, fp, ip}^
    4284:	16120000 	ldrne	r0, [r2], -r0
    4288:	0000b302 	andeq	fp, r0, r2, lsl #6
    428c:	e31b0800 	tst	fp, #0, 16
    4290:	12000021 	andne	r0, r0, #33	; 0x21
    4294:	00b30217 	adcseq	r0, r3, r7, lsl r2
    4298:	000c0000 	andeq	r0, ip, r0
    429c:	0039ca1a 	eorseq	ip, r9, sl, lsl sl
    42a0:	23120c00 	tstcs	r2, #0, 24
    42a4:	0042d102 	subeq	sp, r2, r2, lsl #2
    42a8:	23be1b00 			; <UNDEFINED> instruction: 0x23be1b00
    42ac:	25120000 	ldrcs	r0, [r2, #-0]
    42b0:	00282202 	eoreq	r2, r8, r2, lsl #4
    42b4:	801b0000 	andshi	r0, fp, r0
    42b8:	12000005 	andne	r0, r0, #5
    42bc:	28220226 	stmdacs	r2!, {r1, r2, r5, r9}
    42c0:	1b040000 	blne	1042c8 <unflatten_and_copy_device_tree+0x103454>
    42c4:	0000155a 	andeq	r1, r0, sl, asr r5
    42c8:	cd022712 	stcgt	7, cr2, [r2, #-72]	; 0xffffffb8
    42cc:	08000010 	stmdaeq	r0, {r4}
    42d0:	23a71a00 			; <UNDEFINED> instruction: 0x23a71a00
    42d4:	12100000 	andsne	r0, r0, #0
    42d8:	4306023d 	movwmi	r0, #25149	; 0x623d
    42dc:	be1b0000 	cdplt	0, 1, cr0, cr11, cr0, {0}
    42e0:	12000023 	andne	r0, r0, #35	; 0x23
    42e4:	2822023e 	stmdacs	r2!, {r1, r2, r3, r4, r5, r9}
    42e8:	1b000000 	blne	42f0 <.debug_info+0x42f0>
    42ec:	00000580 	andeq	r0, r0, r0, lsl #11
    42f0:	22023f12 	andcs	r3, r2, #18, 30	; 0x48
    42f4:	04000028 	streq	r0, [r0], #-40	; 0xffffffd8
    42f8:	005aae1b 	subseq	sl, sl, fp, lsl lr
    42fc:	02401200 	subeq	r1, r0, #0, 4
    4300:	00000082 	andeq	r0, r0, r2, lsl #1
    4304:	471a0008 	ldrmi	r0, [sl, -r8]
    4308:	18000043 	stmdane	r0, {r0, r1, r6}
    430c:	3b025312 	blcc	98f5c <unflatten_and_copy_device_tree+0x980e8>
    4310:	1b000043 	blne	4424 <.debug_info+0x4424>
    4314:	000023be 			; <UNDEFINED> instruction: 0x000023be
    4318:	b0025412 	andlt	r5, r2, r2, lsl r4
    431c:	00000011 	andeq	r0, r0, r1, lsl r0
    4320:	0005801b 	andeq	r8, r5, fp, lsl r0
    4324:	02551200 	subseq	r1, r5, #0, 4
    4328:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
    432c:	5aae1b08 	bpl	feb86c28 <__crc_of_fdt_unflatten_tree+0x77e4566b>
    4330:	56120000 	ldrpl	r0, [r2], -r0
    4334:	0011b002 	andseq	fp, r1, r2
    4338:	1a001000 	bne	8340 <.debug_info+0x8340>
    433c:	0000641b 	andeq	r6, r0, fp, lsl r4
    4340:	02801220 	addeq	r1, r0, #32, 4
    4344:	00004370 	andeq	r4, r0, r0, ror r3
    4348:	004b5d1b 	subeq	r5, fp, fp, lsl sp
    434c:	02811200 	addeq	r1, r1, #0, 4
    4350:	00004306 	andeq	r4, r0, r6, lsl #6
    4354:	0d871b00 	vstreq	d1, [r7]
    4358:	82120000 	andshi	r0, r2, #0
    435c:	0001fb02 	andeq	pc, r1, r2, lsl #22
    4360:	091b1800 	ldmdbeq	fp, {fp, ip}
    4364:	12000009 	andne	r0, r0, #9
    4368:	01fb0283 	mvnseq	r0, r3, lsl #5
    436c:	00190000 	andseq	r0, r9, r0
    4370:	0060f71c 	rsbeq	pc, r0, ip, lsl r7	; <UNPREDICTABLE>
    4374:	12023800 	andne	r3, r2, #0, 16
    4378:	467d0290 			; <UNDEFINED> instruction: 0x467d0290
    437c:	f11b0000 			; <UNDEFINED> instruction: 0xf11b0000
    4380:	12000033 	andne	r0, r0, #51	; 0x33
    4384:	02bc0291 	adcseq	r0, ip, #268435465	; 0x10000009
    4388:	1b000000 	blne	4390 <.debug_info+0x4390>
    438c:	000007b7 			; <UNDEFINED> instruction: 0x000007b7
    4390:	bc029212 	sfmlt	f1, 1, [r2], {18}
    4394:	04000002 	streq	r0, [r0], #-2
    4398:	0013c11b 	andseq	ip, r3, fp, lsl r1
    439c:	02931200 	addseq	r1, r3, #0, 4
    43a0:	00000057 	andeq	r0, r0, r7, asr r0
    43a4:	53751b08 	cmnpl	r5, #8, 22	; 0x2000
    43a8:	94120000 	ldrls	r0, [r2], #-0
    43ac:	0002c702 	andeq	ip, r2, r2, lsl #14
    43b0:	f61b0c00 			; <UNDEFINED> instruction: 0xf61b0c00
    43b4:	1200003a 	andne	r0, r0, #58	; 0x3a
    43b8:	11eb0296 			; <UNDEFINED> instruction: 0x11eb0296
    43bc:	1b140000 	blne	5043c4 <unflatten_and_copy_device_tree+0x503550>
    43c0:	00004678 	andeq	r4, r0, r8, ror r6
    43c4:	27029912 	smladcs	r2, r2, r9, r9
    43c8:	20000010 	andcs	r0, r0, r0, lsl r0
    43cc:	005d631b 	subseq	r6, sp, fp, lsl r3
    43d0:	029c1200 	addseq	r1, ip, #0, 4
    43d4:	00002c43 	andeq	r2, r0, r3, asr #24
    43d8:	51c01b24 	bicpl	r1, r0, r4, lsr #22
    43dc:	9f120000 	svcls	0x00120000
    43e0:	00005702 	andeq	r5, r0, r2, lsl #14
    43e4:	fa1b3400 	blx	6cd008 <unflatten_and_copy_device_tree+0x6cc194>
    43e8:	12000027 	andne	r0, r0, #39	; 0x27
    43ec:	005702a5 	subseq	r0, r7, r5, lsr #5
    43f0:	1b380000 	blne	e043f8 <unflatten_and_copy_device_tree+0xe03584>
    43f4:	00002d2a 	andeq	r2, r0, sl, lsr #26
    43f8:	2702a612 	smladcs	r2, r2, r6, sl
    43fc:	3c000010 	stccc	0, cr0, [r0], {16}
    4400:	0008931b 	andeq	r9, r8, fp, lsl r3
    4404:	02a91200 	adceq	r1, r9, #0, 4
    4408:	00000057 	andeq	r0, r0, r7, asr r0
    440c:	596a1b40 	stmdbpl	sl!, {r6, r8, r9, fp, ip}^
    4410:	aa120000 	bge	484418 <unflatten_and_copy_device_tree+0x4835a4>
    4414:	00006902 	andeq	r6, r0, r2, lsl #18
    4418:	b6344400 	ldrtlt	r4, [r4], -r0, lsl #8
    441c:	1200002d 	andne	r0, r0, #45	; 0x2d
    4420:	006902b5 	strhteq	r0, [r9], #-37	; 0xffffffdb
    4424:	01040000 	mrseq	r0, (UNDEF: 4)
    4428:	4734481f 			; <UNDEFINED> instruction: 0x4734481f
    442c:	12000062 	andne	r0, r0, #98	; 0x62
    4430:	006902b6 	strhteq	r0, [r9], #-38	; 0xffffffda
    4434:	01040000 	mrseq	r0, (UNDEF: 4)
    4438:	a11b481e 	tstge	fp, lr, lsl r8
    443c:	1200000d 	andne	r0, r0, #13
    4440:	005702b9 	ldrheq	r0, [r7], #-41	; 0xffffffd7
    4444:	1b4c0000 	blne	130444c <unflatten_and_copy_device_tree+0x13035d8>
    4448:	00005424 	andeq	r5, r0, r4, lsr #8
    444c:	c702ba12 	smladgt	r2, r2, sl, fp
    4450:	50000002 	andpl	r0, r0, r2
    4454:	0018be1b 	andseq	fp, r8, fp, lsl lr
    4458:	02bd1200 	adcseq	r1, sp, #0, 4
    445c:	00002e9b 	muleq	r0, fp, lr
    4460:	43171b58 	tstmi	r7, #88, 22	; 0x16000
    4464:	be120000 	cdplt	0, 1, cr0, cr2, cr0, {0}
    4468:	002db502 	eoreq	fp, sp, r2, lsl #10
    446c:	321b8800 	andscc	r8, fp, #0, 16
    4470:	1200002e 	andne	r0, r0, #46	; 0x2e
    4474:	1a4f02bf 	bne	13c4f78 <unflatten_and_copy_device_tree+0x13c4104>
    4478:	1d900000 	ldcne	0, cr0, [r0]
    447c:	12007469 	andne	r7, r0, #1761607680	; 0x69000000
    4480:	467d02c6 	ldrbtmi	r0, [sp], -r6, asr #5
    4484:	1b980000 	blne	fe60448c <__crc_of_fdt_unflatten_tree+0x778c2ecf>
    4488:	00005d2a 	andeq	r5, r0, sl, lsr #26
    448c:	3b02cc12 	blcc	b74dc <unflatten_and_copy_device_tree+0xb6668>
    4490:	b8000043 	stmdalt	r0, {r0, r1, r6}
    4494:	005cd61b 	subseq	sp, ip, fp, lsl r6
    4498:	02cf1200 	sbceq	r1, pc, #0, 4
    449c:	000042d1 	ldrdeq	r4, [r0], -r1
    44a0:	2e0e1bd8 	mcrcs	11, 0, r1, cr14, cr8, {6}
    44a4:	d1120000 	tstle	r2, r0
    44a8:	00171302 	andseq	r1, r7, r2, lsl #6
    44ac:	8b1fe800 	blhi	7fa008 <unflatten_and_copy_device_tree+0x7f9194>
    44b0:	1200003d 	andne	r0, r0, #61	; 0x3d
    44b4:	2db502d3 	lfmcs	f0, 4, [r5, #844]!	; 0x34c
    44b8:	01000000 	mrseq	r0, (UNDEF: 0)
    44bc:	0059a61f 	subseq	sl, r9, pc, lsl r6
    44c0:	02d61200 	sbcseq	r1, r6, #0, 4
    44c4:	00000057 	andeq	r0, r0, r7, asr r0
    44c8:	741e0104 	ldrvc	r0, [lr], #-260	; 0xfffffefc
    44cc:	12007974 	andne	r7, r0, #116, 18	; 0x1d0000
    44d0:	492f02d8 	stmdbmi	pc!, {r3, r4, r6, r7, r9}	; <UNPREDICTABLE>
    44d4:	01080000 	mrseq	r0, (UNDEF: 8)
    44d8:	00150e1f 	andseq	r0, r5, pc, lsl lr
    44dc:	02e31200 	rsceq	r1, r3, #0, 4
    44e0:	0000123e 	andeq	r1, r0, lr, lsr r2
    44e4:	be1f010c 	muflte	f0, f7, #4.0
    44e8:	12000023 	andne	r0, r0, #35	; 0x23
    44ec:	282202e4 	stmdacs	r2!, {r2, r5, r6, r7, r9}
    44f0:	01140000 	tsteq	r4, r0
    44f4:	0005801f 	andeq	r8, r5, pc, lsl r0
    44f8:	02e41200 	rsceq	r1, r4, #0, 4
    44fc:	00002822 	andeq	r2, r0, r2, lsr #16
    4500:	b91f0118 	ldmdblt	pc, {r3, r4, r8}	; <UNPREDICTABLE>
    4504:	12000064 	andne	r0, r0, #100	; 0x64
    4508:	282202e4 	stmdacs	r2!, {r2, r5, r6, r7, r9}
    450c:	011c0000 	tsteq	ip, r0
    4510:	00465c1f 	subeq	r5, r6, pc, lsl ip
    4514:	02e41200 	rsceq	r1, r4, #0, 4
    4518:	00002822 	andeq	r2, r0, r2, lsr #16
    451c:	8b1f0120 	blhi	7c0488 <unflatten_and_copy_device_tree+0x7bf614>
    4520:	12000015 	andne	r0, r0, #21
    4524:	282202e5 	stmdacs	r2!, {r0, r2, r5, r6, r7, r9}
    4528:	01240000 			; <UNDEFINED> instruction: 0x01240000
    452c:	0028541f 	eoreq	r5, r8, pc, lsl r4
    4530:	02e61200 	rsceq	r1, r6, #0, 4
    4534:	00002822 	andeq	r2, r0, r2, lsr #16
    4538:	ca1f0128 	bgt	7c04a8 <unflatten_and_copy_device_tree+0x7bf634>
    453c:	12000039 	andne	r0, r0, #57	; 0x39
    4540:	429c02e7 	addsmi	r0, ip, #1879048206	; 0x7000000e
    4544:	012c0000 			; <UNDEFINED> instruction: 0x012c0000
    4548:	00308f1f 	eorseq	r8, r0, pc, lsl pc
    454c:	02e81200 	rsceq	r1, r8, #0, 4
    4550:	000000d4 	ldrdeq	r0, [r0], -r4
    4554:	521f0138 	andspl	r0, pc, #56, 2
    4558:	12000050 	andne	r0, r0, #80	; 0x50
    455c:	00d402e8 	sbcseq	r0, r4, r8, ror #5
    4560:	013c0000 	teqeq	ip, r0
    4564:	000b381f 	andeq	r3, fp, pc, lsl r8
    4568:	02e81200 	rsceq	r1, r8, #0, 4
    456c:	000000d4 	ldrdeq	r0, [r0], -r4
    4570:	521f0140 	andspl	r0, pc, #64, 2
    4574:	1200001e 	andne	r0, r0, #30
    4578:	00d402e8 	sbcseq	r0, r4, r8, ror #5
    457c:	01440000 	mrseq	r0, (UNDEF: 68)
    4580:	0025a31f 	eoreq	sl, r5, pc, lsl r3
    4584:	02e91200 	rsceq	r1, r9, #0, 4
    4588:	000000d4 	ldrdeq	r0, [r0], -r4
    458c:	051f0148 	ldreq	r0, [pc, #-328]	; fffffec0 <__crc_of_fdt_unflatten_tree+0x792be903>
    4590:	1200001c 	andne	r0, r0, #28
    4594:	00d402e9 	sbcseq	r0, r4, r9, ror #5
    4598:	014c0000 	mrseq	r0, (UNDEF: 76)
    459c:	0035c71f 	eorseq	ip, r5, pc, lsl r7
    45a0:	02e91200 	rsceq	r1, r9, #0, 4
    45a4:	000000d4 	ldrdeq	r0, [r0], -r4
    45a8:	9b1f0150 	blls	7c0548 <unflatten_and_copy_device_tree+0x7bf6d4>
    45ac:	12000029 	andne	r0, r0, #41	; 0x29
    45b0:	00d402e9 	sbcseq	r0, r4, r9, ror #5
    45b4:	01540000 	cmpeq	r4, r0
    45b8:	0041871f 	subeq	r8, r1, pc, lsl r7
    45bc:	02ea1200 	rsceq	r1, sl, #0, 4
    45c0:	000000d4 	ldrdeq	r0, [r0], -r4
    45c4:	ce1f0158 	mrcgt	1, 0, r0, cr15, cr8, {2}
    45c8:	1200001f 	andne	r0, r0, #31
    45cc:	00d402ea 	sbcseq	r0, r4, sl, ror #5
    45d0:	015c0000 	cmpeq	ip, r0
    45d4:	0052c71f 	subseq	ip, r2, pc, lsl r7
    45d8:	02ea1200 	rsceq	r1, sl, #0, 4
    45dc:	000000d4 	ldrdeq	r0, [r0], -r4
    45e0:	4a1f0160 	bmi	7c0588 <unflatten_and_copy_device_tree+0x7bf714>
    45e4:	1200002e 	andne	r0, r0, #46	; 0x2e
    45e8:	00d402ea 	sbcseq	r0, r4, sl, ror #5
    45ec:	01640000 	cmneq	r4, r0
    45f0:	005b3f1f 	subseq	r3, fp, pc, lsl pc
    45f4:	02eb1200 	rsceq	r1, fp, #0, 4
    45f8:	000000d4 	ldrdeq	r0, [r0], -r4
    45fc:	2f1f0168 	svccs	0x001f0168
    4600:	12000009 	andne	r0, r0, #9
    4604:	00d402eb 	sbcseq	r0, r4, fp, ror #5
    4608:	016c0000 	cmneq	ip, r0
    460c:	0003251f 	andeq	r2, r3, pc, lsl r5
    4610:	02ec1200 	rsceq	r1, ip, #0, 4
    4614:	000030a4 	andeq	r3, r0, r4, lsr #1
    4618:	a61f0170 			; <UNDEFINED> instruction: 0xa61f0170
    461c:	1200002f 	andne	r0, r0, #47	; 0x2f
    4620:	008202f4 	strdeq	r0, [r2], r4
    4624:	01700000 	cmneq	r0, r0
    4628:	0055e81f 	subseq	lr, r5, pc, lsl r8
    462c:	02ff1200 	rscseq	r1, pc, #0, 4
    4630:	00004935 	andeq	r4, r0, r5, lsr r9
    4634:	031f0178 	tsteq	pc, #120, 2
    4638:	1200003a 	andne	r0, r0, #58	; 0x3a
    463c:	41f10302 	mvnsmi	r0, r2, lsl #6
    4640:	01f80000 	mvnseq	r0, r0
    4644:	0018281f 	andseq	r2, r8, pc, lsl r8
    4648:	030d1200 	movweq	r1, #53760	; 0xd200
    464c:	00000291 	muleq	r0, r1, r2
    4650:	001f0214 	andseq	r0, pc, r4, lsl r2	; <UNPREDICTABLE>
    4654:	1200005a 	andne	r0, r0, #90	; 0x5a
    4658:	0033030e 	eorseq	r0, r3, lr, lsl #6
    465c:	02180000 	andseq	r0, r8, #0
    4660:	001fa11f 	andseq	sl, pc, pc, lsl r1	; <UNPREDICTABLE>
    4664:	030f1200 	movweq	r1, #61952	; 0xf200
    4668:	00000033 	andeq	r0, r0, r3, lsr r0
    466c:	7c1f021a 	lfmvc	f0, 4, [pc], {26}
    4670:	12000038 	andne	r0, r0, #56	; 0x38
    4674:	19400312 	stmdbne	r0, {r1, r4, r8, r9}^
    4678:	021c0000 	andseq	r0, ip, #0
    467c:	425a0600 	subsmi	r0, sl, #0, 12
    4680:	468d0000 	strmi	r0, [sp], r0
    4684:	eb070000 	bl	1c468c <unflatten_and_copy_device_tree+0x1c3818>
    4688:	01000000 	mrseq	r0, (UNDEF: 0)
    468c:	15d81c00 	ldrbne	r1, [r8, #3072]	; 0xc00
    4690:	01e40000 	mvneq	r0, r0
    4694:	2f01034c 	svccs	0x0001034c
    4698:	1b000049 	blne	47c4 <.debug_info+0x47c4>
    469c:	000022e8 	andeq	r2, r0, r8, ror #5
    46a0:	5701044c 	strpl	r0, [r1, -ip, asr #8]
    46a4:	00000000 	andeq	r0, r0, r0
    46a8:	000e251b 	andeq	r2, lr, fp, lsl r5
    46ac:	01054c00 	tsteq	r5, r0, lsl #24
    46b0:	00005800 	andeq	r5, r0, r0, lsl #16
    46b4:	65641d04 	strbvs	r1, [r4, #-3332]!	; 0xfffff2fc
    46b8:	064c0076 			; <UNDEFINED> instruction: 0x064c0076
    46bc:	005bfa01 	subseq	pc, fp, r1, lsl #20
    46c0:	361b0800 	ldrcc	r0, [fp], -r0, lsl #16
    46c4:	4c000067 	stcmi	0, cr0, [r0], {103}	; 0x67
    46c8:	8d3b0107 	ldfhis	f0, [fp, #-28]!	; 0xffffffe4
    46cc:	1d0c0000 	stcne	0, cr0, [ip, #-0]
    46d0:	0073706f 	rsbseq	r7, r3, pc, rrx
    46d4:	0101084c 	tsteq	r1, ip, asr #16
    46d8:	10000092 	mulne	r0, r2, r0
    46dc:	0027ca1b 	eoreq	ip, r7, fp, lsl sl
    46e0:	01094c00 	tsteq	r9, r0, lsl #24
    46e4:	00000057 	andeq	r0, r0, r7, asr r0
    46e8:	3e471b14 	vmovcc.8	d7[0], r1
    46ec:	0c4c0000 	mareq	acc0, r0, ip
    46f0:	00920c01 	addseq	r0, r2, r1, lsl #24
    46f4:	211b1800 	tstcs	fp, r0, lsl #16
    46f8:	4c000035 	stcmi	0, cr0, [r0], {53}	; 0x35
    46fc:	966b010d 	strbtls	r0, [fp], -sp, lsl #2
    4700:	1b340000 	blne	d04708 <unflatten_and_copy_device_tree+0xd03894>
    4704:	00004369 	andeq	r4, r0, r9, ror #6
    4708:	40010f4c 	andmi	r0, r1, ip, asr #30
    470c:	38000019 	stmdacc	r0, {r0, r3, r4}
    4710:	001cc41b 	andseq	ip, ip, fp, lsl r4
    4714:	01104c00 	tsteq	r0, r0, lsl #24
    4718:	00001940 	andeq	r1, r0, r0, asr #18
    471c:	053f1b50 	ldreq	r1, [pc, #-2896]!	; fffff4b8 <__crc_of_fdt_unflatten_tree+0x792bdefb>
    4720:	114c0000 	mrsne	r0, (UNDEF: 76)
    4724:	00194001 	andseq	r4, r9, r1
    4728:	321b6800 	andscc	r6, fp, #0, 16
    472c:	4c000007 	stcmi	0, cr0, [r0], {7}
    4730:	19890112 	stmibne	r9, {r1, r4, r8}
    4734:	1b800000 	blne	fe00473c <__crc_of_fdt_unflatten_tree+0x772c317f>
    4738:	000064a0 	andeq	r6, r0, r0, lsr #9
    473c:	4001134c 	andmi	r1, r1, ip, asr #6
    4740:	98000019 	stmdals	r0, {r0, r3, r4}
    4744:	0053cd1b 	subseq	ip, r3, fp, lsl sp
    4748:	01144c00 	tsteq	r4, r0, lsl #24
    474c:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    4750:	3efb1bb0 	vmovcc.u8	r1, d27[5]
    4754:	154c0000 	strbne	r0, [ip, #-0]
    4758:	0010ff01 	andseq	pc, r0, r1, lsl #30
    475c:	6a1bb400 	bvs	6ed008 <unflatten_and_copy_device_tree+0x6ec194>
    4760:	4c00005a 	stcmi	0, cr0, [r0], {90}	; 0x5a
    4764:	8a8e0117 	bhi	fe384bc8 <__crc_of_fdt_unflatten_tree+0x7764360b>
    4768:	1bb80000 	blne	fee04770 <__crc_of_fdt_unflatten_tree+0x780c31b3>
    476c:	000052f0 	strdeq	r5, [r0], -r0
    4770:	8e01174c 	cdphi	7, 0, cr1, cr1, cr12, {2}
    4774:	e400008a 	str	r0, [r0], #-138	; 0xffffff76
    4778:	005a721f 	subseq	r7, sl, pc, lsl r2
    477c:	01184c00 	tsteq	r8, r0, lsl #24
    4780:	00009025 	andeq	r9, r0, r5, lsr #32
    4784:	9b1f0110 	blls	7c0448 <unflatten_and_copy_device_tree+0x7bf5d4>
    4788:	4c000005 	stcmi	0, cr0, [r0], {5}
    478c:	3d3f0119 	ldfccs	f0, [pc, #-100]!	; 4730 <.debug_info+0x4730>
    4790:	01140000 	tsteq	r4, r0
    4794:	0054961f 	subseq	r9, r4, pc, lsl r6
    4798:	011a4c00 	tsteq	sl, r0, lsl #24
    479c:	00002db5 			; <UNDEFINED> instruction: 0x00002db5
    47a0:	531f0154 	tstpl	pc, #84, 2
    47a4:	4c00002a 	stcmi	0, cr0, [r0], {42}	; 0x2a
    47a8:	2db5011b 	ldfcss	f0, [r5, #108]!	; 0x6c
    47ac:	01580000 	cmpeq	r8, r0
    47b0:	00596a1f 	subseq	r6, r9, pc, lsl sl
    47b4:	011c4c00 	tsteq	ip, r0, lsl #24
    47b8:	000000d4 	ldrdeq	r0, [r0], -r4
    47bc:	a11f015c 	tstge	pc, ip, asr r1	; <UNPREDICTABLE>
    47c0:	4c00003b 	stcmi	0, cr0, [r0], {59}	; 0x3b
    47c4:	0057011d 	subseq	r0, r7, sp, lsl r1
    47c8:	01600000 	cmneq	r0, r0
    47cc:	0044a01f 	subeq	sl, r4, pc, lsl r0
    47d0:	011e4c00 	tsteq	lr, r0, lsl #24
    47d4:	00008afb 	strdeq	r8, [r0], -fp
    47d8:	65200164 	strvs	r0, [r0, #-356]!	; 0xfffffe9c
    47dc:	4c000009 	stcmi	0, cr0, [r0], {9}
    47e0:	00d4011f 	sbcseq	r0, r4, pc, lsl r1
    47e4:	01040000 	mrseq	r0, (UNDEF: 4)
    47e8:	20016c1f 	andcs	r6, r1, pc, lsl ip
    47ec:	00004ba3 	andeq	r4, r0, r3, lsr #23
    47f0:	d401204c 	strle	r2, [r1], #-76	; 0xffffffb4
    47f4:	04000000 	streq	r0, [r0], #-0
    47f8:	016c1e01 	cmneq	ip, r1, lsl #28
    47fc:	00449920 	subeq	r9, r4, r0, lsr #18
    4800:	01214c00 			; <UNDEFINED> instruction: 0x01214c00
    4804:	000000d4 	ldrdeq	r0, [r0], -r4
    4808:	6c001e04 	stcvs	14, cr1, [r0], {4}
    480c:	00131f01 	andseq	r1, r3, r1, lsl #30
    4810:	224c0000 	subcs	r0, ip, #0
    4814:	00005701 	andeq	r5, r0, r1, lsl #14
    4818:	20017000 	andcs	r7, r1, r0
    481c:	00002782 	andeq	r2, r0, r2, lsl #15
    4820:	d401234c 	strle	r2, [r1], #-844	; 0xfffffcb4
    4824:	04000000 	streq	r0, [r0], #-0
    4828:	01741808 	cmneq	r4, r8, lsl #16
    482c:	00513e20 	subseq	r3, r1, r0, lsr #28
    4830:	01244c00 			; <UNDEFINED> instruction: 0x01244c00
    4834:	000000d4 	ldrdeq	r0, [r0], -r4
    4838:	74170104 	ldrvc	r0, [r7], #-260	; 0xfffffefc
    483c:	4ab52001 	bmi	fed4800c <__crc_of_fdt_unflatten_tree+0x78006a4f>
    4840:	254c0000 	strbcs	r0, [ip, #-0]
    4844:	0000d401 	andeq	sp, r0, r1, lsl #8
    4848:	00170400 	andseq	r0, r7, r0, lsl #8
    484c:	071f0174 			; <UNDEFINED> instruction: 0x071f0174
    4850:	4c00002f 	stcmi	0, cr0, [r0], {47}	; 0x2f
    4854:	00690126 	rsbeq	r0, r9, r6, lsr #2
    4858:	01780000 	cmneq	r8, r0
    485c:	0039be1f 	eorseq	fp, r9, pc, lsl lr
    4860:	01274c00 			; <UNDEFINED> instruction: 0x01274c00
    4864:	00000057 	andeq	r0, r0, r7, asr r0
    4868:	4c1f017c 	ldfmis	f0, [pc], {124}	; 0x7c
    486c:	4c000000 	stcmi	0, cr0, [r0], {-0}
    4870:	492f0129 	stmdbmi	pc!, {r0, r3, r5, r8}	; <UNPREDICTABLE>
    4874:	01800000 	orreq	r0, r0, r0
    4878:	005c2f1f 	subseq	r2, ip, pc, lsl pc
    487c:	012a4c00 			; <UNDEFINED> instruction: 0x012a4c00
    4880:	00007f12 	andeq	r7, r0, r2, lsl pc
    4884:	b51f0184 	ldrlt	r0, [pc, #-388]	; fffffe84 <__crc_of_fdt_unflatten_tree+0x792be8c7>
    4888:	4c00000f 	stcmi	0, cr0, [r0], {15}
    488c:	0057012b 	subseq	r0, r7, fp, lsr #2
    4890:	01880000 	orreq	r0, r8, r0
    4894:	00437b1f 	subeq	r7, r3, pc, lsl fp
    4898:	012c4c00 			; <UNDEFINED> instruction: 0x012c4c00
    489c:	000011eb 	andeq	r1, r0, fp, ror #3
    48a0:	7b1f018c 	blvc	7c0638 <unflatten_and_copy_device_tree+0x7bf7c4>
    48a4:	4c00004b 	stcmi	0, cr0, [r0], {75}	; 0x4b
    48a8:	11eb012d 	mvnne	r0, sp, lsr #2
    48ac:	01980000 	orrseq	r0, r8, r0
    48b0:	002cff1f 	eoreq	pc, ip, pc, lsl pc	; <UNPREDICTABLE>
    48b4:	012e4c00 			; <UNDEFINED> instruction: 0x012e4c00
    48b8:	00001afa 	strdeq	r1, [r0], -sl
    48bc:	5d1f01a4 	ldfpls	f0, [pc, #-656]	; fffffd78 <__crc_of_fdt_unflatten_tree+0x792be7bb>
    48c0:	4c00000b 	stcmi	0, cr0, [r0], {11}
    48c4:	0378012f 	cmneq	r8, #-1073741813	; 0xc000000b
    48c8:	01b40000 			; <UNDEFINED> instruction: 0x01b40000
    48cc:	005b331f 	subseq	r3, fp, pc, lsl r3
    48d0:	01304c00 	teqeq	r0, r0, lsl #24
    48d4:	00000378 	andeq	r0, r0, r8, ror r3
    48d8:	801f01b8 			; <UNDEFINED> instruction: 0x801f01b8
    48dc:	4c00002e 	stcmi	0, cr0, [r0], {46}	; 0x2e
    48e0:	02c70131 	sbceq	r0, r7, #1073741836	; 0x4000000c
    48e4:	01bc0000 			; <UNDEFINED> instruction: 0x01bc0000
    48e8:	0023fe1f 	eoreq	pc, r3, pc, lsl lr	; <UNPREDICTABLE>
    48ec:	01354c00 	teqeq	r5, r0, lsl #24
    48f0:	00000057 	andeq	r0, r0, r7, asr r0
    48f4:	ab1f01c4 	blge	7c0718 <unflatten_and_copy_device_tree+0x7bf8a4>
    48f8:	4c000024 	stcmi	0, cr0, [r0], {36}	; 0x24
    48fc:	939d0136 	orrsls	r0, sp, #-2147483635	; 0x8000000d
    4900:	01c80000 	biceq	r0, r8, r0
    4904:	00588f1f 	subseq	r8, r8, pc, lsl pc
    4908:	01374c00 	teqeq	r7, r0, lsl #24
    490c:	00000057 	andeq	r0, r0, r7, asr r0
    4910:	f01f01cc 			; <UNDEFINED> instruction: 0xf01f01cc
    4914:	4c000064 	stcmi	0, cr0, [r0], {100}	; 0x64
    4918:	1afa0139 	bne	ffe84e04 <__crc_of_fdt_unflatten_tree+0x79143847>
    491c:	01d00000 	bicseq	r0, r0, r0
    4920:	00153b1f 	andseq	r3, r5, pc, lsl fp
    4924:	013a4c00 	teqeq	sl, r0, lsl #24
    4928:	000091f5 	strdeq	r9, [r0], -r5
    492c:	080001e0 	stmdaeq	r0, {r5, r6, r7, r8}
    4930:	00468d04 	subeq	r8, r6, r4, lsl #26
    4934:	26970600 	ldrcs	r0, [r7], r0, lsl #12
    4938:	49450000 	stmdbmi	r5, {}^	; <UNPREDICTABLE>
    493c:	eb070000 	bl	1c4944 <unflatten_and_copy_device_tree+0x1c3ad0>
    4940:	0f000000 	svceq	0x00000000
    4944:	0c191a00 	ldceq	10, cr1, [r9], {-0}
    4948:	12200000 	eorne	r0, r0, #0
    494c:	49870361 	stmibmi	r7, {r0, r5, r6, r8, r9}
    4950:	f71b0000 			; <UNDEFINED> instruction: 0xf71b0000
    4954:	1200001b 	andne	r0, r0, #27
    4958:	00d40363 	sbcseq	r0, r4, r3, ror #6
    495c:	1b000000 	blne	4964 <.debug_info+0x4964>
    4960:	0000340a 	andeq	r3, r0, sl, lsl #8
    4964:	82036412 	andhi	r6, r3, #301989888	; 0x12000000
    4968:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    496c:	0038591b 	eorseq	r5, r8, fp, lsl r9
    4970:	03671200 	cmneq	r7, #0, 4
    4974:	00000082 	andeq	r0, r0, r2, lsl #1
    4978:	0b511b10 	bleq	1446c48 <unflatten_and_copy_device_tree+0x1445dd4>
    497c:	68120000 	ldmdavs	r2, {}	; <UNPREDICTABLE>
    4980:	00008203 	andeq	r8, r0, r3, lsl #4
    4984:	24001800 	strcs	r1, [r0], #-2048	; 0xfffff800
    4988:	00000dba 			; <UNDEFINED> instruction: 0x00000dba
    498c:	00006904 	andeq	r6, r0, r4, lsl #18
    4990:	039a1200 	orrseq	r1, sl, #0, 4
    4994:	000049b1 			; <UNDEFINED> instruction: 0x000049b1
    4998:	0061930b 	rsbeq	r9, r1, fp, lsl #6
    499c:	ea0b0000 	b	2c0008 <unflatten_and_copy_device_tree+0x2bf194>
    49a0:	01000060 	tsteq	r0, r0, rrx
    49a4:	0038ac0b 	eorseq	sl, r8, fp, lsl #24
    49a8:	a00b0200 	andge	r0, fp, r0, lsl #4
    49ac:	0300000a 	movweq	r0, #10
    49b0:	5c9a1a00 	vldmiapl	sl, {s2-s1}
    49b4:	12040000 	andne	r0, r4, #0
    49b8:	49cc03c1 	stmibmi	ip, {r0, r6, r7, r8, r9}^
    49bc:	221b0000 	andscs	r0, fp, #0
    49c0:	12000022 	andne	r0, r0, #34	; 0x22
    49c4:	49cc03c2 	stmibmi	ip, {r1, r6, r7, r8, r9}^
    49c8:	00000000 	andeq	r0, r0, r0
    49cc:	49b10408 	ldmibmi	r1!, {r3, sl}
    49d0:	04080000 	streq	r0, [r8], #-0
    49d4:	000049d8 	ldrdeq	r4, [r0], -r8
    49d8:	0019d209 	andseq	sp, r9, r9, lsl #4
    49dc:	07261a00 	streq	r1, [r6, -r0, lsl #20]!
    49e0:	12080000 	andne	r0, r8, #0
    49e4:	4a0504a9 	bmi	145c90 <unflatten_and_copy_device_tree+0x144e1c>
    49e8:	fc1b0000 	ldc2	0, cr0, [fp], {-0}
    49ec:	1200004b 	andne	r0, r0, #75	; 0x4b
    49f0:	00d404aa 	sbcseq	r0, r4, sl, lsr #9
    49f4:	1b000000 	blne	49fc <.debug_info+0x49fc>
    49f8:	00000abd 			; <UNDEFINED> instruction: 0x00000abd
    49fc:	b304ab12 	movwlt	sl, #19218	; 0x4b12
    4a00:	04000000 	streq	r0, [r0], #-0
    4a04:	22021a00 	andcs	r1, r2, #0, 20
    4a08:	12200000 	eorne	r0, r0, #0
    4a0c:	4a6104bc 	bmi	1845d04 <unflatten_and_copy_device_tree+0x1844e90>
    4a10:	541b0000 	ldrpl	r0, [fp], #-0
    4a14:	12000044 	andne	r0, r0, #68	; 0x44
    4a18:	00c904bd 	strheq	r0, [r9], #77	; 0x4d
    4a1c:	1b000000 	blne	4a24 <.debug_info+0x4a24>
    4a20:	0000671c 	andeq	r6, r0, ip, lsl r7
    4a24:	c904bd12 	stmdbgt	r4, {r1, r4, r8, sl, fp, ip, sp, pc}
    4a28:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4a2c:	0016d91b 	andseq	sp, r6, fp, lsl r9
    4a30:	04be1200 	ldrteq	r1, [lr], #512	; 0x200
    4a34:	000000b3 	strheq	r0, [r0], -r3
    4a38:	22bf1b10 	adcscs	r1, pc, #16, 22	; 0x4000
    4a3c:	be120000 	cdplt	0, 1, cr0, cr2, cr0, {0}
    4a40:	0000b304 	andeq	fp, r0, r4, lsl #6
    4a44:	7e1b1400 	cfmulsvc	mvf1, mvf11, mvf0
    4a48:	1200000d 	andne	r0, r0, #13
    4a4c:	00d404bf 	ldrheq	r0, [r4], #79	; 0x4f
    4a50:	1b180000 	blne	604a58 <unflatten_and_copy_device_tree+0x603be4>
    4a54:	00003275 	andeq	r3, r0, r5, ror r2
    4a58:	d404bf12 	strle	fp, [r4], #-3858	; 0xfffff0ee
    4a5c:	1c000000 	stcne	0, cr0, [r0], {-0}
    4a60:	0e2a1a00 	vmuleq.f32	s2, s20, s0
    4a64:	12d80000 	sbcsne	r0, r8, #0
    4a68:	4bce04c3 	blmi	ff385d7c <__crc_of_fdt_unflatten_tree+0x786447bf>
    4a6c:	b91b0000 	ldmdblt	fp, {}	; <UNPREDICTABLE>
    4a70:	12000056 	andne	r0, r0, #86	; 0x56
    4a74:	00c904c4 	sbceq	r0, r9, r4, asr #9
    4a78:	1b000000 	blne	4a80 <.debug_info+0x4a80>
    4a7c:	00006341 	andeq	r6, r0, r1, asr #6
    4a80:	c904c512 	stmdbgt	r4, {r1, r4, r8, sl, lr, pc}
    4a84:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4a88:	004a641b 	subeq	r6, sl, fp, lsl r4
    4a8c:	04c61200 	strbeq	r1, [r6], #512	; 0x200
    4a90:	000000c9 	andeq	r0, r0, r9, asr #1
    4a94:	3ae21b10 	bcc	ff886c48 <__crc_of_fdt_unflatten_tree+0x78b4568b>
    4a98:	c7120000 	ldrgt	r0, [r2, -r0]
    4a9c:	0000c904 	andeq	ip, r0, r4, lsl #18
    4aa0:	831b1800 	tsthi	fp, #0, 16
    4aa4:	12000013 	andne	r0, r0, #19
    4aa8:	00c904c8 	sbceq	r0, r9, r8, asr #9
    4aac:	1b200000 	blne	804ab4 <unflatten_and_copy_device_tree+0x803c40>
    4ab0:	000006d1 	ldrdeq	r0, [r0], -r1
    4ab4:	c904c912 	stmdbgt	r4, {r1, r4, r8, fp, lr, pc}
    4ab8:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    4abc:	0011171b 	andseq	r1, r1, fp, lsl r7
    4ac0:	04cb1200 	strbeq	r1, [fp], #512	; 0x200
    4ac4:	000000c9 	andeq	r0, r0, r9, asr #1
    4ac8:	20991b30 	addscs	r1, r9, r0, lsr fp
    4acc:	cc120000 	ldcgt	0, cr0, [r2], {-0}
    4ad0:	0000c904 	andeq	ip, r0, r4, lsl #18
    4ad4:	b81b3800 	ldmdalt	fp, {fp, ip, sp}
    4ad8:	12000062 	andne	r0, r0, #98	; 0x62
    4adc:	00be04cd 	adcseq	r0, lr, sp, asr #9
    4ae0:	1b400000 	blne	1004ae8 <unflatten_and_copy_device_tree+0x1003c74>
    4ae4:	00005a80 	andeq	r5, r0, r0, lsl #21
    4ae8:	c904cf12 	stmdbgt	r4, {r1, r4, r8, r9, sl, fp, lr, pc}
    4aec:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    4af0:	000df41b 	andeq	pc, sp, fp, lsl r4	; <UNPREDICTABLE>
    4af4:	04d01200 	ldrbeq	r1, [r0], #512	; 0x200
    4af8:	000000c9 	andeq	r0, r0, r9, asr #1
    4afc:	60051b50 	andvs	r1, r5, r0, asr fp
    4b00:	d1120000 	tstle	r2, r0
    4b04:	0000c904 	andeq	ip, r0, r4, lsl #18
    4b08:	a01b5800 	andsge	r5, fp, r0, lsl #16
    4b0c:	12000043 	andne	r0, r0, #67	; 0x43
    4b10:	00c904d2 	ldrdeq	r0, [r9], #66	; 0x42
    4b14:	1b600000 	blne	1804b1c <unflatten_and_copy_device_tree+0x1803ca8>
    4b18:	00005c0b 	andeq	r5, r0, fp, lsl #24
    4b1c:	c904d412 	stmdbgt	r4, {r1, r4, sl, ip, lr, pc}
    4b20:	68000000 	stmdavs	r0, {}	; <UNPREDICTABLE>
    4b24:	0033281b 	eorseq	r2, r3, fp, lsl r8
    4b28:	04d51200 	ldrbeq	r1, [r5], #512	; 0x200
    4b2c:	000000c9 	andeq	r0, r0, r9, asr #1
    4b30:	1f7c1b70 	svcne	0x007c1b70
    4b34:	d6120000 	ldrle	r0, [r2], -r0
    4b38:	0000c904 	andeq	ip, r0, r4, lsl #18
    4b3c:	d61b7800 	ldrle	r7, [fp], -r0, lsl #16
    4b40:	1200005e 	andne	r0, r0, #94	; 0x5e
    4b44:	00c904d7 	ldrdeq	r0, [r9], #71	; 0x47
    4b48:	1b800000 	blne	fe004b50 <__crc_of_fdt_unflatten_tree+0x772c3593>
    4b4c:	0000243d 	andeq	r2, r0, sp, lsr r4
    4b50:	c904d812 	stmdbgt	r4, {r1, r4, fp, ip, lr, pc}
    4b54:	88000000 	stmdahi	r0, {}	; <UNPREDICTABLE>
    4b58:	004c191b 	subeq	r1, ip, fp, lsl r9
    4b5c:	04da1200 	ldrbeq	r1, [sl], #512	; 0x200
    4b60:	000000c9 	andeq	r0, r0, r9, asr #1
    4b64:	44011b90 	strmi	r1, [r1], #-2960	; 0xfffff470
    4b68:	db120000 	blle	484b70 <unflatten_and_copy_device_tree+0x483cfc>
    4b6c:	0000c904 	andeq	ip, r0, r4, lsl #18
    4b70:	bf1b9800 	svclt	0x001b9800
    4b74:	1200005a 	andne	r0, r0, #90	; 0x5a
    4b78:	00c904dc 	ldrdeq	r0, [r9], #76	; 0x4c
    4b7c:	1ba00000 	blne	fe804b84 <__crc_of_fdt_unflatten_tree+0x77ac35c7>
    4b80:	00002269 	andeq	r2, r0, r9, ror #4
    4b84:	c904dd12 	stmdbgt	r4, {r1, r4, r8, sl, fp, ip, lr, pc}
    4b88:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    4b8c:	004e1a1b 	subeq	r1, lr, fp, lsl sl
    4b90:	04de1200 	ldrbeq	r1, [lr], #512	; 0x200
    4b94:	000000c9 	andeq	r0, r0, r9, asr #1
    4b98:	17791bb0 			; <UNDEFINED> instruction: 0x17791bb0
    4b9c:	df120000 	svcle	0x00120000
    4ba0:	0000c904 	andeq	ip, r0, r4, lsl #18
    4ba4:	e01bb800 	ands	fp, fp, r0, lsl #16
    4ba8:	1200003e 	andne	r0, r0, #62	; 0x3e
    4bac:	00c904e0 	sbceq	r0, r9, r0, ror #9
    4bb0:	1bc00000 	blne	ff004bb8 <__crc_of_fdt_unflatten_tree+0x782c35fb>
    4bb4:	00002c95 	muleq	r0, r5, ip
    4bb8:	c904e112 	stmdbgt	r4, {r1, r4, r8, sp, lr, pc}
    4bbc:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    4bc0:	005fac1b 	subseq	sl, pc, fp, lsl ip	; <UNPREDICTABLE>
    4bc4:	04e21200 	strbteq	r1, [r2], #512	; 0x200
    4bc8:	000000c9 	andeq	r0, r0, r9, asr #1
    4bcc:	001c00d0 	ldrsbeq	r0, [ip], -r0	; <UNPREDICTABLE>
    4bd0:	50000000 	andpl	r0, r0, r0
    4bd4:	04e61201 	strbteq	r1, [r6], #513	; 0x201
    4bd8:	00004ca5 	andeq	r4, r0, r5, lsr #25
    4bdc:	00271b1b 	eoreq	r1, r7, fp, lsl fp
    4be0:	04e71200 	strbteq	r1, [r7], #512	; 0x200
    4be4:	000049dd 	ldrdeq	r4, [r0], -sp
    4be8:	595c1b00 	ldmdbpl	ip, {r8, r9, fp, ip}^
    4bec:	e8120000 	ldmda	r2, {}	; <UNPREDICTABLE>
    4bf0:	001a6b04 	andseq	r6, sl, r4, lsl #22
    4bf4:	8f1b0800 	svchi	0x001b0800
    4bf8:	12000014 	andne	r0, r0, #20
    4bfc:	02c704e9 	sbceq	r0, r7, #-385875968	; 0xe9000000
    4c00:	1b140000 	blne	504c08 <unflatten_and_copy_device_tree+0x503d94>
    4c04:	00004725 	andeq	r4, r0, r5, lsr #14
    4c08:	6904ea12 	stmdbvs	r4, {r1, r4, r9, fp, sp, lr, pc}
    4c0c:	1c000000 	stcne	0, cr0, [r0], {-0}
    4c10:	002f351b 	eoreq	r3, pc, fp, lsl r5	; <UNPREDICTABLE>
    4c14:	04ec1200 	strbteq	r1, [ip], #512	; 0x200
    4c18:	000000c9 	andeq	r0, r0, r9, asr #1
    4c1c:	5aae1b20 	bpl	feb86c88 <__crc_of_fdt_unflatten_tree+0x77e456cb>
    4c20:	ed120000 	ldc	0, cr0, [r2, #-0]
    4c24:	0000c904 	andeq	ip, r0, r4, lsl #18
    4c28:	e71b2800 	ldr	r2, [fp, -r0, lsl #16]
    4c2c:	12000054 	andne	r0, r0, #84	; 0x54
    4c30:	00c904ee 	sbceq	r0, r9, lr, ror #9
    4c34:	1b300000 	blne	c04c3c <unflatten_and_copy_device_tree+0xc03dc8>
    4c38:	000041a6 	andeq	r4, r0, r6, lsr #3
    4c3c:	c904ef12 	stmdbgt	r4, {r1, r4, r8, r9, sl, fp, sp, lr, pc}
    4c40:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    4c44:	0002a81b 	andeq	sl, r2, fp, lsl r8
    4c48:	04f11200 	ldrbteq	r1, [r1], #512	; 0x200
    4c4c:	000000c9 	andeq	r0, r0, r9, asr #1
    4c50:	3f401b40 	svccc	0x00401b40
    4c54:	f4120000 			; <UNDEFINED> instruction: 0xf4120000
    4c58:	004a6104 	subeq	r6, sl, r4, lsl #2
    4c5c:	1b1f4800 	blne	7d2008 <unflatten_and_copy_device_tree+0x7d1194>
    4c60:	12000058 	andne	r0, r0, #88	; 0x58
    4c64:	005704f8 	ldrsheq	r0, [r7], #-72	; 0xffffffb8
    4c68:	01200000 			; <UNDEFINED> instruction: 0x01200000
    4c6c:	0023221f 	eoreq	r2, r3, pc, lsl r2
    4c70:	04f91200 	ldrbteq	r1, [r9], #512	; 0x200
    4c74:	00004ca5 	andeq	r4, r0, r5, lsr #25
    4c78:	c61f0124 	ldrgt	r0, [pc], -r4, lsr #2
    4c7c:	12000034 	andne	r0, r0, #52	; 0x34
    4c80:	4cb004fb 	cfldrsmi	mvf0, [r0], #1004	; 0x3ec
    4c84:	01280000 			; <UNDEFINED> instruction: 0x01280000
    4c88:	0024b51f 	eoreq	fp, r4, pc, lsl r5
    4c8c:	04fd1200 	ldrbteq	r1, [sp], #512	; 0x200
    4c90:	00004cb0 			; <UNDEFINED> instruction: 0x00004cb0
    4c94:	611e012c 	tstvs	lr, ip, lsr #2
    4c98:	12006776 	andne	r6, r0, #30932992	; 0x1d80000
    4c9c:	4a050502 	bmi	1460ac <unflatten_and_copy_device_tree+0x145238>
    4ca0:	01300000 	teqeq	r0, r0
    4ca4:	ce040800 	cdpgt	8, 0, cr0, cr4, cr0, {0}
    4ca8:	1600004b 	strne	r0, [r0], -fp, asr #32
    4cac:	000034c6 	andeq	r3, r0, r6, asr #9
    4cb0:	4cab0408 	cfstrsmi	mvf0, [fp], #32
    4cb4:	891a0000 	ldmdbhi	sl, {}	; <UNPREDICTABLE>
    4cb8:	18000020 	stmdane	r0, {r5}
    4cbc:	05050612 	streq	r0, [r5, #-1554]	; 0xfffff9ee
    4cc0:	1b00004d 	blne	4dfc <.debug_info+0x4dfc>
    4cc4:	00004ebf 			; <UNDEFINED> instruction: 0x00004ebf
    4cc8:	c7050712 	smladgt	r5, r2, r7, r0
    4ccc:	00000002 	andeq	r0, r0, r2
    4cd0:	00605c1b 	rsbeq	r5, r0, fp, lsl ip
    4cd4:	05081200 	streq	r1, [r8, #-512]	; 0xfffffe00
    4cd8:	000000d4 	ldrdeq	r0, [r0], -r4
    4cdc:	06dc1b08 	ldrbeq	r1, [ip], r8, lsl #22
    4ce0:	09120000 	ldmdbeq	r2, {}	; <UNPREDICTABLE>
    4ce4:	0000d405 	andeq	sp, r0, r5, lsl #8
    4ce8:	431b0c00 	tstmi	fp, #0, 24
    4cec:	1200000d 	andne	r0, r0, #13
    4cf0:	0069050a 	rsbeq	r0, r9, sl, lsl #10
    4cf4:	1b100000 	blne	404cfc <unflatten_and_copy_device_tree+0x403e88>
    4cf8:	000022ce 	andeq	r2, r0, lr, asr #5
    4cfc:	05050c12 	streq	r0, [r5, #-3090]	; 0xfffff3ee
    4d00:	1400004d 	strne	r0, [r0], #-77	; 0xffffffb3
    4d04:	b6040800 	strlt	r0, [r4], -r0, lsl #16
    4d08:	1a00004c 	bne	4e40 <.debug_info+0x4e40>
    4d0c:	00002955 	andeq	r2, r0, r5, asr r9
    4d10:	05161288 	ldreq	r1, [r6, #-648]	; 0xfffffd78
    4d14:	00004dc2 	andeq	r4, r0, r2, asr #27
    4d18:	000a701b 	andeq	r7, sl, fp, lsl r0
    4d1c:	05171200 	ldreq	r1, [r7, #-512]	; 0xfffffe00
    4d20:	00001a6b 	andeq	r1, r0, fp, ror #20
    4d24:	4a331b00 	bmi	cc6c08 <unflatten_and_copy_device_tree+0xcc5d94>
    4d28:	1e120000 	cdpne	0, 1, cr0, cr2, cr0, {0}
    4d2c:	0000c905 	andeq	ip, r0, r5, lsl #18
    4d30:	a01b1000 	andsge	r1, fp, r0
    4d34:	12000046 	andne	r0, r0, #70	; 0x46
    4d38:	00c9051f 	sbceq	r0, r9, pc, lsl r5
    4d3c:	1b180000 	blne	604d44 <unflatten_and_copy_device_tree+0x603ed0>
    4d40:	000003a8 	andeq	r0, r0, r8, lsr #7
    4d44:	c9052012 	stmdbgt	r5, {r1, r4, sp}
    4d48:	20000000 	andcs	r0, r0, r0
    4d4c:	0006851b 	andeq	r8, r6, fp, lsl r5
    4d50:	05211200 	streq	r1, [r1, #-512]!	; 0xfffffe00
    4d54:	000000c9 	andeq	r0, r0, r9, asr #1
    4d58:	2b841b28 	blcs	fe106ca8 <__crc_of_fdt_unflatten_tree+0x773c56eb>
    4d5c:	28120000 	ldmdacs	r2, {}	; <UNPREDICTABLE>
    4d60:	0000be05 	andeq	fp, r0, r5, lsl #28
    4d64:	ea1b3000 	b	6cc008 <unflatten_and_copy_device_tree+0x6cb194>
    4d68:	1200002d 	andne	r0, r0, #45	; 0x2d
    4d6c:	00c90529 	sbceq	r0, r9, r9, lsr #10
    4d70:	1b380000 	blne	e04d78 <unflatten_and_copy_device_tree+0xe03f04>
    4d74:	0000596a 	andeq	r5, r0, sl, ror #18
    4d78:	69052a12 	stmdbvs	r5, {r1, r4, r9, fp, sp}
    4d7c:	40000000 	andmi	r0, r0, r0
    4d80:	000bb51b 	andeq	fp, fp, fp, lsl r5
    4d84:	053e1200 	ldreq	r1, [lr, #-512]!	; 0xfffffe00
    4d88:	00000057 	andeq	r0, r0, r7, asr r0
    4d8c:	32661b44 	rsbcc	r1, r6, #68, 22	; 0x11000
    4d90:	3e120000 	cdpcc	0, 1, cr0, cr2, cr0, {0}
    4d94:	00005705 	andeq	r5, r0, r5, lsl #14
    4d98:	5b1b4800 	blpl	6d2008 <unflatten_and_copy_device_tree+0x6d1194>
    4d9c:	1200003c 	andne	r0, r0, #60	; 0x3c
    4da0:	0057053e 	subseq	r0, r7, lr, lsr r5
    4da4:	1b4c0000 	blne	1304dac <unflatten_and_copy_device_tree+0x1303f38>
    4da8:	0000521c 	andeq	r5, r0, ip, lsl r2
    4dac:	57053e12 	smladpl	r5, r2, lr, r3
    4db0:	50000000 	andpl	r0, r0, r0
    4db4:	0044ef1b 	subeq	lr, r4, fp, lsl pc
    4db8:	05441200 	strbeq	r1, [r4, #-512]	; 0xfffffe00
    4dbc:	00002e9b 	muleq	r0, fp, lr
    4dc0:	04220058 	strteq	r0, [r2], #-88	; 0xffffffa8
    4dc4:	00054812 	andeq	r4, r5, r2, lsl r8
    4dc8:	1b00004e 	blne	4f08 <.debug_info+0x4f08>
    4dcc:	00006299 	muleq	r0, r9, r2
    4dd0:	93054912 	movwls	r4, #22802	; 0x5912
    4dd4:	00000000 	andeq	r0, r0, r0
    4dd8:	002e781b 	eoreq	r7, lr, fp, lsl r8
    4ddc:	054a1200 	strbeq	r1, [sl, #-512]	; 0xfffffe00
    4de0:	00000093 	muleq	r0, r3, r0
    4de4:	2a941b01 	bcs	fe506c0c <__crc_of_fdt_unflatten_tree+0x777c564f>
    4de8:	4b120000 	blmi	484df0 <unflatten_and_copy_device_tree+0x483f7c>
    4dec:	00009305 	andeq	r9, r0, r5, lsl #6
    4df0:	701d0200 	andsvc	r0, sp, r0, lsl #4
    4df4:	12006461 	andne	r6, r0, #1627389952	; 0x61000000
    4df8:	0093054c 	addseq	r0, r3, ip, asr #10
    4dfc:	00030000 	andeq	r0, r3, r0
    4e00:	002f4735 	eoreq	r4, pc, r5, lsr r7	; <UNPREDICTABLE>
    4e04:	47120400 	ldrmi	r0, [r2, -r0, lsl #8]
    4e08:	004e2205 	subeq	r2, lr, r5, lsl #4
    4e0c:	00623600 	rsbeq	r3, r2, r0, lsl #12
    4e10:	c2054d12 	andgt	r4, r5, #1152	; 0x480
    4e14:	3600004d 	strcc	r0, [r0], -sp, asr #32
    4e18:	4e120073 	mrcmi	0, 0, r0, cr2, cr3, {3}
    4e1c:	0000b305 	andeq	fp, r0, r5, lsl #6
    4e20:	a0240000 	eorge	r0, r4, r0
    4e24:	0400001e 	streq	r0, [r0], #-30	; 0xffffffe2
    4e28:	00000057 	andeq	r0, r0, r7, asr r0
    4e2c:	4c055212 	sfmmi	f5, 4, [r5], {18}
    4e30:	3700004e 	strcc	r0, [r0, -lr, asr #32]
    4e34:	00000fa0 	andeq	r0, r0, r0, lsr #31
    4e38:	2dfe0b7f 	ldclcs	11, cr0, [lr, #508]!	; 0x1fc
    4e3c:	0b000000 	bleq	4e44 <.debug_info+0x4e44>
    4e40:	0000572a 	andeq	r5, r0, sl, lsr #14
    4e44:	4c9c0b01 	fldmiaxmi	ip, {d0-d-1}	;@ Deprecated
    4e48:	00020000 	andeq	r0, r2, r0
    4e4c:	0001332c 	andeq	r3, r1, ip, lsr #6
    4e50:	3f281600 	svccc	0x00281600
    4e54:	04080000 	streq	r0, [r8], #-0
    4e58:	00004e5c 	andeq	r4, r0, ip, asr lr
    4e5c:	004e5109 	subeq	r5, lr, r9, lsl #2
    4e60:	5d471600 	stclpl	6, cr1, [r7, #-0]
    4e64:	04080000 	streq	r0, [r8], #-0
    4e68:	00004e61 	andeq	r4, r0, r1, ror #28
    4e6c:	003c9f16 	eorseq	r9, ip, r6, lsl pc
    4e70:	6c040800 	stcvs	8, cr0, [r4], {-0}
    4e74:	0600004e 	streq	r0, [r0], -lr, asr #32
    4e78:	000005a7 	andeq	r0, r0, r7, lsr #11
    4e7c:	00004e87 	andeq	r4, r0, r7, lsl #29
    4e80:	0000eb07 	andeq	lr, r0, r7, lsl #22
    4e84:	06000300 	streq	r0, [r0], -r0, lsl #6
    4e88:	00002d90 	muleq	r0, r0, sp
    4e8c:	00004e97 	muleq	r0, r7, lr
    4e90:	0000eb07 	andeq	lr, r0, r7, lsl #22
    4e94:	08000200 	stmdaeq	r0, {r9}
    4e98:	004e9d04 	subeq	r9, lr, r4, lsl #26
    4e9c:	33530900 	cmpcc	r3, #0, 18
    4ea0:	f8060000 			; <UNDEFINED> instruction: 0xf8060000
    4ea4:	b2000000 	andlt	r0, r0, #0
    4ea8:	0700004e 	streq	r0, [r0, -lr, asr #32]
    4eac:	000000eb 	andeq	r0, r0, fp, ror #1
    4eb0:	7916000f 	ldmdbvc	r6, {r0, r1, r2, r3}
    4eb4:	08000044 	stmdaeq	r0, {r2, r6}
    4eb8:	004eb204 	subeq	fp, lr, r4, lsl #4
    4ebc:	01841600 	orreq	r1, r4, r0, lsl #12
    4ec0:	04080000 	streq	r0, [r8], #-0
    4ec4:	00004ebd 			; <UNDEFINED> instruction: 0x00004ebd
    4ec8:	002ade16 	eoreq	sp, sl, r6, lsl lr
    4ecc:	c8040800 	stmdagt	r4, {fp}
    4ed0:	0800004e 	stmdaeq	r0, {r1, r2, r3, r6}
    4ed4:	00437004 	subeq	r7, r3, r4
    4ed8:	9c040800 	stcls	8, cr0, [r4], {-0}
    4edc:	16000041 	strne	r0, [r0], -r1, asr #32
    4ee0:	00000032 	andeq	r0, r0, r2, lsr r0
    4ee4:	4edf0408 	cdpmi	4, 13, cr0, cr15, cr8, {0}
    4ee8:	60160000 	andsvs	r0, r6, r0
    4eec:	08000064 	stmdaeq	r0, {r2, r5, r6}
    4ef0:	004eea04 	subeq	lr, lr, r4, lsl #20
    4ef4:	159a1600 	ldrne	r1, [sl, #1536]	; 0x600
    4ef8:	04080000 	streq	r0, [r8], #-0
    4efc:	00004ef5 	strdeq	r4, [r0], -r5
    4f00:	004ced16 	subeq	lr, ip, r6, lsl sp
    4f04:	00040800 	andeq	r0, r4, r0, lsl #16
    4f08:	1600004f 	strne	r0, [r0], -pc, asr #32
    4f0c:	00004e2c 	andeq	r4, r0, ip, lsr #28
    4f10:	4f0b0408 	svcmi	0x000b0408
    4f14:	e3160000 	tst	r6, #0
    4f18:	0800000a 	stmdaeq	r0, {r1, r3}
    4f1c:	004f1604 	subeq	r1, pc, r4, lsl #12
    4f20:	46951600 	ldrmi	r1, [r5], r0, lsl #12
    4f24:	04080000 	streq	r0, [r8], #-0
    4f28:	00004f21 	andeq	r4, r0, r1, lsr #30
    4f2c:	2c380408 	cfldrscs	mvf0, [r8], #-32	; 0xffffffe0
    4f30:	1f160000 	svcne	0x00160000
    4f34:	08000038 	stmdaeq	r0, {r3, r4, r5}
    4f38:	004f3204 	subeq	r3, pc, r4, lsl #4
    4f3c:	41341600 	teqmi	r4, r0, lsl #12
    4f40:	04080000 	streq	r0, [r8], #-0
    4f44:	00004f3d 	andeq	r4, r0, sp, lsr pc
    4f48:	004f5806 	subeq	r5, pc, r6, lsl #16
    4f4c:	004f5800 	subeq	r5, pc, r0, lsl #16
    4f50:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    4f54:	00010000 	andeq	r0, r1, r0
    4f58:	4f5e0408 	svcmi	0x005e0408
    4f5c:	ed160000 	ldc	0, cr0, [r6, #-0]
    4f60:	16000048 	strne	r0, [r0], -r8, asr #32
    4f64:	00002979 	andeq	r2, r0, r9, ror r9
    4f68:	4f630408 	svcmi	0x00630408
    4f6c:	dc160000 	ldcle	0, cr0, [r6], {-0}
    4f70:	0800004b 	stmdaeq	r0, {r0, r1, r3, r6}
    4f74:	004f6e04 	subeq	r6, pc, r4, lsl #28
    4f78:	19040800 	stmdbne	r4, {fp}
    4f7c:	1000001f 	andne	r0, r0, pc, lsl r0
    4f80:	00006335 	andeq	r6, r0, r5, lsr r3
    4f84:	b0ce4d0c 	sbclt	r4, lr, ip, lsl #26
    4f88:	0f00004f 	svceq	0x0000004f
    4f8c:	00004862 	andeq	r4, r0, r2, ror #16
    4f90:	4fc5cf4d 	svcmi	0x00c5cf4d
    4f94:	0f000000 	svceq	0x00000000
    4f98:	0000034a 	andeq	r0, r0, sl, asr #6
    4f9c:	4fdbd04d 	svcmi	0x00dbd04d
    4fa0:	0f040000 	svceq	0x00040000
    4fa4:	000060bb 	strheq	r6, [r0], -fp
    4fa8:	00d4d14d 	sbcseq	sp, r4, sp, asr #2
    4fac:	00080000 	andeq	r0, r8, r0
    4fb0:	004fc50c 	subeq	ip, pc, ip, lsl #10
    4fb4:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    4fb8:	d40d0000 	strle	r0, [sp], #-0
    4fbc:	0d000000 	stceq	0, cr0, [r0, #-0]
    4fc0:	000005a7 	andeq	r0, r0, r7, lsr #11
    4fc4:	b0040800 	andlt	r0, r4, r0, lsl #16
    4fc8:	0c00004f 	stceq	0, cr0, [r0], {79}	; 0x4f
    4fcc:	00004fdb 	ldrdeq	r4, [r0], -fp
    4fd0:	0000d40d 	andeq	sp, r0, sp, lsl #8
    4fd4:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    4fd8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    4fdc:	004fcb04 	subeq	ip, pc, r4, lsl #22
    4fe0:	06eb1000 	strbteq	r1, [fp], r0
    4fe4:	2d1c0000 	ldccs	0, cr0, [ip, #-0]
    4fe8:	005042e6 	subseq	r4, r0, r6, ror #5
    4fec:	596a0f00 	stmdbpl	sl!, {r8, r9, sl, fp}^
    4ff0:	e72d0000 	str	r0, [sp, -r0]!
    4ff4:	00000069 	andeq	r0, r0, r9, rrx
    4ff8:	30030f00 	andcc	r0, r3, r0, lsl #30
    4ffc:	e82d0000 	stmda	sp!, {}	; <UNPREDICTABLE>
    5000:	000000d4 	ldrdeq	r0, [r0], -r4
    5004:	318e0f04 	orrcc	r0, lr, r4, lsl #30
    5008:	e92d0000 	push	{}	; <UNPREDICTABLE>
    500c:	00000378 	andeq	r0, r0, r8, ror r3
    5010:	58090f08 	stmdapl	r9, {r3, r8, r9, sl, fp}
    5014:	eb2d0000 	bl	b4501c <unflatten_and_copy_device_tree+0xb441a8>
    5018:	00000564 	andeq	r0, r0, r4, ror #10
    501c:	2b350f0c 	blcs	d43c38 <unflatten_and_copy_device_tree+0xd42dc4>
    5020:	ec2d0000 	stc	0, cr0, [sp], #-0
    5024:	00000564 	andeq	r0, r0, r4, ror #10
    5028:	18d00f10 	ldmne	r0, {r4, r8, r9, sl, fp}^
    502c:	f22d0000 	vhadd.s32	d0, d13, d0
    5030:	000000d4 	ldrdeq	r0, [r0], -r4
    5034:	74701414 	ldrbtvc	r1, [r0], #-1044	; 0xfffffbec
    5038:	f42d0065 	vld4.16	{d0-d3}, [sp :128], r5
    503c:	000027c1 	andeq	r2, r0, r1, asr #15
    5040:	4d0c0018 	stcmi	0, cr0, [ip, #-96]	; 0xffffffa0
    5044:	0d000050 	stceq	0, cr0, [r0, #-320]	; 0xfffffec0
    5048:	000005a7 	andeq	r0, r0, r7, lsr #11
    504c:	42040800 	andmi	r0, r4, #0, 16
    5050:	15000050 	strne	r0, [r0, #-80]	; 0xffffffb0
    5054:	00000057 	andeq	r0, r0, r7, asr r0
    5058:	00005062 	andeq	r5, r0, r2, rrx
    505c:	0005a70d 	andeq	sl, r5, sp, lsl #14
    5060:	04080000 	streq	r0, [r8], #-0
    5064:	00005053 	andeq	r5, r0, r3, asr r0
    5068:	00005715 	andeq	r5, r0, r5, lsl r7
    506c:	00507c00 	subseq	r7, r0, r0, lsl #24
    5070:	05a70d00 	streq	r0, [r7, #3328]!	; 0xd00
    5074:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    5078:	00000050 	andeq	r0, r0, r0, asr r0
    507c:	4fe10408 	svcmi	0x00e10408
    5080:	04080000 	streq	r0, [r8], #-0
    5084:	00005068 	andeq	r5, r0, r8, rrx
    5088:	00005715 	andeq	r5, r0, r5, lsl r7
    508c:	0050a600 	subseq	sl, r0, r0, lsl #12
    5090:	05a70d00 	streq	r0, [r7, #3328]!	; 0xd00
    5094:	d40d0000 	strle	r0, [sp], #-0
    5098:	0d000000 	stceq	0, cr0, [r0, #-0]
    509c:	000050a6 	andeq	r5, r0, r6, lsr #1
    50a0:	0000690d 	andeq	r6, r0, sp, lsl #18
    50a4:	04080000 	streq	r0, [r8], #-0
    50a8:	000006c4 	andeq	r0, r0, r4, asr #13
    50ac:	50880408 	addpl	r0, r8, r8, lsl #8
    50b0:	c20c0000 	andgt	r0, ip, #0
    50b4:	0d000050 	stceq	0, cr0, [r0, #-320]	; 0xfffffec0
    50b8:	000005a7 	andeq	r0, r0, r7, lsr #11
    50bc:	00507c0d 	subseq	r7, r0, sp, lsl #24
    50c0:	04080000 	streq	r0, [r8], #-0
    50c4:	000050b2 	strheq	r5, [r0], -r2
    50c8:	00005715 	andeq	r5, r0, r5, lsl r7
    50cc:	0050eb00 	subseq	lr, r0, r0, lsl #22
    50d0:	05a70d00 	streq	r0, [r7, #3328]!	; 0xd00
    50d4:	d40d0000 	strle	r0, [sp], #-0
    50d8:	0d000000 	stceq	0, cr0, [r0, #-0]
    50dc:	00000378 	andeq	r0, r0, r8, ror r3
    50e0:	0000570d 	andeq	r5, r0, sp, lsl #14
    50e4:	00570d00 	subseq	r0, r7, r0, lsl #26
    50e8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    50ec:	0050c804 	subseq	ip, r0, r4, lsl #16
    50f0:	00f21500 	rscseq	r1, r2, r0, lsl #10
    50f4:	51000000 	mrspl	r0, (UNDEF: 0)
    50f8:	a70d0000 	strge	r0, [sp, -r0]
    50fc:	00000005 	andeq	r0, r0, r5
    5100:	50f10408 	rscspl	r0, r1, r8, lsl #8
    5104:	64150000 	ldrvs	r0, [r5], #-0
    5108:	1a000005 	bne	5124 <.debug_info+0x5124>
    510c:	0d000051 	stceq	0, cr0, [r0, #-324]	; 0xfffffebc
    5110:	000005a7 	andeq	r0, r0, r7, lsr #11
    5114:	0000d40d 	andeq	sp, r0, sp, lsl #8
    5118:	04080000 	streq	r0, [r8], #-0
    511c:	00005106 	andeq	r5, r0, r6, lsl #2
    5120:	002d3a23 	eoreq	r3, sp, r3, lsr #20
    5124:	020f2d00 	andeq	r2, pc, #0, 26
    5128:	0000512c 	andeq	r5, r0, ip, lsr #2
    512c:	0051370c 	subseq	r3, r1, ip, lsl #14
    5130:	05640d00 	strbeq	r0, [r4, #-3328]!	; 0xfffff300
    5134:	26000000 	strcs	r0, [r0], -r0
    5138:	00001375 	andeq	r1, r0, r5, ror r3
    513c:	00006904 	andeq	r6, r0, r4, lsl #18
    5140:	c2184e00 	andsgt	r4, r8, #0, 28
    5144:	0b000052 	bleq	5294 <.debug_info+0x5294>
    5148:	000011a6 	andeq	r1, r0, r6, lsr #3
    514c:	3b990b00 	blcc	fe642c08 <__crc_of_fdt_unflatten_tree+0x7790164b>
    5150:	0b010000 	bleq	45158 <unflatten_and_copy_device_tree+0x442e4>
    5154:	00006431 	andeq	r6, r0, r1, lsr r4
    5158:	05860b02 	streq	r0, [r6, #2818]	; 0xb02
    515c:	0b030000 	bleq	c5164 <unflatten_and_copy_device_tree+0xc42f0>
    5160:	00000400 	andeq	r0, r0, r0, lsl #8
    5164:	30c40b04 	sbccc	r0, r4, r4, lsl #22
    5168:	0b050000 	bleq	145170 <unflatten_and_copy_device_tree+0x1442fc>
    516c:	00005af5 	strdeq	r5, [r0], -r5	; <UNPREDICTABLE>
    5170:	4b4d0b06 	blmi	1342c20 <unflatten_and_copy_device_tree+0x1341dac>
    5174:	0b070000 	bleq	1c517c <unflatten_and_copy_device_tree+0x1c4308>
    5178:	000063c3 	andeq	r6, r0, r3, asr #7
    517c:	63220b08 			; <UNDEFINED> instruction: 0x63220b08
    5180:	0b090000 	bleq	245188 <unflatten_and_copy_device_tree+0x244314>
    5184:	000033fd 	strdeq	r3, [r0], -sp
    5188:	5fea0b0a 	svcpl	0x00ea0b0a
    518c:	0b0b0000 	bleq	2c5194 <unflatten_and_copy_device_tree+0x2c4320>
    5190:	000043e0 	andeq	r4, r0, r0, ror #7
    5194:	2a730b0c 	bcs	1cc2c38 <unflatten_and_copy_device_tree+0x1cc1dc4>
    5198:	0b0d0000 	bleq	3451a0 <unflatten_and_copy_device_tree+0x34432c>
    519c:	00000315 	andeq	r0, r0, r5, lsl r3
    51a0:	0b140b0e 	bleq	502c40 <unflatten_and_copy_device_tree+0x501dcc>
    51a4:	0b0f0000 	bleq	3c51ac <unflatten_and_copy_device_tree+0x3c4338>
    51a8:	00001f5e 	andeq	r1, r0, lr, asr pc
    51ac:	3ea50b10 	vdupcc.32	<illegal reg q2.5>, r0
    51b0:	0b110000 	bleq	4451b8 <unflatten_and_copy_device_tree+0x444344>
    51b4:	00001088 	andeq	r1, r0, r8, lsl #1
    51b8:	31730b12 	cmncc	r3, r2, lsl fp
    51bc:	0b130000 	bleq	4c51c4 <unflatten_and_copy_device_tree+0x4c4350>
    51c0:	00003245 	andeq	r3, r0, r5, asr #4
    51c4:	16350b14 			; <UNDEFINED> instruction: 0x16350b14
    51c8:	0b150000 	bleq	5451d0 <unflatten_and_copy_device_tree+0x54435c>
    51cc:	0000526f 	andeq	r5, r0, pc, ror #4
    51d0:	3f9f0b16 	svccc	0x009f0b16
    51d4:	0b170000 	bleq	5c51dc <unflatten_and_copy_device_tree+0x5c4368>
    51d8:	00001c50 	andeq	r1, r0, r0, asr ip
    51dc:	37dc0b18 	bficc	r0, r8, #22, #7
    51e0:	0b190000 	bleq	6451e8 <unflatten_and_copy_device_tree+0x644374>
    51e4:	00003542 	andeq	r3, r0, r2, asr #10
    51e8:	21a80b1a 			; <UNDEFINED> instruction: 0x21a80b1a
    51ec:	0b1b0000 	bleq	6c51f4 <unflatten_and_copy_device_tree+0x6c4380>
    51f0:	000029ce 	andeq	r2, r0, lr, asr #19
    51f4:	0f170b1c 	svceq	0x00170b1c
    51f8:	0b1d0000 	bleq	745200 <unflatten_and_copy_device_tree+0x74438c>
    51fc:	00003db9 			; <UNDEFINED> instruction: 0x00003db9
    5200:	20600b1e 	rsbcs	r0, r0, lr, lsl fp
    5204:	0b1f0000 	bleq	7c520c <unflatten_and_copy_device_tree+0x7c4398>
    5208:	00001327 	andeq	r1, r0, r7, lsr #6
    520c:	0ed00b20 	vfnmseq.f64	d16, d0, d16
    5210:	0b210000 	bleq	845218 <unflatten_and_copy_device_tree+0x8443a4>
    5214:	00005611 	andeq	r5, r0, r1, lsl r6
    5218:	568d0b22 	strpl	r0, [sp], r2, lsr #22
    521c:	0b230000 	bleq	8c5224 <unflatten_and_copy_device_tree+0x8c43b0>
    5220:	00002dd8 	ldrdeq	r2, [r0], -r8
    5224:	2be90b24 	blcs	ffa42c98 <__crc_of_fdt_unflatten_tree+0x78d016db>
    5228:	0b250000 	bleq	945230 <unflatten_and_copy_device_tree+0x9443bc>
    522c:	0000165b 	andeq	r1, r0, fp, asr r6
    5230:	12420b26 	subne	r0, r2, #38912	; 0x9800
    5234:	0b270000 	bleq	9c523c <unflatten_and_copy_device_tree+0x9c43c8>
    5238:	00002887 	andeq	r2, r0, r7, lsl #17
    523c:	564e0b28 	strbpl	r0, [lr], -r8, lsr #22
    5240:	0b290000 	bleq	a45248 <unflatten_and_copy_device_tree+0xa443d4>
    5244:	0000345a 	andeq	r3, r0, sl, asr r4
    5248:	4f580b2a 	svcmi	0x00580b2a
    524c:	0b2b0000 	bleq	ac5254 <unflatten_and_copy_device_tree+0xac43e0>
    5250:	00004bbe 			; <UNDEFINED> instruction: 0x00004bbe
    5254:	07a80b2c 	streq	r0, [r8, ip, lsr #22]!
    5258:	0b2d0000 	bleq	b45260 <unflatten_and_copy_device_tree+0xb443ec>
    525c:	00004cc3 	andeq	r4, r0, r3, asr #25
    5260:	047a0b2e 	ldrbteq	r0, [sl], #-2862	; 0xfffff4d2
    5264:	0b2f0000 	bleq	bc526c <unflatten_and_copy_device_tree+0xbc43f8>
    5268:	00000836 	andeq	r0, r0, r6, lsr r8
    526c:	0a0d0b30 	beq	342cc8 <unflatten_and_copy_device_tree+0x341e54>
    5270:	0b310000 	bleq	c45278 <unflatten_and_copy_device_tree+0xc44404>
    5274:	000006c5 	andeq	r0, r0, r5, asr #13
    5278:	429e0b32 	addsmi	r0, lr, #51200	; 0xc800
    527c:	0b330000 	bleq	cc5284 <unflatten_and_copy_device_tree+0xcc4410>
    5280:	0000285b 	andeq	r2, r0, fp, asr r8
    5284:	26110b34 			; <UNDEFINED> instruction: 0x26110b34
    5288:	0b350000 	bleq	d45290 <unflatten_and_copy_device_tree+0xd4441c>
    528c:	00005259 	andeq	r5, r0, r9, asr r2
    5290:	1fb80b36 	svcne	0x00b80b36
    5294:	0b370000 	bleq	dc529c <unflatten_and_copy_device_tree+0xdc4428>
    5298:	00000431 	andeq	r0, r0, r1, lsr r4
    529c:	02720b38 	rsbseq	r0, r2, #56, 22	; 0xe000
    52a0:	0b390000 	bleq	e452a8 <unflatten_and_copy_device_tree+0xe44434>
    52a4:	00003976 	andeq	r3, r0, r6, ror r9
    52a8:	54ae0b3a 	strtpl	r0, [lr], #2874	; 0xb3a
    52ac:	0b3b0000 	bleq	ec52b4 <unflatten_and_copy_device_tree+0xec4440>
    52b0:	00002ace 	andeq	r2, r0, lr, asr #21
    52b4:	25930b3c 	ldrcs	r0, [r3, #2876]	; 0xb3c
    52b8:	0b3d0000 	bleq	f452c0 <unflatten_and_copy_device_tree+0xf4444c>
    52bc:	0000199e 	muleq	r0, lr, r9
    52c0:	2e10003e 	mrccs	0, 0, r0, cr0, cr14, {1}
    52c4:	f8000058 			; <UNDEFINED> instruction: 0xf8000058
    52c8:	52db184f 	sbcspl	r1, fp, #5177344	; 0x4f0000
    52cc:	750f0000 	strvc	r0, [pc, #-0]	; 8 <.debug_info+0x8>
    52d0:	4f00000f 	svcmi	0x0000000f
    52d4:	0052db19 	subseq	sp, r2, r9, lsl fp
    52d8:	06000000 	streq	r0, [r0], -r0
    52dc:	000000d4 	ldrdeq	r0, [r0], -r4
    52e0:	000052eb 	andeq	r5, r0, fp, ror #5
    52e4:	0000eb07 	andeq	lr, r0, r7, lsl #22
    52e8:	10003d00 	andne	r3, r0, r0, lsl #26
    52ec:	00002eab 	andeq	r2, r0, fp, lsr #29
    52f0:	1c4a4a0c 	mcrrne	10, 0, r4, sl, cr12
    52f4:	0f000053 	svceq	0x00000053
    52f8:	000046e8 	andeq	r4, r0, r8, ror #13
    52fc:	00d44b4a 	sbcseq	r4, r4, sl, asr #22
    5300:	0f000000 	svceq	0x00000000
    5304:	00004fb7 			; <UNDEFINED> instruction: 0x00004fb7
    5308:	1aa24d4a 	bne	fe898838 <__crc_of_fdt_unflatten_tree+0x77b5727b>
    530c:	0f040000 	svceq	0x00040000
    5310:	00003df8 	strdeq	r3, [r0], -r8
    5314:	3d28534a 	stccc	3, cr5, [r8, #-296]!	; 0xfffffed8
    5318:	00080000 	andeq	r0, r8, r0
    531c:	0011c710 	andseq	ip, r1, r0, lsl r7
    5320:	564a0400 	strbpl	r0, [sl], -r0, lsl #8
    5324:	00005335 	andeq	r5, r0, r5, lsr r3
    5328:	0002510f 	andeq	r5, r2, pc, lsl #2
    532c:	31574a00 	cmpcc	r7, r0, lsl #20
    5330:	00000038 	andeq	r0, r0, r8, lsr r0
    5334:	5e7a1000 	cdppl	0, 7, cr1, cr10, cr0, {0}
    5338:	4a180000 	bmi	605340 <unflatten_and_copy_device_tree+0x6044cc>
    533c:	0053725a 	subseq	r7, r3, sl, asr r2
    5340:	706f1400 	rsbvc	r1, pc, r0, lsl #8
    5344:	5b4a0073 	blpl	1285518 <unflatten_and_copy_device_tree+0x12846a4>
    5348:	00005372 	andeq	r5, r0, r2, ror r3
    534c:	5e2a0f00 	cdppl	15, 2, cr0, cr10, cr0, {0}
    5350:	5c4a0000 	marpl	acc0, r0, sl
    5354:	00005382 	andeq	r5, r0, r2, lsl #7
    5358:	0c6b0f04 	stcleq	15, cr0, [fp], #-16
    535c:	5d4a0000 	stclpl	0, cr0, [sl, #-0]
    5360:	00000223 	andeq	r0, r0, r3, lsr #4
    5364:	342c0f08 	strtcc	r0, [ip], #-3848	; 0xfffff0f8
    5368:	5e4a0000 	cdppl	0, 4, cr0, cr10, cr0, {0}
    536c:	00003831 	andeq	r3, r0, r1, lsr r8
    5370:	04080010 	streq	r0, [r8], #-16
    5374:	00005378 	andeq	r5, r0, r8, ror r3
    5378:	003e3909 	eorseq	r3, lr, r9, lsl #18
    537c:	1b311600 	blne	c45808 <unflatten_and_copy_device_tree+0xc44994>
    5380:	04080000 	streq	r0, [r8], #-0
    5384:	0000537d 	andeq	r5, r0, sp, ror r3
    5388:	7d4a1817 	stclvc	8, cr1, [sl, #-92]	; 0xffffffa4
    538c:	000053b2 			; <UNDEFINED> instruction: 0x000053b2
    5390:	7269642a 	rsbvc	r6, r9, #704643072	; 0x2a000000
    5394:	eb7e4a00 	bl	1f97b9c <unflatten_and_copy_device_tree+0x1f96d28>
    5398:	18000052 	stmdane	r0, {r1, r4, r6}
    539c:	00004a19 	andeq	r4, r0, r9, lsl sl
    53a0:	531c7f4a 	tstpl	ip, #296	; 0x128
    53a4:	8d180000 	ldchi	0, cr0, [r8, #-0]
    53a8:	4a00001c 	bmi	5420 <.debug_info+0x5420>
    53ac:	00533580 	subseq	r3, r3, r0, lsl #11
    53b0:	ed160000 	ldc	0, cr0, [r6, #-0]
    53b4:	0800004a 	stmdaeq	r0, {r1, r3, r6}
    53b8:	0053b204 	subseq	fp, r3, r4, lsl #4
    53bc:	0ef01000 	cdpeq	0, 15, cr1, cr0, cr0, {0}
    53c0:	4a140000 	bmi	5053c8 <unflatten_and_copy_device_tree+0x504554>
    53c4:	00540692 			; <UNDEFINED> instruction: 0x00540692
    53c8:	2ea00f00 	cdpcs	15, 10, cr0, cr0, cr0, {0}
    53cc:	934a0000 	movtls	r0, #40960	; 0xa000
    53d0:	0000541f 	andeq	r5, r0, pc, lsl r4
    53d4:	55ed0f00 	strbpl	r0, [sp, #3840]!	; 0xf00
    53d8:	944a0000 	strbls	r0, [sl], #-0
    53dc:	00005439 	andeq	r5, r0, r9, lsr r4
    53e0:	5b460f04 	blpl	1183c18 <unflatten_and_copy_device_tree+0x1182da4>
    53e4:	964a0000 	strbls	r0, [sl], -r0
    53e8:	00005458 	andeq	r5, r0, r8, asr r4
    53ec:	093e0f08 	ldmdbeq	lr!, {r3, r8, r9, sl, fp}
    53f0:	984a0000 	stmdals	sl, {}^	; <UNPREDICTABLE>
    53f4:	0000546d 	andeq	r5, r0, sp, ror #8
    53f8:	33440f0c 	movtcc	r0, #20236	; 0x4f0c
    53fc:	994a0000 	stmdbls	sl, {}^	; <UNPREDICTABLE>
    5400:	0000548c 	andeq	r5, r0, ip, lsl #9
    5404:	57150010 			; <UNDEFINED> instruction: 0x57150010
    5408:	1f000000 	svcne	0x00000000
    540c:	0d000054 	stceq	0, cr0, [r0, #-336]	; 0xfffffeb0
    5410:	00003d28 	andeq	r3, r0, r8, lsr #26
    5414:	001abb0d 	andseq	fp, sl, sp, lsl #22
    5418:	01b30d00 			; <UNDEFINED> instruction: 0x01b30d00
    541c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    5420:	00540604 	subseq	r0, r4, r4, lsl #12
    5424:	00571500 	subseq	r1, r7, r0, lsl #10
    5428:	54390000 	ldrtpl	r0, [r9], #-0
    542c:	060d0000 	streq	r0, [sp], -r0
    5430:	0d00003f 	stceq	0, cr0, [r0, #-252]	; 0xffffff04
    5434:	00003d28 	andeq	r3, r0, r8, lsr #26
    5438:	25040800 	strcs	r0, [r4, #-2048]	; 0xfffff800
    543c:	15000054 	strne	r0, [r0, #-84]	; 0xffffffac
    5440:	00000057 	andeq	r0, r0, r7, asr r0
    5444:	00005458 	andeq	r5, r0, r8, asr r4
    5448:	0038310d 	eorseq	r3, r8, sp, lsl #2
    544c:	00f20d00 	rscseq	r0, r2, r0, lsl #26
    5450:	da0d0000 	ble	345458 <unflatten_and_copy_device_tree+0x3445e4>
    5454:	00000001 	andeq	r0, r0, r1
    5458:	543f0408 	ldrtpl	r0, [pc], #-1032	; 5460 <.debug_info+0x5460>
    545c:	57150000 	ldrpl	r0, [r5, -r0]
    5460:	6d000000 	stcvs	0, cr0, [r0, #-0]
    5464:	0d000054 	stceq	0, cr0, [r0, #-336]	; 0xfffffeb0
    5468:	00003831 	andeq	r3, r0, r1, lsr r8
    546c:	5e040800 	cdppl	8, 0, cr0, cr4, cr0, {0}
    5470:	15000054 	strne	r0, [r0, #-84]	; 0xffffffac
    5474:	00000057 	andeq	r0, r0, r7, asr r0
    5478:	0000548c 	andeq	r5, r0, ip, lsl #9
    547c:	0038310d 	eorseq	r3, r8, sp, lsl #2
    5480:	38310d00 	ldmdacc	r1!, {r8, sl, fp}
    5484:	f20d0000 	vhadd.s8	d0, d13, d0
    5488:	00000000 	andeq	r0, r0, r0
    548c:	54730408 	ldrbtpl	r0, [r3], #-1032	; 0xfffffbf8
    5490:	04080000 	streq	r0, [r8], #-0
    5494:	000053bd 			; <UNDEFINED> instruction: 0x000053bd
    5498:	00005715 	andeq	r5, r0, r5, lsl r7
    549c:	0054ac00 	subseq	sl, r4, r0, lsl #24
    54a0:	40590d00 	subsmi	r0, r9, r0, lsl #26
    54a4:	a70d0000 	strge	r0, [sp, -r0]
    54a8:	00000005 	andeq	r0, r0, r5
    54ac:	54980408 	ldrpl	r0, [r8], #1032	; 0x408
    54b0:	96260000 	strtls	r0, [r6], -r0
    54b4:	04000017 	streq	r0, [r0], #-23	; 0xffffffe9
    54b8:	00000069 	andeq	r0, r0, r9, rrx
    54bc:	54d51b50 	ldrbpl	r1, [r5], #2896	; 0xb50
    54c0:	760b0000 	strvc	r0, [fp], -r0
    54c4:	00000042 	andeq	r0, r0, r2, asr #32
    54c8:	004a980b 	subeq	r9, sl, fp, lsl #16
    54cc:	380b0100 	stmdacc	fp, {r8}
    54d0:	0200003c 	andeq	r0, r0, #60	; 0x3c
    54d4:	3f4b1000 	svccc	0x004b1000
    54d8:	50180000 	andspl	r0, r8, r0
    54dc:	00552a28 	subseq	r2, r5, r8, lsr #20
    54e0:	357e0f00 	ldrbcc	r0, [lr, #-3840]!	; 0xfffff100
    54e4:	29500000 	ldmdbcs	r0, {}^	; <UNPREDICTABLE>
    54e8:	000054b2 			; <UNDEFINED> instruction: 0x000054b2
    54ec:	10a70f00 	adcne	r0, r7, r0, lsl #30
    54f0:	2a500000 	bcs	14054f8 <unflatten_and_copy_device_tree+0x1404684>
    54f4:	000026c1 	andeq	r2, r0, r1, asr #13
    54f8:	274e0f04 	strbcs	r0, [lr, -r4, lsl #30]
    54fc:	2b500000 	blcs	1405504 <unflatten_and_copy_device_tree+0x1404690>
    5500:	0000552f 	andeq	r5, r0, pc, lsr #10
    5504:	22ee0f08 	rsccs	r0, lr, #8, 30
    5508:	2c500000 	mracs	r0, r0, acc0
    550c:	0000554f 	andeq	r5, r0, pc, asr #10
    5510:	3aeb0f0c 	bcc	ffac3c38 <__crc_of_fdt_unflatten_tree+0x78d8267b>
    5514:	2d500000 	ldclcs	0, cr0, [r0, #-0]
    5518:	0000555a 	andeq	r5, r0, sl, asr r5
    551c:	33b50f10 			; <UNDEFINED> instruction: 0x33b50f10
    5520:	2e500000 	cdpcs	0, 5, cr0, cr0, cr0, {0}
    5524:	00001b6e 	andeq	r1, r0, lr, ror #22
    5528:	78120014 	ldmdavc	r2, {r2, r4}
    552c:	08000003 	stmdaeq	r0, {r0, r1}
    5530:	00552a04 	subseq	r2, r5, r4, lsl #20
    5534:	30dc1500 	sbcscc	r1, ip, r0, lsl #10
    5538:	55440000 	strbpl	r0, [r4, #-0]
    553c:	440d0000 	strmi	r0, [sp], #-0
    5540:	00000055 	andeq	r0, r0, r5, asr r0
    5544:	554a0408 	strbpl	r0, [sl, #-1032]	; 0xfffffbf8
    5548:	dd160000 	ldcle	0, cr0, [r6, #-0]
    554c:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
    5550:	00553504 	subseq	r3, r5, r4, lsl #10
    5554:	30dc1200 	sbcscc	r1, ip, r0, lsl #4
    5558:	04080000 	streq	r0, [r8], #-0
    555c:	00005555 	andeq	r5, r0, r5, asr r5
    5560:	0003c310 	andeq	ip, r3, r0, lsl r3
    5564:	15515000 	ldrbne	r5, [r1, #-0]
    5568:	00005609 	andeq	r5, r0, r9, lsl #12
    556c:	6f6e6914 	svcvs	0x006e6914
    5570:	c9165100 	ldmdbgt	r6, {r8, ip, lr}
    5574:	00000000 	andeq	r0, r0, r0
    5578:	76656414 			; <UNDEFINED> instruction: 0x76656414
    557c:	cf175100 	svcgt	0x00175100
    5580:	08000001 	stmdaeq	r0, {r0}
    5584:	005ebc0f 	subseq	fp, lr, pc, lsl #24
    5588:	da185100 	ble	619990 <unflatten_and_copy_device_tree+0x618b1c>
    558c:	0c000001 	stceq	0, cr0, [r0], {1}
    5590:	0036f00f 	eorseq	pc, r6, pc
    5594:	69195100 	ldmdbvs	r9, {r8, ip, lr}
    5598:	10000000 	andne	r0, r0, r0
    559c:	64697514 	strbtvs	r7, [r9], #-1300	; 0xfffffaec
    55a0:	421a5100 	andsmi	r5, sl, #0, 2
    55a4:	14000028 	strne	r0, [r0], #-40	; 0xffffffd8
    55a8:	64696714 	strbtvs	r6, [r9], #-1812	; 0xfffff8ec
    55ac:	621b5100 	andsvs	r5, fp, #0, 2
    55b0:	18000028 	stmdane	r0, {r3, r5}
    55b4:	0031e70f 	eorseq	lr, r1, pc, lsl #14
    55b8:	cf1c5100 	svcgt	0x001c5100
    55bc:	1c000001 	stcne	0, cr0, [r0], {1}
    55c0:	000c6b0f 	andeq	r6, ip, pc, lsl #22
    55c4:	231d5100 	tstcs	sp, #0, 2
    55c8:	20000002 	andcs	r0, r0, r2
    55cc:	001d3b0f 	andseq	r3, sp, pc, lsl #22
    55d0:	861e5100 	ldrhi	r5, [lr], -r0, lsl #2
    55d4:	28000004 	stmdacs	r0, {r2}
    55d8:	000cc50f 	andeq	ip, ip, pc, lsl #10
    55dc:	861f5100 	ldrhi	r5, [pc], -r0, lsl #2
    55e0:	30000004 	andcc	r0, r0, r4
    55e4:	003c660f 	eorseq	r6, ip, pc, lsl #12
    55e8:	86205100 	strthi	r5, [r0], -r0, lsl #2
    55ec:	38000004 	stmdacc	r0, {r2}
    55f0:	005e720f 	subseq	r7, lr, pc, lsl #4
    55f4:	d4215100 	strtle	r5, [r1], #-256	; 0xffffff00
    55f8:	40000000 	andmi	r0, r0, r0
    55fc:	0027470f 	eoreq	r4, r7, pc, lsl #14
    5600:	82225100 	eorhi	r5, r2, #0, 2
    5604:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    5608:	3a601000 	bcc	1804008 <unflatten_and_copy_device_tree+0x1803194>
    560c:	52080000 	andpl	r0, r8, #0
    5610:	00562e1d 	subseq	r2, r6, sp, lsl lr
    5614:	059b0f00 	ldreq	r0, [fp, #3840]	; 0xf00
    5618:	1e520000 	cdpne	0, 5, cr0, cr2, cr0, {0}
    561c:	000000f2 	strdeq	r0, [r0], -r2
    5620:	5ebc0f00 	cdppl	15, 11, cr0, cr12, cr0, {0}
    5624:	1f520000 	svcne	0x00520000
    5628:	000001da 	ldrdeq	r0, [r0], -sl
    562c:	04080004 	streq	r0, [r8], #-4
    5630:	00005634 	andeq	r5, r0, r4, lsr r6
    5634:	00591510 	subseq	r1, r9, r0, lsl r5
    5638:	3f532400 	svccc	0x00532400
    563c:	000056df 	ldrdeq	r5, [r0], -pc	; <UNPREDICTABLE>
    5640:	00059b0f 	andeq	r9, r5, pc, lsl #22
    5644:	f2405300 	vcgt.s8	d21, d0, d0
    5648:	00000000 	andeq	r0, r0, r0
    564c:	0044730f 	subeq	r7, r4, pc, lsl #6
    5650:	c7415300 	strbgt	r5, [r1, -r0, lsl #6]
    5654:	04000002 	streq	r0, [r0], #-2
    5658:	0023220f 	eoreq	r2, r3, pc, lsl #4
    565c:	2e425300 	cdpcs	3, 4, cr5, cr2, cr0, {0}
    5660:	0c000056 	stceq	0, cr0, [r0], {86}	; 0x56
    5664:	0047de0f 	subeq	sp, r7, pc, lsl #28
    5668:	56435300 	strbpl	r5, [r3], -r0, lsl #6
    566c:	10000058 	andne	r0, r0, r8, asr r0
    5670:	004a6f0f 	subeq	r6, sl, pc, lsl #30
    5674:	a5445300 	strbge	r5, [r4, #-768]	; 0xfffffd00
    5678:	14000058 	strne	r0, [r0], #-88	; 0xffffffa8
    567c:	00647314 	rsbeq	r7, r4, r4, lsl r3
    5680:	38314553 	ldmdacc	r1!, {r0, r1, r4, r6, r8, sl, lr}
    5684:	0f180000 	svceq	0x00180000
    5688:	00000e25 	andeq	r0, r0, r5, lsr #28
    568c:	58004653 	stmdapl	r0, {r0, r1, r4, r6, r9, sl, lr}
    5690:	291c0000 	ldmdbcs	ip, {}	; <UNPREDICTABLE>
    5694:	000020ce 	andeq	r2, r0, lr, asr #1
    5698:	00694a53 	rsbeq	r4, r9, r3, asr sl
    569c:	01040000 	mrseq	r0, (UNDEF: 4)
    56a0:	d529201f 	strle	r2, [r9, #-31]!	; 0xffffffe1
    56a4:	5300002c 	movwpl	r0, #44	; 0x2c
    56a8:	0000694b 	andeq	r6, r0, fp, asr #18
    56ac:	1e010400 	cfcpysne	mvf0, mvf1
    56b0:	1adf2920 	bne	ff7ca488 <__crc_of_fdt_unflatten_tree+0x78a88ecb>
    56b4:	4c530000 	mrami	r0, r3, acc0
    56b8:	00000069 	andeq	r0, r0, r9, rrx
    56bc:	201d0104 	andscs	r0, sp, r4, lsl #2
    56c0:	00018e29 	andeq	r8, r1, r9, lsr #28
    56c4:	694d5300 	stmdbvs	sp, {r8, r9, ip, lr}^
    56c8:	04000000 	streq	r0, [r0], #-0
    56cc:	29201c01 	stmdbcs	r0!, {r0, sl, fp, ip}
    56d0:	00000b22 	andeq	r0, r0, r2, lsr #22
    56d4:	00694e53 	rsbeq	r4, r9, r3, asr lr
    56d8:	01040000 	mrseq	r0, (UNDEF: 4)
    56dc:	0800201b 	stmdaeq	r0, {r0, r1, r3, r4, sp}
    56e0:	00560904 	subseq	r0, r6, r4, lsl #18
    56e4:	eb040800 	bl	1076ec <unflatten_and_copy_device_tree+0x106878>
    56e8:	10000056 	andne	r0, r0, r6, asr r0
    56ec:	00003387 	andeq	r3, r0, r7, lsl #7
    56f0:	409b521c 	addsmi	r5, fp, ip, lsl r2
    56f4:	0f000057 	svceq	0x00000057
    56f8:	00001c8d 	andeq	r1, r0, sp, lsl #25
    56fc:	56099c52 			; <UNDEFINED> instruction: 0x56099c52
    5700:	0f000000 	svceq	0x00000000
    5704:	00000c6b 	andeq	r0, r0, fp, ror #24
    5708:	022e9d52 	eoreq	r9, lr, #5248	; 0x1480
    570c:	0f080000 	svceq	0x00080000
    5710:	0000016d 	andeq	r0, r0, sp, ror #2
    5714:	03789e52 	cmneq	r8, #1312	; 0x520
    5718:	0f0c0000 	svceq	0x000c0000
    571c:	000002f2 	strdeq	r0, [r0], -r2
    5720:	576e9f52 			; <UNDEFINED> instruction: 0x576e9f52
    5724:	0f100000 	svceq	0x00100000
    5728:	00001d13 	andeq	r1, r0, r3, lsl sp
    572c:	576ea152 			; <UNDEFINED> instruction: 0x576ea152
    5730:	0f140000 	svceq	0x00140000
    5734:	000053e3 	andeq	r5, r0, r3, ror #7
    5738:	5792a352 			; <UNDEFINED> instruction: 0x5792a352
    573c:	00180000 	andseq	r0, r8, r0
    5740:	56df0408 	ldrbpl	r0, [pc], r8, lsl #8
    5744:	39150000 	ldmdbcc	r5, {}	; <UNPREDICTABLE>
    5748:	6e000002 	cdpvs	0, 0, cr0, cr0, cr2, {0}
    574c:	0d000057 	stceq	0, cr0, [r0, #-348]	; 0xfffffea4
    5750:	000023cc 	andeq	r2, r0, ip, asr #7
    5754:	00562e0d 	subseq	r2, r6, sp, lsl #28
    5758:	56e50d00 	strbtpl	r0, [r5], r0, lsl #26
    575c:	b30d0000 	movwlt	r0, #53248	; 0xd000
    5760:	0d000001 	stceq	0, cr0, [r0, #-4]
    5764:	00000223 	andeq	r0, r0, r3, lsr #4
    5768:	00022e0d 	andeq	r2, r2, sp, lsl #28
    576c:	04080000 	streq	r0, [r8], #-0
    5770:	00005746 	andeq	r5, r0, r6, asr #14
    5774:	00005715 	andeq	r5, r0, r5, lsl r7
    5778:	00579200 	subseq	r9, r7, r0, lsl #4
    577c:	23cc0d00 	biccs	r0, ip, #0, 26
    5780:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    5784:	0d000056 	stceq	0, cr0, [r0, #-344]	; 0xfffffea8
    5788:	000056e5 	andeq	r5, r0, r5, ror #13
    578c:	0005a70d 	andeq	sl, r5, sp, lsl #14
    5790:	04080000 	streq	r0, [r8], #-0
    5794:	00005774 	andeq	r5, r0, r4, ror r7
    5798:	00465210 	subeq	r5, r6, r0, lsl r2
    579c:	d1520800 	cmple	r2, r0, lsl #16
    57a0:	000057bd 			; <UNDEFINED> instruction: 0x000057bd
    57a4:	0031210f 	eorseq	r2, r1, pc, lsl #2
    57a8:	d6d25200 	ldrble	r5, [r2], r0, lsl #4
    57ac:	00000057 	andeq	r0, r0, r7, asr r0
    57b0:	00251e0f 	eoreq	r1, r5, pc, lsl #28
    57b4:	fad35200 	blx	ff4d9fbc <__crc_of_fdt_unflatten_tree+0x787989ff>
    57b8:	04000057 	streq	r0, [r0], #-87	; 0xffffffa9
    57bc:	02391500 	eorseq	r1, r9, #0, 10
    57c0:	57d60000 	ldrbpl	r0, [r6, r0]
    57c4:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    57c8:	0d000056 	stceq	0, cr0, [r0, #-344]	; 0xfffffea8
    57cc:	000056df 	ldrdeq	r5, [r0], -pc	; <UNPREDICTABLE>
    57d0:	0001b30d 	andeq	fp, r1, sp, lsl #6
    57d4:	04080000 	streq	r0, [r8], #-0
    57d8:	000057bd 			; <UNDEFINED> instruction: 0x000057bd
    57dc:	00023915 	andeq	r3, r2, r5, lsl r9
    57e0:	0057fa00 	subseq	pc, r7, r0, lsl #20
    57e4:	562e0d00 	strtpl	r0, [lr], -r0, lsl #26
    57e8:	df0d0000 	svcle	0x000d0000
    57ec:	0d000056 	stceq	0, cr0, [r0, #-344]	; 0xfffffea8
    57f0:	000000f2 	strdeq	r0, [r0], -r2
    57f4:	00022e0d 	andeq	r2, r2, sp, lsl #28
    57f8:	04080000 	streq	r0, [r8], #-0
    57fc:	000057dc 	ldrdeq	r5, [r0], -ip
    5800:	000e2510 	andeq	r2, lr, r0, lsl r5
    5804:	17540400 	ldrbne	r0, [r4, -r0, lsl #8]
    5808:	00005819 	andeq	r5, r0, r9, lsl r8
    580c:	002c800f 	eoreq	r8, ip, pc
    5810:	bc185400 	cfldrslt	mvf5, [r8], {-0}
    5814:	00000002 	andeq	r0, r0, r2
    5818:	47de1000 	ldrbmi	r1, [lr, r0]
    581c:	53340000 	teqpl	r4, #0
    5820:	005856a8 	subseq	r5, r8, r8, lsr #13
    5824:	058e0f00 	streq	r0, [lr, #3840]	; 0xf00
    5828:	a9530000 	ldmdbge	r3, {}^	; <UNPREDICTABLE>
    582c:	000002c7 	andeq	r0, r0, r7, asr #5
    5830:	615f0f00 	cmpvs	pc, r0, lsl #30
    5834:	aa530000 	bge	14c583c <unflatten_and_copy_device_tree+0x14c49c8>
    5838:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    583c:	2fa10f08 	svccs	0x00a10f08
    5840:	ab530000 	blge	14c5848 <unflatten_and_copy_device_tree+0x14c49d4>
    5844:	00005634 	andeq	r5, r0, r4, lsr r6
    5848:	49c30f0c 	stmibmi	r3, {r2, r3, r8, r9, sl, fp}^
    584c:	ac530000 	mrage	r0, r3, acc0
    5850:	00005a11 	andeq	r5, r0, r1, lsl sl
    5854:	04080030 	streq	r0, [r8], #-48	; 0xffffffd0
    5858:	00005819 	andeq	r5, r0, r9, lsl r8
    585c:	00594510 	subseq	r4, r9, r0, lsl r5
    5860:	74531400 	ldrbvc	r1, [r3], #-1024	; 0xfffffc00
    5864:	000058a5 	andeq	r5, r0, r5, lsr #17
    5868:	00026a0f 	andeq	r6, r2, pc, lsl #20
    586c:	b6755300 	ldrbtlt	r5, [r5], -r0, lsl #6
    5870:	00000058 	andeq	r0, r0, r8, asr r0
    5874:	0046520f 	subeq	r5, r6, pc, lsl #4
    5878:	bc765300 	ldcllt	3, cr5, [r6], #-0
    587c:	04000058 	streq	r0, [r0], #-88	; 0xffffffa8
    5880:	003d3e0f 	eorseq	r3, sp, pc, lsl #28
    5884:	40775300 	rsbsmi	r5, r7, r0, lsl #6
    5888:	08000057 	stmdaeq	r0, {r0, r1, r2, r4, r6}
    588c:	00079a0f 	andeq	r9, r7, pc, lsl #20
    5890:	e1785300 	cmn	r8, r0, lsl #6
    5894:	0c000058 	stceq	0, cr0, [r0], {88}	; 0x58
    5898:	0046ac0f 	subeq	sl, r6, pc, lsl #24
    589c:	f6795300 			; <UNDEFINED> instruction: 0xf6795300
    58a0:	10000058 	andne	r0, r0, r8, asr r0
    58a4:	5c040800 	stcpl	8, cr0, [r4], {-0}
    58a8:	0c000058 	stceq	0, cr0, [r0], {88}	; 0x58
    58ac:	000058b6 			; <UNDEFINED> instruction: 0x000058b6
    58b0:	00562e0d 	subseq	r2, r6, sp, lsl #28
    58b4:	04080000 	streq	r0, [r8], #-0
    58b8:	000058ab 	andeq	r5, r0, fp, lsr #17
    58bc:	58c20408 	stmiapl	r2, {r3, sl}^
    58c0:	98090000 	stmdals	r9, {}	; <UNPREDICTABLE>
    58c4:	15000057 	strne	r0, [r0, #-87]	; 0xffffffa9
    58c8:	000058d6 	ldrdeq	r5, [r0], -r6
    58cc:	000058d6 	ldrdeq	r5, [r0], -r6
    58d0:	00562e0d 	subseq	r2, r6, sp, lsl #28
    58d4:	04080000 	streq	r0, [r8], #-0
    58d8:	000058dc 	ldrdeq	r5, [r0], -ip
    58dc:	0054d509 	subseq	sp, r4, r9, lsl #10
    58e0:	c7040800 	strgt	r0, [r4, -r0, lsl #16]
    58e4:	15000058 	strne	r0, [r0, #-88]	; 0xffffffa8
    58e8:	000030dc 	ldrdeq	r3, [r0], -ip
    58ec:	000058f6 	strdeq	r5, [r0], -r6
    58f0:	00562e0d 	subseq	r2, r6, sp, lsl #28
    58f4:	04080000 	streq	r0, [r8], #-0
    58f8:	000058e7 	andeq	r5, r0, r7, ror #17
    58fc:	00394e30 	eorseq	r4, r9, r0, lsr lr
    5900:	53089400 	movwpl	r9, #33792	; 0x8400
    5904:	0059477c 	subseq	r4, r9, ip, ror r7
    5908:	59650f00 	stmdbpl	r5!, {r8, r9, sl, fp}^
    590c:	7d530000 	ldclvc	0, cr0, [r3, #-0]
    5910:	00005947 	andeq	r5, r0, r7, asr #18
    5914:	33f80f00 	mvnscc	r0, #0, 30
    5918:	7e530000 	cdpvc	0, 5, cr0, cr3, cr0, {0}
    591c:	00005957 	andeq	r5, r0, r7, asr r9
    5920:	60170f0c 	andsvs	r0, r7, ip, lsl #30
    5924:	7f530000 	svcvc	0x00530000
    5928:	00000057 	andeq	r0, r0, r7, asr r0
    592c:	7562148c 	strbvc	r1, [r2, #-1164]!	; 0xfffffb74
    5930:	80530066 	subshi	r0, r3, r6, rrx
    5934:	00005967 	andeq	r5, r0, r7, ror #18
    5938:	13e53190 	mvnne	r3, #144, 2	; 0x24
    593c:	81530000 	cmphi	r3, r0
    5940:	00000057 	andeq	r0, r0, r7, asr r0
    5944:	06000890 			; <UNDEFINED> instruction: 0x06000890
    5948:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    594c:	00005957 	andeq	r5, r0, r7, asr r9
    5950:	0000eb07 	andeq	lr, r0, r7, lsl #22
    5954:	06000200 	streq	r0, [r0], -r0, lsl #4
    5958:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    595c:	00005967 	andeq	r5, r0, r7, ror #18
    5960:	0000eb07 	andeq	lr, r0, r7, lsl #22
    5964:	06001f00 	streq	r1, [r0], -r0, lsl #30
    5968:	000000f8 	strdeq	r0, [r0], -r8
    596c:	00005978 	andeq	r5, r0, r8, ror r9
    5970:	0000eb33 	andeq	lr, r0, r3, lsr fp
    5974:	0007ff00 	andeq	pc, r7, r0, lsl #30
    5978:	00075510 	andeq	r5, r7, r0, lsl r5
    597c:	84530c00 	ldrbhi	r0, [r3], #-3072	; 0xfffff400
    5980:	000059a9 	andeq	r5, r0, r9, lsr #19
    5984:	001dfc0f 	andseq	pc, sp, pc, lsl #24
    5988:	c3855300 	orrgt	r5, r5, #0, 6
    598c:	00000059 	andeq	r0, r0, r9, asr r0
    5990:	00059b0f 	andeq	r9, r5, pc, lsl #22
    5994:	e2865300 	add	r5, r6, #0, 6
    5998:	04000059 	streq	r0, [r0], #-89	; 0xffffffa7
    599c:	0011100f 	andseq	r1, r1, pc
    59a0:	0c875300 	stceq	3, cr5, [r7], {0}
    59a4:	0800005a 	stmdaeq	r0, {r1, r3, r4, r6}
    59a8:	00571500 	subseq	r1, r7, r0, lsl #10
    59ac:	59bd0000 	ldmibpl	sp!, {}	; <UNPREDICTABLE>
    59b0:	560d0000 	strpl	r0, [sp], -r0
    59b4:	0d000058 	stceq	0, cr0, [r0, #-352]	; 0xfffffea0
    59b8:	0000562e 	andeq	r5, r0, lr, lsr #12
    59bc:	a9040800 	stmdbge	r4, {fp}
    59c0:	09000059 	stmdbeq	r0, {r0, r3, r4, r6}
    59c4:	000059bd 			; <UNDEFINED> instruction: 0x000059bd
    59c8:	0000f215 	andeq	pc, r0, r5, lsl r2	; <UNPREDICTABLE>
    59cc:	0059dc00 	subseq	sp, r9, r0, lsl #24
    59d0:	58560d00 	ldmdapl	r6, {r8, sl, fp}^
    59d4:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    59d8:	00000056 	andeq	r0, r0, r6, asr r0
    59dc:	59c80408 	stmibpl	r8, {r3, sl}^
    59e0:	dc090000 	stcle	0, cr0, [r9], {-0}
    59e4:	15000059 	strne	r0, [r0, #-89]	; 0xffffffa7
    59e8:	00000057 	andeq	r0, r0, r7, asr r0
    59ec:	00005a00 	andeq	r5, r0, r0, lsl #20
    59f0:	0058560d 	subseq	r5, r8, sp, lsl #12
    59f4:	562e0d00 	strtpl	r0, [lr], -r0, lsl #26
    59f8:	000d0000 	andeq	r0, sp, r0
    59fc:	0000005a 	andeq	r0, r0, sl, asr r0
    5a00:	58fc0408 	ldmpl	ip!, {r3, sl}^
    5a04:	04080000 	streq	r0, [r8], #-0
    5a08:	000059e7 	andeq	r5, r0, r7, ror #19
    5a0c:	005a0609 	subseq	r0, sl, r9, lsl #12
    5a10:	17040800 	strne	r0, [r4, -r0, lsl #16]
    5a14:	0900005a 	stmdbeq	r0, {r1, r3, r4, r6}
    5a18:	00005978 	andeq	r5, r0, r8, ror r9
    5a1c:	0063f010 	rsbeq	pc, r3, r0, lsl r0	; <UNPREDICTABLE>
    5a20:	e955c400 	ldmdb	r5, {sl, lr, pc}^
    5a24:	00005a59 	andeq	r5, r0, r9, asr sl
    5a28:	00059b0f 	andeq	r9, r5, pc, lsl #22
    5a2c:	59ea5500 	stmibpl	sl!, {r8, sl, ip, lr}^
    5a30:	0000005a 	andeq	r0, r0, sl, asr r0
    5a34:	00357e0f 	eorseq	r7, r5, pc, lsl #28
    5a38:	59eb5500 	stmibpl	fp!, {r8, sl, ip, lr}^
    5a3c:	2000005a 	andcs	r0, r0, sl, asr r0
    5a40:	003d190f 	eorseq	r1, sp, pc, lsl #18
    5a44:	69ec5500 	stmibvs	ip!, {r8, sl, ip, lr}^
    5a48:	4000005a 	andmi	r0, r0, sl, asr r0
    5a4c:	005dca0f 	subseq	ip, sp, pc, lsl #20
    5a50:	dced5500 	cfstr64le	mvdx5, [sp]
    5a54:	c0000030 	andgt	r0, r0, r0, lsr r0
    5a58:	00f80600 	rscseq	r0, r8, r0, lsl #12
    5a5c:	5a690000 	bpl	1a45a64 <unflatten_and_copy_device_tree+0x1a44bf0>
    5a60:	eb070000 	bl	1c5a68 <unflatten_and_copy_device_tree+0x1c4bf4>
    5a64:	1f000000 	svcne	0x00000000
    5a68:	00f80600 	rscseq	r0, r8, r0, lsl #12
    5a6c:	5a790000 	bpl	1e45a74 <unflatten_and_copy_device_tree+0x1e44c00>
    5a70:	eb070000 	bl	1c5a78 <unflatten_and_copy_device_tree+0x1c4c04>
    5a74:	7f000000 	svcvc	0x00000000
    5a78:	0f3c2600 	svceq	0x003c2600
    5a7c:	69040000 	stmdbvs	r4, {}	; <UNPREDICTABLE>
    5a80:	56000000 	strpl	r0, [r0], -r0
    5a84:	005aae0f 	subseq	sl, sl, pc, lsl #28
    5a88:	64f90b00 	ldrbtvs	r0, [r9], #2816	; 0xb00
    5a8c:	0b000000 	bleq	5a94 <.debug_info+0x5a94>
    5a90:	00000340 	andeq	r0, r0, r0, asr #6
    5a94:	04a80b01 	strteq	r0, [r8], #2817	; 0xb01
    5a98:	0b020000 	bleq	85aa0 <unflatten_and_copy_device_tree+0x84c2c>
    5a9c:	000039f2 	strdeq	r3, [r0], -r2
    5aa0:	30090b03 	andcc	r0, r9, r3, lsl #22
    5aa4:	0b040000 	bleq	105aac <unflatten_and_copy_device_tree+0x104c38>
    5aa8:	00004ac1 	andeq	r4, r0, r1, asr #21
    5aac:	62100005 	andsvs	r0, r0, #5
    5ab0:	08000005 	stmdaeq	r0, {r0, r2}
    5ab4:	5ad31856 	bpl	ff4cbc14 <__crc_of_fdt_unflatten_tree+0x7878a657>
    5ab8:	7e0f0000 	cdpvc	0, 0, cr0, cr15, cr0, {0}
    5abc:	56000035 			; <UNDEFINED> instruction: 0x56000035
    5ac0:	005a7919 	subseq	r7, sl, r9, lsl r9
    5ac4:	270f0000 	strcs	r0, [pc, -r0]
    5ac8:	56000035 			; <UNDEFINED> instruction: 0x56000035
    5acc:	005ad31a 	subseq	sp, sl, sl, lsl r3
    5ad0:	08000400 	stmdaeq	r0, {sl}
    5ad4:	005aae04 	subseq	sl, sl, r4, lsl #28
    5ad8:	31440300 	mrscc	r0, SPSR_abt
    5adc:	20040000 	andcs	r0, r4, r0
    5ae0:	000000b3 	strheq	r0, [r0], -r3
    5ae4:	00543110 	subseq	r3, r4, r0, lsl r1
    5ae8:	23043400 	movwcs	r3, #17408	; 0x4400
    5aec:	00005b45 	andeq	r5, r0, r5, asr #22
    5af0:	00059b0f 	andeq	r9, r5, pc, lsl #22
    5af4:	b3240400 			; <UNDEFINED> instruction: 0xb3240400
    5af8:	00000001 	andeq	r0, r0, r1
    5afc:	0064380f 	rsbeq	r3, r4, pc, lsl #16
    5b00:	57250400 	strpl	r0, [r5, -r0, lsl #8]!
    5b04:	04000000 	streq	r0, [r0], #-0
    5b08:	00392a0f 	eorseq	r2, r9, pc, lsl #20
    5b0c:	78260400 	stmdavc	r6!, {sl}
    5b10:	08000003 	stmdaeq	r0, {r0, r1}
    5b14:	0022220f 	eoreq	r2, r2, pc, lsl #4
    5b18:	45270400 	strmi	r0, [r7, #-1024]!	; 0xfffffc00
    5b1c:	0c00005b 	stceq	0, cr0, [r0], {91}	; 0x5b
    5b20:	003cee0f 	eorseq	lr, ip, pc, lsl #28
    5b24:	d4280400 	strtle	r0, [r8], #-1024	; 0xfffffc00
    5b28:	10000000 	andne	r0, r0, r0
    5b2c:	0060810f 	rsbeq	r8, r0, pc, lsl #2
    5b30:	69290400 	stmdbvs	r9!, {sl}
    5b34:	14000000 	strne	r0, [r0], #-0
    5b38:	001c8d0f 	andseq	r8, ip, pc, lsl #26
    5b3c:	eb2a0400 	bl	a86b44 <unflatten_and_copy_device_tree+0xa85cd0>
    5b40:	18000056 	stmdane	r0, {r1, r2, r4, r6}
    5b44:	e4040800 	str	r0, [r4], #-2048	; 0xfffff800
    5b48:	1000005a 	andne	r0, r0, sl, asr r0
    5b4c:	00002c89 	andeq	r2, r0, r9, lsl #25
    5b50:	f4310458 			; <UNDEFINED> instruction: 0xf4310458
    5b54:	0f00005b 	svceq	0x0000005b
    5b58:	0000059b 	muleq	r0, fp, r5
    5b5c:	00f23204 	rscseq	r3, r2, r4, lsl #4
    5b60:	0f000000 	svceq	0x00000000
    5b64:	0000357e 	andeq	r3, r0, lr, ror r5
    5b68:	00f23304 	rscseq	r3, r2, r4, lsl #6
    5b6c:	0f040000 	svceq	0x00040000
    5b70:	00003144 	andeq	r3, r0, r4, asr #2
    5b74:	5ad93404 	bpl	ff652b8c <__crc_of_fdt_unflatten_tree+0x789115cf>
    5b78:	0f080000 	svceq	0x00080000
    5b7c:	00004f8a 	andeq	r4, r0, sl, lsl #31
    5b80:	00f23504 	rscseq	r3, r2, r4, lsl #10
    5b84:	0f0c0000 	svceq	0x000c0000
    5b88:	00000d3c 	andeq	r0, r0, ip, lsr sp
    5b8c:	5aae3604 	bpl	feb933a4 <__crc_of_fdt_unflatten_tree+0x77e51de7>
    5b90:	0f100000 	svceq	0x00100000
    5b94:	00004d0d 	andeq	r4, r0, sp, lsl #26
    5b98:	5b453804 	blpl	1153bb0 <unflatten_and_copy_device_tree+0x1152d3c>
    5b9c:	0f180000 	svceq	0x00180000
    5ba0:	000012d9 	ldrdeq	r1, [r0], -r9
    5ba4:	5b453904 	blpl	1153fbc <unflatten_and_copy_device_tree+0x1153148>
    5ba8:	0f1c0000 	svceq	0x001c0000
    5bac:	00002322 	andeq	r2, r0, r2, lsr #6
    5bb0:	5bf43a04 	blpl	ffd143c8 <__crc_of_fdt_unflatten_tree+0x78fd2e0b>
    5bb4:	0f200000 	svceq	0x00200000
    5bb8:	00003069 	andeq	r3, r0, r9, rrx
    5bbc:	5bf43b04 	blpl	ffd147d4 <__crc_of_fdt_unflatten_tree+0x78fd3217>
    5bc0:	0f240000 	svceq	0x00240000
    5bc4:	000002a0 	andeq	r0, r0, r0, lsr #5
    5bc8:	5bf43c04 	blpl	ffd14be0 <__crc_of_fdt_unflatten_tree+0x78fd3623>
    5bcc:	0f280000 	svceq	0x00280000
    5bd0:	00002fa1 	andeq	r2, r0, r1, lsr #31
    5bd4:	56343d04 	ldrtpl	r3, [r4], -r4, lsl #26
    5bd8:	0f2c0000 	svceq	0x002c0000
    5bdc:	00003cee 	andeq	r3, r0, lr, ror #25
    5be0:	00d43e04 	sbcseq	r3, r4, r4, lsl #28
    5be4:	0f500000 	svceq	0x00500000
    5be8:	00005dca 	andeq	r5, r0, sl, asr #27
    5bec:	03783f04 	cmneq	r8, #4, 30
    5bf0:	00540000 	subseq	r0, r4, r0
    5bf4:	5b4b0408 	blpl	12c6c1c <unflatten_and_copy_device_tree+0x12c5da8>
    5bf8:	04080000 	streq	r0, [r8], #-0
    5bfc:	00005c00 	andeq	r5, r0, r0, lsl #24
    5c00:	00148816 	andseq	r8, r4, r6, lsl r8
    5c04:	55b80300 	ldrpl	r0, [r8, #768]!	; 0x300
    5c08:	09570000 	ldmdbeq	r7, {}^	; <UNPREDICTABLE>
    5c0c:	000001b9 			; <UNDEFINED> instruction: 0x000001b9
    5c10:	0034bb10 	eorseq	fp, r4, r0, lsl fp
    5c14:	39582800 	ldmdbcc	r8, {fp, sp}^
    5c18:	00005c95 	muleq	r0, r5, ip
    5c1c:	0022e80f 	eoreq	lr, r2, pc, lsl #16
    5c20:	053a5800 	ldreq	r5, [sl, #-2048]!	; 0xfffff800
    5c24:	0000005c 	andeq	r0, r0, ip, asr r0
    5c28:	0028cb0f 	eoreq	ip, r8, pc, lsl #22
    5c2c:	053b5800 	ldreq	r5, [fp, #-2048]!	; 0xfffff800
    5c30:	0400005c 	streq	r0, [r0], #-92	; 0xffffffa4
    5c34:	0023e80f 	eoreq	lr, r3, pc, lsl #16
    5c38:	053c5800 	ldreq	r5, [ip, #-2048]!	; 0xfffff800
    5c3c:	0800005c 	stmdaeq	r0, {r2, r3, r4, r6}
    5c40:	0061c10f 	rsbeq	ip, r1, pc, lsl #2
    5c44:	053d5800 	ldreq	r5, [sp, #-2048]!	; 0xfffff800
    5c48:	0c00005c 	stceq	0, cr0, [r0], {92}	; 0x5c
    5c4c:	001c920f 	andseq	r9, ip, pc, lsl #4
    5c50:	053e5800 	ldreq	r5, [lr, #-2048]!	; 0xfffff800
    5c54:	1000005c 	andne	r0, r0, ip, asr r0
    5c58:	0002490f 	andeq	r4, r2, pc, lsl #18
    5c5c:	053f5800 	ldreq	r5, [pc, #-2048]!	; 5464 <.debug_info+0x5464>
    5c60:	1400005c 	strne	r0, [r0], #-92	; 0xffffffa4
    5c64:	0042df0f 	subeq	sp, r2, pc, lsl #30
    5c68:	05405800 	strbeq	r5, [r0, #-2048]	; 0xfffff800
    5c6c:	1800005c 	stmdane	r0, {r2, r3, r4, r6}
    5c70:	0050330f 	subseq	r3, r0, pc, lsl #6
    5c74:	05435800 	strbeq	r5, [r3, #-2048]	; 0xfffff800
    5c78:	1c00005c 	stcne	0, cr0, [r0], {92}	; 0x5c
    5c7c:	0049ce0f 	subeq	ip, r9, pc, lsl #28
    5c80:	05465800 	strbeq	r5, [r6, #-2048]	; 0xfffff800
    5c84:	2000005c 	andcs	r0, r0, ip, asr r0
    5c88:	004d970f 	subeq	r9, sp, pc, lsl #14
    5c8c:	05495800 	strbeq	r5, [r9, #-2048]	; 0xfffff800
    5c90:	2400005c 	strcs	r0, [r0], #-92	; 0xffffffa4
    5c94:	59bc1000 	ldmibpl	ip!, {ip}
    5c98:	59040000 	stmdbpl	r4, {}	; <UNPREDICTABLE>
    5c9c:	005cae21 	subseq	sl, ip, r1, lsr #28
    5ca0:	0cb80f00 	ldceq	15, cr0, [r8]
    5ca4:	22590000 	subscs	r0, r9, #0
    5ca8:	00005cd3 	ldrdeq	r5, [r0], -r3
    5cac:	9b100000 	blls	400008 <unflatten_and_copy_device_tree+0x3ff194>
    5cb0:	08000047 	stmdaeq	r0, {r0, r1, r2, r6}
    5cb4:	5cd32559 	cfldr64pl	mvdx2, [r3], {89}	; 0x59
    5cb8:	220f0000 	andcs	r0, pc, #0
    5cbc:	59000022 	stmdbpl	r0, {r1, r5}
    5cc0:	005cd326 	subseq	sp, ip, r6, lsr #6
    5cc4:	f30f0000 	vhadd.u8	d0, d15, d0
    5cc8:	5900003b 	stmdbpl	r0, {r0, r1, r3, r4, r5}
    5ccc:	005cd926 	subseq	sp, ip, r6, lsr #18
    5cd0:	08000400 	stmdaeq	r0, {sl}
    5cd4:	005cae04 	subseq	sl, ip, r4, lsl #28
    5cd8:	d3040800 	movwle	r0, #18432	; 0x4800
    5cdc:	0e00005c 	mcreq	0, 0, r0, cr0, cr12, {2}
    5ce0:	001d5a08 	andseq	r5, sp, r8, lsl #20
    5ce4:	0f00005d 	svceq	0x0000005d
    5ce8:	0000155a 	andeq	r1, r0, sl, asr r5
    5cec:	10ff1e5a 	rscsne	r1, pc, sl, asr lr	; <UNPREDICTABLE>
    5cf0:	0f000000 	svceq	0x00000000
    5cf4:	00003ba1 	andeq	r3, r0, r1, lsr #23
    5cf8:	00571f5a 	subseq	r1, r7, sl, asr pc
    5cfc:	00040000 	andeq	r0, r4, r0
    5d00:	195a0817 	ldmdbne	sl, {r0, r1, r2, r4, fp}^
    5d04:	00005d19 	andeq	r5, r0, r9, lsl sp
    5d08:	00251318 	eoreq	r1, r5, r8, lsl r3
    5d0c:	771b5a00 	ldrvc	r5, [fp, -r0, lsl #20]
    5d10:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    5d14:	00005cdf 	ldrdeq	r5, [r0], -pc	; <UNPREDICTABLE>
    5d18:	52901000 	addspl	r1, r0, #0
    5d1c:	5a080000 	bpl	205d24 <unflatten_and_copy_device_tree+0x204eb0>
    5d20:	005d2c18 	subseq	r2, sp, r8, lsl ip
    5d24:	5d001900 	stcpl	9, cr1, [r0, #-0]
    5d28:	00000000 	andeq	r0, r0, r0
    5d2c:	2e5b080e 	cdpcs	8, 5, cr0, cr11, cr14, {0}
    5d30:	00005d4d 	andeq	r5, r0, sp, asr #26
    5d34:	0051dd0f 	subseq	sp, r1, pc, lsl #26
    5d38:	b32f5b00 			; <UNDEFINED> instruction: 0xb32f5b00
    5d3c:	00000000 	andeq	r0, r0, r0
    5d40:	6e656c14 	mcrvs	12, 3, r6, cr5, cr4, {0}
    5d44:	b32f5b00 			; <UNDEFINED> instruction: 0xb32f5b00
    5d48:	04000000 	streq	r0, [r0], #-0
    5d4c:	5b081700 	blpl	20b954 <unflatten_and_copy_device_tree+0x20aae0>
    5d50:	005d662d 	subseq	r6, sp, sp, lsr #12
    5d54:	5d2c2800 	stcpl	8, cr2, [ip, #-0]
    5d58:	34180000 	ldrcc	r0, [r8], #-0
    5d5c:	5b000024 	blpl	5df4 <.debug_info+0x5df4>
    5d60:	0000c931 	andeq	ip, r0, r1, lsr r9
    5d64:	62100000 	andsvs	r0, r0, #0
    5d68:	10000019 	andne	r0, r0, r9, lsl r0
    5d6c:	5d852c5b 	stcpl	12, cr2, [r5, #364]	; 0x16c
    5d70:	4d190000 	ldcmi	0, cr0, [r9, #-0]
    5d74:	0000005d 	andeq	r0, r0, sp, asr r0
    5d78:	00059b0f 	andeq	r9, r5, pc, lsl #22
    5d7c:	85335b00 	ldrhi	r5, [r3, #-2816]!	; 0xfffff500
    5d80:	0800005d 	stmdaeq	r0, {r0, r2, r3, r4, r6}
    5d84:	8b040800 	blhi	107d8c <unflatten_and_copy_device_tree+0x106f18>
    5d88:	0900005d 	stmdbeq	r0, {r0, r2, r3, r4, r6}
    5d8c:	0000002c 	andeq	r0, r0, ip, lsr #32
    5d90:	845b0817 	ldrbhi	r0, [fp], #-2071	; 0xfffff7e9
    5d94:	00005daf 	andeq	r5, r0, pc, lsr #27
    5d98:	005e3e18 	subseq	r3, lr, r8, lsl lr
    5d9c:	0b855b00 	bleq	fe15c9a4 <__crc_of_fdt_unflatten_tree+0x7741b3e7>
    5da0:	18000003 	stmdane	r0, {r0, r1}
    5da4:	00003284 	andeq	r3, r0, r4, lsl #5
    5da8:	033c865b 	teqeq	ip, #95420416	; 0x5b00000
    5dac:	10000000 	andne	r0, r0, r0
    5db0:	00003d37 	andeq	r3, r0, r7, lsr sp
    5db4:	7c6c5b88 	stclvc	11, cr5, [ip], #-544	; 0xfffffde0
    5db8:	0f00005e 	svceq	0x0000005e
    5dbc:	000023f6 	strdeq	r2, [r0], -r6
    5dc0:	00696e5b 	rsbeq	r6, r9, fp, asr lr
    5dc4:	0f000000 	svceq	0x00000000
    5dc8:	00000787 	andeq	r0, r0, r7, lsl #15
    5dcc:	120f6f5b 	andne	r6, pc, #364	; 0x16c
    5dd0:	0f040000 	svceq	0x00040000
    5dd4:	00006537 	andeq	r6, r0, r7, lsr r5
    5dd8:	5cae705b 	stcpl	0, cr7, [lr], #364	; 0x16c
    5ddc:	0f080000 	svceq	0x00080000
    5de0:	000036f6 	strdeq	r3, [r0], -r6
    5de4:	5e7c715b 	mrcpl	1, 3, r7, cr12, cr11, {2}
    5de8:	0f100000 	svceq	0x00100000
    5dec:	000016c9 	andeq	r1, r0, r9, asr #13
    5df0:	5d66725b 	sfmpl	f7, 2, [r6, #-364]!	; 0xfffffe94
    5df4:	0f180000 	svceq	0x00180000
    5df8:	00005c5a 	andeq	r5, r0, sl, asr ip
    5dfc:	60f2735b 	rscsvs	r7, r2, fp, asr r3
    5e00:	0f280000 	svceq	0x00280000
    5e04:	00001f99 	muleq	r0, r9, pc	; <UNPREDICTABLE>
    5e08:	60f8755b 	rscsvs	r7, r8, fp, asr r5
    5e0c:	0f2c0000 	svceq	0x002c0000
    5e10:	00003800 	andeq	r3, r0, r0, lsl #16
    5e14:	5d19785b 	ldcpl	8, cr7, [r9, #-364]	; 0xfffffe94
    5e18:	0f500000 	svceq	0x00500000
    5e1c:	00005178 	andeq	r5, r0, r8, ror r1
    5e20:	61b1795b 			; <UNDEFINED> instruction: 0x61b1795b
    5e24:	0f580000 	svceq	0x00580000
    5e28:	00005462 	andeq	r5, r0, r2, ror #8
    5e2c:	647b7a5b 	ldrbtvs	r7, [fp], #-2651	; 0xfffff5a5
    5e30:	0f5c0000 	svceq	0x005c0000
    5e34:	00005d85 	andeq	r5, r0, r5, lsl #27
    5e38:	00d47b5b 	sbcseq	r7, r4, fp, asr fp
    5e3c:	0f600000 	svceq	0x00600000
    5e40:	00004f6f 	andeq	r4, r0, pc, ror #30
    5e44:	03787c5b 	cmneq	r8, #23296	; 0x5b00
    5e48:	0f640000 	svceq	0x00640000
    5e4c:	0000224c 	andeq	r2, r0, ip, asr #4
    5e50:	02c77e5b 	sbceq	r7, r7, #1456	; 0x5b0
    5e54:	0f680000 	svceq	0x00680000
    5e58:	00002c06 	andeq	r2, r0, r6, lsl #24
    5e5c:	02c77f5b 	sbceq	r7, r7, #364	; 0x16c
    5e60:	0f700000 	svceq	0x00700000
    5e64:	00001987 	andeq	r1, r0, r7, lsl #19
    5e68:	02c7805b 	sbceq	r8, r7, #91	; 0x5b
    5e6c:	14780000 	ldrbtne	r0, [r8], #-0
    5e70:	00755f64 	rsbseq	r5, r5, r4, ror #30
    5e74:	5d90875b 	ldcpl	7, cr8, [r0, #364]	; 0x16c
    5e78:	00800000 	addeq	r0, r0, r0
    5e7c:	5daf0408 	cfstrspl	mvf0, [pc, #32]!	; 5ea4 <.debug_info+0x5ea4>
    5e80:	731c0000 	tstvc	ip, #0
    5e84:	58000029 	stmdapl	r0, {r0, r3, r5}
    5e88:	025b2b01 	subseq	r2, fp, #1024	; 0x400
    5e8c:	000060f2 	strdeq	r6, [r0], -r2
    5e90:	00444d1b 	subeq	r4, r4, fp, lsl sp
    5e94:	025c2b00 	subseq	r2, ip, #0, 22
    5e98:	000001da 	ldrdeq	r0, [r0], -sl
    5e9c:	45ca1b00 	strbmi	r1, [sl, #2816]	; 0xb00
    5ea0:	5d2b0000 	stcpl	0, cr0, [fp, #-0]
    5ea4:	00004502 	andeq	r4, r0, r2, lsl #10
    5ea8:	5b1b0200 	blpl	6c0808 <unflatten_and_copy_device_tree+0x6bf994>
    5eac:	2b000062 	blcs	603c <.debug_info+0x603c>
    5eb0:	2842025e 	stmdacs	r2, {r1, r2, r3, r4, r6, r9}^
    5eb4:	1b040000 	blne	105ebc <unflatten_and_copy_device_tree+0x105048>
    5eb8:	00001e0e 	andeq	r1, r0, lr, lsl #28
    5ebc:	62025f2b 	andvs	r5, r2, #43, 30	; 0xac
    5ec0:	08000028 	stmdaeq	r0, {r3, r5}
    5ec4:	005f1f1b 	subseq	r1, pc, fp, lsl pc	; <UNPREDICTABLE>
    5ec8:	02602b00 	rsbeq	r2, r0, #0, 22
    5ecc:	00000069 	andeq	r0, r0, r9, rrx
    5ed0:	00401b0c 	subeq	r1, r0, ip, lsl #22
    5ed4:	632b0000 			; <UNDEFINED> instruction: 0x632b0000
    5ed8:	00773f02 	rsbseq	r3, r7, r2, lsl #30
    5edc:	0d1b1000 	ldceq	0, cr1, [fp, #-0]
    5ee0:	2b00001c 	blcs	5f58 <.debug_info+0x5f58>
    5ee4:	773f0264 	ldrvc	r0, [pc, -r4, ror #4]!
    5ee8:	1b140000 	blne	505ef0 <unflatten_and_copy_device_tree+0x50507c>
    5eec:	00004d86 	andeq	r4, r0, r6, lsl #27
    5ef0:	a502672b 	strge	r6, [r2, #-1835]	; 0xfffff8d5
    5ef4:	18000078 	stmdane	r0, {r3, r4, r5, r6}
    5ef8:	0028bf1b 	eoreq	fp, r8, fp, lsl pc
    5efc:	02682b00 	rsbeq	r2, r8, #0, 22
    5f00:	0000647b 	andeq	r6, r0, fp, ror r4
    5f04:	591d1b1c 	ldmdbpl	sp, {r2, r3, r4, r8, r9, fp, ip}
    5f08:	692b0000 	stmdbvs	fp!, {}	; <UNPREDICTABLE>
    5f0c:	00211802 	eoreq	r1, r1, r2, lsl #16
    5f10:	231b2000 	tstcs	fp, #0
    5f14:	2b000061 	blcs	60a0 <.debug_info+0x60a0>
    5f18:	00d40270 	sbcseq	r0, r4, r0, ror r2
    5f1c:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>
    5f20:	0000765c 	andeq	r7, r0, ip, asr r6
    5f24:	18891b28 	stmne	r9, {r3, r5, r8, r9, fp, ip}
    5f28:	7c2b0000 	stcvc	0, cr0, [fp], #-0
    5f2c:	0001cf02 	andeq	ip, r1, r2, lsl #30
    5f30:	641b2c00 	ldrvs	r2, [fp], #-3072	; 0xfffff400
    5f34:	2b000058 	blcs	609c <.debug_info+0x609c>
    5f38:	0223027d 	eoreq	r0, r3, #-805306361	; 0xd0000007
    5f3c:	1b300000 	blne	c05f44 <unflatten_and_copy_device_tree+0xc050d0>
    5f40:	00002302 	andeq	r2, r0, r2, lsl #6
    5f44:	86027e2b 	strhi	r7, [r2], -fp, lsr #28
    5f48:	38000004 	stmdacc	r0, {r2}
    5f4c:	0014341b 	andseq	r3, r4, fp, lsl r4
    5f50:	027f2b00 	rsbseq	r2, pc, #0, 22
    5f54:	00000486 	andeq	r0, r0, r6, lsl #9
    5f58:	43d81b40 	bicsmi	r1, r8, #64, 22	; 0x10000
    5f5c:	802b0000 	eorhi	r0, fp, r0
    5f60:	00048602 	andeq	r8, r4, r2, lsl #12
    5f64:	cf1b4800 	svcgt	0x001b4800
    5f68:	2b00005e 	blcs	60e8 <.debug_info+0x60e8>
    5f6c:	10ff0281 	rscsne	r0, pc, r1, lsl #5
    5f70:	1b500000 	blne	1405f78 <unflatten_and_copy_device_tree+0x1405104>
    5f74:	000006bd 			; <UNDEFINED> instruction: 0x000006bd
    5f78:	4502822b 	strmi	r8, [r2, #-555]	; 0xfffffdd5
    5f7c:	54000000 	strpl	r0, [r0], #-0
    5f80:	002d791b 	eoreq	r7, sp, fp, lsl r9
    5f84:	02832b00 	addeq	r2, r3, #0, 22
    5f88:	00000069 	andeq	r0, r0, r9, rrx
    5f8c:	1aab1b58 	bne	feac6d68 <__crc_of_fdt_unflatten_tree+0x77d857ab>
    5f90:	842b0000 	strthi	r0, [fp], #-0
    5f94:	00027002 	andeq	r7, r2, r2
    5f98:	701b6000 	andsvc	r6, fp, r0
    5f9c:	2b00000c 	blcs	5fd4 <.debug_info+0x5fd4>
    5fa0:	120f0287 	andne	r0, pc, #1879048200	; 0x70000008
    5fa4:	1b680000 	blne	1a05fac <unflatten_and_copy_device_tree+0x1a05138>
    5fa8:	00005243 	andeq	r5, r0, r3, asr #4
    5fac:	d4028b2b 	strle	r8, [r2], #-2859	; 0xfffff4d5
    5fb0:	6c000000 	stcvs	0, cr0, [r0], {-0}
    5fb4:	0016a31b 	andseq	sl, r6, fp, lsl r3
    5fb8:	028c2b00 	addeq	r2, ip, #0, 22
    5fbc:	00001940 	andeq	r1, r0, r0, asr #18
    5fc0:	594f1b70 	stmdbpl	pc, {r4, r5, r6, r8, r9, fp, ip}^	; <UNPREDICTABLE>
    5fc4:	8e2b0000 	cdphi	0, 2, cr0, cr11, cr0, {0}
    5fc8:	0000d402 	andeq	sp, r0, r2, lsl #8
    5fcc:	d01b8800 	andsle	r8, fp, r0, lsl #16
    5fd0:	2b000035 	blcs	60ac <.debug_info+0x60ac>
    5fd4:	00d4028f 	sbcseq	r0, r4, pc, lsl #5
    5fd8:	1b8c0000 	blne	fe305fe0 <__crc_of_fdt_unflatten_tree+0x775c4a23>
    5fdc:	000033ea 	andeq	r3, r0, sl, ror #7
    5fe0:	0b02912b 	bleq	aa494 <unflatten_and_copy_device_tree+0xa9620>
    5fe4:	90000003 	andls	r0, r0, r3
    5fe8:	001a361b 	andseq	r3, sl, fp, lsl r6
    5fec:	02922b00 	addseq	r2, r2, #0, 22
    5ff0:	000002c7 	andeq	r0, r0, r7, asr #5
    5ff4:	2b761b98 	blcs	1d86e68 <unflatten_and_copy_device_tree+0x1d85ff4>
    5ff8:	942b0000 	strtls	r0, [fp], #-0
    5ffc:	0078b502 	rsbseq	fp, r8, r2, lsl #10
    6000:	cf1ba000 	svcgt	0x001ba000
    6004:	2b000042 	blcs	6114 <.debug_info+0x6114>
    6008:	00570297 			; <UNDEFINED> instruction: 0x00570297
    600c:	1ba40000 	blne	fe906014 <__crc_of_fdt_unflatten_tree+0x77bc4a57>
    6010:	00000303 	andeq	r0, r0, r3, lsl #6
    6014:	9d02982b 	stcls	8, cr9, [r2, #-172]	; 0xffffff54
    6018:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    601c:	0067251b 	rsbeq	r2, r7, fp, lsl r5
    6020:	02992b00 	addseq	r2, r9, #0, 22
    6024:	0000009d 	muleq	r0, sp, r0
    6028:	0ad11baa 	beq	ff446eb0 <__crc_of_fdt_unflatten_tree+0x787058f3>
    602c:	9b2b0000 	blls	ac6034 <unflatten_and_copy_device_tree+0xac51c0>
    6030:	0002c702 	andeq	ip, r2, r2, lsl #14
    6034:	2b1bac00 	blcs	6eb008 <unflatten_and_copy_device_tree+0x6ea194>
    6038:	2b000016 	blcs	6098 <.debug_info+0x6098>
    603c:	02c7029c 	sbceq	r0, r7, #156, 4	; 0xc0000009
    6040:	19b40000 	ldmibne	r4!, {}	; <UNPREDICTABLE>
    6044:	00007683 	andeq	r7, r0, r3, lsl #13
    6048:	021d1bbc 	andseq	r1, sp, #188, 22	; 0x2f000
    604c:	a12b0000 			; <UNDEFINED> instruction: 0xa12b0000
    6050:	0000c902 	andeq	ip, r0, r2, lsl #18
    6054:	2a1bc800 	bcs	6f2008 <unflatten_and_copy_device_tree+0x6f1194>
    6058:	2b000043 	blcs	616c <.debug_info+0x616c>
    605c:	02bc02a2 	adcseq	r0, ip, #536870922	; 0x2000000a
    6060:	1bd00000 	blne	ff406068 <__crc_of_fdt_unflatten_tree+0x786c4aab>
    6064:	000064c8 	andeq	r6, r0, r8, asr #9
    6068:	bc02a32b 	stclt	3, cr10, [r2], {43}	; 0x2b
    606c:	d4000002 	strle	r0, [r0], #-2
    6070:	001f6f1b 	andseq	r6, pc, fp, lsl pc	; <UNPREDICTABLE>
    6074:	02a42b00 	adceq	r2, r4, #0, 22
    6078:	000002bc 			; <UNDEFINED> instruction: 0x000002bc
    607c:	52ea1bd8 	rscpl	r1, sl, #216, 22	; 0x36000
    6080:	a82b0000 	stmdage	fp!, {}	; <UNPREDICTABLE>
    6084:	007a2802 	rsbseq	r2, sl, r2, lsl #16
    6088:	691bdc00 	ldmdbvs	fp, {sl, fp, ip, lr, pc}
    608c:	2b00000d 	blcs	60c8 <.debug_info+0x60c8>
    6090:	7a7502a9 	bvc	1d46b3c <unflatten_and_copy_device_tree+0x1d45cc8>
    6094:	1be00000 	blne	ff80609c <__crc_of_fdt_unflatten_tree+0x78ac4adf>
    6098:	00003187 	andeq	r3, r0, r7, lsl #3
    609c:	5402aa2b 	strpl	sl, [r2], #-2603	; 0xfffff5d5
    60a0:	e4000020 	str	r0, [r0], #-32	; 0xffffffe0
    60a4:	0029331f 	eoreq	r3, r9, pc, lsl r3
    60a8:	02ab2b00 	adceq	r2, fp, #0, 22
    60ac:	000002c7 	andeq	r0, r0, r7, asr #5
    60b0:	a532013c 	ldrge	r0, [r2, #-316]!	; 0xfffffec4
    60b4:	44000076 	strmi	r0, [r0], #-118	; 0xffffff8a
    60b8:	3c031f01 	stccc	15, cr1, [r3], {1}
    60bc:	b32b0000 			; <UNDEFINED> instruction: 0xb32b0000
    60c0:	00005e02 	andeq	r5, r0, r2, lsl #28
    60c4:	1f014800 	svcne	0x00014800
    60c8:	00005e0c 	andeq	r5, r0, ip, lsl #28
    60cc:	5e02b62b 	cfmadd32pl	mvax1, mvfx11, mvfx2, mvfx11
    60d0:	4c000000 	stcmi	0, cr0, [r0], {-0}
    60d4:	213d1f01 	teqcs	sp, r1, lsl #30
    60d8:	b72b0000 	strlt	r0, [fp, -r0]!
    60dc:	0002f202 	andeq	pc, r2, r2, lsl #4
    60e0:	1f015000 	svcne	0x00015000
    60e4:	0000540d 	andeq	r5, r0, sp, lsl #8
    60e8:	7802ba2b 	stmdavc	r2, {r0, r1, r3, r5, r9, fp, ip, sp, pc}
    60ec:	54000003 	strpl	r0, [r0], #-3
    60f0:	04080001 	streq	r0, [r8], #-1
    60f4:	00005e82 	andeq	r5, r0, r2, lsl #29
    60f8:	00002c06 	andeq	r2, r0, r6, lsl #24
    60fc:	00610800 	rsbeq	r0, r1, r0, lsl #16
    6100:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    6104:	00230000 	eoreq	r0, r3, r0
    6108:	000bc210 	andeq	ip, fp, r0, lsl r2
    610c:	965b4000 	ldrbls	r4, [fp], -r0
    6110:	000061b1 			; <UNDEFINED> instruction: 0x000061b1
    6114:	004ed00f 	subeq	sp, lr, pc
    6118:	95975b00 	ldrls	r5, [r7, #2816]	; 0xb00
    611c:	00000064 	andeq	r0, r0, r4, rrx
    6120:	002fc90f 	eoreq	ip, pc, pc, lsl #18
    6124:	95985b00 	ldrls	r5, [r8, #2816]	; 0xb00
    6128:	04000064 	streq	r0, [r0], #-100	; 0xffffff9c
    612c:	0065370f 	rsbeq	r3, r5, pc, lsl #14
    6130:	c0995b00 	addsgt	r5, r9, r0, lsl #22
    6134:	08000064 	stmdaeq	r0, {r2, r5, r6}
    6138:	0019360f 	andseq	r3, r9, pc, lsl #12
    613c:	f49a5b00 			; <UNDEFINED> instruction: 0xf49a5b00
    6140:	0c000064 	stceq	0, cr0, [r0], {100}	; 0x64
    6144:	005d940f 	subseq	r9, sp, pc, lsl #8
    6148:	099c5b00 	ldmibeq	ip, {r8, r9, fp, ip, lr}
    614c:	10000065 	andne	r0, r0, r5, rrx
    6150:	0051340f 	subseq	r3, r1, pc, lsl #8
    6154:	1a9d5b00 	bne	fe75cd5c <__crc_of_fdt_unflatten_tree+0x77a1b79f>
    6158:	14000065 	strne	r0, [r0], #-101	; 0xffffff9b
    615c:	0021890f 	eoreq	r8, r1, pc, lsl #18
    6160:	1a9e5b00 	bne	fe79cd68 <__crc_of_fdt_unflatten_tree+0x77a5b7ab>
    6164:	18000065 	stmdane	r0, {r0, r2, r5, r6}
    6168:	005d1a0f 	subseq	r1, sp, pc, lsl #20
    616c:	309f5b00 	addscc	r5, pc, r0, lsl #22
    6170:	1c000065 	stcne	0, cr0, [r0], {101}	; 0x65
    6174:	0035f80f 	eorseq	pc, r5, pc, lsl #16
    6178:	4fa05b00 	svcmi	0x00a05b00
    617c:	20000065 	andcs	r0, r0, r5, rrx
    6180:	0041280f 	subeq	r2, r1, pc, lsl #16
    6184:	9aa15b00 	bls	fe85cd8c <__crc_of_fdt_unflatten_tree+0x77b1b7cf>
    6188:	24000065 	strcs	r0, [r0], #-101	; 0xffffff9b
    618c:	001a0b0f 	andseq	r0, sl, pc, lsl #22
    6190:	b4a25b00 	strtlt	r5, [r2], #2816	; 0xb00
    6194:	28000065 	stmdacs	r0, {r0, r2, r5, r6}
    6198:	0062130f 	rsbeq	r1, r2, pc, lsl #6
    619c:	cea35b00 	vfmagt.f64	d5, d3, d0
    61a0:	2c000065 	stccs	0, cr0, [r0], {101}	; 0x65
    61a4:	0013900f 	andseq	r9, r3, pc
    61a8:	e8a45b00 	stmia	r4!, {r8, r9, fp, ip, lr}
    61ac:	30000065 	andcc	r0, r0, r5, rrx
    61b0:	b7040800 	strlt	r0, [r4, -r0, lsl #16]
    61b4:	09000061 	stmdbeq	r0, {r0, r5, r6}
    61b8:	00006108 	andeq	r6, r0, r8, lsl #2
    61bc:	001a141c 	andseq	r1, sl, ip, lsl r4
    61c0:	2b040000 	blcs	1061c8 <unflatten_and_copy_device_tree+0x105354>
    61c4:	647b0532 	ldrbtvs	r0, [fp], #-1330	; 0xffffface
    61c8:	da1b0000 	ble	6c0008 <unflatten_and_copy_device_tree+0x6bf194>
    61cc:	2b00005b 	blcs	6340 <.debug_info+0x6340>
    61d0:	02c70533 	sbceq	r0, r7, #213909504	; 0xcc00000
    61d4:	1b000000 	blne	61dc <.debug_info+0x61dc>
    61d8:	00000eca 	andeq	r0, r0, sl, asr #29
    61dc:	cf05342b 	svcgt	0x0005342b
    61e0:	08000001 	stmdaeq	r0, {r0}
    61e4:	0049171b 	subeq	r1, r9, fp, lsl r7
    61e8:	05352b00 	ldreq	r2, [r5, #-2816]!	; 0xfffff500
    61ec:	0000002c 	andeq	r0, r0, ip, lsr #32
    61f0:	60491b0c 	subvs	r1, r9, ip, lsl #22
    61f4:	362b0000 	strtcc	r0, [fp], -r0
    61f8:	0000d405 	andeq	sp, r0, r5, lsl #8
    61fc:	491b1000 	ldmdbmi	fp, {ip}
    6200:	2b000047 	blcs	6324 <.debug_info+0x6324>
    6204:	02230537 	eoreq	r0, r3, #230686720	; 0xdc00000
    6208:	1b180000 	blne	606210 <unflatten_and_copy_device_tree+0x60539c>
    620c:	00002720 	andeq	r2, r0, r0, lsr #14
    6210:	6405382b 	strvs	r3, [r5], #-2091	; 0xfffff7d5
    6214:	20000080 	andcs	r0, r0, r0, lsl #1
    6218:	0038a71b 	eorseq	sl, r8, fp, lsl r7
    621c:	05392b00 	ldreq	r2, [r9, #-2816]!	; 0xfffff500
    6220:	00008196 	muleq	r0, r6, r1
    6224:	32151b24 	andscc	r1, r5, #36, 22	; 0x9000
    6228:	3a2b0000 	bcc	ac6230 <unflatten_and_copy_device_tree+0xac53bc>
    622c:	0081a105 	addeq	sl, r1, r5, lsl #2
    6230:	a11b2800 	tstge	fp, r0, lsl #16
    6234:	2b000003 	blcs	6248 <.debug_info+0x6248>
    6238:	81ac053b 			; <UNDEFINED> instruction: 0x81ac053b
    623c:	1b2c0000 	blne	b06244 <unflatten_and_copy_device_tree+0xb053d0>
    6240:	000023d4 	ldrdeq	r2, [r0], -r4
    6244:	bc053c2b 	stclt	12, cr3, [r5], {43}	; 0x2b
    6248:	30000081 	andcc	r0, r0, r1, lsl #1
    624c:	00084e1b 	andeq	r4, r8, fp, lsl lr
    6250:	053d2b00 	ldreq	r2, [sp, #-2816]!	; 0xfffff500
    6254:	000000d4 	ldrdeq	r0, [r0], -r4
    6258:	1fdf1b34 	svcne	0x00df1b34
    625c:	3e2b0000 	cdpcc	0, 2, cr0, cr11, cr0, {0}
    6260:	0000d405 	andeq	sp, r0, r5, lsl #8
    6264:	f81b3800 			; <UNDEFINED> instruction: 0xf81b3800
    6268:	2b000037 	blcs	634c <.debug_info+0x634c>
    626c:	00d4053f 	sbcseq	r0, r4, pc, lsr r5
    6270:	1b3c0000 	blne	f06278 <unflatten_and_copy_device_tree+0xf05404>
    6274:	00002e99 	muleq	r0, r9, lr
    6278:	7c05402b 	stcvc	0, cr4, [r5], {43}	; 0x2b
    627c:	4000005e 	andmi	r0, r0, lr, asr r0
    6280:	002d211b 	eoreq	r2, sp, fp, lsl r1
    6284:	05412b00 	strbeq	r2, [r1, #-2816]	; 0xfffff500
    6288:	00001989 	andeq	r1, r0, r9, lsl #19
    628c:	52271b44 	eorpl	r1, r7, #68, 22	; 0x11000
    6290:	422b0000 	eormi	r0, fp, #0
    6294:	00005705 	andeq	r5, r0, r5, lsl #14
    6298:	a21b5c00 	andsge	r5, fp, #0, 24
    629c:	2b00004e 	blcs	63dc <.debug_info+0x63dc>
    62a0:	02bc0543 	adcseq	r0, ip, #281018368	; 0x10c00000
    62a4:	1b600000 	blne	18062ac <unflatten_and_copy_device_tree+0x1805438>
    62a8:	0000313c 	andeq	r3, r0, ip, lsr r1
    62ac:	cc05472b 	stcgt	7, cr4, [r5], {43}	; 0x2b
    62b0:	64000081 	strvs	r0, [r0], #-129	; 0xffffff7f
    62b4:	0048241b 	subeq	r2, r8, fp, lsl r4
    62b8:	05492b00 	strbeq	r2, [r9, #-2816]	; 0xfffff500
    62bc:	00005c95 	muleq	r0, r5, ip
    62c0:	52be1b68 	adcspl	r1, lr, #104, 22	; 0x1a000
    62c4:	4a2b0000 	bmi	ac62cc <unflatten_and_copy_device_tree+0xac5458>
    62c8:	0002c705 	andeq	ip, r2, r5, lsl #14
    62cc:	e91b6c00 	ldmdb	fp, {sl, fp, sp, lr}
    62d0:	2b000057 	blcs	6434 <.debug_info+0x6434>
    62d4:	694f054b 	stmdbvs	pc, {r0, r1, r3, r6, r8, sl}^	; <UNPREDICTABLE>
    62d8:	1b740000 	blne	1d062e0 <unflatten_and_copy_device_tree+0x1d0546c>
    62dc:	0000052e 	andeq	r0, r0, lr, lsr #10
    62e0:	1b054c2b 	blne	159394 <unflatten_and_copy_device_tree+0x158520>
    62e4:	7800004f 	stmdavc	r0, {r0, r1, r2, r3, r6}
    62e8:	0015401b 	andseq	r4, r5, fp, lsl r0
    62ec:	054d2b00 	strbeq	r2, [sp, #-2816]	; 0xfffff500
    62f0:	000081e2 	andeq	r8, r0, r2, ror #3
    62f4:	4bd01b7c 	blmi	ff406df8 <__crc_of_fdt_unflatten_tree+0x786c583b>
    62f8:	4e2b0000 	cdpmi	0, 2, cr0, cr11, cr0, {0}
    62fc:	00030b05 	andeq	r0, r3, r5, lsl #22
    6300:	901b8000 	andsls	r8, fp, r0
    6304:	2b000048 	blcs	642c <.debug_info+0x642c>
    6308:	0069054f 	rsbeq	r0, r9, pc, asr #10
    630c:	1b880000 	blne	fe206314 <__crc_of_fdt_unflatten_tree+0x774c4d57>
    6310:	00002713 	andeq	r2, r0, r3, lsl r7
    6314:	4e05502b 	cdpmi	0, 0, cr5, cr5, cr11, {1}
    6318:	90000072 	andls	r0, r0, r2, ror r0
    631c:	0025fb1f 	eoreq	pc, r5, pc, lsl fp	; <UNPREDICTABLE>
    6320:	05522b00 	ldrbeq	r2, [r2, #-2816]	; 0xfffff500
    6324:	00007f5a 	andeq	r7, r0, sl, asr pc
    6328:	ed1f0188 	ldfs	f0, [pc, #-544]	; fffffde8 <__crc_of_fdt_unflatten_tree+0x792be82b>
    632c:	2b000002 	blcs	633c <.debug_info+0x633c>
    6330:	5a590554 	bpl	1647888 <unflatten_and_copy_device_tree+0x1646a14>
    6334:	02880000 	addeq	r0, r8, #0
    6338:	0058211f 	subseq	r2, r8, pc, lsl r1
    633c:	05552b00 	ldrbeq	r2, [r5, #-2816]	; 0xfffff500
    6340:	000081e8 	andeq	r8, r0, r8, ror #3
    6344:	cf1f02a8 	svcgt	0x001f02a8
    6348:	2b00005d 	blcs	64c4 <.debug_info+0x64c4>
    634c:	03780557 	cmneq	r8, #364904448	; 0x15c00000
    6350:	02b80000 	adcseq	r0, r8, #0
    6354:	0004f31f 	andeq	pc, r4, pc, lsl r3	; <UNPREDICTABLE>
    6358:	05582b00 	ldrbeq	r2, [r8, #-2816]	; 0xfffff500
    635c:	00000069 	andeq	r0, r0, r9, rrx
    6360:	fc1f02bc 	ldc2	2, cr0, [pc], {188}	; 0xbc
    6364:	2b000050 	blcs	64ac <.debug_info+0x64ac>
    6368:	02860559 	addeq	r0, r6, #373293056	; 0x16400000
    636c:	02c00000 	sbceq	r0, r0, #0
    6370:	0012a21f 	andseq	sl, r2, pc, lsl r2
    6374:	055d2b00 	ldrbeq	r2, [sp, #-2816]	; 0xfffff500
    6378:	000000b3 	strheq	r0, [r0], -r3
    637c:	711f02c4 	tstvc	pc, r4, asr #5
    6380:	2b00001a 	blcs	63f0 <.debug_info+0x63f0>
    6384:	19400563 	stmdbne	r0, {r0, r1, r5, r6, r8, sl}^
    6388:	02c80000 	sbceq	r0, r8, #0
    638c:	00117e1f 	andseq	r7, r1, pc, lsl lr
    6390:	05692b00 	strbeq	r2, [r9, #-2816]!	; 0xfffff500
    6394:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    6398:	641f02e0 	ldrvs	r0, [pc], #-736	; 8 <.debug_info+0x8>
    639c:	2b000021 	blcs	6428 <.debug_info+0x6428>
    63a0:	01b3056f 			; <UNDEFINED> instruction: 0x01b3056f
    63a4:	02e40000 	rsceq	r0, r4, #0
    63a8:	0056f81f 	subseq	pc, r6, pc, lsl r8	; <UNPREDICTABLE>
    63ac:	05702b00 	ldrbeq	r2, [r0, #-2816]!	; 0xfffff500
    63b0:	000061b1 			; <UNDEFINED> instruction: 0x000061b1
    63b4:	571f02e8 	ldrpl	r0, [pc, -r8, ror #5]
    63b8:	2b00004d 	blcs	64f4 <.debug_info+0x64f4>
    63bc:	00570575 	subseq	r0, r7, r5, ror r5
    63c0:	02ec0000 	rsceq	r0, ip, #0
    63c4:	0020201f 	eoreq	r2, r0, pc, lsl r0
    63c8:	05772b00 	ldrbeq	r2, [r7, #-2816]!	; 0xfffff500
    63cc:	0000260a 	andeq	r2, r0, sl, lsl #12
    63d0:	e31f02f0 	tst	pc, #240, 4
    63d4:	2b000009 	blcs	6400 <.debug_info+0x6400>
    63d8:	11bb057a 			; <UNDEFINED> instruction: 0x11bb057a
    63dc:	03100000 	tsteq	r0, #0
    63e0:	0036c71f 	eorseq	ip, r6, pc, lsl r7
    63e4:	057d2b00 	ldrbeq	r2, [sp, #-2816]!	; 0xfffff500
    63e8:	00000057 	andeq	r0, r0, r7, asr r0
    63ec:	a61f0314 			; <UNDEFINED> instruction: 0xa61f0314
    63f0:	2b00004d 	blcs	652c <.debug_info+0x652c>
    63f4:	1b300580 	blne	c079fc <unflatten_and_copy_device_tree+0xc06b88>
    63f8:	03180000 	tsteq	r8, #0
    63fc:	004c5f1f 	subeq	r5, ip, pc, lsl pc
    6400:	05812b00 	streq	r2, [r1, #2816]	; 0xb00
    6404:	000002f2 	strdeq	r0, [r0], -r2
    6408:	9f1f031c 	svcls	0x001f031c
    640c:	2b000057 	blcs	6570 <.debug_info+0x6570>
    6410:	66780587 	ldrbtvs	r0, [r8], -r7, lsl #11
    6414:	03400000 	movteq	r0, #0
    6418:	00602f1f 	rsbeq	r2, r0, pc, lsl pc
    641c:	05882b00 	streq	r2, [r8, #2816]	; 0xb00
    6420:	00006678 	andeq	r6, r0, r8, ror r6
    6424:	721e0380 	andsvc	r0, lr, #128, 6
    6428:	2b007563 	blcs	239bc <unflatten_and_copy_device_tree+0x22b48>
    642c:	033c0589 	teqeq	ip, #574619648	; 0x22400000
    6430:	038c0000 	orreq	r0, ip, #0
    6434:	0034cd1f 	eorseq	ip, r4, pc, lsl sp
    6438:	058a2b00 	streq	r2, [sl, #2816]	; 0xb00
    643c:	00001afa 	strdeq	r1, [r0], -sl
    6440:	081f0394 	ldmdaeq	pc, {r2, r4, r7, r8, r9}	; <UNPREDICTABLE>
    6444:	2b000053 	blcs	6598 <.debug_info+0x6598>
    6448:	1940058c 	stmdbne	r0, {r2, r3, r7, r8, sl}^
    644c:	03a40000 			; <UNDEFINED> instruction: 0x03a40000
    6450:	0008b91f 	andeq	fp, r8, pc, lsl r9
    6454:	05912b00 	ldreq	r2, [r1, #2816]	; 0xb00
    6458:	00000057 	andeq	r0, r0, r7, asr r0
    645c:	221f03bc 	andscs	r0, pc, #188, 6	; 0xf0000002
    6460:	2b000040 	blcs	6568 <.debug_info+0x6568>
    6464:	10ff0594 	smlalsne	r0, pc, r4, r5	; <UNPREDICTABLE>
    6468:	03c00000 	biceq	r0, r0, #0
    646c:	0011ea1f 	andseq	lr, r1, pc, lsl sl
    6470:	05952b00 	ldreq	r2, [r5, #2816]	; 0xb00
    6474:	000002c7 	andeq	r0, r0, r7, asr #5
    6478:	080003c4 	stmdaeq	r0, {r2, r6, r7, r8, r9}
    647c:	0061bc04 	rsbeq	fp, r1, r4, lsl #24
    6480:	00571500 	subseq	r1, r7, r0, lsl #10
    6484:	64950000 	ldrvs	r0, [r5], #0
    6488:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    648c:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    6490:	00000069 	andeq	r0, r0, r9, rrx
    6494:	81040800 	tsthi	r4, r0, lsl #16
    6498:	15000064 	strne	r0, [r0, #-100]	; 0xffffff9c
    649c:	00000057 	andeq	r0, r0, r7, asr r0
    64a0:	000064af 	andeq	r6, r0, pc, lsr #9
    64a4:	0064af0d 	rsbeq	sl, r4, sp, lsl #30
    64a8:	64ba0d00 	ldrtvs	r0, [sl], #3328	; 0xd00
    64ac:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    64b0:	0064b504 	rsbeq	fp, r4, r4, lsl #10
    64b4:	5daf0900 	stcpl	9, cr0, [pc]	; 64bc <.debug_info+0x64bc>
    64b8:	04080000 	streq	r0, [r8], #-0
    64bc:	00005d66 	andeq	r5, r0, r6, ror #26
    64c0:	649b0408 	ldrvs	r0, [fp], #1032	; 0x408
    64c4:	57150000 	ldrpl	r0, [r5, -r0]
    64c8:	e9000000 	stmdb	r0, {}	; <UNPREDICTABLE>
    64cc:	0d000064 	stceq	0, cr0, [r0, #-400]	; 0xfffffe70
    64d0:	000064af 	andeq	r6, r0, pc, lsr #9
    64d4:	0064af0d 	rsbeq	sl, r4, sp, lsl #30
    64d8:	00690d00 	rsbeq	r0, r9, r0, lsl #26
    64dc:	f20d0000 	vhadd.s8	d0, d13, d0
    64e0:	0d000000 	stceq	0, cr0, [r0, #-0]
    64e4:	000064e9 	andeq	r6, r0, r9, ror #9
    64e8:	ef040800 	svc	0x00040800
    64ec:	09000064 	stmdbeq	r0, {r2, r5, r6}
    64f0:	00005d66 	andeq	r5, r0, r6, ror #26
    64f4:	64c60408 	strbvs	r0, [r6], #1032	; 0x408
    64f8:	57150000 	ldrpl	r0, [r5, -r0]
    64fc:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    6500:	0d000065 	stceq	0, cr0, [r0, #-404]	; 0xfffffe6c
    6504:	000064af 	andeq	r6, r0, pc, lsr #9
    6508:	fa040800 	blx	108510 <unflatten_and_copy_device_tree+0x10769c>
    650c:	0c000064 	stceq	0, cr0, [r0], {100}	; 0x64
    6510:	0000651a 	andeq	r6, r0, sl, lsl r5
    6514:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    6518:	04080000 	streq	r0, [r8], #-0
    651c:	0000650f 	andeq	r6, r0, pc, lsl #10
    6520:	0065300c 	rsbeq	r3, r5, ip
    6524:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    6528:	f20d0000 	vhadd.s8	d0, d13, d0
    652c:	00000060 	andeq	r0, r0, r0, rrx
    6530:	65200408 	strvs	r0, [r0, #-1032]!	; 0xfffffbf8
    6534:	b3150000 	tstlt	r5, #0
    6538:	4f000001 	svcmi	0x00000001
    653c:	0d000065 	stceq	0, cr0, [r0, #-404]	; 0xfffffe6c
    6540:	00005e7c 	andeq	r5, r0, ip, ror lr
    6544:	0001b30d 	andeq	fp, r1, sp, lsl #6
    6548:	00570d00 	subseq	r0, r7, r0, lsl #26
    654c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    6550:	00653604 	rsbeq	r3, r5, r4, lsl #12
    6554:	068b1600 	streq	r1, [fp], r0, lsl #12
    6558:	69150000 	ldmdbvs	r5, {}	; <UNPREDICTABLE>
    655c:	69000065 	stmdbvs	r0, {r0, r2, r5, r6}
    6560:	0d000065 	stceq	0, cr0, [r0, #-404]	; 0xfffffe6c
    6564:	0000656f 	andeq	r6, r0, pc, ror #10
    6568:	55040800 	strpl	r0, [r4, #-2048]	; 0xfffff800
    656c:	08000065 	stmdaeq	r0, {r0, r2, r5, r6}
    6570:	00657504 	rsbeq	r7, r5, r4, lsl #10
    6574:	37261000 	strcc	r1, [r6, -r0]!
    6578:	5c080000 	stcpl	0, cr0, [r8], {-0}
    657c:	00659a07 	rsbeq	r9, r5, r7, lsl #20
    6580:	6e6d1400 	cdpvs	4, 6, cr1, cr13, cr0, {0}
    6584:	085c0074 	ldmdaeq	ip, {r2, r4, r5, r6}^
    6588:	00006569 	andeq	r6, r0, r9, ror #10
    658c:	3d370f00 	ldccc	15, cr0, [r7, #-0]
    6590:	095c0000 	ldmdbeq	ip, {}^	; <UNPREDICTABLE>
    6594:	00005e7c 	andeq	r5, r0, ip, ror lr
    6598:	04080004 	streq	r0, [r8], #-4
    659c:	0000655a 	andeq	r6, r0, sl, asr r5
    65a0:	00005715 	andeq	r5, r0, r5, lsl r7
    65a4:	0065b400 	rsbeq	fp, r5, r0, lsl #8
    65a8:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    65ac:	fb0d0000 	blx	3465b6 <unflatten_and_copy_device_tree+0x345742>
    65b0:	00000001 	andeq	r0, r0, r1
    65b4:	65a00408 	strvs	r0, [r0, #1032]!	; 0x408
    65b8:	f2150000 	vhadd.s16	d0, d5, d0
    65bc:	ce000060 	cdpgt	0, 0, cr0, cr0, cr0, {3}
    65c0:	0d000065 	stceq	0, cr0, [r0, #-404]	; 0xfffffe6c
    65c4:	00005e7c 	andeq	r5, r0, ip, ror lr
    65c8:	0000690d 	andeq	r6, r0, sp, lsl #18
    65cc:	04080000 	streq	r0, [r8], #-0
    65d0:	000065ba 			; <UNDEFINED> instruction: 0x000065ba
    65d4:	005e7c15 	subseq	r7, lr, r5, lsl ip
    65d8:	0065e800 	rsbeq	lr, r5, r0, lsl #16
    65dc:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    65e0:	f20d0000 	vhadd.s8	d0, d13, d0
    65e4:	00000060 	andeq	r0, r0, r0, rrx
    65e8:	65d40408 	ldrbvs	r0, [r4, #1032]	; 0x408
    65ec:	6f100000 	svcvs	0x00100000
    65f0:	0c00003f 	stceq	0, cr0, [r0], {63}	; 0x3f
    65f4:	66131b5d 			; <UNDEFINED> instruction: 0x66131b5d
    65f8:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    65fc:	5d000005 	stcpl	0, cr0, [r0, #-20]	; 0xffffffec
    6600:	0002c71c 	andeq	ip, r2, ip, lsl r7
    6604:	f50f0000 			; <UNDEFINED> instruction: 0xf50f0000
    6608:	5d000051 	stcpl	0, cr0, [r0, #-324]	; 0xfffffebc
    660c:	0001331e 	andeq	r3, r1, lr, lsl r3
    6610:	10000800 	andne	r0, r0, r0, lsl #16
    6614:	000004ba 			; <UNDEFINED> instruction: 0x000004ba
    6618:	2c215d00 	stccs	13, cr5, [r1], #-0
    661c:	14000066 	strne	r0, [r0], #-102	; 0xffffff9a
    6620:	0075726c 	rsbseq	r7, r5, ip, ror #4
    6624:	662c235d 			; <UNDEFINED> instruction: 0x662c235d
    6628:	00000000 	andeq	r0, r0, r0
    662c:	00663b06 	rsbeq	r3, r6, r6, lsl #22
    6630:	00663b00 	rsbeq	r3, r6, r0, lsl #22
    6634:	00eb2500 	rsceq	r2, fp, r0, lsl #10
    6638:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    663c:	0065ee04 	rsbeq	lr, r5, r4, lsl #28
    6640:	174e1000 	strbne	r1, [lr, -r0]
    6644:	5d400000 	stclpl	0, cr0, [r0, #-0]
    6648:	00667226 	rsbeq	r7, r6, r6, lsr #4
    664c:	155a0f00 	ldrbne	r0, [sl, #-3840]	; 0xfffff100
    6650:	285d0000 	ldmdacs	sp, {}^	; <UNPREDICTABLE>
    6654:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    6658:	726c1400 	rsbvc	r1, ip, #0, 8
    665c:	2a5d0075 	bcs	1746838 <unflatten_and_copy_device_tree+0x17459c4>
    6660:	000065ee 	andeq	r6, r0, lr, ror #11
    6664:	10180f04 	andsne	r0, r8, r4, lsl #30
    6668:	2d5d0000 	ldclcs	0, cr0, [sp, #-0]
    666c:	00006672 	andeq	r6, r0, r2, ror r6
    6670:	04080010 	streq	r0, [r8], #-16
    6674:	00006613 	andeq	r6, r0, r3, lsl r6
    6678:	004c8510 	subeq	r8, ip, r0, lsl r5
    667c:	315d0c00 	cmpcc	sp, r0, lsl #24
    6680:	0000669d 	muleq	r0, sp, r6
    6684:	00433d0f 	subeq	r3, r3, pc, lsl #26
    6688:	9d325d00 	ldcls	13, cr5, [r2, #-0]
    668c:	00000066 	andeq	r0, r0, r6, rrx
    6690:	00058e0f 	andeq	r8, r5, pc, lsl #28
    6694:	c7345d00 	ldrgt	r5, [r4, -r0, lsl #26]!
    6698:	04000002 	streq	r0, [r0], #-2
    669c:	41040800 	tstmi	r4, r0, lsl #16
    66a0:	0e000066 	cdpeq	0, 0, cr0, cr0, cr6, {3}
    66a4:	c45b5e08 	ldrbgt	r5, [fp], #-3592	; 0xfffff1f8
    66a8:	0f000066 	svceq	0x00000066
    66ac:	00002322 	andeq	r2, r0, r2, lsr #6
    66b0:	67155d5e 			; <UNDEFINED> instruction: 0x67155d5e
    66b4:	0f000000 	svceq	0x00000000
    66b8:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
    66bc:	03785f5e 	cmneq	r8, #376	; 0x178
    66c0:	00040000 	andeq	r0, r4, r0
    66c4:	002abe30 	eoreq	fp, sl, r0, lsr lr
    66c8:	5e013000 	cdppl	0, 0, cr3, cr1, cr0, {0}
    66cc:	00671557 	rsbeq	r1, r7, r7, asr r5
    66d0:	37260f00 	strcc	r0, [r6, -r0, lsl #30]!
    66d4:	585e0000 	ldmdapl	lr, {}^	; <UNPREDICTABLE>
    66d8:	00000069 	andeq	r0, r0, r9, rrx
    66dc:	3ba10f00 	blcc	fe843c08 <__crc_of_fdt_unflatten_tree+0x77b0264b>
    66e0:	595e0000 	ldmdbpl	lr, {}^	; <UNPREDICTABLE>
    66e4:	00000069 	andeq	r0, r0, r9, rrx
    66e8:	671b1904 	ldrvs	r1, [fp, -r4, lsl #18]
    66ec:	0f080000 	svceq	0x00080000
    66f0:	00001f10 	andeq	r1, r0, r0, lsl pc
    66f4:	02c7655e 	sbceq	r6, r7, #394264576	; 0x17800000
    66f8:	0f100000 	svceq	0x00100000
    66fc:	000042ad 	andeq	r4, r0, sp, lsr #5
    6700:	6734665e 			; <UNDEFINED> instruction: 0x6734665e
    6704:	31180000 	tstcc	r8, r0
    6708:	00001fb3 			; <UNDEFINED> instruction: 0x00001fb3
    670c:	6744675e 	smlsldvs	r6, r4, lr, r7
    6710:	01180000 	tsteq	r8, r0
    6714:	c4040800 	strgt	r0, [r4], #-2048	; 0xfffff800
    6718:	17000066 	strne	r0, [r0, -r6, rrx]
    671c:	345a5e08 	ldrbcc	r5, [sl], #-3592	; 0xfffff1f8
    6720:	28000067 	stmdacs	r0, {r0, r1, r2, r5, r6}
    6724:	000066a3 	andeq	r6, r0, r3, lsr #13
    6728:	0010f318 	andseq	pc, r0, r8, lsl r3	; <UNPREDICTABLE>
    672c:	3c625e00 	stclcc	14, cr5, [r2], #-0
    6730:	00000003 	andeq	r0, r0, r3
    6734:	00037806 	andeq	r7, r3, r6, lsl #16
    6738:	00674400 	rsbeq	r4, r7, r0, lsl #8
    673c:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    6740:	003f0000 	eorseq	r0, pc, r0
    6744:	0000d406 	andeq	sp, r0, r6, lsl #8
    6748:	00675a00 	rsbeq	r5, r7, r0, lsl #20
    674c:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    6750:	07020000 	streq	r0, [r2, -r0]
    6754:	000000eb 	andeq	r0, r0, fp, ror #1
    6758:	1d100001 	ldcne	0, cr0, [r0, #-4]
    675c:	0c000028 	stceq	0, cr0, [r0], {40}	; 0x28
    6760:	678b6b5e 			; <UNDEFINED> instruction: 0x678b6b5e
    6764:	e00f0000 	and	r0, pc, r0
    6768:	5e000004 	cdppl	0, 0, cr0, cr0, cr4, {0}
    676c:	0000696c 	andeq	r6, r0, ip, ror #18
    6770:	fd0f0000 	stc2	0, cr0, [pc, #-0]	; 8 <.debug_info+0x8>
    6774:	5e000030 	mcrpl	0, 0, r0, cr0, cr0, {1}
    6778:	00027b6d 	andeq	r7, r2, sp, ror #22
    677c:	d80f0400 	stmdale	pc, {sl}	; <UNPREDICTABLE>
    6780:	5e000052 	mcrpl	0, 0, r0, cr0, cr2, {2}
    6784:	0067156e 	rsbeq	r1, r7, lr, ror #10
    6788:	10000800 	andne	r0, r0, r0, lsl #16
    678c:	00002627 	andeq	r2, r0, r7, lsr #12
    6790:	e0105f38 	ands	r5, r0, r8, lsr pc
    6794:	0f000067 	svceq	0x00000067
    6798:	00004a3e 	andeq	r4, r0, lr, lsr sl
    679c:	0077115f 	rsbseq	r1, r7, pc, asr r1
    67a0:	0f000000 	svceq	0x00000000
    67a4:	00002989 	andeq	r2, r0, r9, lsl #19
    67a8:	0077135f 	rsbseq	r1, r7, pc, asr r3
    67ac:	0f080000 	svceq	0x00080000
    67b0:	00004e10 	andeq	r4, r0, r0, lsl lr
    67b4:	0077155f 	rsbseq	r1, r7, pc, asr r5
    67b8:	0f100000 	svceq	0x00100000
    67bc:	0000524b 	andeq	r5, r0, fp, asr #4
    67c0:	67e0165f 	ubfxvs	r1, pc, #12, #1
    67c4:	0f180000 	svceq	0x00180000
    67c8:	00001a47 	andeq	r1, r0, r7, asr #20
    67cc:	005e175f 	subseq	r1, lr, pc, asr r7
    67d0:	0f280000 	svceq	0x00280000
    67d4:	00001be6 	andeq	r1, r0, r6, ror #23
    67d8:	67f0185f 	ubfxvs	r1, pc, #16, #17
    67dc:	002c0000 	eoreq	r0, ip, r0
    67e0:	00007706 	andeq	r7, r0, r6, lsl #14
    67e4:	0067f000 	rsbeq	pc, r7, r0
    67e8:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    67ec:	00010000 	andeq	r0, r1, r0
    67f0:	00005e06 	andeq	r5, r0, r6, lsl #28
    67f4:	00680000 	rsbeq	r0, r8, r0
    67f8:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    67fc:	00020000 	andeq	r0, r2, r0
    6800:	00247026 	eoreq	r7, r4, r6, lsr #32
    6804:	00690400 	rsbeq	r0, r9, r0, lsl #8
    6808:	0a600000 	beq	1806810 <unflatten_and_copy_device_tree+0x180599c>
    680c:	00006823 	andeq	r6, r0, r3, lsr #16
    6810:	005e560b 	subseq	r5, lr, fp, lsl #12
    6814:	280b0000 	stmdacs	fp, {}	; <UNPREDICTABLE>
    6818:	0100005a 	qaddeq	r0, sl, r0
    681c:	0042460b 	subeq	r4, r2, fp, lsl #12
    6820:	1a000200 	bne	7028 <.debug_info+0x7028>
    6824:	00000694 	muleq	r0, r4, r6
    6828:	01d52b8c 	bicseq	r2, r5, ip, lsl #23
    682c:	0000694f 	andeq	r6, r0, pc, asr #18
    6830:	0010231b 	andseq	r2, r0, fp, lsl r3
    6834:	01d62b00 	bicseq	r2, r6, r0, lsl #22
    6838:	000001cf 	andeq	r0, r0, pc, asr #3
    683c:	4c2e1b00 	stcmi	11, cr1, [lr], #-0
    6840:	d72b0000 	strle	r0, [fp, -r0]!
    6844:	00005701 	andeq	r5, r0, r1, lsl #14
    6848:	5f1b0400 	svcpl	0x001b0400
    684c:	2b000015 	blcs	68a8 <.debug_info+0x68a8>
    6850:	60f201d8 	ldrsbtvs	r0, [r2], #24
    6854:	1b080000 	blne	20685c <unflatten_and_copy_device_tree+0x2059e8>
    6858:	00005d21 	andeq	r5, r0, r1, lsr #26
    685c:	7b01d92b 	blvc	7cd10 <unflatten_and_copy_device_tree+0x7be9c>
    6860:	0c000064 	stceq	0, cr0, [r0], {100}	; 0x64
    6864:	0012e91b 	andseq	lr, r2, fp, lsl r9
    6868:	01da2b00 	bicseq	r2, sl, r0, lsl #22
    686c:	00001940 	andeq	r1, r0, r0, asr #18
    6870:	19b01b10 	ldmibne	r0!, {r4, r8, r9, fp, ip}
    6874:	db2b0000 	blle	ac687c <unflatten_and_copy_device_tree+0xac5a08>
    6878:	0002c701 	andeq	ip, r2, r1, lsl #14
    687c:	ef1b2800 	svc	0x001b2800
    6880:	2b000025 	blcs	691c <.debug_info+0x691c>
    6884:	037801dc 	cmneq	r8, #220, 2	; 0x37
    6888:	1b300000 	blne	c06890 <unflatten_and_copy_device_tree+0xc05a1c>
    688c:	00005ea4 	andeq	r5, r0, r4, lsr #29
    6890:	7801dd2b 	stmdavc	r1, {r0, r1, r3, r5, r8, sl, fp, ip, lr, pc}
    6894:	34000003 	strcc	r0, [r0], #-3
    6898:	0037491b 	eorseq	r4, r7, fp, lsl r9
    689c:	01de2b00 	bicseq	r2, lr, r0, lsl #22
    68a0:	00000057 	andeq	r0, r0, r7, asr r0
    68a4:	212d1b38 			; <UNDEFINED> instruction: 0x212d1b38
    68a8:	df2b0000 	svcle	0x002b0000
    68ac:	0001fb01 	andeq	pc, r1, r1, lsl #22
    68b0:	111b3c00 	tstne	fp, r0, lsl #24
    68b4:	2b000035 	blcs	6990 <.debug_info+0x6990>
    68b8:	02c701e1 	sbceq	r0, r7, #1073741880	; 0x40000038
    68bc:	1b400000 	blne	10068c4 <unflatten_and_copy_device_tree+0x1005a50>
    68c0:	00001ac2 	andeq	r1, r0, r2, asr #21
    68c4:	4f01e32b 	svcmi	0x0001e32b
    68c8:	48000069 	stmdami	r0, {r0, r3, r5, r6}
    68cc:	0016861b 	andseq	r8, r6, fp, lsl r6
    68d0:	01e42b00 	mvneq	r2, r0, lsl #22
    68d4:	00000069 	andeq	r0, r0, r9, rrx
    68d8:	07ea1b4c 	strbeq	r1, [sl, ip, asr #22]!
    68dc:	e52b0000 	str	r0, [fp, #-0]!
    68e0:	00764001 	rsbseq	r4, r6, r1
    68e4:	b81b5000 	ldmdalt	fp, {ip, lr}
    68e8:	2b00003e 	blcs	69e8 <.debug_info+0x69e8>
    68ec:	006901e7 	rsbeq	r0, r9, r7, ror #3
    68f0:	1b540000 	blne	15068f8 <unflatten_and_copy_device_tree+0x1505a84>
    68f4:	000029b9 			; <UNDEFINED> instruction: 0x000029b9
    68f8:	5701e82b 	strpl	lr, [r1, -fp, lsr #16]
    68fc:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
    6900:	004e5d1b 	subeq	r5, lr, fp, lsl sp
    6904:	01e92b00 	mvneq	r2, r0, lsl #22
    6908:	0000764b 	andeq	r7, r0, fp, asr #12
    690c:	49541b5c 	ldmdbmi	r4, {r2, r3, r4, r6, r8, r9, fp, ip}^
    6910:	ea2b0000 	b	ac6918 <unflatten_and_copy_device_tree+0xac5aa4>
    6914:	00765601 	rsbseq	r5, r6, r1, lsl #12
    6918:	ff1b6000 			; <UNDEFINED> instruction: 0xff1b6000
    691c:	2b000031 	blcs	69e8 <.debug_info+0x69e8>
    6920:	02c701eb 	sbceq	r0, r7, #-1073741766	; 0xc000003a
    6924:	1b640000 	blne	190692c <unflatten_and_copy_device_tree+0x1905ab8>
    6928:	00002d4d 	andeq	r2, r0, sp, asr #26
    692c:	d401f22b 	strle	pc, [r1], #-555	; 0xfffffdd5
    6930:	6c000000 	stcvs	0, cr0, [r0], {-0}
    6934:	004a811b 	subeq	r8, sl, fp, lsl r1
    6938:	01f52b00 	mvnseq	r2, r0, lsl #22
    693c:	00000057 	andeq	r0, r0, r7, asr r0
    6940:	10d41b70 	sbcsne	r1, r4, r0, ror fp
    6944:	f72b0000 			; <UNDEFINED> instruction: 0xf72b0000
    6948:	00194001 	andseq	r4, r9, r1
    694c:	08007400 	stmdaeq	r0, {sl, ip, sp, lr}
    6950:	00682304 	rsbeq	r2, r8, r4, lsl #6
    6954:	5b040800 	blpl	10895c <unflatten_and_copy_device_tree+0x107ae8>
    6958:	1a000069 	bne	6b04 <.debug_info+0x6b04>
    695c:	00000c24 	andeq	r0, r0, r4, lsr #24
    6960:	01562b20 	cmpeq	r6, r0, lsr #22
    6964:	000069aa 	andeq	r6, r0, sl, lsr #19
    6968:	005d331b 	subseq	r3, sp, fp, lsl r3
    696c:	01572b00 	cmpeq	r7, r0, lsl #22
    6970:	000023cc 	andeq	r2, r0, ip, asr #7
    6974:	28c41b00 	stmiacs	r4, {r8, r9, fp, ip}^
    6978:	582b0000 	stmdapl	fp!, {}	; <UNPREDICTABLE>
    697c:	00022301 	andeq	r2, r2, r1, lsl #6
    6980:	db1b0800 	blle	6c2008 <unflatten_and_copy_device_tree+0x6c1194>
    6984:	2b00001e 	blcs	6a04 <.debug_info+0x6a04>
    6988:	72ef0159 	rscvc	r0, pc, #1073741846	; 0x40000016
    698c:	1b100000 	blne	406994 <unflatten_and_copy_device_tree+0x405b20>
    6990:	0000016d 	andeq	r0, r0, sp, ror #2
    6994:	78015a2b 	stmdavc	r1, {r0, r1, r3, r5, r9, fp, ip, lr}
    6998:	14000003 	strne	r0, [r0], #-3
    699c:	001cfc1b 	andseq	pc, ip, fp, lsl ip	; <UNPREDICTABLE>
    69a0:	015b2b00 	cmpeq	fp, r0, lsl #22
    69a4:	00000057 	andeq	r0, r0, r7, asr r0
    69a8:	461a0018 			; <UNDEFINED> instruction: 0x461a0018
    69ac:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    69b0:	2d01072b 	stccs	7, cr0, [r1, #-172]	; 0xffffff54
    69b4:	1b00006a 	blne	6b64 <.debug_info+0x6b64>
    69b8:	00003106 	andeq	r3, r0, r6, lsl #2
    69bc:	6901082b 	stmdbvs	r1, {r0, r1, r3, r5, fp}
    69c0:	00000000 	andeq	r0, r0, r0
    69c4:	000b8f1b 	andeq	r8, fp, fp, lsl pc
    69c8:	01092b00 	tsteq	r9, r0, lsl #22
    69cc:	000001da 	ldrdeq	r0, [r0], -sl
    69d0:	18701b04 	ldmdane	r0!, {r2, r8, r9, fp, ip}^
    69d4:	0a2b0000 	beq	ac69dc <unflatten_and_copy_device_tree+0xac5b68>
    69d8:	00284201 	eoreq	r4, r8, r1, lsl #4
    69dc:	f21b0800 	vadd.i16	d0, d11, d0
    69e0:	2b000038 	blcs	6ac8 <.debug_info+0x6ac8>
    69e4:	2862010b 	stmdacs	r2!, {r0, r1, r3, r8}^
    69e8:	1b0c0000 	blne	3069f0 <unflatten_and_copy_device_tree+0x305b7c>
    69ec:	00000593 	muleq	r0, r3, r5
    69f0:	23010c2b 	movwcs	r0, #7211	; 0x1c2b
    69f4:	10000002 	andne	r0, r0, r2
    69f8:	0055af1b 	subseq	sl, r5, fp, lsl pc
    69fc:	010d2b00 	tsteq	sp, r0, lsl #22
    6a00:	00000486 	andeq	r0, r0, r6, lsl #9
    6a04:	45d91b18 	ldrbmi	r1, [r9, #2840]	; 0xb18
    6a08:	0e2b0000 	cdpeq	0, 2, cr0, cr11, cr0, {0}
    6a0c:	00048601 	andeq	r8, r4, r1, lsl #12
    6a10:	4e1b2000 	cdpmi	0, 1, cr2, cr11, cr0, {0}
    6a14:	2b00000d 	blcs	6a50 <.debug_info+0x6a50>
    6a18:	0486010f 	streq	r0, [r6], #271	; 0x10f
    6a1c:	1b280000 	blne	a06a24 <unflatten_and_copy_device_tree+0xa05bb0>
    6a20:	00003738 	andeq	r3, r0, r8, lsr r7
    6a24:	cc01162b 	stcgt	6, cr1, [r1], {43}	; 0x2b
    6a28:	30000023 	andcc	r0, r0, r3, lsr #32
    6a2c:	33040800 	movwcc	r0, #18432	; 0x4800
    6a30:	1a00006a 	bne	6be0 <.debug_info+0x6be0>
    6a34:	000012e3 	andeq	r1, r0, r3, ror #5
    6a38:	011d61a8 	tsteq	sp, r8, lsr #3
    6a3c:	00006add 	ldrdeq	r6, [r0], -sp
    6a40:	000bd41b 	andeq	sp, fp, fp, lsl r4
    6a44:	011e6100 	tsteq	lr, r0, lsl #2
    6a48:	0000030b 	andeq	r0, r0, fp, lsl #6
    6a4c:	41631b00 	cmnmi	r3, r0, lsl #22
    6a50:	1f610000 	svcne	0x00610000
    6a54:	0002c701 	andeq	ip, r2, r1, lsl #14
    6a58:	9e1b0800 	cdpls	8, 1, cr0, cr11, cr0, {0}
    6a5c:	6100005a 	qaddvs	r0, sl, r0
    6a60:	02c70120 	sbceq	r0, r7, #32, 2
    6a64:	1b100000 	blne	406a6c <unflatten_and_copy_device_tree+0x405bf8>
    6a68:	000041bc 			; <UNDEFINED> instruction: 0x000041bc
    6a6c:	c7012161 	strgt	r2, [r1, -r1, ror #2]
    6a70:	18000002 	stmdane	r0, {r1}
    6a74:	00360b1b 	eorseq	r0, r6, fp, lsl fp
    6a78:	01226100 			; <UNDEFINED> instruction: 0x01226100
    6a7c:	00001940 	andeq	r1, r0, r0, asr #18
    6a80:	27371b20 	ldrcs	r1, [r7, -r0, lsr #22]!
    6a84:	23610000 	cmncs	r1, #0
    6a88:	0002bc01 	andeq	fp, r2, r1, lsl #24
    6a8c:	c91b3800 	ldmdbgt	fp, {fp, ip, sp}
    6a90:	6100002d 	tstvs	r0, sp, lsr #32
    6a94:	11eb0124 	mvnne	r0, r4, lsr #2
    6a98:	1b3c0000 	blne	f06aa0 <unflatten_and_copy_device_tree+0xf05c2c>
    6a9c:	00000fea 	andeq	r0, r0, sl, ror #31
    6aa0:	7b012561 	blvc	5002c <unflatten_and_copy_device_tree+0x4f1b8>
    6aa4:	48000064 	stmdami	r0, {r2, r5, r6}
    6aa8:	0008231b 	andeq	r2, r8, fp, lsl r3
    6aac:	01266100 			; <UNDEFINED> instruction: 0x01266100
    6ab0:	00006b7f 	andeq	r6, r0, pc, ror fp
    6ab4:	55631b4c 	strbpl	r1, [r3, #-2892]!	; 0xfffff4b4
    6ab8:	27610000 	strbcs	r0, [r1, -r0]!
    6abc:	00022301 	andeq	r2, r2, r1, lsl #6
    6ac0:	3b1b5800 	blcc	6d6008 <unflatten_and_copy_device_tree+0x6d5194>
    6ac4:	61000046 	tstvs	r0, r6, asr #32
    6ac8:	00d40128 	sbcseq	r0, r4, r8, lsr #2
    6acc:	1b600000 	blne	1806ad4 <unflatten_and_copy_device_tree+0x1805c60>
    6ad0:	00005aee 	andeq	r5, r0, lr, ror #21
    6ad4:	9e012961 	cdpls	9, 0, cr2, cr1, cr1, {3}
    6ad8:	6800006b 	stmdavs	r0, {r0, r1, r3, r5, r6}
    6adc:	5dd90300 	ldclpl	3, cr0, [r9]
    6ae0:	13620000 	cmnne	r2, #0
    6ae4:	00000150 	andeq	r0, r0, r0, asr r1
    6ae8:	1562040e 	strbne	r0, [r2, #-1038]!	; 0xfffffbf2
    6aec:	00006afd 	strdeq	r6, [r0], -sp
    6af0:	6c617614 	stclvs	6, cr7, [r1], #-80	; 0xffffffb0
    6af4:	dd166200 	lfmle	f6, 4, [r6, #-0]
    6af8:	0000006a 	andeq	r0, r0, sl, rrx
    6afc:	2f970300 	svccs	0x00970300
    6b00:	17620000 	strbne	r0, [r2, -r0]!
    6b04:	00006ae8 	andeq	r6, r0, r8, ror #21
    6b08:	0069040a 	rsbeq	r0, r9, sl, lsl #8
    6b0c:	83630000 	cmnhi	r3, #0
    6b10:	00006b27 	andeq	r6, r0, r7, lsr #22
    6b14:	0055800b 	subseq	r8, r5, fp
    6b18:	700b0000 	andvc	r0, fp, r0
    6b1c:	10000067 	andne	r0, r0, r7, rrx
    6b20:	0033de0b 	eorseq	sp, r3, fp, lsl #28
    6b24:	26001100 	strcs	r1, [r0], -r0, lsl #2
    6b28:	00003d06 	andeq	r3, r0, r6, lsl #26
    6b2c:	00006904 	andeq	r6, r0, r4, lsl #18
    6b30:	4a366100 	bmi	d9ef38 <unflatten_and_copy_device_tree+0xd9e0c4>
    6b34:	0b00006b 	bleq	6ce8 <.debug_info+0x6ce8>
    6b38:	00001ca1 	andeq	r1, r0, r1, lsr #25
    6b3c:	5b180b00 	blpl	602c08 <unflatten_and_copy_device_tree+0x601d94>
    6b40:	0b010000 	bleq	46b48 <unflatten_and_copy_device_tree+0x45cd4>
    6b44:	0000310f 	andeq	r3, r0, pc, lsl #2
    6b48:	cc030002 	stcgt	0, cr0, [r3], {2}
    6b4c:	61000007 	tstvs	r0, r7
    6b50:	00007042 	andeq	r7, r0, r2, asr #32
    6b54:	61041700 	tstvs	r4, r0, lsl #14
    6b58:	006b7f45 	rsbeq	r7, fp, r5, asr #30
    6b5c:	69752a00 	ldmdbvs	r5!, {r9, fp, sp}^
    6b60:	46610064 	strbtmi	r0, [r1], -r4, rrx
    6b64:	00002842 	andeq	r2, r0, r2, asr #16
    6b68:	6469672a 	strbtvs	r6, [r9], #-1834	; 0xfffff8d6
    6b6c:	62476100 	subvs	r6, r7, #0, 2
    6b70:	18000028 	stmdane	r0, {r3, r5}
    6b74:	000032fb 	strdeq	r3, [r0], -fp
    6b78:	6afd4861 	bvs	fff58d04 <__crc_of_fdt_unflatten_tree+0x79217747>
    6b7c:	10000000 	andne	r0, r0, r0
    6b80:	000040ad 	andeq	r4, r0, sp, lsr #1
    6b84:	9e446108 	dvflss	f6, f4, #0.0
    6b88:	1900006b 	stmdbne	r0, {r0, r1, r3, r5, r6}
    6b8c:	00006b55 	andeq	r6, r0, r5, asr fp
    6b90:	357e0f00 	ldrbcc	r0, [lr, #-3840]!	; 0xfffff100
    6b94:	4a610000 	bmi	1846b9c <unflatten_and_copy_device_tree+0x1845d28>
    6b98:	00006b27 	andeq	r6, r0, r7, lsr #22
    6b9c:	67100004 	ldrvs	r0, [r0, -r4]
    6ba0:	40000036 	andmi	r0, r0, r6, lsr r0
    6ba4:	6c17c361 	ldcvs	3, cr12, [r7], {97}	; 0x61
    6ba8:	8a0f0000 	bhi	3c0008 <unflatten_and_copy_device_tree+0x3bf194>
    6bac:	6100002e 	tstvs	r0, lr, lsr #32
    6bb0:	006b4ac4 	rsbeq	r4, fp, r4, asr #21
    6bb4:	f10f0000 			; <UNDEFINED> instruction: 0xf10f0000
    6bb8:	61000053 	qaddvs	r0, r3, r0
    6bbc:	006b4ac5 	rsbeq	r4, fp, r5, asr #21
    6bc0:	f00f0800 			; <UNDEFINED> instruction: 0xf00f0800
    6bc4:	61000014 	tstvs	r0, r4, lsl r0
    6bc8:	006b4ac6 	rsbeq	r4, fp, r6, asr #21
    6bcc:	1b0f1000 	blne	3c4008 <unflatten_and_copy_device_tree+0x3c3194>
    6bd0:	61000050 	qaddvs	r0, r0, r0
    6bd4:	006b4ac7 	rsbeq	r4, fp, r7, asr #21
    6bd8:	aa0f1800 	bge	3c6008 <unflatten_and_copy_device_tree+0x3c5194>
    6bdc:	61000005 	tstvs	r0, r5
    6be0:	006b4ac8 	rsbeq	r4, fp, r8, asr #21
    6be4:	670f2000 	strvs	r2, [pc, -r0]
    6be8:	61000019 	tstvs	r0, r9, lsl r0
    6bec:	006b4ac9 	rsbeq	r4, fp, r9, asr #21
    6bf0:	4e0f2800 	cdpmi	8, 0, cr2, cr15, cr0, {0}
    6bf4:	6100000c 	tstvs	r0, ip
    6bf8:	006b4aca 	rsbeq	r4, fp, sl, asr #21
    6bfc:	4e0f3000 	cdpmi	0, 0, cr3, cr15, cr0, {0}
    6c00:	61000053 	qaddvs	r0, r3, r0
    6c04:	000244cb 	andeq	r4, r2, fp, asr #9
    6c08:	0e0f3800 	cdpeq	8, 0, cr3, cr15, cr0, {0}
    6c0c:	6100005a 	qaddvs	r0, sl, r0
    6c10:	000244cc 	andeq	r4, r2, ip, asr #9
    6c14:	10003c00 	andne	r3, r0, r0, lsl #24
    6c18:	00005899 	muleq	r0, r9, r8
    6c1c:	90d46138 	sbcsls	r6, r4, r8, lsr r1
    6c20:	0f00006c 	svceq	0x0000006c
    6c24:	00000362 	andeq	r0, r0, r2, ror #6
    6c28:	6cd2d561 	cfldr64vs	mvdx13, [r2], {97}	; 0x61
    6c2c:	0f000000 	svceq	0x00000000
    6c30:	0000508c 	andeq	r5, r0, ip, lsl #1
    6c34:	0057d661 	subseq	sp, r7, r1, ror #12
    6c38:	0f040000 	svceq	0x00040000
    6c3c:	000012ae 	andeq	r1, r0, lr, lsr #5
    6c40:	02c7d861 	sbceq	sp, r7, #6356992	; 0x610000
    6c44:	0f080000 	svceq	0x00080000
    6c48:	000041ee 	andeq	r4, r0, lr, ror #3
    6c4c:	00d4d961 	sbcseq	sp, r4, r1, ror #18
    6c50:	0f100000 	svceq	0x00100000
    6c54:	000015bd 			; <UNDEFINED> instruction: 0x000015bd
    6c58:	0069da61 	rsbeq	sp, r9, r1, ror #20
    6c5c:	0f140000 	svceq	0x00140000
    6c60:	00002794 	muleq	r0, r4, r7
    6c64:	0069db61 	rsbeq	sp, r9, r1, ror #22
    6c68:	0f180000 	svceq	0x00180000
    6c6c:	000041c5 	andeq	r4, r0, r5, asr #3
    6c70:	6b4adc61 	blvs	12bddfc <unflatten_and_copy_device_tree+0x12bcf88>
    6c74:	0f200000 	svceq	0x00200000
    6c78:	00005b75 	andeq	r5, r0, r5, ror fp
    6c7c:	6b4add61 	blvs	12be208 <unflatten_and_copy_device_tree+0x12bd394>
    6c80:	0f280000 	svceq	0x00280000
    6c84:	00005eef 	andeq	r5, r0, pc, ror #29
    6c88:	0378de61 	cmneq	r8, #1552	; 0x610
    6c8c:	00300000 	eorseq	r0, r0, r0
    6c90:	0016ab1a 	andseq	sl, r6, sl, lsl fp
    6c94:	b1611000 	cmnlt	r1, r0
    6c98:	006cd201 	rsbeq	sp, ip, r1, lsl #4
    6c9c:	47a91b00 	strmi	r1, [r9, r0, lsl #22]!
    6ca0:	b2610000 	rsblt	r0, r1, #0
    6ca4:	00005701 	andeq	r5, r0, r1, lsl #14
    6ca8:	861b0000 	ldrhi	r0, [fp], -r0
    6cac:	6100001c 	tstvs	r0, ip, lsl r0
    6cb0:	723801b3 	eorsvc	r0, r8, #-1073741780	; 0xc000002c
    6cb4:	1b040000 	blne	106cbc <unflatten_and_copy_device_tree+0x105e48>
    6cb8:	0000192d 	andeq	r1, r0, sp, lsr #18
    6cbc:	4801b461 	stmdami	r1, {r0, r5, r6, sl, ip, sp, pc}
    6cc0:	08000072 	stmdaeq	r0, {r1, r4, r5, r6}
    6cc4:	000c5c1b 	andeq	r5, ip, fp, lsl ip
    6cc8:	01b56100 			; <UNDEFINED> instruction: 0x01b56100
    6ccc:	00006cd2 	ldrdeq	r6, [r0], -r2
    6cd0:	0408000c 	streq	r0, [r8], #-12
    6cd4:	00006c90 	muleq	r0, r0, ip
    6cd8:	0069040a 	rsbeq	r0, r9, sl, lsl #8
    6cdc:	f3610000 	vhadd.u32	d16, d1, d0
    6ce0:	00006d1b 	andeq	r6, r0, fp, lsl sp
    6ce4:	002f280b 	eoreq	r2, pc, fp, lsl #16
    6ce8:	1d0b0000 	stcne	0, cr0, [fp, #-0]
    6cec:	01000033 	tsteq	r0, r3, lsr r0
    6cf0:	0032a60b 	eorseq	sl, r2, fp, lsl #12
    6cf4:	db0b0200 	blle	2c0808 <unflatten_and_copy_device_tree+0x2bf994>
    6cf8:	03000027 	movweq	r0, #39	; 0x27
    6cfc:	0061400b 	rsbeq	r4, r1, fp
    6d00:	410b0400 	tstmi	fp, r0, lsl #8
    6d04:	05000025 	streq	r0, [r0, #-37]	; 0xffffffdb
    6d08:	0025300b 	eoreq	r3, r5, fp
    6d0c:	3c0b0600 	stccc	6, cr0, [fp], {-0}
    6d10:	07000014 	smladeq	r0, r4, r0, r0
    6d14:	0028d50b 	eoreq	sp, r8, fp, lsl #10
    6d18:	30000800 	andcc	r0, r0, r0, lsl #16
    6d1c:	00003d11 	andeq	r3, r0, r1, lsl sp
    6d20:	ff610120 			; <UNDEFINED> instruction: 0xff610120
    6d24:	00006d43 	andeq	r6, r0, r3, asr #26
    6d28:	0060b61b 	rsbeq	fp, r0, fp, lsl r6
    6d2c:	01006100 	mrseq	r6, (UNDEF: 16)
    6d30:	00006d43 	andeq	r6, r0, r3, asr #26
    6d34:	3b5c1b00 	blcc	1706c08 <unflatten_and_copy_device_tree+0x1705d94>
    6d38:	01610000 	cmneq	r1, r0
    6d3c:	006d5301 	rsbeq	r5, sp, r1, lsl #6
    6d40:	06002000 	streq	r2, [r0], -r0
    6d44:	00000057 	andeq	r0, r0, r7, asr r0
    6d48:	00006d53 	andeq	r6, r0, r3, asr sp
    6d4c:	0000eb07 	andeq	lr, r0, r7, lsl #22
    6d50:	06000700 	streq	r0, [r0], -r0, lsl #14
    6d54:	00002dbb 			; <UNDEFINED> instruction: 0x00002dbb
    6d58:	00006d63 	andeq	r6, r0, r3, ror #26
    6d5c:	0000eb07 	andeq	lr, r0, r7, lsl #22
    6d60:	1a000700 	bne	8968 <.debug_info+0x8968>
    6d64:	0000362b 	andeq	r3, r0, fp, lsr #12
    6d68:	012d611c 			; <UNDEFINED> instruction: 0x012d611c
    6d6c:	00006dcc 	andeq	r6, r0, ip, asr #27
    6d70:	0014fd1b 	andseq	pc, r4, fp, lsl sp	; <UNPREDICTABLE>
    6d74:	012e6100 			; <UNDEFINED> instruction: 0x012e6100
    6d78:	00006de0 	andeq	r6, r0, r0, ror #27
    6d7c:	17241b00 	strne	r1, [r4, -r0, lsl #22]!
    6d80:	2f610000 	svccs	0x00610000
    6d84:	006de001 	rsbeq	lr, sp, r1
    6d88:	8b1b0400 	blhi	6c1008 <unflatten_and_copy_device_tree+0x6c0194>
    6d8c:	6100004b 	tstvs	r0, fp, asr #32
    6d90:	6de00130 	stfvse	f0, [r0, #192]!	; 0xc0
    6d94:	1b080000 	blne	206d9c <unflatten_and_copy_device_tree+0x205f28>
    6d98:	0000265d 	andeq	r2, r0, sp, asr r6
    6d9c:	e0013161 	and	r3, r1, r1, ror #2
    6da0:	0c00006d 	stceq	0, cr0, [r0], {109}	; 0x6d
    6da4:	0019221b 	andseq	r2, r9, fp, lsl r2
    6da8:	01326100 	teqeq	r2, r0, lsl #2
    6dac:	00006df5 	strdeq	r6, [r0], -r5
    6db0:	45b21b10 	ldrmi	r1, [r2, #2832]!	; 0xb10
    6db4:	33610000 	cmncc	r1, #0
    6db8:	006df501 	rsbeq	pc, sp, r1, lsl #10
    6dbc:	731b1400 	tstvc	fp, #0, 8
    6dc0:	61000060 	tstvs	r0, r0, rrx
    6dc4:	6df50134 	ldfvse	f0, [r5, #208]!	; 0xd0
    6dc8:	00180000 	andseq	r0, r8, r0
    6dcc:	00005715 	andeq	r5, r0, r5, lsl r7
    6dd0:	006de000 	rsbeq	lr, sp, r0
    6dd4:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    6dd8:	570d0000 	strpl	r0, [sp, -r0]
    6ddc:	00000000 	andeq	r0, r0, r0
    6de0:	6dcc0408 	cfstrdvs	mvd0, [ip, #32]
    6de4:	57150000 	ldrpl	r0, [r5, -r0]
    6de8:	f5000000 			; <UNDEFINED> instruction: 0xf5000000
    6dec:	0d00006d 	stceq	0, cr0, [r0, #-436]	; 0xfffffe4c
    6df0:	00006a2d 	andeq	r6, r0, sp, lsr #20
    6df4:	e6040800 	str	r0, [r4], -r0, lsl #16
    6df8:	1a00006d 	bne	6fb4 <.debug_info+0x6fb4>
    6dfc:	0000116d 	andeq	r1, r0, sp, ror #2
    6e00:	01386124 	teqeq	r8, r4, lsr #2
    6e04:	00006e7e 	andeq	r6, r0, lr, ror lr
    6e08:	001da41b 	andseq	sl, sp, fp, lsl r4
    6e0c:	01396100 	teqeq	r9, r0, lsl #2
    6e10:	00006df5 	strdeq	r6, [r0], -r5
    6e14:	53d71b00 	bicspl	r1, r7, #0, 22
    6e18:	3a610000 	bcc	1846e20 <unflatten_and_copy_device_tree+0x1845fac>
    6e1c:	006e9201 	rsbeq	r9, lr, r1, lsl #4
    6e20:	a41b0400 	ldrge	r0, [fp], #-1024	; 0xfffffc00
    6e24:	61000008 	tstvs	r0, r8
    6e28:	6ea3013b 	mcrvs	1, 5, r0, cr3, cr11, {1}
    6e2c:	1b080000 	blne	206e34 <unflatten_and_copy_device_tree+0x205fc0>
    6e30:	0000643f 	andeq	r6, r0, pc, lsr r4
    6e34:	f5013c61 			; <UNDEFINED> instruction: 0xf5013c61
    6e38:	0c00006d 	stceq	0, cr0, [r0], {109}	; 0x6d
    6e3c:	00267e1b 	eoreq	r7, r6, fp, lsl lr
    6e40:	013d6100 	teqeq	sp, r0, lsl #2
    6e44:	00006df5 	strdeq	r6, [r0], -r5
    6e48:	21911b10 	orrscs	r1, r1, r0, lsl fp
    6e4c:	3e610000 	cdpcc	0, 6, cr0, cr1, cr0, {0}
    6e50:	006df501 	rsbeq	pc, sp, r1, lsl #10
    6e54:	311b1400 	tstcc	fp, r0, lsl #8
    6e58:	61000047 	tstvs	r0, r7, asr #32
    6e5c:	6de0013f 	stfvse	f0, [r0, #252]!	; 0xfc
    6e60:	1b180000 	blne	606e68 <unflatten_and_copy_device_tree+0x605ff4>
    6e64:	00000cea 	andeq	r0, r0, sl, ror #25
    6e68:	be014261 	cdplt	2, 0, cr4, cr1, cr1, {3}
    6e6c:	1c00006e 	stcne	0, cr0, [r0], {110}	; 0x6e
    6e70:	000a1a1b 	andeq	r1, sl, fp, lsl sl
    6e74:	01436100 	mrseq	r6, (UNDEF: 83)
    6e78:	00006ede 	ldrdeq	r6, [r0], -lr
    6e7c:	2d150020 	ldccs	0, cr0, [r5, #-128]	; 0xffffff80
    6e80:	9200006a 	andls	r0, r0, #106	; 0x6a
    6e84:	0d00006e 	stceq	0, cr0, [r0, #-440]	; 0xfffffe48
    6e88:	0000647b 	andeq	r6, r0, fp, ror r4
    6e8c:	0000570d 	andeq	r5, r0, sp, lsl #14
    6e90:	04080000 	streq	r0, [r8], #-0
    6e94:	00006e7e 	andeq	r6, r0, lr, ror lr
    6e98:	006ea30c 	rsbeq	sl, lr, ip, lsl #6
    6e9c:	6a2d0d00 	bvs	b4a2a4 <unflatten_and_copy_device_tree+0xb49430>
    6ea0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    6ea4:	006e9804 	rsbeq	r9, lr, r4, lsl #16
    6ea8:	6eb81500 	cdpvs	5, 11, cr1, cr8, cr0, {0}
    6eac:	6eb80000 	cdpvs	0, 11, cr0, cr8, cr0, {0}
    6eb0:	f20d0000 	vhadd.s8	d0, d13, d0
    6eb4:	00000060 	andeq	r0, r0, r0, rrx
    6eb8:	6b4a0408 	blvs	1287ee0 <unflatten_and_copy_device_tree+0x128706c>
    6ebc:	04080000 	streq	r0, [r8], #-0
    6ec0:	00006ea9 	andeq	r6, r0, r9, lsr #29
    6ec4:	00005715 	andeq	r5, r0, r5, lsl r7
    6ec8:	006ed800 	rsbeq	sp, lr, r0, lsl #16
    6ecc:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    6ed0:	d80d0000 	stmdale	sp, {}	; <UNPREDICTABLE>
    6ed4:	0000006e 	andeq	r0, r0, lr, rrx
    6ed8:	6afd0408 	bvs	fff47f00 <__crc_of_fdt_unflatten_tree+0x79206943>
    6edc:	04080000 	streq	r0, [r8], #-0
    6ee0:	00006ec4 	andeq	r6, r0, r4, asr #29
    6ee4:	0020e81a 	eoreq	lr, r0, sl, lsl r8
    6ee8:	49617800 	stmdbmi	r1!, {fp, ip, sp, lr}^
    6eec:	006fc201 	rsbeq	ip, pc, r1, lsl #4
    6ef0:	63161b00 	tstvs	r6, #0, 22
    6ef4:	4a610000 	bmi	1846efc <unflatten_and_copy_device_tree+0x1846088>
    6ef8:	00005701 	andeq	r5, r0, r1, lsl #14
    6efc:	4c1b0000 	ldcmi	0, cr0, [fp], {-0}
    6f00:	61000031 	tstvs	r0, r1, lsr r0
    6f04:	00c9014b 	sbceq	r0, r9, fp, asr #2
    6f08:	1b080000 	blne	206f10 <unflatten_and_copy_device_tree+0x20609c>
    6f0c:	00005634 	andeq	r5, r0, r4, lsr r6
    6f10:	c9014c61 	stmdbgt	r1, {r0, r5, r6, sl, fp, lr}
    6f14:	10000000 	andne	r0, r0, r0
    6f18:	003c881b 	eorseq	r8, ip, fp, lsl r8
    6f1c:	014d6100 	mrseq	r6, (UNDEF: 93)
    6f20:	000000c9 	andeq	r0, r0, r9, asr #1
    6f24:	5f381b18 	svcpl	0x00381b18
    6f28:	4e610000 	cdpmi	0, 6, cr0, cr1, cr0, {0}
    6f2c:	0000c901 	andeq	ip, r0, r1, lsl #18
    6f30:	1f1b2000 	svcne	0x001b2000
    6f34:	61000015 	tstvs	r0, r5, lsl r0
    6f38:	00c9014f 	sbceq	r0, r9, pc, asr #2
    6f3c:	1b280000 	blne	a06f44 <unflatten_and_copy_device_tree+0xa060d0>
    6f40:	0000586b 	andeq	r5, r0, fp, ror #16
    6f44:	c9015061 	stmdbgt	r1, {r0, r5, r6, ip, lr}
    6f48:	30000000 	andcc	r0, r0, r0
    6f4c:	00498e1b 	subeq	r8, r9, fp, lsl lr
    6f50:	01516100 	cmpeq	r1, r0, lsl #2
    6f54:	000000be 	strheq	r0, [r0], -lr
    6f58:	3ec61b38 	mcrcc	11, 6, r1, cr6, cr8, {1}
    6f5c:	53610000 	cmnpl	r1, #0
    6f60:	0000be01 	andeq	fp, r0, r1, lsl #28
    6f64:	a11b4000 	tstge	fp, r0
    6f68:	61000018 	tstvs	r0, r8, lsl r0
    6f6c:	00570154 	subseq	r0, r7, r4, asr r1
    6f70:	1b480000 	blne	1206f78 <unflatten_and_copy_device_tree+0x1206104>
    6f74:	00005ad2 	ldrdeq	r5, [r0], -r2
    6f78:	57015561 	strpl	r5, [r1, -r1, ror #10]
    6f7c:	4c000000 	stcmi	0, cr0, [r0], {-0}
    6f80:	003d4c1b 	eorseq	r4, sp, fp, lsl ip
    6f84:	01566100 	cmpeq	r6, r0, lsl #2
    6f88:	000000c9 	andeq	r0, r0, r9, asr #1
    6f8c:	5ff21b50 	svcpl	0x00f21b50
    6f90:	57610000 	strbpl	r0, [r1, -r0]!
    6f94:	0000c901 	andeq	ip, r0, r1, lsl #18
    6f98:	ff1b5800 			; <UNDEFINED> instruction: 0xff1b5800
    6f9c:	6100000f 	tstvs	r0, pc
    6fa0:	00c90158 	sbceq	r0, r9, r8, asr r1
    6fa4:	1b600000 	blne	1806fac <unflatten_and_copy_device_tree+0x1806138>
    6fa8:	00003f7c 	andeq	r3, r0, ip, ror pc
    6fac:	be015961 	cdplt	9, 0, cr5, cr1, cr1, {3}
    6fb0:	68000000 	stmdavs	r0, {}	; <UNPREDICTABLE>
    6fb4:	0030e21b 	eorseq	lr, r0, fp, lsl r2
    6fb8:	015a6100 	cmpeq	sl, r0, lsl #2
    6fbc:	00000057 	andeq	r0, r0, r7, asr r0
    6fc0:	ab1a0070 	blge	6801c8 <unflatten_and_copy_device_tree+0x67f354>
    6fc4:	38000056 	stmdacc	r0, {r1, r2, r4, r6}
    6fc8:	52017d61 	andpl	r7, r1, #6208	; 0x1840
    6fcc:	1b000070 	blne	7194 <.debug_info+0x7194>
    6fd0:	0000596a 	andeq	r5, r0, sl, ror #18
    6fd4:	69017e61 	stmdbvs	r1, {r0, r5, r6, r9, sl, fp, ip, sp, lr}
    6fd8:	00000000 	andeq	r0, r0, r0
    6fdc:	00007c1b 	andeq	r7, r0, fp, lsl ip
    6fe0:	017f6100 	cmneq	pc, r0, lsl #2
    6fe4:	00000069 	andeq	r0, r0, r9, rrx
    6fe8:	0b971b04 	bleq	fe5c6c18 <__crc_of_fdt_unflatten_tree+0x7788565b>
    6fec:	81610000 	cmnhi	r1, r0
    6ff0:	00006901 	andeq	r6, r0, r1, lsl #18
    6ff4:	3b1b0800 	blcc	6c2008 <unflatten_and_copy_device_tree+0x6c1194>
    6ff8:	6100002c 	tstvs	r0, ip, lsr #32
    6ffc:	00690182 	rsbeq	r0, r9, r2, lsl #3
    7000:	1b0c0000 	blne	307008 <unflatten_and_copy_device_tree+0x306194>
    7004:	00002965 	andeq	r2, r0, r5, ror #18
    7008:	69018361 	stmdbvs	r1, {r0, r5, r6, r8, r9, pc}
    700c:	10000000 	andne	r0, r0, r0
    7010:	0034f91b 	eorseq	pc, r4, fp, lsl r9	; <UNPREDICTABLE>
    7014:	01846100 	orreq	r6, r4, r0, lsl #2
    7018:	00000069 	andeq	r0, r0, r9, rrx
    701c:	57f01b14 			; <UNDEFINED> instruction: 0x57f01b14
    7020:	85610000 	strbhi	r0, [r1, #-0]!
    7024:	00006901 	andeq	r6, r0, r1, lsl #18
    7028:	691d1800 	ldmdbvs	sp, {fp, ip}
    702c:	61006f6e 	tstvs	r0, lr, ror #30
    7030:	00820186 	addeq	r0, r2, r6, lsl #3
    7034:	1b200000 	blne	80703c <unflatten_and_copy_device_tree+0x8061c8>
    7038:	00002747 	andeq	r2, r0, r7, asr #14
    703c:	70018761 	andvc	r8, r1, r1, ror #14
    7040:	28000002 	stmdacs	r0, {r1}
    7044:	003da21b 	eorseq	sl, sp, fp, lsl r2
    7048:	01886100 	orreq	r6, r8, r0, lsl #2
    704c:	00000270 	andeq	r0, r0, r0, ror r2
    7050:	4c1a0030 	ldcmi	0, cr0, [sl], {48}	; 0x30
    7054:	b0000029 	andlt	r0, r0, r9, lsr #32
    7058:	7a018b61 	bvc	69de4 <unflatten_and_copy_device_tree+0x68f70>
    705c:	1b000070 	blne	7224 <.debug_info+0x7224>
    7060:	0000087d 	andeq	r0, r0, sp, ror r8
    7064:	69018c61 	stmdbvs	r1, {r0, r5, r6, sl, fp, pc}
    7068:	00000000 	andeq	r0, r0, r0
    706c:	005f091b 	subseq	r0, pc, fp, lsl r9	; <UNPREDICTABLE>
    7070:	01936100 	orrseq	r6, r3, r0, lsl #2
    7074:	0000707a 	andeq	r7, r0, sl, ror r0
    7078:	c2060008 	andgt	r0, r6, #8
    707c:	8a00006f 	bhi	7240 <.debug_info+0x7240>
    7080:	07000070 	smlsdxeq	r0, r0, r0, r0
    7084:	000000eb 	andeq	r0, r0, fp, ror #1
    7088:	a81a0002 	ldmdage	sl, {r1}
    708c:	2000003c 	andcs	r0, r0, ip, lsr r0
    7090:	00019761 	andeq	r9, r1, r1, ror #14
    7094:	1b000071 	blne	7260 <.debug_info+0x7260>
    7098:	00003414 	andeq	r3, r0, r4, lsl r4
    709c:	57019861 	strpl	r9, [r1, -r1, ror #16]
    70a0:	00000000 	andeq	r0, r0, r0
    70a4:	005f1f1b 	subseq	r1, pc, fp, lsl pc	; <UNPREDICTABLE>
    70a8:	01996100 	orrseq	r6, r9, r0, lsl #2
    70ac:	00000069 	andeq	r0, r0, r9, rrx
    70b0:	418f1b04 	orrmi	r1, pc, r4, lsl #22
    70b4:	9a610000 	bls	18470bc <unflatten_and_copy_device_tree+0x1846248>
    70b8:	00006901 	andeq	r6, r0, r1, lsl #18
    70bc:	241b0800 	ldrcs	r0, [fp], #-2048	; 0xfffff800
    70c0:	6100004d 	tstvs	r0, sp, asr #32
    70c4:	0069019c 	mlseq	r9, ip, r1, r0
    70c8:	1b0c0000 	blne	3070d0 <unflatten_and_copy_device_tree+0x30625c>
    70cc:	000040d3 	ldrdeq	r4, [r0], -r3
    70d0:	69019d61 	stmdbvs	r1, {r0, r5, r6, r8, sl, fp, ip, pc}
    70d4:	10000000 	andne	r0, r0, r0
    70d8:	0005701b 	andeq	r7, r5, fp, lsl r0
    70dc:	019e6100 	orrseq	r6, lr, r0, lsl #2
    70e0:	00000069 	andeq	r0, r0, r9, rrx
    70e4:	2ef71b14 	vmovcs.u8	r1, d7[4]
    70e8:	9f610000 	svcls	0x00610000
    70ec:	00006901 	andeq	r6, r0, r1, lsl #18
    70f0:	da1b1800 	ble	6c6008 <unflatten_and_copy_device_tree+0x6c5194>
    70f4:	61000048 	tstvs	r0, r8, asr #32
    70f8:	006901a0 	rsbeq	r0, r9, r0, lsr #3
    70fc:	001c0000 	andseq	r0, ip, r0
    7100:	0053c01a 	subseq	ip, r3, sl, lsl r0
    7104:	a4612800 	strbtge	r2, [r1], #-2048	; 0xfffff800
    7108:	00719001 	rsbseq	r9, r1, r1
    710c:	0bdc1b00 	bleq	ff706c08 <__crc_of_fdt_unflatten_tree+0x789c564b>
    7110:	a5610000 	strbge	r0, [r1, #-0]!
    7114:	0071ae01 	rsbseq	sl, r1, r1, lsl #28
    7118:	521b0000 	andspl	r0, fp, #0
    711c:	6100003b 	tstvs	r0, fp, lsr r0
    7120:	6de001a6 	stfvse	f0, [r0, #664]!	; 0x298
    7124:	1b040000 	blne	10712c <unflatten_and_copy_device_tree+0x1062b8>
    7128:	0000063b 	andeq	r0, r0, fp, lsr r6
    712c:	c801a761 	stmdagt	r1, {r0, r5, r6, r8, r9, sl, sp, pc}
    7130:	08000071 	stmdaeq	r0, {r0, r4, r5, r6}
    7134:	005de21b 	subseq	lr, sp, fp, lsl r2
    7138:	01a86100 			; <UNDEFINED> instruction: 0x01a86100
    713c:	000071c8 	andeq	r7, r0, r8, asr #3
    7140:	3c501b0c 	mrrccc	11, 0, r1, r0, cr12
    7144:	a9610000 	stmdbge	r1!, {}^	; <UNPREDICTABLE>
    7148:	006de001 	rsbeq	lr, sp, r1
    714c:	231b1000 	tstcs	fp, #0
    7150:	6100001b 	tstvs	r0, fp, lsl r0
    7154:	71ed01aa 	mvnvc	r0, sl, lsr #3
    7158:	1b140000 	blne	507160 <unflatten_and_copy_device_tree+0x5062ec>
    715c:	00003169 	andeq	r3, r0, r9, ror #2
    7160:	1201ab61 	andne	sl, r1, #99328	; 0x18400
    7164:	18000072 	stmdane	r0, {r1, r4, r5, r6}
    7168:	0025c61b 	eoreq	ip, r5, fp, lsl r6
    716c:	01ac6100 			; <UNDEFINED> instruction: 0x01ac6100
    7170:	00007212 	andeq	r7, r0, r2, lsl r2
    7174:	2f841b1c 	svccs	0x00841b1c
    7178:	ad610000 	stclge	0, cr0, [r1, #-0]
    717c:	00723201 	rsbseq	r3, r2, r1, lsl #4
    7180:	531b2000 	tstpl	fp, #0
    7184:	6100002e 	tstvs	r0, lr, lsr #32
    7188:	71c801ae 	bicvc	r0, r8, lr, lsr #3
    718c:	00240000 	eoreq	r0, r4, r0
    7190:	00005715 	andeq	r5, r0, r5, lsl r7
    7194:	0071ae00 	rsbseq	sl, r1, r0, lsl #28
    7198:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    719c:	570d0000 	strpl	r0, [sp, -r0]
    71a0:	0d000000 	stceq	0, cr0, [r0, #-0]
    71a4:	00000057 	andeq	r0, r0, r7, asr r0
    71a8:	00656f0d 	rsbeq	r6, r5, sp, lsl #30
    71ac:	04080000 	streq	r0, [r8], #-0
    71b0:	00007190 	muleq	r0, r0, r1
    71b4:	00005715 	andeq	r5, r0, r5, lsl r7
    71b8:	0071c800 	rsbseq	ip, r1, r0, lsl #16
    71bc:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    71c0:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    71c4:	00000000 	andeq	r0, r0, r0
    71c8:	71b40408 			; <UNDEFINED> instruction: 0x71b40408
    71cc:	57150000 	ldrpl	r0, [r5, -r0]
    71d0:	e7000000 	str	r0, [r0, -r0]
    71d4:	0d000071 	stceq	0, cr0, [r0, #-452]	; 0xfffffe3c
    71d8:	0000647b 	andeq	r6, r0, fp, ror r4
    71dc:	0000570d 	andeq	r5, r0, sp, lsl #14
    71e0:	71e70d00 	mvnvc	r0, r0, lsl #26
    71e4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    71e8:	00708a04 	rsbseq	r8, r0, r4, lsl #20
    71ec:	ce040800 	cdpgt	8, 0, cr0, cr4, cr0, {0}
    71f0:	15000071 	strne	r0, [r0, #-113]	; 0xffffff8f
    71f4:	00000057 	andeq	r0, r0, r7, asr r0
    71f8:	0000720c 	andeq	r7, r0, ip, lsl #4
    71fc:	00647b0d 	rsbeq	r7, r4, sp, lsl #22
    7200:	6b7f0d00 	blvs	1fca608 <unflatten_and_copy_device_tree+0x1fc9794>
    7204:	0c0d0000 	stceq	0, cr0, [sp], {-0}
    7208:	00000072 	andeq	r0, r0, r2, ror r0
    720c:	6ee40408 	cdpvs	4, 14, cr0, cr4, cr8, {0}
    7210:	04080000 	streq	r0, [r8], #-0
    7214:	000071f3 	strdeq	r7, [r0], -r3
    7218:	00005715 	andeq	r5, r0, r5, lsl r7
    721c:	00722c00 	rsbseq	r2, r2, r0, lsl #24
    7220:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    7224:	2c0d0000 	stccs	0, cr0, [sp], {-0}
    7228:	00000072 	andeq	r0, r0, r2, ror r0
    722c:	70520408 	subsvc	r0, r2, r8, lsl #8
    7230:	04080000 	streq	r0, [r8], #-0
    7234:	00007218 	andeq	r7, r0, r8, lsl r2
    7238:	723e0408 	eorsvc	r0, lr, #8, 8	; 0x8000000
    723c:	63090000 	movwvs	r0, #36864	; 0x9000
    7240:	1600006d 	strne	r0, [r0], -sp, rrx
    7244:	00001ace 	andeq	r1, r0, lr, asr #21
    7248:	72430408 	subvc	r0, r3, #8, 8	; 0x8000000
    724c:	381a0000 	ldmdacc	sl, {}	; <UNPREDICTABLE>
    7250:	f800003b 			; <UNDEFINED> instruction: 0xf800003b
    7254:	aa01f961 	bge	857e0 <unflatten_and_copy_device_tree+0x8496c>
    7258:	1b000072 	blne	7428 <.debug_info+0x7428>
    725c:	0000596a 	andeq	r5, r0, sl, ror #18
    7260:	6901fa61 	stmdbvs	r1, {r0, r5, r6, r9, fp, ip, sp, lr, pc}
    7264:	00000000 	andeq	r0, r0, r0
    7268:	00458b1b 	subeq	r8, r5, fp, lsl fp
    726c:	01fb6100 	mvnseq	r6, r0, lsl #2
    7270:	00001940 	andeq	r1, r0, r0, asr #18
    7274:	1c421b04 	mcrrne	11, 0, r1, r2, cr4
    7278:	fc610000 	stc2l	0, cr0, [r1], #-0
    727c:	00194001 	andseq	r4, r9, r1
    7280:	851b1c00 	ldrhi	r1, [fp, #-3072]	; 0xfffff400
    7284:	6100004b 	tstvs	r0, fp, asr #32
    7288:	72aa01fd 	adcvc	r0, sl, #1073741887	; 0x4000003f
    728c:	1b340000 	blne	d07294 <unflatten_and_copy_device_tree+0xd06420>
    7290:	0000380a 	andeq	r3, r0, sl, lsl #16
    7294:	ba01fe61 	blt	86c20 <unflatten_and_copy_device_tree+0x85dac>
    7298:	40000072 	andmi	r0, r0, r2, ror r0
    729c:	73706f1d 	cmnvc	r0, #29, 30	; 0x74
    72a0:	01ff6100 	mvnseq	r6, r0, lsl #2
    72a4:	000072ca 	andeq	r7, r0, sl, asr #5
    72a8:	f20600e8 	vhadd.s8	q0, q11, q12
    72ac:	ba000060 	blt	7434 <.debug_info+0x7434>
    72b0:	07000072 	smlsdxeq	r0, r2, r0, r0
    72b4:	000000eb 	andeq	r0, r0, fp, ror #1
    72b8:	17060002 	strne	r0, [r6, -r2]
    72bc:	ca00006c 	bgt	7474 <.debug_info+0x7474>
    72c0:	07000072 	smlsdxeq	r0, r2, r0, r0
    72c4:	000000eb 	andeq	r0, r0, fp, ror #1
    72c8:	38060002 	stmdacc	r6, {r1}
    72cc:	da000072 	ble	749c <.debug_info+0x749c>
    72d0:	07000072 	smlsdxeq	r0, r2, r0, r0
    72d4:	000000eb 	andeq	r0, r0, fp, ror #1
    72d8:	ef0c0002 	svc	0x000c0002
    72dc:	0d000072 	stceq	0, cr0, [r0, #-456]	; 0xfffffe38
    72e0:	00006955 	andeq	r6, r0, r5, asr r9
    72e4:	0001330d 	andeq	r3, r1, sp, lsl #6
    72e8:	01330d00 	teqeq	r3, r0, lsl #26
    72ec:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    72f0:	0072da04 	rsbseq	sp, r2, r4, lsl #20
    72f4:	1de31a00 	stclne	10, cr1, [r3]
    72f8:	2b4c0000 	blcs	1307300 <unflatten_and_copy_device_tree+0x130648c>
    72fc:	73fa0183 	mvnsvc	r0, #-1073741792	; 0xc0000020
    7300:	4c1b0000 	ldcmi	0, cr0, [fp], {-0}
    7304:	2b00005e 	blcs	7484 <.debug_info+0x7484>
    7308:	74190184 	ldrvc	r0, [r9], #-388	; 0xfffffe7c
    730c:	1b000000 	blne	7314 <.debug_info+0x7314>
    7310:	00004cf6 	strdeq	r4, [r0], -r6
    7314:	3301852b 	movwcc	r8, #5419	; 0x152b
    7318:	04000074 	streq	r0, [r0], #-116	; 0xffffff8c
    731c:	0024521b 	eoreq	r5, r4, fp, lsl r2
    7320:	01882b00 	orreq	r2, r8, r0, lsl #22
    7324:	0000744d 	andeq	r7, r0, sp, asr #8
    7328:	3b641b08 	blcc	1906c28 <unflatten_and_copy_device_tree+0x1905db4>
    732c:	8b2b0000 	blhi	ac7334 <unflatten_and_copy_device_tree+0xac64c0>
    7330:	00746201 	rsbseq	r6, r4, r1, lsl #4
    7334:	f61b0c00 			; <UNDEFINED> instruction: 0xf61b0c00
    7338:	2b000013 	blcs	738c <.debug_info+0x738c>
    733c:	7486018d 	strvc	r0, [r6], #397	; 0x18d
    7340:	1b100000 	blne	407348 <unflatten_and_copy_device_tree+0x4064d4>
    7344:	00004107 	andeq	r4, r0, r7, lsl #2
    7348:	b901902b 	stmdblt	r1, {r0, r1, r3, r5, ip, pc}
    734c:	14000074 	strne	r0, [r0], #-116	; 0xffffff8c
    7350:	0061551b 	rsbeq	r5, r1, fp, lsl r5
    7354:	01932b00 	orrseq	r2, r3, r0, lsl #22
    7358:	000074ec 	andeq	r7, r0, ip, ror #9
    735c:	5c361b18 	ldcpl	11, cr1, [r6], #-96	; 0xffffffa0
    7360:	982b0000 	stmdals	fp!, {}	; <UNPREDICTABLE>
    7364:	00750601 	rsbseq	r0, r5, r1, lsl #12
    7368:	931b1c00 	tstls	fp, #0, 24
    736c:	2b00002b 	blcs	7420 <.debug_info+0x7420>
    7370:	75210199 	strvc	r0, [r1, #-409]!	; 0xfffffe67
    7374:	1b200000 	blne	80737c <unflatten_and_copy_device_tree+0x806508>
    7378:	00000994 	muleq	r0, r4, r9
    737c:	3b019a2b 	blcc	6dc30 <unflatten_and_copy_device_tree+0x6cdbc>
    7380:	24000075 	strcs	r0, [r0], #-117	; 0xffffff8b
    7384:	001a021b 	andseq	r0, sl, fp, lsl r2
    7388:	019b2b00 	orrseq	r2, fp, r0, lsl #22
    738c:	00007541 	andeq	r7, r0, r1, asr #10
    7390:	306f1b28 	rsbcc	r1, pc, r8, lsr #22
    7394:	9c2b0000 	stcls	0, cr0, [fp], #-0
    7398:	00756b01 	rsbseq	r6, r5, r1, lsl #22
    739c:	9b1b2c00 	blls	6cb008 <unflatten_and_copy_device_tree+0x6ca194>
    73a0:	2b000038 	blcs	7488 <.debug_info+0x7488>
    73a4:	758f01a1 	strvc	r0, [pc, #417]	; 754d <.debug_info+0x754d>
    73a8:	1b300000 	blne	c073b0 <unflatten_and_copy_device_tree+0xc0653c>
    73ac:	0000249e 	muleq	r0, lr, r4
    73b0:	6201a32b 	andvs	sl, r1, #-1409286144	; 0xac000000
    73b4:	34000074 	strcc	r0, [r0], #-116	; 0xffffff8c
    73b8:	0046fc1b 	subeq	pc, r6, fp, lsl ip	; <UNPREDICTABLE>
    73bc:	01a42b00 			; <UNDEFINED> instruction: 0x01a42b00
    73c0:	000075ae 	andeq	r7, r0, lr, lsr #11
    73c4:	0e121b38 	vmoveq.s16	r1, d2[0]
    73c8:	a62b0000 	strtge	r0, [fp], -r0
    73cc:	0075cf01 	rsbseq	ip, r5, r1, lsl #30
    73d0:	cb1b3c00 	blgt	6cf008 <unflatten_and_copy_device_tree+0x6ce194>
    73d4:	2b000001 	blcs	73e0 <.debug_info+0x73e0>
    73d8:	75e901a7 	strbvc	r0, [r9, #423]!	; 0x1a7
    73dc:	1b400000 	blne	10073e4 <unflatten_and_copy_device_tree+0x1006570>
    73e0:	00005097 	muleq	r0, r7, r0
    73e4:	1901aa2b 	stmdbne	r1, {r0, r1, r3, r5, r9, fp, sp, pc}
    73e8:	44000076 	strmi	r0, [r0], #-118	; 0xffffff8a
    73ec:	0028fc1b 	eoreq	pc, r8, fp, lsl ip	; <UNPREDICTABLE>
    73f0:	01ac2b00 			; <UNDEFINED> instruction: 0x01ac2b00
    73f4:	0000762a 	andeq	r7, r0, sl, lsr #12
    73f8:	57150048 	ldrpl	r0, [r5, -r8, asr #32]
    73fc:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    7400:	0d000074 	stceq	0, cr0, [r0, #-464]	; 0xfffffe30
    7404:	00000564 	andeq	r0, r0, r4, ror #10
    7408:	00740e0d 	rsbseq	r0, r4, sp, lsl #28
    740c:	04080000 	streq	r0, [r8], #-0
    7410:	00007414 	andeq	r7, r0, r4, lsl r4
    7414:	004c4d16 	subeq	r4, ip, r6, lsl sp
    7418:	fa040800 	blx	109420 <unflatten_and_copy_device_tree+0x1085ac>
    741c:	15000073 	strne	r0, [r0, #-115]	; 0xffffff8d
    7420:	00000057 	andeq	r0, r0, r7, asr r0
    7424:	00007433 	andeq	r7, r0, r3, lsr r4
    7428:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    742c:	05640d00 	strbeq	r0, [r4, #-3328]!	; 0xfffff300
    7430:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    7434:	00741f04 	rsbseq	r1, r4, r4, lsl #30
    7438:	00571500 	subseq	r1, r7, r0, lsl #10
    743c:	744d0000 	strbvc	r0, [sp], #-0
    7440:	180d0000 	stmdane	sp, {}	; <UNPREDICTABLE>
    7444:	0d000021 	stceq	0, cr0, [r0, #-132]	; 0xffffff7c
    7448:	0000740e 	andeq	r7, r0, lr, lsl #8
    744c:	39040800 	stmdbcc	r4, {fp}
    7450:	15000074 	strne	r0, [r0, #-116]	; 0xffffff8c
    7454:	00000057 	andeq	r0, r0, r7, asr r0
    7458:	00007462 	andeq	r7, r0, r2, ror #8
    745c:	0005640d 	andeq	r6, r5, sp, lsl #8
    7460:	04080000 	streq	r0, [r8], #-0
    7464:	00007453 	andeq	r7, r0, r3, asr r4
    7468:	00005715 	andeq	r5, r0, r5, lsl r7
    746c:	00748600 	rsbseq	r8, r4, r0, lsl #12
    7470:	23cc0d00 	biccs	r0, ip, #0, 26
    7474:	180d0000 	stmdane	sp, {}	; <UNPREDICTABLE>
    7478:	0d000021 	stceq	0, cr0, [r0, #-132]	; 0xffffff7c
    747c:	000002ec 	andeq	r0, r0, ip, ror #5
    7480:	0000690d 	andeq	r6, r0, sp, lsl #18
    7484:	04080000 	streq	r0, [r8], #-0
    7488:	00007468 	andeq	r7, r0, r8, ror #8
    748c:	00005715 	andeq	r5, r0, r5, lsl r7
    7490:	0074b900 	rsbseq	fp, r4, r0, lsl #18
    7494:	23cc0d00 	biccs	r0, ip, #0, 26
    7498:	180d0000 	stmdane	sp, {}	; <UNPREDICTABLE>
    749c:	0d000021 	stceq	0, cr0, [r0, #-132]	; 0xffffff7c
    74a0:	00000223 	andeq	r0, r0, r3, lsr #4
    74a4:	0000690d 	andeq	r6, r0, sp, lsl #18
    74a8:	00690d00 	rsbeq	r0, r9, r0, lsl #26
    74ac:	c70d0000 	strgt	r0, [sp, -r0]
    74b0:	0d000025 	stceq	0, cr0, [r0, #-148]	; 0xffffff6c
    74b4:	00004169 	andeq	r4, r0, r9, ror #2
    74b8:	8c040800 	stchi	8, cr0, [r4], {-0}
    74bc:	15000074 	strne	r0, [r0, #-116]	; 0xffffff8c
    74c0:	00000057 	andeq	r0, r0, r7, asr r0
    74c4:	000074ec 	andeq	r7, r0, ip, ror #9
    74c8:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    74cc:	21180d00 	tstcs	r8, r0, lsl #26
    74d0:	230d0000 	movwcs	r0, #53248	; 0xd000
    74d4:	0d000002 	stceq	0, cr0, [r0, #-8]
    74d8:	00000069 	andeq	r0, r0, r9, rrx
    74dc:	0000690d 	andeq	r6, r0, sp, lsl #18
    74e0:	05640d00 	strbeq	r0, [r4, #-3328]!	; 0xfffff300
    74e4:	780d0000 	stmdavc	sp, {}	; <UNPREDICTABLE>
    74e8:	00000003 	andeq	r0, r0, r3
    74ec:	74bf0408 	ldrtvc	r0, [pc], #1032	; 74f4 <.debug_info+0x74f4>
    74f0:	65150000 	ldrvs	r0, [r5, #-0]
    74f4:	06000002 	streq	r0, [r0], -r2
    74f8:	0d000075 	stceq	0, cr0, [r0, #-468]	; 0xfffffe2c
    74fc:	00002118 	andeq	r2, r0, r8, lsl r1
    7500:	0002650d 	andeq	r6, r2, sp, lsl #10
    7504:	04080000 	streq	r0, [r8], #-0
    7508:	000074f2 	strdeq	r7, [r0], -r2
    750c:	0075210c 	rsbseq	r2, r5, ip, lsl #2
    7510:	05640d00 	strbeq	r0, [r4, #-3328]!	; 0xfffff300
    7514:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    7518:	0d000000 	stceq	0, cr0, [r0, #-0]
    751c:	00000069 	andeq	r0, r0, r9, rrx
    7520:	0c040800 	stceq	8, cr0, [r4], {-0}
    7524:	15000075 	strne	r0, [r0, #-117]	; 0xffffff8b
    7528:	00000057 	andeq	r0, r0, r7, asr r0
    752c:	0000753b 	andeq	r7, r0, fp, lsr r5
    7530:	0005640d 	andeq	r6, r5, sp, lsl #8
    7534:	027b0d00 	rsbseq	r0, fp, #0, 26
    7538:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    753c:	00752704 	rsbseq	r2, r5, r4, lsl #14
    7540:	2c040800 	stccs	8, cr0, [r4], {-0}
    7544:	15000051 	strne	r0, [r0, #-81]	; 0xffffffaf
    7548:	00000239 	andeq	r0, r0, r9, lsr r2
    754c:	00007560 	andeq	r7, r0, r0, ror #10
    7550:	0069550d 	rsbeq	r5, r9, sp, lsl #10
    7554:	75600d00 	strbvc	r0, [r0, #-3328]!	; 0xfffff300
    7558:	230d0000 	movwcs	r0, #53248	; 0xd000
    755c:	00000002 	andeq	r0, r0, r2
    7560:	75660408 	strbvc	r0, [r6, #-1032]!	; 0xfffffbf8
    7564:	6d160000 	ldcvs	0, cr0, [r6, #-0]
    7568:	08000039 	stmdaeq	r0, {r0, r3, r4, r5}
    756c:	00754704 	rsbseq	r4, r5, r4, lsl #14
    7570:	00571500 	subseq	r1, r7, r0, lsl #10
    7574:	758f0000 	strvc	r0, [pc]	; 757c <.debug_info+0x757c>
    7578:	180d0000 	stmdane	sp, {}	; <UNPREDICTABLE>
    757c:	0d000021 	stceq	0, cr0, [r0, #-132]	; 0xffffff7c
    7580:	00000564 	andeq	r0, r0, r4, ror #10
    7584:	0005640d 	andeq	r6, r5, sp, lsl #8
    7588:	68000d00 	stmdavs	r0, {r8, sl, fp}
    758c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    7590:	00757104 	rsbseq	r7, r5, r4, lsl #2
    7594:	00571500 	subseq	r1, r7, r0, lsl #10
    7598:	75ae0000 	strvc	r0, [lr, #0]!
    759c:	640d0000 	strvs	r0, [sp], #-0
    75a0:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    75a4:	000000d4 	ldrdeq	r0, [r0], -r4
    75a8:	0000d40d 	andeq	sp, r0, sp, lsl #8
    75ac:	04080000 	streq	r0, [r8], #-0
    75b0:	00007595 	muleq	r0, r5, r5
    75b4:	0075c90c 	rsbseq	ip, r5, ip, lsl #18
    75b8:	05640d00 	strbeq	r0, [r4, #-3328]!	; 0xfffff300
    75bc:	c90d0000 	stmdbgt	sp, {}	; <UNPREDICTABLE>
    75c0:	0d000075 	stceq	0, cr0, [r0, #-468]	; 0xfffffe2c
    75c4:	000075c9 	andeq	r7, r0, r9, asr #11
    75c8:	fb040800 	blx	1095d2 <unflatten_and_copy_device_tree+0x10875e>
    75cc:	08000001 	stmdaeq	r0, {r0}
    75d0:	0075b404 	rsbseq	fp, r5, r4, lsl #8
    75d4:	00571500 	subseq	r1, r7, r0, lsl #10
    75d8:	75e90000 	strbvc	r0, [r9, #0]!
    75dc:	180d0000 	stmdane	sp, {}	; <UNPREDICTABLE>
    75e0:	0d000021 	stceq	0, cr0, [r0, #-132]	; 0xffffff7c
    75e4:	00000564 	andeq	r0, r0, r4, ror #10
    75e8:	d5040800 	strle	r0, [r4, #-2048]	; 0xfffff800
    75ec:	15000075 	strne	r0, [r0, #-117]	; 0xffffff8b
    75f0:	00000057 	andeq	r0, r0, r7, asr r0
    75f4:	00007608 	andeq	r7, r0, r8, lsl #12
    75f8:	0076080d 	rsbseq	r0, r6, sp, lsl #16
    75fc:	23cc0d00 	biccs	r0, ip, #0, 26
    7600:	130d0000 	movwne	r0, #53248	; 0xd000
    7604:	00000076 	andeq	r0, r0, r6, ror r0
    7608:	760e0408 	strvc	r0, [lr], -r8, lsl #8
    760c:	cd160000 	ldcgt	0, cr0, [r6, #-0]
    7610:	0800003c 	stmdaeq	r0, {r2, r3, r4, r5}
    7614:	00026504 	andeq	r6, r2, r4, lsl #10
    7618:	ef040800 	svc	0x00040800
    761c:	0c000075 	stceq	0, cr0, [r0], {117}	; 0x75
    7620:	0000762a 	andeq	r7, r0, sl, lsr #12
    7624:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    7628:	04080000 	streq	r0, [r8], #-0
    762c:	0000761f 	andeq	r7, r0, pc, lsl r6
    7630:	76360408 	ldrtvc	r0, [r6], -r8, lsl #8
    7634:	f5090000 			; <UNDEFINED> instruction: 0xf5090000
    7638:	16000072 			; <UNDEFINED> instruction: 0x16000072
    763c:	000013ec 	andeq	r1, r0, ip, ror #7
    7640:	763b0408 	ldrtvc	r0, [fp], -r8, lsl #8
    7644:	68160000 	ldmdavs	r6, {}	; <UNPREDICTABLE>
    7648:	0800005f 	stmdaeq	r0, {r0, r1, r2, r3, r4, r6}
    764c:	00764604 	rsbseq	r4, r6, r4, lsl #12
    7650:	048e1600 	streq	r1, [lr], #1536	; 0x600
    7654:	04080000 	streq	r0, [r8], #-0
    7658:	00007651 	andeq	r7, r0, r1, asr r6
    765c:	782b0438 	stmdavc	fp!, {r3, r4, r5, sl}
    7660:	00767e02 	rsbseq	r7, r6, r2, lsl #28
    7664:	3df03900 	ldclcc	9, cr3, [r0]
    7668:	792b0000 	stmdbvc	fp!, {}	; <UNPREDICTABLE>
    766c:	00767e02 	rsbseq	r7, r6, r2, lsl #28
    7670:	21ee3900 	mvncs	r3, r0, lsl #18
    7674:	7a2b0000 	bvc	ac767c <unflatten_and_copy_device_tree+0xac6808>
    7678:	00006902 	andeq	r6, r0, r2, lsl #18
    767c:	69090000 	stmdbvs	r9, {}	; <UNPREDICTABLE>
    7680:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    7684:	029d2b08 	addseq	r2, sp, #8, 22	; 0x2000
    7688:	000076a5 	andeq	r7, r0, r5, lsr #13
    768c:	005f4839 	subseq	r4, pc, r9, lsr r8	; <UNPREDICTABLE>
    7690:	029e2b00 	addseq	r2, lr, #0, 22
    7694:	000002f2 	strdeq	r0, [r0], -r2
    7698:	001c8039 	andseq	r8, ip, r9, lsr r0
    769c:	029f2b00 	addseq	r2, pc, #0, 22
    76a0:	0000033c 	andeq	r0, r0, ip, lsr r3
    76a4:	2b043800 	blcs	1156ac <unflatten_and_copy_device_tree+0x114838>
    76a8:	76df02ac 	ldrbvc	r0, [pc], ip, lsr #5
    76ac:	fc390000 	ldc2	0, cr0, [r9], #-0
    76b0:	2b00003f 	blcs	77b4 <.debug_info+0x77b4>
    76b4:	4f6802ad 	svcmi	0x006802ad
    76b8:	95390000 	ldrls	r0, [r9, #-0]!
    76bc:	2b00004c 	blcs	77f4 <.debug_info+0x77f4>
    76c0:	694f02ae 	stmdbvs	pc, {r1, r2, r3, r5, r7, r9}^	; <UNPREDICTABLE>
    76c4:	ce390000 	cdpgt	0, 3, cr0, cr9, cr0, {0}
    76c8:	2b00002c 	blcs	7780 <.debug_info+0x7780>
    76cc:	773402af 	ldrvc	r0, [r4, -pc, lsr #5]!
    76d0:	8e390000 	cdphi	0, 3, cr0, cr9, cr0, {0}
    76d4:	2b00004c 	blcs	780c <.debug_info+0x780c>
    76d8:	01b302b0 			; <UNDEFINED> instruction: 0x01b302b0
    76dc:	10000000 	andne	r0, r0, r0
    76e0:	00004b48 	andeq	r4, r0, r8, asr #22
    76e4:	340c643c 	strcc	r6, [ip], #-1084	; 0xfffffbc4
    76e8:	0f000077 	svceq	0x00000077
    76ec:	00002fa1 	andeq	r2, r0, r1, lsr #31
    76f0:	56340d64 	ldrtpl	r0, [r4], -r4, ror #26
    76f4:	0f000000 	svceq	0x00000000
    76f8:	00001c27 	andeq	r1, r0, r7, lsr #24
    76fc:	72480e64 	subvc	r0, r8, #100, 28	; 0x640
    7700:	14240000 	strtne	r0, [r4], #-0
    7704:	0073706f 	rsbseq	r7, r3, pc, rrx
    7708:	7a280f64 	bvc	a0b4a0 <unflatten_and_copy_device_tree+0xa0a62c>
    770c:	0f280000 	svceq	0x00280000
    7710:	0000058e 	andeq	r0, r0, lr, lsl #11
    7714:	02c71064 	sbceq	r1, r7, #100	; 0x64
    7718:	142c0000 	strtne	r0, [ip], #-0
    771c:	00766564 	rsbseq	r6, r6, r4, ror #10
    7720:	01cf1164 	biceq	r1, pc, r4, ror #2
    7724:	0f340000 	svceq	0x00340000
    7728:	00003ba1 	andeq	r3, r0, r1, lsr #23
    772c:	00691264 	rsbeq	r1, r9, r4, ror #4
    7730:	00380000 	eorseq	r0, r8, r0
    7734:	76df0408 	ldrbvc	r0, [pc], r8, lsl #8
    7738:	59160000 	ldmdbpl	r6, {}	; <UNPREDICTABLE>
    773c:	08000041 	stmdaeq	r0, {r0, r6}
    7740:	00773a04 	rsbseq	r3, r7, r4, lsl #20
    7744:	1ff51a00 	svcne	0x00f51a00
    7748:	2b800000 	blcs	fe007750 <__crc_of_fdt_unflatten_tree+0x772c6193>
    774c:	78a50698 	stmiavc	r5!, {r3, r4, r7, r9, sl}
    7750:	8c1b0000 	ldchi	0, cr0, [fp], {-0}
    7754:	2b00002b 	blcs	7808 <.debug_info+0x7808>
    7758:	85680699 	strbhi	r0, [r8, #-1689]!	; 0xfffff967
    775c:	1b000000 	blne	7764 <.debug_info+0x7764>
    7760:	00005c62 	andeq	r5, r0, r2, ror #24
    7764:	82069a2b 	andhi	r9, r6, #176128	; 0x2b000
    7768:	04000085 	streq	r0, [r0], #-133	; 0xffffff7b
    776c:	001e031b 	andseq	r0, lr, fp, lsl r3
    7770:	069b2b00 	ldreq	r2, [fp], r0, lsl #22
    7774:	0000859c 	muleq	r0, ip, r5
    7778:	4f041b08 	svcmi	0x00041b08
    777c:	9c2b0000 	stcls	0, cr0, [fp], #-0
    7780:	0085b606 	addeq	fp, r5, r6, lsl #12
    7784:	491b0c00 	ldmdbmi	fp, {sl, fp}
    7788:	2b00001f 	blcs	780c <.debug_info+0x780c>
    778c:	85d5069e 	ldrbhi	r0, [r5, #1694]	; 0x69e
    7790:	1b100000 	blne	407798 <unflatten_and_copy_device_tree+0x406924>
    7794:	00003873 	andeq	r3, r0, r3, ror r8
    7798:	eb069f2b 	bl	1af44c <unflatten_and_copy_device_tree+0x1ae5d8>
    779c:	14000085 	strne	r0, [r0], #-133	; 0xffffff7b
    77a0:	0029a41b 	eoreq	sl, r9, fp, lsl r4
    77a4:	06a12b00 	strteq	r2, [r1], r0, lsl #22
    77a8:	0000860f 	andeq	r8, r0, pc, lsl #12
    77ac:	004c1b18 	subeq	r1, ip, r8, lsl fp
    77b0:	a22b0000 	eorge	r0, fp, #0
    77b4:	00862e06 	addeq	r2, r6, r6, lsl #28
    77b8:	d61b1c00 	ldrle	r1, [fp], -r0, lsl #24
    77bc:	2b000051 	blcs	7908 <.debug_info+0x7908>
    77c0:	864806a3 	strbhi	r0, [r8], -r3, lsr #13
    77c4:	1b200000 	blne	8077cc <unflatten_and_copy_device_tree+0x806958>
    77c8:	00004a19 	andeq	r4, r0, r9, lsl sl
    77cc:	6706a42b 	strvs	sl, [r6, -fp, lsr #8]
    77d0:	24000086 	strcs	r0, [r0], #-134	; 0xffffff7a
    77d4:	005b461b 	subseq	r4, fp, fp, lsl r6
    77d8:	06a52b00 	strteq	r2, [r5], r0, lsl #22
    77dc:	00008686 	andeq	r8, r0, r6, lsl #13
    77e0:	093e1b28 	ldmdbeq	lr!, {r3, r5, r8, r9, fp, ip}
    77e4:	a62b0000 	strtge	r0, [fp], -r0
    77e8:	00864806 	addeq	r4, r6, r6, lsl #16
    77ec:	951b2c00 	ldrls	r2, [fp, #-3072]	; 0xfffff400
    77f0:	2b000029 	blcs	789c <.debug_info+0x789c>
    77f4:	86aa06a7 	strthi	r0, [sl], r7, lsr #13
    77f8:	1b300000 	blne	c07800 <unflatten_and_copy_device_tree+0xc0698c>
    77fc:	00003344 	andeq	r3, r0, r4, asr #6
    7800:	ce06a82b 	cdpgt	8, 0, cr10, cr6, cr11, {1}
    7804:	34000086 	strcc	r0, [r0], #-134	; 0xffffff7a
    7808:	005cee1b 	subseq	lr, ip, fp, lsl lr
    780c:	06aa2b00 	strteq	r2, [sl], r0, lsl #22
    7810:	000086f7 	strdeq	r8, [r0], -r7
    7814:	00d21b38 	sbcseq	r1, r2, r8, lsr fp
    7818:	ac2b0000 	stcge	0, cr0, [fp], #-0
    781c:	00871706 	addeq	r1, r7, r6, lsl #14
    7820:	ca1b3c00 	bgt	6cf008 <unflatten_and_copy_device_tree+0x6ce194>
    7824:	2b00004d 	blcs	7960 <.debug_info+0x7960>
    7828:	873c06ad 	ldrhi	r0, [ip, -sp, lsr #13]!
    782c:	1b400000 	blne	1007834 <unflatten_and_copy_device_tree+0x10069c0>
    7830:	00002c64 	andeq	r2, r0, r4, ror #24
    7834:	6506ae2b 	strvs	sl, [r6, #-3627]	; 0xfffff1d5
    7838:	44000087 	strmi	r0, [r0], #-135	; 0xffffff79
    783c:	002e191b 	eoreq	r1, lr, fp, lsl r9
    7840:	06af2b00 	strteq	r2, [pc], r0, lsl #22
    7844:	00008789 	andeq	r8, r0, r9, lsl #15
    7848:	50f21b48 	rscspl	r1, r2, r8, asr #22
    784c:	b02b0000 	eorlt	r0, fp, r0
    7850:	0087a806 	addeq	sl, r7, r6, lsl #16
    7854:	961b4c00 	ldrls	r4, [fp], -r0, lsl #24
    7858:	2b00004e 	blcs	7998 <.debug_info+0x7998>
    785c:	87c206b1 			; <UNDEFINED> instruction: 0x87c206b1
    7860:	1b500000 	blne	1407868 <unflatten_and_copy_device_tree+0x14069f4>
    7864:	00002740 	andeq	r2, r0, r0, asr #14
    7868:	ec06b22b 	sfm	f3, 1, [r6], {43}	; 0x2b
    786c:	54000087 	strpl	r0, [r0], #-135	; 0xffffff79
    7870:	00175c1b 	andseq	r5, r7, fp, lsl ip
    7874:	06b42b00 	ldrteq	r2, [r4], r0, lsl #22
    7878:	0000880b 	andeq	r8, r0, fp, lsl #16
    787c:	31301b58 	teqcc	r0, r8, asr fp
    7880:	b52b0000 	strlt	r0, [fp, #-0]!
    7884:	00883906 	addeq	r3, r8, r6, lsl #18
    7888:	561b5c00 	ldrpl	r5, [fp], -r0, lsl #24
    788c:	2b000001 	blcs	7898 <.debug_info+0x7898>
    7890:	868606b8 			; <UNDEFINED> instruction: 0x868606b8
    7894:	1b600000 	blne	180789c <unflatten_and_copy_device_tree+0x1806a28>
    7898:	00004b9b 	muleq	r0, fp, fp
    789c:	5806b92b 	stmdapl	r6, {r0, r1, r3, r5, r8, fp, ip, sp, pc}
    78a0:	64000088 	strvs	r0, [r0], #-136	; 0xffffff78
    78a4:	ab040800 	blge	1098ac <unflatten_and_copy_device_tree+0x108a38>
    78a8:	09000078 	stmdbeq	r0, {r3, r4, r5, r6}
    78ac:	00007745 	andeq	r7, r0, r5, asr #14
    78b0:	00107a16 	andseq	r7, r0, r6, lsl sl
    78b4:	b0040800 	andlt	r0, r4, r0, lsl #16
    78b8:	1a000078 	bne	7aa0 <.debug_info+0x7aa0>
    78bc:	0000203c 	andeq	r2, r0, ip, lsr r0
    78c0:	06762b6c 	ldrbteq	r2, [r6], -ip, ror #22
    78c4:	00007a28 	andeq	r7, r0, r8, lsr #20
    78c8:	001c271b 	andseq	r2, ip, fp, lsl r7
    78cc:	06772b00 	ldrbteq	r2, [r7], -r0, lsl #22
    78d0:	00007248 	andeq	r7, r0, r8, asr #4
    78d4:	00fb1b00 	rscseq	r1, fp, r0, lsl #22
    78d8:	782b0000 	stmdavc	fp!, {}	; <UNPREDICTABLE>
    78dc:	0082c606 	addeq	ip, r2, r6, lsl #12
    78e0:	f21b0400 	vshl.s16	d0, d0, d11
    78e4:	2b000002 	blcs	78f4 <.debug_info+0x78f4>
    78e8:	82ea0679 	rschi	r0, sl, #126877696	; 0x7900000
    78ec:	1b080000 	blne	2078f4 <unflatten_and_copy_device_tree+0x206a80>
    78f0:	00001d13 	andeq	r1, r0, r3, lsl sp
    78f4:	0e067a2b 	vmlaeq.f32	s14, s12, s23
    78f8:	0c000083 	stceq	0, cr0, [r0], {131}	; 0x83
    78fc:	00336f1b 	eorseq	r6, r3, fp, lsl pc
    7900:	067b2b00 	ldrbteq	r2, [fp], -r0, lsl #22
    7904:	00008328 	andeq	r8, r0, r8, lsr #6
    7908:	62ca1b10 	sbcvs	r1, sl, #16, 22	; 0x4000
    790c:	7c2b0000 	stcvc	0, cr0, [fp], #-0
    7910:	00832806 	addeq	r2, r3, r6, lsl #16
    7914:	8e1b1400 	cfmulshi	mvf1, mvf11, mvf0
    7918:	2b00004e 	blcs	7a58 <.debug_info+0x7a58>
    791c:	8342067d 	movthi	r0, #9853	; 0x267d
    7920:	1b180000 	blne	607928 <unflatten_and_copy_device_tree+0x606ab4>
    7924:	00000f37 	andeq	r0, r0, r7, lsr pc
    7928:	67067e2b 	strvs	r7, [r6, -fp, lsr #28]
    792c:	1c000083 	stcne	0, cr0, [r0], {131}	; 0x83
    7930:	0050431b 	subseq	r4, r0, fp, lsl r3
    7934:	067f2b00 	ldrbteq	r2, [pc], -r0, lsl #22
    7938:	00008386 	andeq	r8, r0, r6, lsl #7
    793c:	42881b20 	addmi	r1, r8, #32, 22	; 0x8000
    7940:	802b0000 	eorhi	r0, fp, r0
    7944:	00838606 	addeq	r8, r3, r6, lsl #12
    7948:	e31b2400 	tst	fp, #0, 8
    794c:	2b000053 	blcs	7aa0 <.debug_info+0x7aa0>
    7950:	83a00681 	movhi	r0, #135266304	; 0x8100000
    7954:	1b280000 	blne	a0795c <unflatten_and_copy_device_tree+0xa06ae8>
    7958:	00005e2a 	andeq	r5, r0, sl, lsr #28
    795c:	ba06822b 	blt	1a8210 <unflatten_and_copy_device_tree+0x1a739c>
    7960:	2c000083 	stccs	0, cr0, [r0], {131}	; 0x83
    7964:	001b931b 	andseq	r9, fp, fp, lsl r3
    7968:	06832b00 	streq	r2, [r3], r0, lsl #22
    796c:	000083d4 	ldrdeq	r8, [r0], -r4
    7970:	026a1b30 	rsbeq	r1, sl, #48, 22	; 0xc000
    7974:	842b0000 	strthi	r0, [fp], #-0
    7978:	0083ba06 	addeq	fp, r3, r6, lsl #20
    797c:	b31b3400 	tstlt	fp, #0, 8
    7980:	2b000047 	blcs	7aa4 <.debug_info+0x7aa4>
    7984:	83f80685 	mvnshi	r0, #139460608	; 0x8500000
    7988:	1b380000 	blne	e07990 <unflatten_and_copy_device_tree+0xe06b1c>
    798c:	00005f9d 	muleq	r0, sp, pc	; <UNPREDICTABLE>
    7990:	1206862b 	andne	r8, r6, #45088768	; 0x2b00000
    7994:	3c000084 	stccc	0, cr0, [r0], {132}	; 0x84
    7998:	005c2f1b 	subseq	r2, ip, fp, lsl pc
    799c:	06872b00 	streq	r2, [r7], r0, lsl #22
    79a0:	00008431 	andeq	r8, r0, r1, lsr r4
    79a4:	155a1b40 	ldrbne	r1, [sl, #-2880]	; 0xfffff4c0
    79a8:	882b0000 	stmdahi	fp!, {}	; <UNPREDICTABLE>
    79ac:	00845006 	addeq	r5, r4, r6
    79b0:	f91b4400 			; <UNDEFINED> instruction: 0xf91b4400
    79b4:	2b00004f 	blcs	7af8 <.debug_info+0x7af8>
    79b8:	847e0689 	ldrbthi	r0, [lr], #-1673	; 0xfffff977
    79bc:	1b480000 	blne	12079c4 <unflatten_and_copy_device_tree+0x1206b50>
    79c0:	00003a8e 	andeq	r3, r0, lr, lsl #21
    79c4:	84068a2b 	strhi	r8, [r6], #-2603	; 0xfffff5d5
    79c8:	4c000025 	stcmi	0, cr0, [r0], {37}	; 0x25
    79cc:	000ca21b 	andeq	sl, ip, fp, lsl r2
    79d0:	068b2b00 	streq	r2, [fp], r0, lsl #22
    79d4:	00008493 	muleq	r0, r3, r4
    79d8:	33811b50 	orrcc	r1, r1, #80, 22	; 0x14000
    79dc:	8c2b0000 	stchi	0, cr0, [fp], #-0
    79e0:	00845006 	addeq	r5, r4, r6
    79e4:	8d1b5400 	cfldrshi	mvf5, [fp, #-0]
    79e8:	2b000007 	blcs	7a0c <.debug_info+0x7a0c>
    79ec:	84bc068d 	ldrthi	r0, [ip], #1677	; 0x68d
    79f0:	1b580000 	blne	16079f8 <unflatten_and_copy_device_tree+0x1606b84>
    79f4:	00005161 	andeq	r5, r0, r1, ror #2
    79f8:	e5068e2b 	str	r8, [r6, #-3627]	; 0xfffff1d5
    79fc:	5c000084 	stcpl	0, cr0, [r0], {132}	; 0x84
    7a00:	00248e1b 	eoreq	r8, r4, fp, lsl lr
    7a04:	068f2b00 	streq	r2, [pc], r0, lsl #22
    7a08:	0000850f 	andeq	r8, r0, pc, lsl #10
    7a0c:	59f01b60 	ldmibpl	r0!, {r5, r6, r8, r9, fp, ip}^
    7a10:	902b0000 	eorls	r0, fp, r0
    7a14:	00853306 	addeq	r3, r5, r6, lsl #6
    7a18:	f71b6400 			; <UNDEFINED> instruction: 0xf71b6400
    7a1c:	2b00002f 	blcs	7ae0 <.debug_info+0x7ae0>
    7a20:	85490692 	strbhi	r0, [r9, #-1682]	; 0xfffff96e
    7a24:	00680000 	rsbeq	r0, r8, r0
    7a28:	7a2e0408 	bvc	b88a50 <unflatten_and_copy_device_tree+0xb87bdc>
    7a2c:	bb090000 	bllt	247a34 <unflatten_and_copy_device_tree+0x246bc0>
    7a30:	1a000078 	bne	7c18 <.debug_info+0x7c18>
    7a34:	00000a25 	andeq	r0, r0, r5, lsr #20
    7a38:	04202b1c 	strteq	r2, [r0], #-2844	; 0xfffff4e4
    7a3c:	00007a75 	andeq	r7, r0, r5, ror sl
    7a40:	001d6a1b 	andseq	r6, sp, fp, lsl sl
    7a44:	04212b00 	strteq	r2, [r1], #-2816	; 0xfffff500
    7a48:	000010ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    7a4c:	53891b00 	orrpl	r1, r9, #0, 22
    7a50:	222b0000 	eorcs	r0, fp, #0
    7a54:	0002c704 	andeq	ip, r2, r4, lsl #14
    7a58:	941b0400 	ldrls	r0, [fp], #-1024	; 0xfffffc00
    7a5c:	2b000011 	blcs	7aa8 <.debug_info+0x7aa8>
    7a60:	02c70423 	sbceq	r0, r7, #587202560	; 0x23000000
    7a64:	1b0c0000 	blne	307a6c <unflatten_and_copy_device_tree+0x306bf8>
    7a68:	00003b83 	andeq	r3, r0, r3, lsl #23
    7a6c:	c704242b 	strgt	r2, [r4, -fp, lsr #8]
    7a70:	14000002 	strne	r0, [r0], #-2
    7a74:	33040800 	movwcc	r0, #18432	; 0x4800
    7a78:	1a00007a 	bne	7c68 <.debug_info+0x7c68>
    7a7c:	00000923 	andeq	r0, r0, r3, lsr #18
    7a80:	03542b18 	cmpeq	r4, #24, 22	; 0x6000
    7a84:	00007ad7 	ldrdeq	r7, [r0], -r7	; <UNPREDICTABLE>
    7a88:	00155a1b 	andseq	r5, r5, fp, lsl sl
    7a8c:	03552b00 	cmpeq	r5, #0, 22
    7a90:	0000111f 	andeq	r1, r0, pc, lsl r1
    7a94:	69701d00 	ldmdbvs	r0!, {r8, sl, fp, ip}^
    7a98:	562b0064 	strtpl	r0, [fp], -r4, rrx
    7a9c:	002db503 	eoreq	fp, sp, r3, lsl #10
    7aa0:	671b0400 	ldrvs	r0, [fp, -r0, lsl #8]
    7aa4:	2b00000b 	blcs	7ad8 <.debug_info+0x7ad8>
    7aa8:	2cc40357 	stclcs	3, cr0, [r4], {87}	; 0x57
    7aac:	1d080000 	stcne	0, cr0, [r8, #-0]
    7ab0:	00646975 	rsbeq	r6, r4, r5, ror r9
    7ab4:	4203582b 	andmi	r5, r3, #2818048	; 0x2b0000
    7ab8:	0c000028 	stceq	0, cr0, [r0], {40}	; 0x28
    7abc:	00334b1b 	eorseq	r4, r3, fp, lsl fp
    7ac0:	03582b00 	cmpeq	r8, #0, 22
    7ac4:	00002842 	andeq	r2, r0, r2, asr #16
    7ac8:	3d301b10 	vldmdbcc	r0!, {d1-d8}
    7acc:	592b0000 	stmdbpl	fp!, {}	; <UNPREDICTABLE>
    7ad0:	00005703 	andeq	r5, r0, r3, lsl #14
    7ad4:	1a001400 	bne	cadc <unflatten_and_copy_device_tree+0xbc68>
    7ad8:	000000c4 	andeq	r0, r0, r4, asr #1
    7adc:	035f2b20 	cmpeq	pc, #32, 22	; 0x8000
    7ae0:	00007b33 	andeq	r7, r0, r3, lsr fp
    7ae4:	0048d41b 	subeq	sp, r8, fp, lsl r4
    7ae8:	03602b00 	cmneq	r0, #0, 22
    7aec:	000000d4 	ldrdeq	r0, [r0], -r4
    7af0:	0c6b1b00 	stcleq	11, cr1, [fp], #-0
    7af4:	612b0000 			; <UNDEFINED> instruction: 0x612b0000
    7af8:	00006903 	andeq	r6, r0, r3, lsl #18
    7afc:	321b0400 	andscc	r0, fp, #0, 8
    7b00:	2b000043 	blcs	7c14 <.debug_info+0x7c14>
    7b04:	00690362 	rsbeq	r0, r9, r2, ror #6
    7b08:	1b080000 	blne	207b10 <unflatten_and_copy_device_tree+0x206c9c>
    7b0c:	000052ff 	strdeq	r5, [r0], -pc	; <UNPREDICTABLE>
    7b10:	6903652b 	stmdbvs	r3, {r0, r1, r3, r5, r8, sl, sp, lr}
    7b14:	0c000000 	stceq	0, cr0, [r0], {-0}
    7b18:	0020b61b 	eoreq	fp, r0, fp, lsl r6
    7b1c:	03662b00 	cmneq	r6, #0, 22
    7b20:	00000069 	andeq	r0, r0, r9, rrx
    7b24:	109e1b10 	addsne	r1, lr, r0, lsl fp
    7b28:	672b0000 	strvs	r0, [fp, -r0]!
    7b2c:	00022303 	andeq	r2, r2, r3, lsl #6
    7b30:	38001800 	stmdacc	r0, {fp, ip}
    7b34:	03742b08 	cmneq	r4, #8, 22	; 0x2000
    7b38:	00007b55 	andeq	r7, r0, r5, asr fp
    7b3c:	001dc139 	andseq	ip, sp, r9, lsr r1
    7b40:	03752b00 	cmneq	r5, #0, 22
    7b44:	00001b4f 	andeq	r1, r0, pc, asr #22
    7b48:	004f7839 	subeq	r7, pc, r9, lsr r8	; <UNPREDICTABLE>
    7b4c:	03762b00 	cmneq	r6, #0, 22
    7b50:	0000033c 	andeq	r0, r0, ip, lsr r3
    7b54:	15f32300 	ldrbne	r2, [r3, #768]!	; 0x300
    7b58:	c72b0000 	strgt	r0, [fp, -r0]!
    7b5c:	00037803 	andeq	r7, r3, r3, lsl #16
    7b60:	02d81a00 	sbcseq	r1, r8, #0, 20
    7b64:	2b080000 	blcs	207b6c <unflatten_and_copy_device_tree+0x206cf8>
    7b68:	7b8903cb 	blvc	fe248a9c <__crc_of_fdt_unflatten_tree+0x775074df>
    7b6c:	ef1b0000 	svc	0x001b0000
    7b70:	2b00001c 	blcs	7be8 <.debug_info+0x7be8>
    7b74:	7cb103cc 	ldcvc	3, cr0, [r1], #816	; 0x330
    7b78:	1b000000 	blne	7b80 <.debug_info+0x7b80>
    7b7c:	00001baf 	andeq	r1, r0, pc, lsr #23
    7b80:	c203cd2b 	andgt	ip, r3, #2752	; 0xac0
    7b84:	0400007c 	streq	r0, [r0], #-124	; 0xffffff84
    7b88:	7b990c00 	blvc	fe64ab90 <__crc_of_fdt_unflatten_tree+0x779095d3>
    7b8c:	990d0000 	stmdbls	sp, {}	; <UNPREDICTABLE>
    7b90:	0d00007b 	stceq	0, cr0, [r0, #-492]	; 0xfffffe14
    7b94:	00007b99 	muleq	r0, r9, fp
    7b98:	9f040800 	svcls	0x00040800
    7b9c:	1a00007b 	bne	7d90 <.debug_info+0x7d90>
    7ba0:	00002af2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    7ba4:	03ff2b80 	mvnseq	r2, #128, 22	; 0x20000
    7ba8:	00007cb1 			; <UNDEFINED> instruction: 0x00007cb1
    7bac:	005f511b 	subseq	r5, pc, fp, lsl r1	; <UNPREDICTABLE>
    7bb0:	04002b00 	streq	r2, [r0], #-2816	; 0xfffff500
    7bb4:	00007b99 	muleq	r0, r9, fp
    7bb8:	43cb1b00 	bicmi	r1, fp, #0, 22
    7bbc:	012b0000 			; <UNDEFINED> instruction: 0x012b0000
    7bc0:	0002c704 	andeq	ip, r2, r4, lsl #14
    7bc4:	651b0400 	ldrvs	r0, [fp, #-1024]	; 0xfffffc00
    7bc8:	2b00003e 	blcs	7cc8 <.debug_info+0x7cc8>
    7bcc:	030b0402 	movweq	r0, #46082	; 0xb402
    7bd0:	1b0c0000 	blne	307bd8 <unflatten_and_copy_device_tree+0x306d64>
    7bd4:	00004616 	andeq	r4, r0, r6, lsl r6
    7bd8:	c704032b 	strgt	r0, [r4, -fp, lsr #6]
    7bdc:	14000002 	strne	r0, [r0], #-2
    7be0:	00064f1b 	andeq	r4, r6, fp, lsl pc
    7be4:	04042b00 	streq	r2, [r4], #-2816	; 0xfffff500
    7be8:	00007b55 	andeq	r7, r0, r5, asr fp
    7bec:	43eb1b1c 	mvnmi	r1, #28, 22	; 0x7000
    7bf0:	052b0000 	streq	r0, [fp, #-0]!
    7bf4:	00006904 	andeq	r6, r0, r4, lsl #18
    7bf8:	451b2000 	ldrmi	r2, [fp, #-0]
    7bfc:	2b00000e 	blcs	7c3c <.debug_info+0x7c3c>
    7c00:	002c0406 	eoreq	r0, ip, r6, lsl #8
    7c04:	1b240000 	blne	907c0c <unflatten_and_copy_device_tree+0x906d98>
    7c08:	00001a40 	andeq	r1, r0, r0, asr #20
    7c0c:	6904072b 	stmdbvs	r4, {r0, r1, r3, r5, r8, r9, sl}
    7c10:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    7c14:	0046b61b 	subeq	fp, r6, fp, lsl r6
    7c18:	04082b00 	streq	r2, [r8], #-2816	; 0xfffff500
    7c1c:	00000057 	andeq	r0, r0, r7, asr r0
    7c20:	0f481b2c 	svceq	0x00481b2c
    7c24:	092b0000 	stmdbeq	fp!, {}	; <UNPREDICTABLE>
    7c28:	002db504 	eoreq	fp, sp, r4, lsl #10
    7c2c:	781b3000 	ldmdavc	fp, {ip, sp}
    7c30:	2b000009 	blcs	7c5c <.debug_info+0x7c5c>
    7c34:	11eb040a 	mvnne	r0, sl, lsl #8
    7c38:	1b340000 	blne	d07c40 <unflatten_and_copy_device_tree+0xd06dcc>
    7c3c:	00001d19 	andeq	r1, r0, r9, lsl sp
    7c40:	cc040b2b 	stcgt	11, cr0, [r4], {43}	; 0x2b
    7c44:	40000023 	andmi	r0, r0, r3, lsr #32
    7c48:	0038d11b 	eorseq	sp, r8, fp, lsl r1
    7c4c:	040c2b00 	streq	r2, [ip], #-2816	; 0xfffff500
    7c50:	00000223 	andeq	r0, r0, r3, lsr #4
    7c54:	1b5c1b48 	blne	1706d28 <unflatten_and_copy_device_tree+0x1705eb4>
    7c58:	0d2b0000 	stceq	0, cr0, [fp, #-0]
    7c5c:	00022304 	andeq	r2, r2, r4, lsl #6
    7c60:	461b5000 	ldrmi	r5, [fp], -r0
    7c64:	2b00003c 	blcs	7d5c <.debug_info+0x7d5c>
    7c68:	7f12040f 	svcvc	0x0012040f
    7c6c:	1b580000 	blne	1607c74 <unflatten_and_copy_device_tree+0x1606e00>
    7c70:	00000eb3 			; <UNDEFINED> instruction: 0x00000eb3
    7c74:	d404112b 	strle	r1, [r4], #-299	; 0xfffffed5
    7c78:	5c000000 	stcpl	0, cr0, [r0], {-0}
    7c7c:	003c6c1b 	eorseq	r6, ip, fp, lsl ip
    7c80:	04122b00 	ldreq	r2, [r2], #-2816	; 0xfffff500
    7c84:	000000d4 	ldrdeq	r0, [r0], -r4
    7c88:	4f831b60 	svcmi	0x00831b60
    7c8c:	142b0000 	strtne	r0, [fp], #-0
    7c90:	007f1804 	rsbseq	r1, pc, r4, lsl #16
    7c94:	6c1b6400 	cfldrsvs	mvf6, [fp], {-0}
    7c98:	2b000026 	blcs	7d38 <.debug_info+0x7d38>
    7c9c:	7f230415 	svcvc	0x00230415
    7ca0:	1b680000 	blne	1a07ca8 <unflatten_and_copy_device_tree+0x1a06e34>
    7ca4:	00001656 	andeq	r1, r0, r6, asr r6
    7ca8:	88041d2b 	stmdahi	r4, {r0, r1, r3, r5, r8, sl, fp, ip}
    7cac:	6c00007e 	stcvs	0, cr0, [r0], {126}	; 0x7e
    7cb0:	89040800 	stmdbhi	r4, {fp}
    7cb4:	0c00007b 	stceq	0, cr0, [r0], {123}	; 0x7b
    7cb8:	00007cc2 	andeq	r7, r0, r2, asr #25
    7cbc:	007b990d 	rsbseq	r9, fp, sp, lsl #18
    7cc0:	04080000 	streq	r0, [r8], #-0
    7cc4:	00007cb7 			; <UNDEFINED> instruction: 0x00007cb7
    7cc8:	0044271a 	subeq	r2, r4, sl, lsl r7
    7ccc:	d02b2400 	eorle	r2, fp, r0, lsl #8
    7cd0:	007d4b03 	rsbseq	r4, sp, r3, lsl #22
    7cd4:	37541b00 	ldrbcc	r1, [r4, -r0, lsl #22]
    7cd8:	d12b0000 			; <UNDEFINED> instruction: 0xd12b0000
    7cdc:	007d5f03 	rsbseq	r5, sp, r3, lsl #30
    7ce0:	3c1b0000 	ldccc	0, cr0, [fp], {-0}
    7ce4:	2b000047 	blcs	7e08 <.debug_info+0x7e08>
    7ce8:	7d7403d2 	ldclvc	3, cr0, [r4, #-840]!	; 0xfffffcb8
    7cec:	1b040000 	blne	107cf4 <unflatten_and_copy_device_tree+0x106e80>
    7cf0:	0000359d 	muleq	r0, sp, r5
    7cf4:	8903d32b 	stmdbhi	r3, {r0, r1, r3, r5, r8, r9, ip, lr, pc}
    7cf8:	0800007d 	stmdaeq	r0, {r0, r2, r3, r4, r5, r6}
    7cfc:	003cc01b 	eorseq	ip, ip, fp, lsl r0
    7d00:	03d42b00 	bicseq	r2, r4, #0, 22
    7d04:	00007d9a 	muleq	r0, sl, sp
    7d08:	56e41b0c 	strbtpl	r1, [r4], ip, lsl #22
    7d0c:	d52b0000 	strle	r0, [fp, #-0]!
    7d10:	007cc203 	rsbseq	ip, ip, r3, lsl #4
    7d14:	1e1b1000 	cdpne	0, 1, cr1, cr11, cr0, {0}
    7d18:	2b000024 	blcs	7db0 <.debug_info+0x7db0>
    7d1c:	7db403d6 	ldcvc	3, cr0, [r4, #856]!	; 0x358
    7d20:	1b140000 	blne	507d28 <unflatten_and_copy_device_tree+0x506eb4>
    7d24:	00000658 	andeq	r0, r0, r8, asr r6
    7d28:	c903d72b 	stmdbgt	r3, {r0, r1, r3, r5, r8, r9, sl, ip, lr, pc}
    7d2c:	1800007d 	stmdane	r0, {r0, r2, r3, r4, r5, r6}
    7d30:	002a191b 	eoreq	r1, sl, fp, lsl r9
    7d34:	03d82b00 	bicseq	r2, r8, #0, 22
    7d38:	00007de8 	andeq	r7, r0, r8, ror #27
    7d3c:	28321b1c 	ldmdacs	r2!, {r2, r3, r4, r8, r9, fp, ip}
    7d40:	d92b0000 	stmdble	fp!, {}	; <UNPREDICTABLE>
    7d44:	007dfe03 	rsbseq	pc, sp, r3, lsl #28
    7d48:	15002000 	strne	r2, [r0, #-0]
    7d4c:	00000057 	andeq	r0, r0, r7, asr r0
    7d50:	00007d5f 	andeq	r7, r0, pc, asr sp
    7d54:	007b990d 	rsbseq	r9, fp, sp, lsl #18
    7d58:	7b990d00 	blvc	fe64b160 <__crc_of_fdt_unflatten_tree+0x77909ba3>
    7d5c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    7d60:	007d4b04 	rsbseq	r4, sp, r4, lsl #22
    7d64:	00d41500 	sbcseq	r1, r4, r0, lsl #10
    7d68:	7d740000 	ldclvc	0, cr0, [r4, #-0]
    7d6c:	990d0000 	stmdbls	sp, {}	; <UNPREDICTABLE>
    7d70:	0000007b 	andeq	r0, r0, fp, ror r0
    7d74:	7d650408 	cfstrdvc	mvd0, [r5, #-32]!	; 0xffffffe0
    7d78:	55150000 	ldrpl	r0, [r5, #-0]
    7d7c:	8900007b 	stmdbhi	r0, {r0, r1, r3, r4, r5, r6}
    7d80:	0d00007d 	stceq	0, cr0, [r0, #-500]	; 0xfffffe0c
    7d84:	00007b55 	andeq	r7, r0, r5, asr fp
    7d88:	7a040800 	bvc	109d90 <unflatten_and_copy_device_tree+0x108f1c>
    7d8c:	0c00007d 	stceq	0, cr0, [r0], {125}	; 0x7d
    7d90:	00007d9a 	muleq	r0, sl, sp
    7d94:	007b550d 	rsbseq	r5, fp, sp, lsl #10
    7d98:	04080000 	streq	r0, [r8], #-0
    7d9c:	00007d8f 	andeq	r7, r0, pc, lsl #27
    7da0:	00005715 	andeq	r5, r0, r5, lsl r7
    7da4:	007db400 	rsbseq	fp, sp, r0, lsl #8
    7da8:	7b990d00 	blvc	fe64b1b0 <__crc_of_fdt_unflatten_tree+0x77909bf3>
    7dac:	570d0000 	strpl	r0, [sp, -r0]
    7db0:	00000000 	andeq	r0, r0, r0
    7db4:	7da00408 	cfstrsvc	mvf0, [r0, #32]!
    7db8:	fb150000 	blx	547dc2 <unflatten_and_copy_device_tree+0x546f4e>
    7dbc:	c9000001 	stmdbgt	r0, {r0}
    7dc0:	0d00007d 	stceq	0, cr0, [r0, #-500]	; 0xfffffe0c
    7dc4:	00007b99 	muleq	r0, r9, fp
    7dc8:	ba040800 	blt	109dd0 <unflatten_and_copy_device_tree+0x108f5c>
    7dcc:	1500007d 	strne	r0, [r0, #-125]	; 0xffffff83
    7dd0:	00000057 	andeq	r0, r0, r7, asr r0
    7dd4:	00007de8 	andeq	r7, r0, r8, ror #27
    7dd8:	007b990d 	rsbseq	r9, fp, sp, lsl #18
    7ddc:	00570d00 	subseq	r0, r7, r0, lsl #26
    7de0:	ec0d0000 	stc	0, cr0, [sp], {-0}
    7de4:	00000002 	andeq	r0, r0, r2
    7de8:	7dcf0408 	cfstrdvc	mvd0, [pc, #32]	; 7e10 <.debug_info+0x7e10>
    7dec:	fe0c0000 	cdp2	0, 0, cr0, cr12, cr0, {0}
    7df0:	0d00007d 	stceq	0, cr0, [r0, #-500]	; 0xfffffe0c
    7df4:	00007b99 	muleq	r0, r9, fp
    7df8:	0041690d 	subeq	r6, r1, sp, lsl #18
    7dfc:	04080000 	streq	r0, [r8], #-0
    7e00:	00007dee 	andeq	r7, r0, lr, ror #27
    7e04:	004f3e10 	subeq	r3, pc, r0, lsl lr	; <UNPREDICTABLE>
    7e08:	09651000 	stmdbeq	r5!, {ip}^
    7e0c:	00007e35 	andeq	r7, r0, r5, lsr lr
    7e10:	004ad00f 	subeq	sp, sl, pc
    7e14:	b30a6500 	movwlt	r6, #42240	; 0xa500
    7e18:	00000000 	andeq	r0, r0, r0
    7e1c:	001c270f 	andseq	r2, ip, pc, lsl #14
    7e20:	3a0b6500 	bcc	2e1228 <unflatten_and_copy_device_tree+0x2e03b4>
    7e24:	0400007e 	streq	r0, [r0], #-126	; 0xffffff82
    7e28:	00058e0f 	andeq	r8, r5, pc, lsl #28
    7e2c:	c70c6500 	strgt	r6, [ip, -r0, lsl #10]
    7e30:	08000002 	stmdaeq	r0, {r1}
    7e34:	0a921600 	beq	fe485808 <__crc_of_fdt_unflatten_tree+0x7774424b>
    7e38:	04080000 	streq	r0, [r8], #-0
    7e3c:	00007e35 	andeq	r7, r0, r5, lsr lr
    7e40:	005dfd10 	subseq	pc, sp, r0, lsl sp	; <UNPREDICTABLE>
    7e44:	10650400 	rsbne	r0, r5, r0, lsl #8
    7e48:	00007e59 	andeq	r7, r0, r9, asr lr
    7e4c:	001c270f 	andseq	r2, ip, pc, lsl #14
    7e50:	5e116500 	cfmul32pl	mvfx6, mvfx1, mvfx0
    7e54:	0000007e 	andeq	r0, r0, lr, ror r0
    7e58:	36ff1600 	ldrbtcc	r1, [pc], r0, lsl #12
    7e5c:	04080000 	streq	r0, [r8], #-0
    7e60:	00007e59 	andeq	r7, r0, r9, asr lr
    7e64:	192b0c22 	stmdbne	fp!, {r1, r5, sl, fp}
    7e68:	007e8804 	rsbseq	r8, lr, r4, lsl #16
    7e6c:	004c1b00 	subeq	r1, ip, r0, lsl #22
    7e70:	1a2b0000 	bne	ac7e78 <unflatten_and_copy_device_tree+0xac7004>
    7e74:	0002c704 	andeq	ip, r2, r4, lsl #14
    7e78:	d01b0000 	andsle	r0, fp, r0
    7e7c:	2b00004a 	blcs	7fac <.debug_info+0x7fac>
    7e80:	0057041b 	subseq	r0, r7, fp, lsl r4
    7e84:	00080000 	andeq	r0, r8, r0
    7e88:	162b1038 			; <UNDEFINED> instruction: 0x162b1038
    7e8c:	007eb604 	rsbseq	fp, lr, r4, lsl #12
    7e90:	57983900 	ldrpl	r3, [r8, r0, lsl #18]
    7e94:	172b0000 	strne	r0, [fp, -r0]!
    7e98:	007e0404 	rsbseq	r0, lr, r4, lsl #8
    7e9c:	222e3900 	eorcs	r3, lr, #0, 18
    7ea0:	182b0000 	stmdane	fp!, {}	; <UNPREDICTABLE>
    7ea4:	007e4004 	rsbseq	r4, lr, r4
    7ea8:	66613600 	strbtvs	r3, [r1], -r0, lsl #12
    7eac:	1c2b0073 	stcne	0, cr0, [fp], #-460	; 0xfffffe34
    7eb0:	007e6404 	rsbseq	r6, lr, r4, lsl #8
    7eb4:	321a0000 	andscc	r0, sl, #0
    7eb8:	1c000061 	stcne	0, cr0, [r0], {97}	; 0x61
    7ebc:	1204f52b 	andne	pc, r4, #180355072	; 0xac00000
    7ec0:	1b00007f 	blne	80c4 <.debug_info+0x80c4>
    7ec4:	000024e9 	andeq	r2, r0, r9, ror #9
    7ec8:	ff04f62b 			; <UNDEFINED> instruction: 0xff04f62b
    7ecc:	00000010 	andeq	r0, r0, r0, lsl r0
    7ed0:	0022e81b 	eoreq	lr, r2, fp, lsl r8
    7ed4:	04f72b00 	ldrbteq	r2, [r7], #2816	; 0xb00
    7ed8:	00000057 	andeq	r0, r0, r7, asr r0
    7edc:	58281b04 	stmdapl	r8!, {r2, r8, r9, fp, ip}
    7ee0:	f82b0000 			; <UNDEFINED> instruction: 0xf82b0000
    7ee4:	00005704 	andeq	r5, r0, r4, lsl #14
    7ee8:	6d1b0800 	ldcvs	8, cr0, [fp, #-0]
    7eec:	2b000032 	blcs	7fbc <.debug_info+0x7fbc>
    7ef0:	7f1204f9 	svcvc	0x001204f9
    7ef4:	1b0c0000 	blne	307efc <unflatten_and_copy_device_tree+0x307088>
    7ef8:	000056c4 	andeq	r5, r0, r4, asr #13
    7efc:	cc04fa2b 	stcgt	10, cr15, [r4], {43}	; 0x2b
    7f00:	10000023 	andne	r0, r0, r3, lsr #32
    7f04:	003d771b 	eorseq	r7, sp, fp, lsl r7
    7f08:	04fb2b00 	ldrbteq	r2, [fp], #2816	; 0xb00
    7f0c:	0000033c 	andeq	r0, r0, ip, lsr r3
    7f10:	04080014 	streq	r0, [r8], #-20	; 0xffffffec
    7f14:	00007eb6 			; <UNDEFINED> instruction: 0x00007eb6
    7f18:	7f1e0408 	svcvc	0x001e0408
    7f1c:	61090000 	mrsvs	r0, (UNDEF: 9)
    7f20:	0800007b 	stmdaeq	r0, {r0, r1, r3, r4, r5, r6}
    7f24:	007f2904 	rsbseq	r2, pc, r4, lsl #18
    7f28:	7cc80900 	stclvc	9, cr0, [r8], {0}
    7f2c:	042b0000 	strteq	r0, [fp], #-0
    7f30:	00000069 	andeq	r0, r0, r9, rrx
    7f34:	5a05212b 	bpl	1503e8 <unflatten_and_copy_device_tree+0x14f574>
    7f38:	0b00007f 	bleq	813c <.debug_info+0x813c>
    7f3c:	00003d24 	andeq	r3, r0, r4, lsr #26
    7f40:	54670b00 	strbtpl	r0, [r7], #-2816	; 0xfffff500
    7f44:	0b010000 	bleq	47f4c <unflatten_and_copy_device_tree+0x470d8>
    7f48:	0000393a 	andeq	r3, r0, sl, lsr r9
    7f4c:	12350b02 	eorsne	r0, r5, #2048	; 0x800
    7f50:	0b030000 	bleq	c7f58 <unflatten_and_copy_device_tree+0xc70e4>
    7f54:	0000114e 	andeq	r1, r0, lr, asr #2
    7f58:	631c0004 	tstvs	ip, #4
    7f5c:	00000046 	andeq	r0, r0, r6, asr #32
    7f60:	052c2b01 	streq	r2, [ip, #-2817]!	; 0xfffff4ff
    7f64:	00007f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
    7f68:	000bf81b 	andeq	pc, fp, fp, lsl r8	; <UNPREDICTABLE>
    7f6c:	052d2b00 	streq	r2, [sp, #-2816]!	; 0xfffff500
    7f70:	00000057 	andeq	r0, r0, r7, asr r0
    7f74:	36a91b00 	strtcc	r1, [r9], r0, lsl #22
    7f78:	2e2b0000 	cdpcs	0, 2, cr0, cr11, cr0, {0}
    7f7c:	0011eb05 	andseq	lr, r1, r5, lsl #22
    7f80:	f41b0400 			; <UNDEFINED> instruction: 0xf41b0400
    7f84:	2b00001e 	blcs	8004 <.debug_info+0x8004>
    7f88:	7f90052f 	svcvc	0x0090052f
    7f8c:	00100000 	andseq	r0, r0, r0
    7f90:	0036ca06 	eorseq	ip, r6, r6, lsl #20
    7f94:	007fa000 	rsbseq	sl, pc, r0
    7f98:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    7f9c:	00020000 	andeq	r0, r2, r0
    7fa0:	0064801a 	rsbeq	r8, r4, sl, lsl r0
    7fa4:	b82b1c00 	stmdalt	fp!, {sl, fp, ip}
    7fa8:	00806407 	addeq	r6, r0, r7, lsl #8
    7fac:	059b1b00 	ldreq	r1, [fp, #2816]	; 0xb00
    7fb0:	b92b0000 	stmdblt	fp!, {}	; <UNPREDICTABLE>
    7fb4:	0000f207 	andeq	pc, r0, r7, lsl #4
    7fb8:	061b0000 	ldreq	r0, [fp], -r0
    7fbc:	2b000006 	blcs	7fdc <.debug_info+0x7fdc>
    7fc0:	005707ba 	ldrheq	r0, [r7], #-122	; 0xffffff86
    7fc4:	1b040000 	blne	107fcc <unflatten_and_copy_device_tree+0x107158>
    7fc8:	00000c2a 	andeq	r0, r0, sl, lsr #24
    7fcc:	a407c22b 	strge	ip, [r7], #-555	; 0xfffffdd5
    7fd0:	08000089 	stmdaeq	r0, {r0, r3, r7}
    7fd4:	0053811b 	subseq	r8, r3, fp, lsl r1
    7fd8:	07c42b00 	strbeq	r2, [r4, r0, lsl #22]
    7fdc:	000088d4 	ldrdeq	r8, [r0], -r4
    7fe0:	1c271b0c 	stcne	11, cr1, [r7], #-48	; 0xffffffd0
    7fe4:	c52b0000 	strgt	r0, [fp, #-0]!
    7fe8:	00724807 	rsbseq	r4, r2, r7, lsl #16
    7fec:	221b1000 	andscs	r1, fp, #0
    7ff0:	2b000022 	blcs	8080 <.debug_info+0x8080>
    7ff4:	806407c6 	rsbhi	r0, r4, r6, asr #15
    7ff8:	1b140000 	blne	508000 <unflatten_and_copy_device_tree+0x50718c>
    7ffc:	000039d7 	ldrdeq	r3, [r0], -r7
    8000:	f207c72b 	vabd.s8	d12, d7, d27
    8004:	18000002 	stmdane	r0, {r1}
    8008:	002a801b 	eoreq	r8, sl, fp, lsl r0
    800c:	07c92b00 	strbeq	r2, [r9, r0, lsl #22]
    8010:	000010ab 	andeq	r1, r0, fp, lsr #1
    8014:	35831b1c 	strcc	r1, [r3, #2844]	; 0xb1c
    8018:	ca2b0000 	bgt	ac8020 <unflatten_and_copy_device_tree+0xac71ac>
    801c:	0010ab07 	andseq	sl, r0, r7, lsl #22
    8020:	741b1c00 	ldrvc	r1, [fp], #-3072	; 0xfffff400
    8024:	2b000023 	blcs	80b8 <.debug_info+0x80b8>
    8028:	10ab07cb 	adcne	r0, fp, fp, asr #15
    802c:	1b1c0000 	blne	708034 <unflatten_and_copy_device_tree+0x7071c0>
    8030:	00000d25 	andeq	r0, r0, r5, lsr #26
    8034:	aa07cc2b 	bge	1fb0e8 <unflatten_and_copy_device_tree+0x1fa274>
    8038:	1c000089 	stcne	0, cr0, [r0], {137}	; 0x89
    803c:	0001b31b 	andeq	fp, r1, fp, lsl r3
    8040:	07ce2b00 	strbeq	r2, [lr, r0, lsl #22]
    8044:	000010ab 	andeq	r1, r0, fp, lsr #1
    8048:	3f341b1c 	svccc	0x00341b1c
    804c:	cf2b0000 	svcgt	0x002b0000
    8050:	0010ab07 	andseq	sl, r0, r7, lsl #22
    8054:	7f1b1c00 	svcvc	0x001b1c00
    8058:	2b000067 	blcs	81fc <.debug_info+0x81fc>
    805c:	10ab07d0 	ldrdne	r0, [fp], r0	; <UNPREDICTABLE>
    8060:	001c0000 	andseq	r0, ip, r0
    8064:	7fa00408 	svcvc	0x00a00408
    8068:	3a1a0000 	bcc	680008 <unflatten_and_copy_device_tree+0x67f194>
    806c:	58000018 	stmdapl	r0, {r3, r4}
    8070:	9606ca2b 	strls	ip, [r6], -fp, lsr #20
    8074:	1b000081 	blne	8280 <.debug_info+0x8280>
    8078:	000004e7 	andeq	r0, r0, r7, ror #9
    807c:	6d06cb2b 	vstrvs	d12, [r6, #-172]	; 0xffffff54
    8080:	00000088 	andeq	r0, r0, r8, lsl #1
    8084:	00207b1b 	eoreq	r7, r0, fp, lsl fp
    8088:	06cc2b00 	strbeq	r2, [ip], r0, lsl #22
    808c:	0000887e 	andeq	r8, r0, lr, ror r8
    8090:	046e1b04 	strbteq	r1, [lr], #-2820	; 0xfffff4fc
    8094:	ce2b0000 	cdpgt	0, 2, cr0, cr11, cr0, {0}
    8098:	00889406 	addeq	r9, r8, r6, lsl #8
    809c:	851b0800 	ldrhi	r0, [fp, #-2048]	; 0xfffff800
    80a0:	2b000034 	blcs	8178 <.debug_info+0x8178>
    80a4:	88ae06cf 	stmiahi	lr!, {r0, r1, r2, r3, r6, r7, r9, sl}
    80a8:	1b0c0000 	blne	3080b0 <unflatten_and_copy_device_tree+0x30723c>
    80ac:	000064ae 	andeq	r6, r0, lr, lsr #9
    80b0:	c306d02b 	movwgt	sp, #24619	; 0x602b
    80b4:	10000088 	andne	r0, r0, r8, lsl #1
    80b8:	0012f21b 	andseq	pc, r2, fp, lsl r2	; <UNPREDICTABLE>
    80bc:	06d12b00 	ldrbeq	r2, [r1], r0, lsl #22
    80c0:	0000887e 	andeq	r8, r0, lr, ror r8
    80c4:	23b41b14 			; <UNDEFINED> instruction: 0x23b41b14
    80c8:	d22b0000 	eorle	r0, fp, #0
    80cc:	0088d406 	addeq	sp, r8, r6, lsl #8
    80d0:	b81b1800 	ldmdalt	fp, {fp, ip}
    80d4:	2b00002c 	blcs	818c <.debug_info+0x818c>
    80d8:	6de006d3 	stclvs	6, cr0, [r0, #844]!	; 0x34c
    80dc:	1b1c0000 	blne	7080e4 <unflatten_and_copy_device_tree+0x707270>
    80e0:	00004053 	andeq	r4, r0, r3, asr r0
    80e4:	e906d42b 	stmdb	r6, {r0, r1, r3, r5, sl, ip, lr, pc}
    80e8:	20000088 	andcs	r0, r0, r8, lsl #1
    80ec:	005ade1b 	subseq	sp, sl, fp, lsl lr
    80f0:	06d52b00 	ldrbeq	r2, [r5], r0, lsl #22
    80f4:	000088e9 	andeq	r8, r0, r9, ror #17
    80f8:	16161b24 	ldrne	r1, [r6], -r4, lsr #22
    80fc:	d62b0000 	strtle	r0, [fp], -r0
    8100:	0088e906 	addeq	lr, r8, r6, lsl #18
    8104:	201b2800 	andscs	r2, fp, r0, lsl #16
    8108:	2b00001a 	blcs	8178 <.debug_info+0x8178>
    810c:	88e906d7 	stmiahi	r9!, {r0, r1, r2, r4, r6, r7, r9, sl}^
    8110:	1b2c0000 	blne	b08118 <unflatten_and_copy_device_tree+0xb072a4>
    8114:	00000e78 	andeq	r0, r0, r8, ror lr
    8118:	0e06d82b 	cdpeq	8, 0, cr13, cr6, cr11, {1}
    811c:	30000089 	andcc	r0, r0, r9, lsl #1
    8120:	002ea01b 	eoreq	sl, lr, fp, lsl r0
    8124:	06d92b00 	ldrbeq	r2, [r9], r0, lsl #22
    8128:	0000892d 	andeq	r8, r0, sp, lsr #18
    812c:	31ec1b34 	mvncc	r1, r4, lsr fp
    8130:	da2b0000 	ble	ac8138 <unflatten_and_copy_device_tree+0xac72c4>
    8134:	0088d406 	addeq	sp, r8, r6, lsl #8
    8138:	ed1b3800 	ldc	8, cr3, [fp, #-0]
    813c:	2b000055 	blcs	8298 <.debug_info+0x8298>
    8140:	894706dc 	stmdbhi	r7, {r2, r3, r4, r6, r7, r9, sl}^
    8144:	1b3c0000 	blne	f0814c <unflatten_and_copy_device_tree+0xf072d8>
    8148:	000038e5 	andeq	r3, r0, r5, ror #17
    814c:	4706dd2b 	strmi	sp, [r6, -fp, lsr #26]
    8150:	40000089 	andmi	r0, r0, r9, lsl #1
    8154:	000fe01b 	andeq	lr, pc, fp, lsl r0	; <UNPREDICTABLE>
    8158:	06de2b00 	ldrbeq	r2, [lr], r0, lsl #22
    815c:	00008947 	andeq	r8, r0, r7, asr #18
    8160:	60ce1b44 	sbcvs	r1, lr, r4, asr #22
    8164:	df2b0000 	svcle	0x002b0000
    8168:	00894706 	addeq	r4, r9, r6, lsl #14
    816c:	031b4800 	tsteq	fp, #0, 16
    8170:	2b00004c 	blcs	82a8 <.debug_info+0x82a8>
    8174:	896606e5 	stmdbhi	r6!, {r0, r2, r5, r6, r7, r9, sl}^
    8178:	1b4c0000 	blne	1308180 <unflatten_and_copy_device_tree+0x130730c>
    817c:	0000539e 	muleq	r0, lr, r3
    8180:	8006e62b 	andhi	lr, r6, fp, lsr #12
    8184:	50000089 	andpl	r0, r0, r9, lsl #1
    8188:	00204c1b 	eoreq	r4, r0, fp, lsl ip
    818c:	06e82b00 	strbteq	r2, [r8], r0, lsl #22
    8190:	00008980 	andeq	r8, r0, r0, lsl #19
    8194:	04080054 	streq	r0, [r8], #-84	; 0xffffffac
    8198:	0000819c 	muleq	r0, ip, r1
    819c:	00806a09 	addeq	r6, r0, r9, lsl #20
    81a0:	a7040800 	strge	r0, [r4, -r0, lsl #16]
    81a4:	09000081 	stmdbeq	r0, {r0, r7}
    81a8:	00006dfb 	strdeq	r6, [r0], -fp
    81ac:	81b20408 			; <UNDEFINED> instruction: 0x81b20408
    81b0:	00090000 	andeq	r0, r9, r0
    81b4:	16000071 			; <UNDEFINED> instruction: 0x16000071
    81b8:	00000e4d 	andeq	r0, r0, sp, asr #28
    81bc:	81c20408 	bichi	r0, r2, r8, lsl #8
    81c0:	b7090000 	strlt	r0, [r9, -r0]
    81c4:	16000081 	strne	r0, [r0], -r1, lsl #1
    81c8:	00005e1c 	andeq	r5, r0, ip, lsl lr
    81cc:	81d20408 	bicshi	r0, r2, r8, lsl #8
    81d0:	04080000 	streq	r0, [r8], #-0
    81d4:	000081d8 	ldrdeq	r8, [r0], -r8	; <UNPREDICTABLE>
    81d8:	0081c709 	addeq	ip, r1, r9, lsl #14
    81dc:	184b1600 	stmdane	fp, {r9, sl, ip}^
    81e0:	04080000 	streq	r0, [r8], #-0
    81e4:	000081dd 	ldrdeq	r8, [r0], -sp
    81e8:	00009306 	andeq	r9, r0, r6, lsl #6
    81ec:	0081f800 	addeq	pc, r1, r0, lsl #16
    81f0:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    81f4:	000f0000 	andeq	r0, pc, r0
    81f8:	002b0b1a 	eoreq	r0, fp, sl, lsl fp
    81fc:	2e2b1000 	cdpcs	0, 2, cr1, cr11, cr0, {0}
    8200:	00823a06 	addeq	r3, r2, r6, lsl #20
    8204:	5cc01b00 	vstmiapl	r0, {d17-d16}
    8208:	2f2b0000 	svccs	0x002b0000
    820c:	00006906 	andeq	r6, r0, r6, lsl #18
    8210:	211b0000 	tstcs	fp, r0
    8214:	2b00004a 	blcs	8344 <.debug_info+0x8344>
    8218:	00690630 	rsbeq	r0, r9, r0, lsr r6
    821c:	1b040000 	blne	108224 <unflatten_and_copy_device_tree+0x1073b0>
    8220:	000009a0 	andeq	r0, r0, r0, lsr #19
    8224:	6906312b 	stmdbvs	r6, {r0, r1, r3, r5, r8, ip, sp}
    8228:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    822c:	004cb21b 	subeq	fp, ip, fp, lsl r2
    8230:	06322b00 	ldrteq	r2, [r2], -r0, lsl #22
    8234:	0000823a 	andeq	r8, r0, sl, lsr r2
    8238:	0408000c 	streq	r0, [r8], #-12
    823c:	0000678b 	andeq	r6, r0, fp, lsl #15
    8240:	00566b23 	subseq	r6, r6, r3, lsr #22
    8244:	06502b00 	ldrbeq	r2, [r0], -r0, lsl #22
    8248:	0000824c 	andeq	r8, r0, ip, asr #4
    824c:	82520408 	subshi	r0, r2, #8, 8	; 0x8000000
    8250:	57150000 	ldrpl	r0, [r5, -r0]
    8254:	7a000000 	bvc	825c <.debug_info+0x825c>
    8258:	0d000082 	stceq	0, cr0, [r0, #-520]	; 0xfffffdf8
    825c:	0000827a 	andeq	r8, r0, sl, ror r2
    8260:	0000f20d 	andeq	pc, r0, sp, lsl #4
    8264:	00570d00 	subseq	r0, r7, r0, lsl #26
    8268:	230d0000 	movwcs	r0, #53248	; 0xd000
    826c:	0d000002 	stceq	0, cr0, [r0, #-8]
    8270:	000000c9 	andeq	r0, r0, r9, asr #1
    8274:	0000690d 	andeq	r6, r0, sp, lsl #18
    8278:	04080000 	streq	r0, [r8], #-0
    827c:	00008280 	andeq	r8, r0, r0, lsl #5
    8280:	005cf61a 	subseq	pc, ip, sl, lsl r6	; <UNPREDICTABLE>
    8284:	532b1000 			; <UNDEFINED> instruction: 0x532b1000
    8288:	0082a806 	addeq	sl, r2, r6, lsl #16
    828c:	0b321b00 	bleq	c86c08 <unflatten_and_copy_device_tree+0xc85d94>
    8290:	542b0000 	strtpl	r0, [fp], #-0
    8294:	0082a806 	addeq	sl, r2, r6, lsl #16
    8298:	701d0000 	andsvc	r0, sp, r0
    829c:	2b00736f 	blcs	25060 <unflatten_and_copy_device_tree+0x241ec>
    82a0:	02230655 	eoreq	r0, r3, #89128960	; 0x5500000
    82a4:	00080000 	andeq	r0, r8, r0
    82a8:	00824009 	addeq	r4, r2, r9
    82ac:	02231500 	eoreq	r1, r3, #0, 10
    82b0:	82c60000 	sbchi	r0, r6, #0
    82b4:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    82b8:	0d000023 	stceq	0, cr0, [r0, #-140]	; 0xffffff74
    82bc:	00000223 	andeq	r0, r0, r3, lsr #4
    82c0:	0000570d 	andeq	r5, r0, sp, lsl #14
    82c4:	04080000 	streq	r0, [r8], #-0
    82c8:	000082ad 	andeq	r8, r0, sp, lsr #5
    82cc:	00023915 	andeq	r3, r2, r5, lsl r9
    82d0:	0082ea00 	addeq	lr, r2, r0, lsl #20
    82d4:	23cc0d00 	biccs	r0, ip, #0, 26
    82d8:	b30d0000 	movwlt	r0, #53248	; 0xd000
    82dc:	0d000001 	stceq	0, cr0, [r0, #-4]
    82e0:	0000022e 	andeq	r0, r0, lr, lsr #4
    82e4:	001ac10d 	andseq	ip, sl, sp, lsl #2
    82e8:	04080000 	streq	r0, [r8], #-0
    82ec:	000082cc 	andeq	r8, r0, ip, asr #5
    82f0:	00023915 	andeq	r3, r2, r5, lsl r9
    82f4:	00830e00 	addeq	r0, r3, r0, lsl #28
    82f8:	23cc0d00 	biccs	r0, ip, #0, 26
    82fc:	f20d0000 	vhadd.s8	d0, d13, d0
    8300:	0d000000 	stceq	0, cr0, [r0, #-0]
    8304:	0000022e 	andeq	r0, r0, lr, lsr #4
    8308:	001ac10d 	andseq	ip, sl, sp, lsl #2
    830c:	04080000 	streq	r0, [r8], #-0
    8310:	000082f0 	strdeq	r8, [r0], -r0
    8314:	00023915 	andeq	r3, r2, r5, lsl r9
    8318:	00832800 	addeq	r2, r3, r0, lsl #16
    831c:	69550d00 	ldmdbvs	r5, {r8, sl, fp}^
    8320:	600d0000 	andvs	r0, sp, r0
    8324:	00000075 	andeq	r0, r0, r5, ror r0
    8328:	83140408 	tsthi	r4, #8, 8	; 0x8000000
    832c:	57150000 	ldrpl	r0, [r5, -r0]
    8330:	42000000 	andmi	r0, r0, #0
    8334:	0d000083 	stceq	0, cr0, [r0, #-524]	; 0xfffffdf4
    8338:	000023cc 	andeq	r2, r0, ip, asr #7
    833c:	00827a0d 	addeq	r7, r2, sp, lsl #20
    8340:	04080000 	streq	r0, [r8], #-0
    8344:	0000832e 	andeq	r8, r0, lr, lsr #6
    8348:	00006915 	andeq	r6, r0, r5, lsl r9
    834c:	00835c00 	addeq	r5, r3, r0, lsl #24
    8350:	23cc0d00 	biccs	r0, ip, #0, 26
    8354:	5c0d0000 	stcpl	0, cr0, [sp], {-0}
    8358:	00000083 	andeq	r0, r0, r3, lsl #1
    835c:	83620408 	cmnhi	r2, #8, 8	; 0x8000000
    8360:	c0160000 	andsgt	r0, r6, r0
    8364:	0800003a 	stmdaeq	r0, {r1, r3, r4, r5}
    8368:	00834804 	addeq	r4, r3, r4, lsl #16
    836c:	01331500 	teqeq	r3, r0, lsl #10
    8370:	83860000 	orrhi	r0, r6, #0
    8374:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    8378:	0d000023 	stceq	0, cr0, [r0, #-140]	; 0xffffff74
    837c:	00000069 	andeq	r0, r0, r9, rrx
    8380:	0000d40d 	andeq	sp, r0, sp, lsl #8
    8384:	04080000 	streq	r0, [r8], #-0
    8388:	0000836d 	andeq	r8, r0, sp, ror #6
    838c:	00005715 	andeq	r5, r0, r5, lsl r7
    8390:	0083a000 	addeq	sl, r3, r0
    8394:	23cc0d00 	biccs	r0, ip, #0, 26
    8398:	a70d0000 	strge	r0, [sp, -r0]
    839c:	00000005 	andeq	r0, r0, r5
    83a0:	838c0408 	orrhi	r0, ip, #8, 8	; 0x8000000
    83a4:	57150000 	ldrpl	r0, [r5, -r0]
    83a8:	ba000000 	blt	83b0 <.debug_info+0x83b0>
    83ac:	0d000083 	stceq	0, cr0, [r0, #-524]	; 0xfffffdf4
    83b0:	000060f2 	strdeq	r6, [r0], -r2
    83b4:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    83b8:	04080000 	streq	r0, [r8], #-0
    83bc:	000083a6 	andeq	r8, r0, r6, lsr #7
    83c0:	00005715 	andeq	r5, r0, r5, lsl r7
    83c4:	0083d400 	addeq	sp, r3, r0, lsl #8
    83c8:	23cc0d00 	biccs	r0, ip, #0, 26
    83cc:	550d0000 	strpl	r0, [sp, #-0]
    83d0:	0000007b 	andeq	r0, r0, fp, ror r0
    83d4:	83c00408 	bichi	r0, r0, #8, 8	; 0x8000000
    83d8:	57150000 	ldrpl	r0, [r5, -r0]
    83dc:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    83e0:	0d000083 	stceq	0, cr0, [r0, #-524]	; 0xfffffdf4
    83e4:	000023cc 	andeq	r2, r0, ip, asr #7
    83e8:	0002230d 	andeq	r2, r2, sp, lsl #6
    83ec:	02230d00 	eoreq	r0, r3, #0, 26
    83f0:	570d0000 	strpl	r0, [sp, -r0]
    83f4:	00000000 	andeq	r0, r0, r0
    83f8:	83da0408 	bicshi	r0, sl, #8, 8	; 0x8000000
    83fc:	57150000 	ldrpl	r0, [r5, -r0]
    8400:	12000000 	andne	r0, r0, #0
    8404:	0d000084 	stceq	0, cr0, [r0, #-528]	; 0xfffffdf0
    8408:	00006955 	andeq	r6, r0, r5, asr r9
    840c:	0000570d 	andeq	r5, r0, sp, lsl #14
    8410:	04080000 	streq	r0, [r8], #-0
    8414:	000083fe 	strdeq	r8, [r0], -lr
    8418:	00005715 	andeq	r5, r0, r5, lsl r7
    841c:	00843100 	addeq	r3, r4, r0, lsl #2
    8420:	00570d00 	subseq	r0, r7, r0, lsl #26
    8424:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    8428:	0d000023 	stceq	0, cr0, [r0, #-140]	; 0xffffff74
    842c:	00000057 	andeq	r0, r0, r7, asr r0
    8430:	18040800 	stmdane	r4, {fp}
    8434:	15000084 	strne	r0, [r0, #-132]	; 0xffffff7c
    8438:	00000057 	andeq	r0, r0, r7, asr r0
    843c:	00008450 	andeq	r8, r0, r0, asr r4
    8440:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    8444:	00570d00 	subseq	r0, r7, r0, lsl #26
    8448:	990d0000 	stmdbls	sp, {}	; <UNPREDICTABLE>
    844c:	0000007b 	andeq	r0, r0, fp, ror r0
    8450:	84370408 	ldrthi	r0, [r7], #-1032	; 0xfffffbf8
    8454:	39150000 	ldmdbcc	r5, {}	; <UNPREDICTABLE>
    8458:	7e000002 	cdpvc	0, 0, cr0, cr0, cr2, {0}
    845c:	0d000084 	stceq	0, cr0, [r0, #-528]	; 0xfffffdf0
    8460:	000023cc 	andeq	r2, r0, ip, asr #7
    8464:	0005640d 	andeq	r6, r5, sp, lsl #8
    8468:	00570d00 	subseq	r0, r7, r0, lsl #26
    846c:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    8470:	0d000002 	stceq	0, cr0, [r0, #-8]
    8474:	00001ac1 	andeq	r1, r0, r1, asr #21
    8478:	0000570d 	andeq	r5, r0, sp, lsl #14
    847c:	04080000 	streq	r0, [r8], #-0
    8480:	00008456 	andeq	r8, r0, r6, asr r4
    8484:	00005715 	andeq	r5, r0, r5, lsl r7
    8488:	00849300 	addeq	r9, r4, r0, lsl #6
    848c:	00570d00 	subseq	r0, r7, r0, lsl #26
    8490:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8494:	00848404 	addeq	r8, r4, r4, lsl #8
    8498:	02391500 	eorseq	r1, r9, #0, 10
    849c:	84bc0000 	ldrthi	r0, [ip], #0
    84a0:	680d0000 	stmdavs	sp, {}	; <UNPREDICTABLE>
    84a4:	0d00004f 	stceq	0, cr0, [r0, #-316]	; 0xfffffec4
    84a8:	000023cc 	andeq	r2, r0, ip, asr #7
    84ac:	001ac10d 	andseq	ip, sl, sp, lsl #2
    84b0:	022e0d00 	eoreq	r0, lr, #0, 26
    84b4:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    84b8:	00000000 	andeq	r0, r0, r0
    84bc:	84990408 	ldrhi	r0, [r9], #1032	; 0x408
    84c0:	39150000 	ldmdbcc	r5, {}	; <UNPREDICTABLE>
    84c4:	e5000002 	str	r0, [r0, #-2]
    84c8:	0d000084 	stceq	0, cr0, [r0, #-528]	; 0xfffffdf0
    84cc:	000023cc 	andeq	r2, r0, ip, asr #7
    84d0:	001ac10d 	andseq	ip, sl, sp, lsl #2
    84d4:	4f680d00 	svcmi	0x00680d00
    84d8:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    84dc:	0d000002 	stceq	0, cr0, [r0, #-8]
    84e0:	00000069 	andeq	r0, r0, r9, rrx
    84e4:	c2040800 	andgt	r0, r4, #0, 16
    84e8:	15000084 	strne	r0, [r0, #-132]	; 0xffffff7c
    84ec:	00000057 	andeq	r0, r0, r7, asr r0
    84f0:	00008509 	andeq	r8, r0, r9, lsl #10
    84f4:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    84f8:	01330d00 	teqeq	r3, r0, lsl #26
    84fc:	090d0000 	stmdbeq	sp, {}	; <UNPREDICTABLE>
    8500:	0d000085 	stceq	0, cr0, [r0, #-532]	; 0xfffffdec
    8504:	00004169 	andeq	r4, r0, r9, ror #2
    8508:	99040800 	stmdbls	r4, {fp}
    850c:	0800007b 	stmdaeq	r0, {r0, r1, r3, r4, r5, r6}
    8510:	0084eb04 	addeq	lr, r4, r4, lsl #22
    8514:	01331500 	teqeq	r3, r0, lsl #10
    8518:	85330000 	ldrhi	r0, [r3, #-0]!
    851c:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
    8520:	0d000023 	stceq	0, cr0, [r0, #-140]	; 0xffffff74
    8524:	00000057 	andeq	r0, r0, r7, asr r0
    8528:	0002230d 	andeq	r2, r2, sp, lsl #6
    852c:	02230d00 	eoreq	r0, r3, #0, 26
    8530:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8534:	00851504 	addeq	r1, r5, r4, lsl #10
    8538:	85490c00 	strbhi	r0, [r9, #-3072]	; 0xfffff400
    853c:	060d0000 	streq	r0, [sp], -r0
    8540:	0d00003f 	stceq	0, cr0, [r0, #-252]	; 0xffffff04
    8544:	000023cc 	andeq	r2, r0, ip, asr #7
    8548:	39040800 	stmdbcc	r4, {fp}
    854c:	15000085 	strne	r0, [r0, #-133]	; 0xffffff7b
    8550:	00005e7c 	andeq	r5, r0, ip, ror lr
    8554:	00008568 	andeq	r8, r0, r8, ror #10
    8558:	0060f20d 	rsbeq	pc, r0, sp, lsl #4
    855c:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    8560:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    8564:	00000000 	andeq	r0, r0, r0
    8568:	854f0408 	strbhi	r0, [pc, #-1032]	; 8168 <.debug_info+0x8168>
    856c:	f2150000 	vhadd.s16	d0, d5, d0
    8570:	82000000 	andhi	r0, r0, #0
    8574:	0d000085 	stceq	0, cr0, [r0, #-532]	; 0xfffffdec
    8578:	00005e7c 	andeq	r5, r0, ip, ror lr
    857c:	0041690d 	subeq	r6, r1, sp, lsl #18
    8580:	04080000 	streq	r0, [r8], #-0
    8584:	0000856e 	andeq	r8, r0, lr, ror #10
    8588:	00005715 	andeq	r5, r0, r5, lsl r7
    858c:	00859c00 	addeq	r9, r5, r0, lsl #24
    8590:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    8594:	570d0000 	strpl	r0, [sp, -r0]
    8598:	00000000 	andeq	r0, r0, r0
    859c:	85880408 	strhi	r0, [r8, #1032]	; 0x408
    85a0:	3f150000 	svccc	0x00150000
    85a4:	b6000077 			; <UNDEFINED> instruction: 0xb6000077
    85a8:	0d000085 	stceq	0, cr0, [r0, #-532]	; 0xfffffdec
    85ac:	000060f2 	strdeq	r6, [r0], -r2
    85b0:	0000570d 	andeq	r5, r0, sp, lsl #14
    85b4:	04080000 	streq	r0, [r8], #-0
    85b8:	000085a2 	andeq	r8, r0, r2, lsr #11
    85bc:	00005715 	andeq	r5, r0, r5, lsl r7
    85c0:	0085d500 	addeq	sp, r5, r0, lsl #10
    85c4:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    85c8:	b30d0000 	movwlt	r0, #53248	; 0xd000
    85cc:	0d000001 	stceq	0, cr0, [r0, #-4]
    85d0:	00000057 	andeq	r0, r0, r7, asr r0
    85d4:	bc040800 	stclt	8, cr0, [r4], {-0}
    85d8:	0c000085 	stceq	0, cr0, [r0], {133}	; 0x85
    85dc:	000085eb 	andeq	r8, r0, fp, ror #11
    85e0:	0060f20d 	rsbeq	pc, r0, sp, lsl #4
    85e4:	03780d00 	cmneq	r8, #0, 26
    85e8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    85ec:	0085db04 	addeq	sp, r5, r4, lsl #22
    85f0:	00571500 	subseq	r1, r7, r0, lsl #10
    85f4:	860f0000 	strhi	r0, [pc], -r0
    85f8:	f20d0000 	vhadd.s8	d0, d13, d0
    85fc:	0d000060 	stceq	0, cr0, [r0, #-384]	; 0xfffffe80
    8600:	00005e7c 	andeq	r5, r0, ip, ror lr
    8604:	0001da0d 	andeq	sp, r1, sp, lsl #20
    8608:	01fb0d00 	mvnseq	r0, r0, lsl #26
    860c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8610:	0085f104 	addeq	pc, r5, r4, lsl #2
    8614:	00571500 	subseq	r1, r7, r0, lsl #10
    8618:	862e0000 	strthi	r0, [lr], -r0
    861c:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    8620:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    8624:	000060f2 	strdeq	r6, [r0], -r2
    8628:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    862c:	04080000 	streq	r0, [r8], #-0
    8630:	00008615 	andeq	r8, r0, r5, lsl r6
    8634:	00005715 	andeq	r5, r0, r5, lsl r7
    8638:	00864800 	addeq	r4, r6, r0, lsl #16
    863c:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    8640:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    8644:	0000005e 	andeq	r0, r0, lr, asr r0
    8648:	86340408 	ldrthi	r0, [r4], -r8, lsl #8
    864c:	57150000 	ldrpl	r0, [r5, -r0]
    8650:	67000000 	strvs	r0, [r0, -r0]
    8654:	0d000086 	stceq	0, cr0, [r0, #-536]	; 0xfffffde8
    8658:	000060f2 	strdeq	r6, [r0], -r2
    865c:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    8660:	00f20d00 	rscseq	r0, r2, r0, lsl #26
    8664:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8668:	00864e04 	addeq	r4, r6, r4, lsl #28
    866c:	00571500 	subseq	r1, r7, r0, lsl #10
    8670:	86860000 	strhi	r0, [r6], r0
    8674:	f20d0000 	vhadd.s8	d0, d13, d0
    8678:	0d000060 	stceq	0, cr0, [r0, #-384]	; 0xfffffe80
    867c:	00005e7c 	andeq	r5, r0, ip, ror lr
    8680:	0001da0d 	andeq	sp, r1, sp, lsl #20
    8684:	04080000 	streq	r0, [r8], #-0
    8688:	0000866d 	andeq	r8, r0, sp, ror #12
    868c:	00005715 	andeq	r5, r0, r5, lsl r7
    8690:	0086aa00 	addeq	sl, r6, r0, lsl #20
    8694:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    8698:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    869c:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    86a0:	000001da 	ldrdeq	r0, [r0], -sl
    86a4:	0001cf0d 	andeq	ip, r1, sp, lsl #30
    86a8:	04080000 	streq	r0, [r8], #-0
    86ac:	0000868c 	andeq	r8, r0, ip, lsl #13
    86b0:	00005715 	andeq	r5, r0, r5, lsl r7
    86b4:	0086ce00 	addeq	ip, r6, r0, lsl #28
    86b8:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    86bc:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    86c0:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    86c4:	000060f2 	strdeq	r6, [r0], -r2
    86c8:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    86cc:	04080000 	streq	r0, [r8], #-0
    86d0:	000086b0 			; <UNDEFINED> instruction: 0x000086b0
    86d4:	00005715 	andeq	r5, r0, r5, lsl r7
    86d8:	0086f700 	addeq	pc, r6, r0, lsl #14
    86dc:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    86e0:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    86e4:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    86e8:	000060f2 	strdeq	r6, [r0], -r2
    86ec:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    86f0:	00690d00 	rsbeq	r0, r9, r0, lsl #26
    86f4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    86f8:	0086d404 	addeq	sp, r6, r4, lsl #8
    86fc:	00571500 	subseq	r1, r7, r0, lsl #10
    8700:	87110000 	ldrhi	r0, [r1, -r0]
    8704:	7c0d0000 	stcvc	0, cr0, [sp], {-0}
    8708:	0d00005e 	stceq	0, cr0, [r0, #-376]	; 0xfffffe88
    870c:	00008711 	andeq	r8, r0, r1, lsl r7
    8710:	aa040800 	bge	10a718 <unflatten_and_copy_device_tree+0x1098a4>
    8714:	08000069 	stmdaeq	r0, {r0, r3, r5, r6}
    8718:	0086fd04 	addeq	pc, r6, r4, lsl #26
    871c:	00571500 	subseq	r1, r7, r0, lsl #10
    8720:	87360000 	ldrhi	r0, [r6, -r0]!
    8724:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    8728:	0d000065 	stceq	0, cr0, [r0, #-404]	; 0xfffffe6c
    872c:	00005e7c 	andeq	r5, r0, ip, ror lr
    8730:	0087360d 	addeq	r3, r7, sp, lsl #12
    8734:	04080000 	streq	r0, [r8], #-0
    8738:	00005560 	andeq	r5, r0, r0, ror #10
    873c:	871d0408 	ldrhi	r0, [sp, -r8, lsl #8]
    8740:	57150000 	ldrpl	r0, [r5, -r0]
    8744:	65000000 	strvs	r0, [r0, #-0]
    8748:	0d000087 	stceq	0, cr0, [r0, #-540]	; 0xfffffde4
    874c:	00005e7c 	andeq	r5, r0, ip, ror lr
    8750:	0000f20d 	andeq	pc, r0, sp, lsl #4
    8754:	30dc0d00 	sbcscc	r0, ip, r0, lsl #26
    8758:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    875c:	0d000002 	stceq	0, cr0, [r0, #-8]
    8760:	00000057 	andeq	r0, r0, r7, asr r0
    8764:	42040800 	andmi	r0, r4, #0, 16
    8768:	15000087 	strne	r0, [r0, #-135]	; 0xffffff79
    876c:	00000239 	andeq	r0, r0, r9, lsr r2
    8770:	00008789 	andeq	r8, r0, r9, lsl #15
    8774:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    8778:	00f20d00 	rscseq	r0, r2, r0, lsl #26
    877c:	780d0000 	stmdavc	sp, {}	; <UNPREDICTABLE>
    8780:	0d000003 	stceq	0, cr0, [r0, #-12]
    8784:	0000022e 	andeq	r0, r0, lr, lsr #4
    8788:	6b040800 	blvs	10a790 <unflatten_and_copy_device_tree+0x10991c>
    878c:	15000087 	strne	r0, [r0, #-135]	; 0xffffff79
    8790:	00000239 	andeq	r0, r0, r9, lsr r2
    8794:	000087a8 	andeq	r8, r0, r8, lsr #15
    8798:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    879c:	01b30d00 			; <UNDEFINED> instruction: 0x01b30d00
    87a0:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
    87a4:	00000002 	andeq	r0, r0, r2
    87a8:	878f0408 	strhi	r0, [pc, r8, lsl #8]
    87ac:	57150000 	ldrpl	r0, [r5, -r0]
    87b0:	c2000000 	andgt	r0, r0, #0
    87b4:	0d000087 	stceq	0, cr0, [r0, #-540]	; 0xfffffde4
    87b8:	00005e7c 	andeq	r5, r0, ip, ror lr
    87bc:	0000f20d 	andeq	pc, r0, sp, lsl #4
    87c0:	04080000 	streq	r0, [r8], #-0
    87c4:	000087ae 	andeq	r8, r0, lr, lsr #15
    87c8:	00005715 	andeq	r5, r0, r5, lsl r7
    87cc:	0087e600 	addeq	lr, r7, r0, lsl #12
    87d0:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    87d4:	e60d0000 	str	r0, [sp], -r0
    87d8:	0d000087 	stceq	0, cr0, [r0, #-540]	; 0xfffffde4
    87dc:	000000c9 	andeq	r0, r0, r9, asr #1
    87e0:	0000c90d 	andeq	ip, r0, sp, lsl #18
    87e4:	04080000 	streq	r0, [r8], #-0
    87e8:	000081f8 	strdeq	r8, [r0], -r8	; <UNPREDICTABLE>
    87ec:	87c80408 	strbhi	r0, [r8, r8, lsl #8]
    87f0:	57150000 	ldrpl	r0, [r5, -r0]
    87f4:	0b000000 	bleq	87fc <.debug_info+0x87fc>
    87f8:	0d000088 	stceq	0, cr0, [r0, #-544]	; 0xfffffde0
    87fc:	000060f2 	strdeq	r6, [r0], -r2
    8800:	0004ab0d 	andeq	sl, r4, sp, lsl #22
    8804:	00570d00 	subseq	r0, r7, r0, lsl #26
    8808:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    880c:	0087f204 	addeq	pc, r7, r4, lsl #4
    8810:	00571500 	subseq	r1, r7, r0, lsl #10
    8814:	88390000 	ldmdahi	r9!, {}	; <UNPREDICTABLE>
    8818:	f20d0000 	vhadd.s8	d0, d13, d0
    881c:	0d000060 	stceq	0, cr0, [r0, #-384]	; 0xfffffe80
    8820:	00005e7c 	andeq	r5, r0, ip, ror lr
    8824:	0023cc0d 	eoreq	ip, r3, sp, lsl #24
    8828:	00690d00 	rsbeq	r0, r9, r0, lsl #26
    882c:	da0d0000 	ble	348834 <unflatten_and_copy_device_tree+0x3479c0>
    8830:	0d000001 	stceq	0, cr0, [r0, #-4]
    8834:	00001abb 			; <UNDEFINED> instruction: 0x00001abb
    8838:	11040800 	tstne	r4, r0, lsl #16
    883c:	15000088 	strne	r0, [r0, #-136]	; 0xffffff78
    8840:	00000057 	andeq	r0, r0, r7, asr r0
    8844:	00008858 	andeq	r8, r0, r8, asr r8
    8848:	0060f20d 	rsbeq	pc, r0, sp, lsl #4
    884c:	773f0d00 	ldrvc	r0, [pc, -r0, lsl #26]!
    8850:	570d0000 	strpl	r0, [sp, -r0]
    8854:	00000000 	andeq	r0, r0, r0
    8858:	883f0408 	ldmdahi	pc!, {r3, sl}	; <UNPREDICTABLE>
    885c:	f2150000 	vhadd.s16	d0, d5, d0
    8860:	6d000060 	stcvs	0, cr0, [r0, #-384]	; 0xfffffe80
    8864:	0d000088 	stceq	0, cr0, [r0, #-544]	; 0xfffffde0
    8868:	0000647b 	andeq	r6, r0, fp, ror r4
    886c:	5e040800 	cdppl	8, 0, cr0, cr4, cr0, {0}
    8870:	0c000088 	stceq	0, cr0, [r0], {136}	; 0x88
    8874:	0000887e 	andeq	r8, r0, lr, ror r8
    8878:	0060f20d 	rsbeq	pc, r0, sp, lsl #4
    887c:	04080000 	streq	r0, [r8], #-0
    8880:	00008873 	andeq	r8, r0, r3, ror r8
    8884:	0088940c 	addeq	r9, r8, ip, lsl #8
    8888:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    888c:	570d0000 	strpl	r0, [sp, -r0]
    8890:	00000000 	andeq	r0, r0, r0
    8894:	88840408 	stmhi	r4, {r3, sl}
    8898:	57150000 	ldrpl	r0, [r5, -r0]
    889c:	ae000000 	cdpge	0, 0, cr0, cr0, cr0, {0}
    88a0:	0d000088 	stceq	0, cr0, [r0, #-544]	; 0xfffffde0
    88a4:	000060f2 	strdeq	r6, [r0], -r2
    88a8:	00740e0d 	rsbseq	r0, r4, sp, lsl #28
    88ac:	04080000 	streq	r0, [r8], #-0
    88b0:	0000889a 	muleq	r0, sl, r8
    88b4:	00005715 	andeq	r5, r0, r5, lsl r7
    88b8:	0088c300 	addeq	ip, r8, r0, lsl #6
    88bc:	60f20d00 	rscsvs	r0, r2, r0, lsl #26
    88c0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    88c4:	0088b404 	addeq	fp, r8, r4, lsl #8
    88c8:	88d40c00 	ldmhi	r4, {sl, fp}^
    88cc:	7b0d0000 	blvc	3488d4 <unflatten_and_copy_device_tree+0x347a60>
    88d0:	00000064 	andeq	r0, r0, r4, rrx
    88d4:	88c90408 	stmiahi	r9, {r3, sl}^
    88d8:	57150000 	ldrpl	r0, [r5, -r0]
    88dc:	e9000000 	stmdb	r0, {}	; <UNPREDICTABLE>
    88e0:	0d000088 	stceq	0, cr0, [r0, #-544]	; 0xfffffde0
    88e4:	0000647b 	andeq	r6, r0, fp, ror r4
    88e8:	da040800 	ble	10a8f0 <unflatten_and_copy_device_tree+0x109a7c>
    88ec:	15000088 	strne	r0, [r0, #-136]	; 0xffffff78
    88f0:	00000057 	andeq	r0, r0, r7, asr r0
    88f4:	00008903 	andeq	r8, r0, r3, lsl #18
    88f8:	005e7c0d 	subseq	r7, lr, sp, lsl #24
    88fc:	89030d00 	stmdbhi	r3, {r8, sl, fp}
    8900:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8904:	00890904 	addeq	r0, r9, r4, lsl #18
    8908:	441f1600 	ldrmi	r1, [pc], #-1536	; 8 <.debug_info+0x8>
    890c:	04080000 	streq	r0, [r8], #-0
    8910:	000088ef 	andeq	r8, r0, pc, ror #17
    8914:	00005715 	andeq	r5, r0, r5, lsl r7
    8918:	00892d00 	addeq	r2, r9, r0, lsl #26
    891c:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    8920:	bb0d0000 	bllt	348928 <unflatten_and_copy_device_tree+0x347ab4>
    8924:	0d00001a 	stceq	0, cr0, [r0, #-104]	; 0xffffff98
    8928:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    892c:	14040800 	strne	r0, [r4], #-2048	; 0xfffff800
    8930:	15000089 	strne	r0, [r0, #-137]	; 0xffffff77
    8934:	00000057 	andeq	r0, r0, r7, asr r0
    8938:	00008947 	andeq	r8, r0, r7, asr #18
    893c:	003f060d 	eorseq	r0, pc, sp, lsl #12
    8940:	5e7c0d00 	cdppl	13, 7, cr0, cr12, cr0, {0}
    8944:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8948:	00893304 	addeq	r3, r9, r4, lsl #6
    894c:	00571500 	subseq	r1, r7, r0, lsl #10
    8950:	89660000 	stmdbhi	r6!, {}^	; <UNPREDICTABLE>
    8954:	7b0d0000 	blvc	34895c <unflatten_and_copy_device_tree+0x347ae8>
    8958:	0d000064 	stceq	0, cr0, [r0, #-400]	; 0xfffffe70
    895c:	00000564 	andeq	r0, r0, r4, ror #10
    8960:	00027b0d 	andeq	r7, r2, sp, lsl #22
    8964:	04080000 	streq	r0, [r8], #-0
    8968:	0000894d 	andeq	r8, r0, sp, asr #18
    896c:	00013315 	andeq	r3, r1, r5, lsl r3
    8970:	00898000 	addeq	r8, r9, r0
    8974:	647b0d00 	ldrbtvs	r0, [fp], #-3328	; 0xfffff300
    8978:	850d0000 	strhi	r0, [sp, #-0]
    897c:	00000026 	andeq	r0, r0, r6, lsr #32
    8980:	896c0408 	stmdbhi	ip!, {r3, sl}^
    8984:	7c150000 	ldcvc	0, cr0, [r5], {-0}
    8988:	a400005e 	strge	r0, [r0], #-94	; 0xffffffa2
    898c:	0d000089 	stceq	0, cr0, [r0, #-548]	; 0xfffffddc
    8990:	00008064 	andeq	r8, r0, r4, rrx
    8994:	0000570d 	andeq	r5, r0, sp, lsl #14
    8998:	00f20d00 	rscseq	r0, r2, r0, lsl #26
    899c:	780d0000 	stmdavc	sp, {}	; <UNPREDICTABLE>
    89a0:	00000003 	andeq	r0, r0, r3
    89a4:	89860408 	stmibhi	r6, {r3, sl}
    89a8:	ab060000 	blge	1889b0 <unflatten_and_copy_device_tree+0x187b3c>
    89ac:	ba000010 	blt	89f4 <.debug_info+0x89f4>
    89b0:	07000089 	streq	r0, [r0, -r9, lsl #1]
    89b4:	000000eb 	andeq	r0, r0, fp, ror #1
    89b8:	27100002 	ldrcs	r0, [r0, -r2]
    89bc:	1000001e 	andne	r0, r0, lr, lsl r0
    89c0:	89f7244b 	ldmibhi	r7!, {r0, r1, r3, r6, sl, sp}^
    89c4:	d40f0000 	strle	r0, [pc], #-0	; 8 <.debug_info+0x8>
    89c8:	4b000048 	blmi	8af0 <.debug_info+0x8af0>
    89cc:	003fc225 	eorseq	ip, pc, r5, lsr #4
    89d0:	400f0000 	andmi	r0, pc, r0
    89d4:	4b000007 	blmi	89f8 <.debug_info+0x89f8>
    89d8:	003ff726 	eorseq	pc, pc, r6, lsr #14
    89dc:	220f0400 	andcs	r0, pc, #0, 8
    89e0:	4b000022 	blmi	8a70 <.debug_info+0x8a70>
    89e4:	003fe127 	eorseq	lr, pc, r7, lsr #2
    89e8:	210f0800 	tstcs	pc, r0, lsl #16
    89ec:	4b000031 	blmi	8ab8 <.debug_info+0x8ab8>
    89f0:	003fa828 	eorseq	sl, pc, r8, lsr #16
    89f4:	08000c00 	stmdaeq	r0, {sl, fp}
    89f8:	0089fd04 	addeq	pc, r9, r4, lsl #26
    89fc:	89ba0900 	ldmibhi	sl!, {r8, fp}
    8a00:	2f160000 	svccs	0x00160000
    8a04:	0800004f 	stmdaeq	r0, {r0, r1, r2, r3, r6}
    8a08:	008a0204 	addeq	r0, sl, r4, lsl #4
    8a0c:	69042b00 	stmdbvs	r4, {r8, r9, fp, sp}
    8a10:	66000000 	strvs	r0, [r0], -r0
    8a14:	8a5d0199 	bhi	1749080 <unflatten_and_copy_device_tree+0x174820c>
    8a18:	7f0b0000 	svcvc	0x000b0000
    8a1c:	0000001b 	andeq	r0, r0, fp, lsl r0
    8a20:	0030790b 	eorseq	r7, r0, fp, lsl #18
    8a24:	c20b0100 	andgt	r0, fp, #0, 2
    8a28:	02000031 	andeq	r0, r0, #49	; 0x31
    8a2c:	004e450b 	subeq	r4, lr, fp, lsl #10
    8a30:	0e0b0300 	cdpeq	3, 0, cr0, cr11, cr0, {0}
    8a34:	04000007 	streq	r0, [r0], #-7
    8a38:	000c390b 	andeq	r3, ip, fp, lsl #18
    8a3c:	c20b0500 	andgt	r0, fp, #0, 10
    8a40:	06000021 	streq	r0, [r0], -r1, lsr #32
    8a44:	0029f50b 	eoreq	pc, r9, fp, lsl #10
    8a48:	a70b0700 	strge	r0, [fp, -r0, lsl #14]
    8a4c:	0800003b 	stmdaeq	r0, {r0, r1, r3, r4, r5}
    8a50:	0063a10b 	rsbeq	sl, r3, fp, lsl #2
    8a54:	be0b0900 	cdplt	9, 0, cr0, cr11, cr0, {0}
    8a58:	0a00004d 	beq	8b94 <.debug_info+0x8b94>
    8a5c:	0c940300 	ldceq	3, cr0, [r4], {0}
    8a60:	06670000 	strbteq	r0, [r7], -r0
    8a64:	0000002c 	andeq	r0, r0, ip, lsr #32
    8a68:	0052d003 	subseq	sp, r2, r3
    8a6c:	69076700 	stmdbvs	r7, {r8, r9, sl, sp, lr}
    8a70:	03000000 	movweq	r0, #0
    8a74:	00004764 	andeq	r4, r0, r4, ror #14
    8a78:	00690867 	rsbeq	r0, r9, r7, ror #16
    8a7c:	5d060000 	stcpl	0, cr0, [r6, #-0]
    8a80:	8e00008a 	cdphi	0, 0, cr0, cr0, cr10, {4}
    8a84:	0700008a 	streq	r0, [r0, -sl, lsl #1]
    8a88:	000000eb 	andeq	r0, r0, fp, ror #1
    8a8c:	98100012 	ldmdals	r0, {r1, r4}
    8a90:	2c000018 	stccs	0, cr0, [r0], {24}
    8a94:	8afb1f67 	bhi	ffed0838 <__crc_of_fdt_unflatten_tree+0x7918f27b>
    8a98:	430f0000 	movwmi	r0, #61440	; 0xf000
    8a9c:	6700003a 	smladxvs	r0, sl, r0, r0
    8aa0:	008a7320 	addeq	r7, sl, r0, lsr #6
    8aa4:	bc0f0000 	stclt	0, cr0, [pc], {-0}
    8aa8:	6700001c 	smladvs	r0, ip, r0, r0
    8aac:	008a7321 	addeq	r7, sl, r1, lsr #6
    8ab0:	010f0400 	tsteq	pc, r0, lsl #8
    8ab4:	67000025 	strvs	r0, [r0, -r5, lsr #32]
    8ab8:	008a7322 	addeq	r7, sl, r2, lsr #6
    8abc:	790f0800 	stmdbvc	pc, {fp}	; <UNPREDICTABLE>
    8ac0:	67000003 	strvs	r0, [r0, -r3]
    8ac4:	008a7323 	addeq	r7, sl, r3, lsr #6
    8ac8:	3d0f0c00 	stccc	12, cr0, [pc, #-0]	; 8 <.debug_info+0x8>
    8acc:	67000058 	smlsdvs	r0, r8, r0, r0
    8ad0:	008a5d24 	addeq	r5, sl, r4, lsr #26
    8ad4:	b20f1000 	andlt	r1, pc, #0
    8ad8:	6700004f 	strvs	r0, [r0, -pc, asr #32]
    8adc:	008a7e25 	addeq	r7, sl, r5, lsr #28
    8ae0:	700f1100 	andvc	r1, pc, r0, lsl #2
    8ae4:	6700000b 	strvs	r0, [r0, -fp]
    8ae8:	008a6826 	addeq	r6, sl, r6, lsr #16
    8aec:	770f2400 	strvc	r2, [pc, -r0, lsl #8]
    8af0:	67000064 	strvs	r0, [r0, -r4, rrx]
    8af4:	008a6827 	addeq	r6, sl, r7, lsr #16
    8af8:	10002800 	andne	r2, r0, r0, lsl #16
    8afc:	000044a0 	andeq	r4, r0, r0, lsr #9
    8b00:	380e6808 	stmdacc	lr, {r3, fp, sp, lr}
    8b04:	0f00008b 	svceq	0x0000008b
    8b08:	000008e9 	andeq	r0, r0, r9, ror #17
    8b0c:	00450f68 	subeq	r0, r5, r8, ror #30
    8b10:	0f000000 	svceq	0x00000000
    8b14:	0000419f 	muleq	r0, pc, r1	; <UNPREDICTABLE>
    8b18:	00451068 	subeq	r1, r5, r8, rrx
    8b1c:	0f020000 	svceq	0x00020000
    8b20:	0000383d 	andeq	r3, r0, sp, lsr r8
    8b24:	00451168 	subeq	r1, r5, r8, ror #2
    8b28:	0f040000 	svceq	0x00040000
    8b2c:	00005935 	andeq	r5, r0, r5, lsr r9
    8b30:	00451268 	subeq	r1, r5, r8, ror #4
    8b34:	00060000 	andeq	r0, r6, r0
    8b38:	005a7210 	subseq	r7, sl, r0, lsl r2
    8b3c:	09691000 	stmdbeq	r9!, {ip}^
    8b40:	00008b75 	andeq	r8, r0, r5, ror fp
    8b44:	00403c0f 	subeq	r3, r0, pc, lsl #24
    8b48:	3a0b6900 	bcc	2e2f50 <unflatten_and_copy_device_tree+0x2e20dc>
    8b4c:	00000000 	andeq	r0, r0, r0
    8b50:	0058010f 	subseq	r0, r8, pc, lsl #2
    8b54:	3a0c6900 	bcc	322f5c <unflatten_and_copy_device_tree+0x3220e8>
    8b58:	02000000 	andeq	r0, r0, #0
    8b5c:	0010c30f 	andseq	ip, r0, pc, lsl #6
    8b60:	750d6900 	strvc	r6, [sp, #-2304]	; 0xfffff700
    8b64:	0400008b 	streq	r0, [r0], #-139	; 0xffffff75
    8b68:	00210e0f 	eoreq	r0, r1, pc, lsl #28
    8b6c:	3a0e6900 	bcc	3a2f74 <unflatten_and_copy_device_tree+0x3a2100>
    8b70:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    8b74:	003a0600 	eorseq	r0, sl, r0, lsl #12
    8b78:	8b850000 	blhi	fe148b80 <__crc_of_fdt_unflatten_tree+0x774075c3>
    8b7c:	eb070000 	bl	1c8b84 <unflatten_and_copy_device_tree+0x1c7d10>
    8b80:	04000000 	streq	r0, [r0], #-0
    8b84:	24c41000 	strbcs	r1, [r4], #0
    8b88:	6a7c0000 	bvs	1f08b90 <unflatten_and_copy_device_tree+0x1f07d1c>
    8b8c:	008d22fb 	strdeq	r2, [sp], fp
    8b90:	2b8c0f00 	blcs	fe303c08 <__crc_of_fdt_unflatten_tree+0x775c264b>
    8b94:	fc6a0000 	stc2l	0, cr0, [sl], #-0
    8b98:	00008e6d 	andeq	r8, r0, sp, ror #28
    8b9c:	287f0f00 	ldmdacs	pc!, {r8, r9, sl, fp}^	; <UNPREDICTABLE>
    8ba0:	fe6a0000 	cdp2	0, 6, cr0, cr10, cr0, {0}
    8ba4:	00008e87 	andeq	r8, r0, r7, lsl #29
    8ba8:	08c70f04 	stmiaeq	r7, {r2, r8, r9, sl, fp}^
    8bac:	ff6a0000 			; <UNDEFINED> instruction: 0xff6a0000
    8bb0:	00008e9d 	muleq	r0, sp, lr
    8bb4:	5e2a1b08 	vmulpl.f64	d1, d10, d8
    8bb8:	006a0000 	rsbeq	r0, sl, r0
    8bbc:	008eb701 	addeq	fp, lr, r1, lsl #14
    8bc0:	831b0c00 	tsthi	fp, #0, 24
    8bc4:	6a000012 	bvs	8c14 <.debug_info+0x8c14>
    8bc8:	8ecd0101 	polhie	f0, f5, f1
    8bcc:	1b100000 	blne	408bd4 <unflatten_and_copy_device_tree+0x407d60>
    8bd0:	000042fe 	strdeq	r4, [r0], -lr
    8bd4:	de01026a 	cdple	2, 0, cr0, cr1, cr10, {3}
    8bd8:	1400008e 	strne	r0, [r0], #-142	; 0xffffff72
    8bdc:	00468d1b 	subeq	r8, r6, fp, lsl sp
    8be0:	01036a00 	tsteq	r3, r0, lsl #20
    8be4:	00008ede 	ldrdeq	r8, [r0], -lr
    8be8:	1d131b18 	vldrne	d1, [r3, #-96]	; 0xffffffa0
    8bec:	046a0000 	strbteq	r0, [sl], #-0
    8bf0:	008efd01 	addeq	pc, lr, r1, lsl #26
    8bf4:	8b1b1c00 	blhi	6c7008 <unflatten_and_copy_device_tree+0x6c6194>
    8bf8:	6a00002a 	bvs	8ca8 <.debug_info+0x8ca8>
    8bfc:	8f170106 	svchi	0x00170106
    8c00:	1b200000 	blne	808c08 <unflatten_and_copy_device_tree+0x807d94>
    8c04:	000061f4 	strdeq	r6, [r0], -r4
    8c08:	de01076a 	cdple	7, 0, cr0, cr1, cr10, {3}
    8c0c:	2400008e 	strcs	r0, [r0], #-142	; 0xffffff72
    8c10:	0050db1b 	subseq	sp, r0, fp, lsl fp
    8c14:	01086a00 	tsteq	r8, r0, lsl #20
    8c18:	00008f2c 	andeq	r8, r0, ip, lsr #30
    8c1c:	5bbe1b28 	blpl	fef86ca8 <__crc_of_fdt_unflatten_tree+0x782456eb>
    8c20:	096a0000 	stmdbeq	sl!, {}^	; <UNPREDICTABLE>
    8c24:	008f2c01 	addeq	r2, pc, r1, lsl #24
    8c28:	5e1b2c00 	cdppl	12, 1, cr2, cr11, cr0, {0}
    8c2c:	6a000047 	bvs	8d50 <.debug_info+0x8d50>
    8c30:	8f4b010a 	svchi	0x004b010a
    8c34:	1b300000 	blne	c08c3c <unflatten_and_copy_device_tree+0xc07dc8>
    8c38:	00004288 	andeq	r4, r0, r8, lsl #5
    8c3c:	6a010c6a 	bvs	4bdec <unflatten_and_copy_device_tree+0x4af78>
    8c40:	3400008f 	strcc	r0, [r0], #-143	; 0xffffff71
    8c44:	0024dd1b 	eoreq	sp, r4, fp, lsl sp
    8c48:	010e6a00 	tsteq	lr, r0, lsl #20
    8c4c:	00008f86 	andeq	r8, r0, r6, lsl #31
    8c50:	53141b38 	tstpl	r4, #56, 22	; 0xe000
    8c54:	0f6a0000 	svceq	0x006a0000
    8c58:	008ede01 	addeq	sp, lr, r1, lsl #28
    8c5c:	141b3c00 	ldrne	r3, [fp], #-3072	; 0xfffff400
    8c60:	6a00001e 	bvs	8ce0 <.debug_info+0x8ce0>
    8c64:	8ede0110 	mrchi	1, 6, r0, cr14, cr0, {0}
    8c68:	1b400000 	blne	1008c70 <unflatten_and_copy_device_tree+0x1007dfc>
    8c6c:	00000740 	andeq	r0, r0, r0, asr #14
    8c70:	de01116a 	adflesz	f1, f1, #2.0
    8c74:	4400008e 	strmi	r0, [r0], #-142	; 0xffffff72
    8c78:	0048d41b 	subeq	sp, r8, fp, lsl r4
    8c7c:	01126a00 	tsteq	r2, r0, lsl #20
    8c80:	00008ede 	ldrdeq	r8, [r0], -lr
    8c84:	0c641b48 	stcleq	11, cr1, [r4], #-288	; 0xfffffee0
    8c88:	136a0000 	cmnne	sl, #0
    8c8c:	008ede01 	addeq	sp, lr, r1, lsl #28
    8c90:	541b4c00 	ldrpl	r4, [fp], #-3072	; 0xfffff400
    8c94:	6a000047 	bvs	8db8 <.debug_info+0x8db8>
    8c98:	8fa00114 	svchi	0x00a00114
    8c9c:	1b500000 	blne	1408ca4 <unflatten_and_copy_device_tree+0x1407e30>
    8ca0:	000042f1 	strdeq	r4, [r0], -r1
    8ca4:	de01156a 	cfsh32le	mvfx1, mvfx1, #58
    8ca8:	5400008e 	strpl	r0, [r0], #-142	; 0xffffff72
    8cac:	0010561b 	andseq	r5, r0, fp, lsl r6
    8cb0:	01166a00 	tsteq	r6, r0, lsl #20
    8cb4:	00008ede 	ldrdeq	r8, [r0], -lr
    8cb8:	21161b58 	tstcs	r6, r8, asr fp
    8cbc:	176a0000 	strbne	r0, [sl, -r0]!
    8cc0:	008fb601 	addeq	fp, pc, r1, lsl #12
    8cc4:	291b5c00 	ldmdbcs	fp, {sl, fp, ip, lr}
    8cc8:	6a000020 	bvs	8d50 <.debug_info+0x8d50>
    8ccc:	8fcc0118 	svchi	0x00cc0118
    8cd0:	1b600000 	blne	1808cd8 <unflatten_and_copy_device_tree+0x1807e64>
    8cd4:	00001cb3 			; <UNDEFINED> instruction: 0x00001cb3
    8cd8:	2c01196a 	stccs	9, cr1, [r1], {106}	; 0x6a
    8cdc:	6400008f 	strvs	r0, [r0], #-143	; 0xffffff71
    8ce0:	0057bb1b 	subseq	fp, r7, fp, lsl fp
    8ce4:	011a6a00 	tsteq	sl, r0, lsl #20
    8ce8:	00008feb 	andeq	r8, r0, fp, ror #31
    8cec:	3c981b68 	vldmiacc	r8, {d1-<overflow reg d52>}
    8cf0:	1c6a0000 	stclne	0, cr0, [sl], #-0
    8cf4:	00900b01 	addseq	r0, r0, r1, lsl #22
    8cf8:	f11b6c00 			; <UNDEFINED> instruction: 0xf11b6c00
    8cfc:	6a000020 	bvs	8d84 <.debug_info+0x8d84>
    8d00:	902b011d 	eorls	r0, fp, sp, lsl r1
    8d04:	1b700000 	blne	1c08d0c <unflatten_and_copy_device_tree+0x1c07e98>
    8d08:	000045fb 	strdeq	r4, [r0], -fp
    8d0c:	e6011e6a 	str	r1, [r1], -sl, ror #28
    8d10:	74000090 	strvc	r0, [r0], #-144	; 0xffffff70
    8d14:	005b871b 	subseq	r8, fp, fp, lsl r7
    8d18:	01256a00 			; <UNDEFINED> instruction: 0x01256a00
    8d1c:	00007a28 	andeq	r7, r0, r8, lsr #20
    8d20:	2f150078 	svccs	0x00150078
    8d24:	3b000049 	blcc	8e50 <.debug_info+0x8e50>
    8d28:	0d00008d 	stceq	0, cr0, [r0, #-564]	; 0xfffffdcc
    8d2c:	00008d3b 	andeq	r8, r0, fp, lsr sp
    8d30:	0060f20d 	rsbeq	pc, r0, sp, lsl #4
    8d34:	00570d00 	subseq	r0, r7, r0, lsl #26
    8d38:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8d3c:	008d4104 	addeq	r4, sp, r4, lsl #2
    8d40:	54771a00 	ldrbtpl	r1, [r7], #-2560	; 0xfffff600
    8d44:	6a800000 	bvs	fe008d4c <__crc_of_fdt_unflatten_tree+0x772c778f>
    8d48:	8e6d0128 	powhiep	f0, f5, #0.0
    8d4c:	e81b0000 	ldmda	fp, {}	; <UNPREDICTABLE>
    8d50:	6a000022 	bvs	8de0 <.debug_info+0x8de0>
    8d54:	00570129 	subseq	r0, r7, r9, lsr #2
    8d58:	1b000000 	blne	8d60 <.debug_info+0x8d60>
    8d5c:	00000e25 	andeq	r0, r0, r5, lsr #28
    8d60:	00012a6a 	andeq	r2, r1, sl, ror #20
    8d64:	04000058 	streq	r0, [r0], #-88	; 0xffffffa8
    8d68:	0030161b 	eorseq	r1, r0, fp, lsl r6
    8d6c:	012b6a00 			; <UNDEFINED> instruction: 0x012b6a00
    8d70:	000090ec 	andeq	r9, r0, ip, ror #1
    8d74:	1c271b08 	stcne	11, cr1, [r7], #-32	; 0xffffffe0
    8d78:	2c6a0000 	stclcs	0, cr0, [sl], #-0
    8d7c:	00724801 	rsbseq	r4, r2, r1, lsl #16
    8d80:	031b0c00 	tsteq	fp, #0, 24
    8d84:	6a000051 	bvs	8ed0 <.debug_info+0x8ed0>
    8d88:	00f2012d 	rscseq	r0, r2, sp, lsr #2
    8d8c:	1b100000 	blne	408d94 <unflatten_and_copy_device_tree+0x407f20>
    8d90:	0000059b 	muleq	r0, fp, r5
    8d94:	f2012e6a 	vceq.f32	q1, <illegal reg q0.5>, q13
    8d98:	14000000 	strne	r0, [r0], #-0
    8d9c:	00466e1b 	subeq	r6, r6, fp, lsl lr
    8da0:	012f6a00 			; <UNDEFINED> instruction: 0x012f6a00
    8da4:	00000057 	andeq	r0, r0, r7, asr r0
    8da8:	04b41b18 	ldrteq	r1, [r4], #2840	; 0xb18
    8dac:	306a0000 	rsbcc	r0, sl, r0
    8db0:	00005701 	andeq	r5, r0, r1, lsl #14
    8db4:	181b1c00 	ldmdane	fp, {sl, fp, ip}
    8db8:	6a000048 	bvs	8ee0 <.debug_info+0x8ee0>
    8dbc:	00570131 	subseq	r0, r7, r1, lsr r1
    8dc0:	1d200000 	stcne	0, cr0, [r0, #-0]
    8dc4:	006d756e 	rsbeq	r7, sp, lr, ror #10
    8dc8:	6901326a 	stmdbvs	r1, {r1, r3, r5, r6, r9, ip, sp}
    8dcc:	24000000 	strcs	r0, [r0], #-0
    8dd0:	00357e1b 	eorseq	r7, r5, fp, lsl lr
    8dd4:	01336a00 	teqeq	r3, r0, lsl #20
    8dd8:	00000033 	andeq	r0, r0, r3, lsr r0
    8ddc:	1f411b28 	svcne	0x00411b28
    8de0:	346a0000 	strbtcc	r0, [sl], #-0
    8de4:	00003301 	andeq	r3, r0, r1, lsl #6
    8de8:	be1b2a00 	vnmlslt.f32	s4, s22, s0
    8dec:	6a000001 	bvs	8df8 <.debug_info+0x8df8>
    8df0:	8a8e0135 	bhi	fe3892cc <__crc_of_fdt_unflatten_tree+0x77647d0f>
    8df4:	1b2c0000 	blne	b08dfc <unflatten_and_copy_device_tree+0xb07f88>
    8df8:	0000596a 	andeq	r5, r0, sl, ror #18
    8dfc:	d401366a 	strle	r3, [r1], #-1642	; 0xfffff996
    8e00:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
    8e04:	0053431b 	subseq	r4, r3, fp, lsl r3
    8e08:	01376a00 	teqeq	r7, r0, lsl #20
    8e0c:	00008a07 	andeq	r8, r0, r7, lsl #20
    8e10:	556a1b5c 	strbpl	r1, [sl, #-2908]!	; 0xfffff4a4
    8e14:	386a0000 	stmdacc	sl!, {}^	; <UNPREDICTABLE>
    8e18:	008d3b01 	addeq	r3, sp, r1, lsl #22
    8e1c:	271b6000 	ldrcs	r6, [fp, -r0]
    8e20:	6a000059 	bvs	8f8c <.debug_info+0x8f8c>
    8e24:	90f2013d 	rscsls	r0, r2, sp, lsr r1
    8e28:	1b640000 	blne	1908e30 <unflatten_and_copy_device_tree+0x1907fbc>
    8e2c:	000064db 	ldrdeq	r6, [r0], -fp
    8e30:	ef013e6a 	svc	0x00013e6a
    8e34:	68000091 	stmdavs	r0, {r0, r4, r7}
    8e38:	005a6a1b 	subseq	r6, sl, fp, lsl sl
    8e3c:	013f6a00 	teqeq	pc, r0, lsl #20
    8e40:	000091fb 	strdeq	r9, [r0], -fp
    8e44:	54171b6c 	ldrpl	r1, [r7], #-2924	; 0xfffff494
    8e48:	406a0000 	rsbmi	r0, sl, r0
    8e4c:	00037801 	andeq	r7, r3, r1, lsl #16
    8e50:	6f1d7000 	svcvs	0x001d7000
    8e54:	6a007370 	bvs	25c1c <unflatten_and_copy_device_tree+0x24da8>
    8e58:	92010146 	andls	r0, r1, #-2147483631	; 0x80000011
    8e5c:	1b740000 	blne	1d08e64 <unflatten_and_copy_device_tree+0x1d07ff0>
    8e60:	0000219c 	muleq	r0, ip, r1
    8e64:	c701476a 	strgt	r4, [r1, -sl, ror #14]
    8e68:	78000002 	stmdavc	r0, {r1}
    8e6c:	22040800 	andcs	r0, r4, #0, 16
    8e70:	1500008d 	strne	r0, [r0, #-141]	; 0xffffff73
    8e74:	00000057 	andeq	r0, r0, r7, asr r0
    8e78:	00008e87 	andeq	r8, r0, r7, lsl #29
    8e7c:	008d3b0d 	addeq	r3, sp, sp, lsl #22
    8e80:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    8e84:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8e88:	008e7304 	addeq	r7, lr, r4, lsl #6
    8e8c:	8e9d0c00 	cdphi	12, 9, cr0, cr13, cr0, {0}
    8e90:	3b0d0000 	blcc	348e98 <unflatten_and_copy_device_tree+0x348024>
    8e94:	0d00008d 	stceq	0, cr0, [r0, #-564]	; 0xfffffdcc
    8e98:	0000492f 	andeq	r4, r0, pc, lsr #18
    8e9c:	8d040800 	stchi	8, cr0, [r4, #-0]
    8ea0:	1500008e 	strne	r0, [r0, #-142]	; 0xffffff72
    8ea4:	00000057 	andeq	r0, r0, r7, asr r0
    8ea8:	00008eb7 			; <UNDEFINED> instruction: 0x00008eb7
    8eac:	00492f0d 	subeq	r2, r9, sp, lsl #30
    8eb0:	23cc0d00 	biccs	r0, ip, #0, 26
    8eb4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8eb8:	008ea304 	addeq	sl, lr, r4, lsl #6
    8ebc:	8ecd0c00 	cdphi	12, 12, cr0, cr13, cr0, {0}
    8ec0:	2f0d0000 	svccs	0x000d0000
    8ec4:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    8ec8:	000023cc 	andeq	r2, r0, ip, asr #7
    8ecc:	bd040800 	stclt	8, cr0, [r4, #-0]
    8ed0:	0c00008e 	stceq	0, cr0, [r0], {142}	; 0x8e
    8ed4:	00008ede 	ldrdeq	r8, [r0], -lr
    8ed8:	00492f0d 	subeq	r2, r9, sp, lsl #30
    8edc:	04080000 	streq	r0, [r8], #-0
    8ee0:	00008ed3 	ldrdeq	r8, [r0], -r3
    8ee4:	00005715 	andeq	r5, r0, r5, lsl r7
    8ee8:	008efd00 	addeq	pc, lr, r0, lsl #26
    8eec:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    8ef0:	850d0000 	strhi	r0, [sp, #-0]
    8ef4:	0d00005d 	stceq	0, cr0, [r0, #-372]	; 0xfffffe8c
    8ef8:	00000057 	andeq	r0, r0, r7, asr r0
    8efc:	e4040800 	str	r0, [r4], #-2048	; 0xfffff800
    8f00:	1500008e 	strne	r0, [r0, #-142]	; 0xffffff72
    8f04:	00000057 	andeq	r0, r0, r7, asr r0
    8f08:	00008f17 	andeq	r8, r0, r7, lsl pc
    8f0c:	00492f0d 	subeq	r2, r9, sp, lsl #30
    8f10:	002c0d00 	eoreq	r0, ip, r0, lsl #26
    8f14:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8f18:	008f0304 	addeq	r0, pc, r4, lsl #6
    8f1c:	00571500 	subseq	r1, r7, r0, lsl #10
    8f20:	8f2c0000 	svchi	0x002c0000
    8f24:	2f0d0000 	svccs	0x000d0000
    8f28:	00000049 	andeq	r0, r0, r9, asr #32
    8f2c:	8f1d0408 	svchi	0x001d0408
    8f30:	57150000 	ldrpl	r0, [r5, -r0]
    8f34:	4b000000 	blmi	8f3c <.debug_info+0x8f3c>
    8f38:	0d00008f 	stceq	0, cr0, [r0, #-572]	; 0xfffffdc4
    8f3c:	0000492f 	andeq	r4, r0, pc, lsr #18
    8f40:	0000690d 	andeq	r6, r0, sp, lsl #18
    8f44:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    8f48:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8f4c:	008f3204 	addeq	r3, pc, r4, lsl #4
    8f50:	01331500 	teqeq	r3, r0, lsl #10
    8f54:	8f6a0000 	svchi	0x006a0000
    8f58:	2f0d0000 	svccs	0x000d0000
    8f5c:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    8f60:	00000069 	andeq	r0, r0, r9, rrx
    8f64:	0000d40d 	andeq	sp, r0, sp, lsl #8
    8f68:	04080000 	streq	r0, [r8], #-0
    8f6c:	00008f51 	andeq	r8, r0, r1, asr pc
    8f70:	008f800c 	addeq	r8, pc, ip
    8f74:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    8f78:	800d0000 	andhi	r0, sp, r0
    8f7c:	0000008f 	andeq	r0, r0, pc, lsl #1
    8f80:	8a8e0408 	bhi	fe389fa8 <__crc_of_fdt_unflatten_tree+0x776489eb>
    8f84:	04080000 	streq	r0, [r8], #-0
    8f88:	00008f70 	andeq	r8, r0, r0, ror pc
    8f8c:	00005715 	andeq	r5, r0, r5, lsl r7
    8f90:	008fa000 	addeq	sl, pc, r0
    8f94:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    8f98:	570d0000 	strpl	r0, [sp, -r0]
    8f9c:	00000000 	andeq	r0, r0, r0
    8fa0:	8f8c0408 	svchi	0x008c0408
    8fa4:	b60c0000 	strlt	r0, [ip], -r0
    8fa8:	0d00008f 	stceq	0, cr0, [r0, #-572]	; 0xfffffdc4
    8fac:	0000492f 	andeq	r4, r0, pc, lsr #18
    8fb0:	0000570d 	andeq	r5, r0, sp, lsl #14
    8fb4:	04080000 	streq	r0, [r8], #-0
    8fb8:	00008fa6 	andeq	r8, r0, r6, lsr #31
    8fbc:	008fcc0c 	addeq	ip, pc, ip, lsl #24
    8fc0:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    8fc4:	f80d0000 			; <UNDEFINED> instruction: 0xf80d0000
    8fc8:	00000000 	andeq	r0, r0, r0
    8fcc:	8fbc0408 	svchi	0x00bc0408
    8fd0:	57150000 	ldrpl	r0, [r5, -r0]
    8fd4:	eb000000 	bl	8fdc <.debug_info+0x8fdc>
    8fd8:	0d00008f 	stceq	0, cr0, [r0, #-572]	; 0xfffffdc4
    8fdc:	0000492f 	andeq	r4, r0, pc, lsr #18
    8fe0:	0000690d 	andeq	r6, r0, sp, lsl #18
    8fe4:	00690d00 	rsbeq	r0, r9, r0, lsl #26
    8fe8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8fec:	008fd204 	addeq	sp, pc, r4, lsl #4
    8ff0:	00571500 	subseq	r1, r7, r0, lsl #10
    8ff4:	90050000 	andls	r0, r5, r0
    8ff8:	2f0d0000 	svccs	0x000d0000
    8ffc:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    9000:	00009005 	andeq	r9, r0, r5
    9004:	fb040800 	blx	10b00e <unflatten_and_copy_device_tree+0x10a19a>
    9008:	0800008a 	stmdaeq	r0, {r1, r3, r7}
    900c:	008ff104 	addeq	pc, pc, r4, lsl #2
    9010:	00571500 	subseq	r1, r7, r0, lsl #10
    9014:	90250000 	eorls	r0, r5, r0
    9018:	2f0d0000 	svccs	0x000d0000
    901c:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    9020:	00009025 	andeq	r9, r0, r5, lsr #32
    9024:	38040800 	stmdacc	r4, {fp}
    9028:	0800008b 	stmdaeq	r0, {r0, r1, r3, r7}
    902c:	00901104 	addseq	r1, r0, r4, lsl #2
    9030:	00571500 	subseq	r1, r7, r0, lsl #10
    9034:	90450000 	subls	r0, r5, r0
    9038:	2f0d0000 	svccs	0x000d0000
    903c:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    9040:	00009045 	andeq	r9, r0, r5, asr #32
    9044:	4b040800 	blmi	10b04c <unflatten_and_copy_device_tree+0x10a1d8>
    9048:	10000090 	mulne	r0, r0, r0
    904c:	00004ad6 	ldrdeq	r4, [r0], -r6
    9050:	e6646b50 			; <UNDEFINED> instruction: 0xe6646b50
    9054:	14000090 	strne	r0, [r0], #-144	; 0xffffff70
    9058:	00737463 	rsbseq	r7, r3, r3, ror #8
    905c:	0057656b 	subseq	r6, r7, fp, ror #10
    9060:	14000000 	strne	r0, [r0], #-0
    9064:	00727364 	rsbseq	r7, r2, r4, ror #6
    9068:	0057656b 	subseq	r6, r7, fp, ror #10
    906c:	14040000 	strne	r0, [r4], #-0
    9070:	00676e72 	rsbeq	r6, r7, r2, ror lr
    9074:	0057656b 	subseq	r6, r7, fp, ror #10
    9078:	14080000 	strne	r0, [r8], #-0
    907c:	00646364 	rsbeq	r6, r4, r4, ror #6
    9080:	0057656b 	subseq	r6, r7, fp, ror #10
    9084:	140c0000 	strne	r0, [ip], #-0
    9088:	6b007872 	blvs	27258 <unflatten_and_copy_device_tree+0x263e4>
    908c:	00005766 	andeq	r5, r0, r6, ror #14
    9090:	74141000 	ldrvc	r1, [r4], #-0
    9094:	666b0078 			; <UNDEFINED> instruction: 0x666b0078
    9098:	00000057 	andeq	r0, r0, r7, asr r0
    909c:	5df00f14 	ldclpl	15, cr0, [r0, #80]!	; 0x50
    90a0:	676b0000 	strbvs	r0, [fp, -r0]!
    90a4:	00000057 	andeq	r0, r0, r7, asr r0
    90a8:	134d0f18 	movtne	r0, #57112	; 0xdf18
    90ac:	676b0000 	strbvs	r0, [fp, -r0]!
    90b0:	00000057 	andeq	r0, r0, r7, asr r0
    90b4:	25d00f1c 	ldrbcs	r0, [r0, #3868]	; 0xf1c
    90b8:	676b0000 	strbvs	r0, [fp, -r0]!
    90bc:	00000057 	andeq	r0, r0, r7, asr r0
    90c0:	72621420 	rsbvc	r1, r2, #32, 8	; 0x20000000
    90c4:	676b006b 	strbvs	r0, [fp, -fp, rrx]!
    90c8:	00000057 	andeq	r0, r0, r7, asr r0
    90cc:	1ec20f24 	cdpne	15, 12, cr0, cr2, cr4, {1}
    90d0:	686b0000 	stmdavs	fp!, {}^	; <UNPREDICTABLE>
    90d4:	00000057 	andeq	r0, r0, r7, asr r0
    90d8:	2bcc0f28 	blcs	ff303ca8 <__crc_of_fdt_unflatten_tree+0x785c26eb>
    90dc:	696b0000 	stmdbvs	fp!, {}^	; <UNPREDICTABLE>
    90e0:	00009671 	andeq	r9, r0, r1, ror r6
    90e4:	0408002c 	streq	r0, [r8], #-44	; 0xffffffd4
    90e8:	00009031 	andeq	r9, r0, r1, lsr r0
    90ec:	77340408 	ldrvc	r0, [r4, -r8, lsl #8]!
    90f0:	04080000 	streq	r0, [r8], #-0
    90f4:	0000492f 	andeq	r4, r0, pc, lsr #18
    90f8:	0031b910 	eorseq	fp, r1, r0, lsl r9
    90fc:	dd4cd400 	cfstrdle	mvd13, [ip, #-0]
    9100:	000091ef 	andeq	r9, r0, pc, ror #3
    9104:	66756214 			; <UNDEFINED> instruction: 0x66756214
    9108:	48de4c00 	ldmmi	lr, {sl, fp, lr}^
    910c:	00000095 	muleq	r0, r5, r0
    9110:	79747414 	ldmdbvc	r4!, {r2, r4, sl, ip, sp, lr}^
    9114:	2fdf4c00 	svccs	0x00df4c00
    9118:	58000049 	stmdapl	r0, {r0, r3, r6}
    911c:	005e9f0f 	subseq	r9, lr, pc, lsl #30
    9120:	2fe04c00 	svccs	0x00e04c00
    9124:	5c000049 	stcpl	0, cr0, [r0], {73}	; 0x49
    9128:	73706f14 	cmnvc	r0, #20, 30	; 0x50
    912c:	60e14c00 	rscvs	r4, r1, r0, lsl #24
    9130:	60000096 	mulvs	r0, r6, r0
    9134:	00155a0f 	andseq	r5, r5, pc, lsl #20
    9138:	ffe24c00 			; <UNDEFINED> instruction: 0xffe24c00
    913c:	64000010 	strvs	r0, [r0], #-16
    9140:	002b4a0f 	eoreq	r4, fp, pc, lsl #20
    9144:	57e34c00 	strbpl	r4, [r3, r0, lsl #24]!
    9148:	68000000 	stmdavs	r0, {}	; <UNPREDICTABLE>
    914c:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    9150:	57e44c00 	strbpl	r4, [r4, r0, lsl #24]!
    9154:	6c000000 	stcvs	0, cr0, [r0], {-0}
    9158:	0049ab0f 	subeq	sl, r9, pc, lsl #22
    915c:	ebe54c00 	bl	ff95c164 <__crc_of_fdt_unflatten_tree+0x78c1aba7>
    9160:	70000011 	andvc	r0, r0, r1, lsl r0
    9164:	0037770f 	eorseq	r7, r7, pc, lsl #14
    9168:	ebe64c00 	bl	ff99c170 <__crc_of_fdt_unflatten_tree+0x78c5abb3>
    916c:	7c000011 	stcvc	0, cr0, [r0], {17}
    9170:	00596a0f 	subseq	r6, r9, pc, lsl #20
    9174:	d4e74c00 	strbtle	r4, [r7], #3072	; 0xc00
    9178:	88000000 	stmdahi	r0, {}	; <UNPREDICTABLE>
    917c:	00292b29 	eoreq	r2, r9, r9, lsr #22
    9180:	2ce84c00 	stclcs	12, cr4, [r8]
    9184:	01000000 	mrseq	r0, (UNDEF: 0)
    9188:	298c0701 	stmibcs	ip, {r0, r8, r9, sl}
    918c:	00005be1 	andeq	r5, r0, r1, ror #23
    9190:	002ce94c 	eoreq	lr, ip, ip, asr #18
    9194:	01010000 	mrseq	r0, (UNDEF: 1)
    9198:	530f8c06 	movwpl	r8, #64518	; 0xfc06
    919c:	4c000054 	stcmi	0, cr0, [r0], {84}	; 0x54
    91a0:	001940ea 	andseq	r4, r9, sl, ror #1
    91a4:	980f9000 	stmdals	pc, {ip, pc}	; <UNPREDICTABLE>
    91a8:	4c00003d 	stcmi	0, cr0, [r0], {61}	; 0x3d
    91ac:	001940eb 	andseq	r4, r9, fp, ror #1
    91b0:	780fa800 	stmdavc	pc, {fp, sp, pc}	; <UNPREDICTABLE>
    91b4:	4c00000a 	stcmi	0, cr0, [r0], {10}
    91b8:	00939dec 	addseq	r9, r3, ip, ror #27
    91bc:	4e0fc000 	cdpmi	0, 0, cr12, cr15, cr0, {0}
    91c0:	4c00005c 	stcmi	0, cr0, [r0], {92}	; 0x5c
    91c4:	000069ed 	andeq	r6, r0, sp, ror #19
    91c8:	ab0fc400 	blge	3f1008 <unflatten_and_copy_device_tree+0x3f0194>
    91cc:	4c00004e 	stcmi	0, cr0, [r0], {78}	; 0x4e
    91d0:	000069ee 	andeq	r6, r0, lr, ror #19
    91d4:	750fc800 	strvc	ip, [pc, #-2048]	; fffff808 <__crc_of_fdt_unflatten_tree+0x792be24b>
    91d8:	4c00004a 	stcmi	0, cr0, [r0], {74}	; 0x4a
    91dc:	000057ef 	andeq	r5, r0, pc, ror #15
    91e0:	250fcc00 	strcs	ip, [pc, #-3072]	; fffff408 <__crc_of_fdt_unflatten_tree+0x792bde4b>
    91e4:	4c00000e 	stcmi	0, cr0, [r0], {14}
    91e8:	005800f2 	ldrsheq	r0, [r8], #-2
    91ec:	0800d000 	stmdaeq	r0, {ip, lr, pc}
    91f0:	0091f504 	addseq	pc, r1, r4, lsl #10
    91f4:	f8040800 			; <UNDEFINED> instruction: 0xf8040800
    91f8:	08000090 	stmdaeq	r0, {r4, r7}
    91fc:	008f8004 	addeq	r8, pc, r4
    9200:	07040800 	streq	r0, [r4, -r0, lsl #16]
    9204:	09000092 	stmdbeq	r0, {r1, r4, r7}
    9208:	00008b85 	andeq	r8, r0, r5, lsl #23
    920c:	00490a10 	subeq	r0, r9, r0, lsl sl
    9210:	896c1c00 	stmdbhi	ip!, {sl, fp, ip}^
    9214:	00009255 	andeq	r9, r0, r5, asr r2
    9218:	003ba10f 	eorseq	sl, fp, pc, lsl #2
    921c:	338a6c00 	orrcc	r6, sl, #0, 24
    9220:	00000001 	andeq	r0, r0, r1
    9224:	0009d20f 	andeq	sp, r9, pc, lsl #4
    9228:	cd8b6c00 	stcgt	12, cr6, [fp]
    922c:	04000010 	streq	r0, [r0], #-16
    9230:	0035900f 	eorseq	r9, r5, pc
    9234:	698c6c00 	stmibvs	ip, {sl, fp, sp, lr}
    9238:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    923c:	004b7b0f 	subeq	r7, fp, pc, lsl #22
    9240:	c78d6c00 	strgt	r6, [sp, r0, lsl #24]
    9244:	0c000002 	stceq	0, cr0, [r0], {2}
    9248:	00437b0f 	subeq	r7, r3, pc, lsl #22
    924c:	c78e6c00 	strgt	r6, [lr, r0, lsl #24]
    9250:	14000002 	strne	r0, [r0], #-2
    9254:	03ec1000 	mvneq	r1, #0
    9258:	6c580000 	mravs	r0, r8, acc0
    925c:	00936ab3 			; <UNDEFINED> instruction: 0x00936ab3
    9260:	22e80f00 	rsccs	r0, r8, #0, 30
    9264:	b46c0000 	strbtlt	r0, [ip], #-0
    9268:	00000057 	andeq	r0, r0, r7, asr r0
    926c:	059b0f00 	ldreq	r0, [fp, #3840]	; 0xf00
    9270:	b56c0000 	strblt	r0, [ip, #-0]!
    9274:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    9278:	756e1404 	strbvc	r1, [lr, #-1028]!	; 0xfffffbfc
    927c:	b66c006d 	strbtlt	r0, [ip], -sp, rrx
    9280:	00000057 	andeq	r0, r0, r7, asr r0
    9284:	596a0f08 	stmdbpl	sl!, {r3, r8, r9, sl, fp}^
    9288:	b76c0000 	strblt	r0, [ip, -r0]!
    928c:	00000057 	andeq	r0, r0, r7, asr r0
    9290:	5e2a0f0c 	cdppl	15, 2, cr0, cr10, cr12, {0}
    9294:	bc6c0000 	stcllt	0, cr0, [ip], #-0
    9298:	00008f2c 	andeq	r8, r0, ip, lsr #30
    929c:	12830f10 	addne	r0, r3, #16, 30	; 0x40
    92a0:	bd6c0000 	stcllt	0, cr0, [ip, #-0]
    92a4:	00008ede 	ldrdeq	r8, [r0], -lr
    92a8:	42f10f14 	rscsmi	r0, r1, #20, 30	; 0x50
    92ac:	be6c0000 	cdplt	0, 6, cr0, cr12, cr0, {0}
    92b0:	00008ede 	ldrdeq	r8, [r0], -lr
    92b4:	5bbe0f18 	blpl	fef83c68 <__crc_of_fdt_unflatten_tree+0x782426ab>
    92b8:	bf6c0000 	svclt	0x006c0000
    92bc:	00009379 	andeq	r9, r0, r9, ror r3
    92c0:	02f20f1c 	rscseq	r0, r2, #28, 30	; 0x70
    92c4:	c06c0000 	rsbgt	r0, ip, r0
    92c8:	000093a3 	andeq	r9, r0, r3, lsr #7
    92cc:	1d130f20 	ldcne	15, cr0, [r3, #-128]	; 0xffffff80
    92d0:	c26c0000 	rsbgt	r0, ip, #0
    92d4:	000093c7 	andeq	r9, r0, r7, asr #7
    92d8:	475e0f24 	ldrbmi	r0, [lr, -r4, lsr #30]
    92dc:	c46c0000 	strbtgt	r0, [ip], #-0
    92e0:	000093eb 	andeq	r9, r0, fp, ror #7
    92e4:	42880f28 	addmi	r0, r8, #40, 30	; 0xa0
    92e8:	c66c0000 	strbtgt	r0, [ip], -r0
    92ec:	0000940f 	andeq	r9, r0, pc, lsl #8
    92f0:	24dd0f2c 	ldrbcs	r0, [sp], #3884	; 0xf2c
    92f4:	c86c0000 	stmdagt	ip!, {}^	; <UNPREDICTABLE>
    92f8:	00008f86 	andeq	r8, r0, r6, lsl #31
    92fc:	0f370f30 	svceq	0x00370f30
    9300:	c96c0000 	stmdbgt	ip!, {}^	; <UNPREDICTABLE>
    9304:	0000942e 	andeq	r9, r0, lr, lsr #8
    9308:	0c640f34 	stcleq	15, cr0, [r4], #-208	; 0xffffff30
    930c:	cb6c0000 	blgt	1b09314 <unflatten_and_copy_device_tree+0x1b084a0>
    9310:	00008f2c 	andeq	r8, r0, ip, lsr #30
    9314:	18f00f38 	ldmne	r0!, {r3, r4, r5, r8, r9, sl, fp}^
    9318:	d06c0000 	rsble	r0, ip, r0
    931c:	0000944e 	andeq	r9, r0, lr, asr #8
    9320:	48c70f3c 	stmiami	r7, {r2, r3, r4, r5, r8, r9, sl, fp}^
    9324:	d26c0000 	rsble	r0, ip, #0
    9328:	00008ede 	ldrdeq	r8, [r0], -lr
    932c:	36000f40 	strcc	r0, [r0], -r0, asr #30
    9330:	d36c0000 	cmnle	ip, #0
    9334:	00009464 	andeq	r9, r0, r4, ror #8
    9338:	5c2f0f44 	stcpl	15, cr0, [pc], #-272	; fffffef8 <__crc_of_fdt_unflatten_tree+0x792be93b>
    933c:	d46c0000 	strbtle	r0, [ip], #-0
    9340:	00008fb6 			; <UNDEFINED> instruction: 0x00008fb6
    9344:	12890f48 	addne	r0, r9, #72, 30	; 0x120
    9348:	d56c0000 	strble	r0, [ip, #-0]!
    934c:	00009488 	andeq	r9, r0, r8, lsl #9
    9350:	1c270f4c 	stcne	15, cr0, [r7], #-304	; 0xfffffed0
    9354:	d86c0000 	stmdale	ip!, {}^	; <UNPREDICTABLE>
    9358:	00007248 	andeq	r7, r0, r8, asr #4
    935c:	2c800f50 	stccs	15, cr0, [r0], {80}	; 0x50
    9360:	da6c0000 	ble	1b09368 <unflatten_and_copy_device_tree+0x1b084f4>
    9364:	00000057 	andeq	r0, r0, r7, asr r0
    9368:	39150054 	ldmdbcc	r5, {r2, r4, r6}
    936c:	79000002 	stmdbvc	r0, {r1}
    9370:	0d000093 	stceq	0, cr0, [r0, #-588]	; 0xfffffdb4
    9374:	0000492f 	andeq	r4, r0, pc, lsr #18
    9378:	6a040800 	bvs	10b380 <unflatten_and_copy_device_tree+0x10a50c>
    937c:	15000093 	strne	r0, [r0, #-147]	; 0xffffff6d
    9380:	00000239 	andeq	r0, r0, r9, lsr r2
    9384:	0000939d 	muleq	r0, sp, r3
    9388:	00492f0d 	subeq	r2, r9, sp, lsl #30
    938c:	23cc0d00 	biccs	r0, ip, #0, 26
    9390:	9d0d0000 	stcls	0, cr0, [sp, #-0]
    9394:	0d000093 	stceq	0, cr0, [r0, #-588]	; 0xfffffdb4
    9398:	0000022e 	andeq	r0, r0, lr, lsr #4
    939c:	2c040800 	stccs	8, cr0, [r4], {-0}
    93a0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    93a4:	00937f04 	addseq	r7, r3, r4, lsl #30
    93a8:	02391500 	eorseq	r1, r9, #0, 10
    93ac:	93c70000 	bicls	r0, r7, #0
    93b0:	2f0d0000 	svccs	0x000d0000
    93b4:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    93b8:	000023cc 	andeq	r2, r0, ip, asr #7
    93bc:	005d850d 	subseq	r8, sp, sp, lsl #10
    93c0:	022e0d00 	eoreq	r0, lr, #0, 26
    93c4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    93c8:	0093a904 	addseq	sl, r3, r4, lsl #18
    93cc:	00571500 	subseq	r1, r7, r0, lsl #10
    93d0:	93eb0000 	mvnls	r0, #0
    93d4:	2f0d0000 	svccs	0x000d0000
    93d8:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    93dc:	000023cc 	andeq	r2, r0, ip, asr #7
    93e0:	0000690d 	andeq	r6, r0, sp, lsl #18
    93e4:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    93e8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    93ec:	0093cd04 	addseq	ip, r3, r4, lsl #26
    93f0:	01331500 	teqeq	r3, r0, lsl #10
    93f4:	940f0000 	strls	r0, [pc], #-0	; 93fc <.debug_info+0x93fc>
    93f8:	2f0d0000 	svccs	0x000d0000
    93fc:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    9400:	000023cc 	andeq	r2, r0, ip, asr #7
    9404:	0000690d 	andeq	r6, r0, sp, lsl #18
    9408:	00d40d00 	sbcseq	r0, r4, r0, lsl #26
    940c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    9410:	0093f104 	addseq	pc, r3, r4, lsl #2
    9414:	00691500 	rsbeq	r1, r9, r0, lsl #10
    9418:	942e0000 	strtls	r0, [lr], #-0
    941c:	2f0d0000 	svccs	0x000d0000
    9420:	0d000049 	stceq	0, cr0, [r0, #-292]	; 0xfffffedc
    9424:	000023cc 	andeq	r2, r0, ip, asr #7
    9428:	00835c0d 	addeq	r5, r3, sp, lsl #24
    942c:	04080000 	streq	r0, [r8], #-0
    9430:	00009415 	andeq	r9, r0, r5, lsl r4
    9434:	00944e0c 	addseq	r4, r4, ip, lsl #28
    9438:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    943c:	850d0000 	strhi	r0, [sp, #-0]
    9440:	0d00005d 	stceq	0, cr0, [r0, #-372]	; 0xfffffe8c
    9444:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    9448:	0000570d 	andeq	r5, r0, sp, lsl #14
    944c:	04080000 	streq	r0, [r8], #-0
    9450:	00009434 	andeq	r9, r0, r4, lsr r4
    9454:	0094640c 	addseq	r6, r4, ip, lsl #8
    9458:	492f0d00 	stmdbmi	pc!, {r8, sl, fp}	; <UNPREDICTABLE>
    945c:	690d0000 	stmdbvs	sp, {}	; <UNPREDICTABLE>
    9460:	00000000 	andeq	r0, r0, r0
    9464:	94540408 	ldrbls	r0, [r4], #-1032	; 0xfffffbf8
    9468:	57150000 	ldrpl	r0, [r5, -r0]
    946c:	88000000 	stmdahi	r0, {}	; <UNPREDICTABLE>
    9470:	0d000094 	stceq	0, cr0, [r0, #-592]	; 0xfffffdb0
    9474:	0000492f 	andeq	r4, r0, pc, lsr #18
    9478:	005d850d 	subseq	r8, sp, sp, lsl #10
    947c:	01b30d00 			; <UNDEFINED> instruction: 0x01b30d00
    9480:	570d0000 	strpl	r0, [sp, -r0]
    9484:	00000000 	andeq	r0, r0, r0
    9488:	946a0408 	strbtls	r0, [sl], #-1032	; 0xfffffbf8
    948c:	75100000 	ldrvc	r0, [r0, #-0]
    9490:	0800001b 	stmdaeq	r0, {r0, r1, r3, r4}
    9494:	94b3dd6c 	ldrtls	sp, [r3], #3436	; 0xd6c
    9498:	6f140000 	svcvs	0x00140000
    949c:	6c007370 	stcvs	3, cr7, [r0], {112}	; 0x70
    94a0:	0094b3de 			; <UNDEFINED> instruction: 0x0094b3de
    94a4:	74140000 	ldrvc	r0, [r4], #-0
    94a8:	6c007974 	stcvs	9, cr7, [r0], {116}	; 0x74
    94ac:	00492fdf 	ldrdeq	r2, [r9], #-255	; 0xffffff01
    94b0:	08000400 	stmdaeq	r0, {sl}
    94b4:	00925504 	addseq	r5, r2, r4, lsl #10
    94b8:	4c041700 	stcmi	7, cr1, [r4], {-0}
    94bc:	0094d839 	addseq	sp, r4, r9, lsr r8
    94c0:	22221800 	eorcs	r1, r2, #0, 16
    94c4:	3a4c0000 	bcc	13094cc <unflatten_and_copy_device_tree+0x1308658>
    94c8:	00009533 	andeq	r9, r0, r3, lsr r5
    94cc:	0037ee18 	eorseq	lr, r7, r8, lsl lr
    94d0:	4f3b4c00 	svcmi	0x003b4c00
    94d4:	0000001b 	andeq	r0, r0, fp, lsl r0
    94d8:	004c3910 	subeq	r3, ip, r0, lsl r9
    94dc:	384c1800 	stmdacc	ip, {fp, ip}^
    94e0:	00009533 	andeq	r9, r0, r3, lsr r5
    94e4:	0094b919 	addseq	fp, r4, r9, lsl r9
    94e8:	700f0000 	andvc	r0, pc, r0
    94ec:	4c000059 	stcmi	0, cr0, [r0], {89}	; 0x59
    94f0:	0000573d 	andeq	r5, r0, sp, lsr r7
    94f4:	6b0f0400 	blvs	3c1008 <unflatten_and_copy_device_tree+0x3c0194>
    94f8:	4c00000c 	stcmi	0, cr0, [r0], {12}
    94fc:	0000573e 	andeq	r5, r0, lr, lsr r7
    9500:	630f0800 	movwvs	r0, #63488	; 0xf800
    9504:	4c000014 	stcmi	0, cr0, [r0], {20}
    9508:	0000573f 	andeq	r5, r0, pc, lsr r7
    950c:	f20f0c00 			; <UNDEFINED> instruction: 0xf20f0c00
    9510:	4c000002 	stcmi	0, cr0, [r0], {2}
    9514:	00005740 	andeq	r5, r0, r0, asr #14
    9518:	6a0f1000 	bvs	3c4008 <unflatten_and_copy_device_tree+0x3c3194>
    951c:	4c000059 	stcmi	0, cr0, [r0], {89}	; 0x59
    9520:	00005741 	andeq	r5, r0, r1, asr #14
    9524:	ca0f1400 	bgt	3c5008 <unflatten_and_copy_device_tree+0x3c4194>
    9528:	4c00005d 	stcmi	0, cr0, [r0], {93}	; 0x5d
    952c:	00953943 	addseq	r3, r5, r3, asr #18
    9530:	08001800 	stmdaeq	r0, {fp, ip}
    9534:	0094d804 	addseq	sp, r4, r4, lsl #16
    9538:	00d40600 	sbcseq	r0, r4, r0, lsl #12
    953c:	95480000 	strbls	r0, [r8, #-0]
    9540:	eb250000 	bl	949548 <unflatten_and_copy_device_tree+0x9486d4>
    9544:	00000000 	andeq	r0, r0, r0
    9548:	004fed10 	subeq	lr, pc, r0, lsl sp	; <UNPREDICTABLE>
    954c:	534c5800 	movtpl	r5, #51200	; 0xc800
    9550:	000095c1 	andeq	r9, r0, r1, asr #11
    9554:	0055d20f 	subseq	sp, r5, pc, lsl #4
    9558:	33544c00 	cmpcc	r4, #0, 24
    955c:	00000095 	muleq	r0, r5, r0
    9560:	0050d60f 	subseq	sp, r0, pc, lsl #12
    9564:	fa554c00 	blx	155c56c <unflatten_and_copy_device_tree+0x155b6f8>
    9568:	0400001a 	streq	r0, [r0], #-26	; 0xffffffe6
    956c:	00155a0f 	andseq	r5, r5, pc, lsl #20
    9570:	40564c00 	subsmi	r4, r6, r0, lsl #24
    9574:	14000019 	strne	r0, [r0], #-25	; 0xffffffe7
    9578:	0014e10f 	andseq	lr, r4, pc, lsl #2
    957c:	bc574c00 	mrrclt	12, 0, r4, r7, cr0
    9580:	2c000002 	stccs	0, cr0, [r0], {2}
    9584:	0028140f 	eoreq	r1, r8, pc, lsl #8
    9588:	d8584c00 	ldmdale	r8, {sl, fp, lr}^
    958c:	30000094 	mulcc	r0, r4, r0
    9590:	0037ee0f 	eorseq	lr, r7, pc, lsl #28
    9594:	36594c00 	ldrbcc	r4, [r9], -r0, lsl #24
    9598:	4800001b 	stmdami	r0, {r0, r1, r3, r4}
    959c:	0051450f 	subseq	r4, r1, pc, lsl #10
    95a0:	bc5a4c00 	mrrclt	12, 0, r4, sl, cr0
    95a4:	4c000002 	stcmi	0, cr0, [r0], {2}
    95a8:	0002ce0f 	andeq	ip, r2, pc, lsl #28
    95ac:	575b4c00 	ldrbpl	r4, [fp, -r0, lsl #24]
    95b0:	50000000 	andpl	r0, r0, r0
    95b4:	0021570f 	eoreq	r5, r1, pc, lsl #14
    95b8:	335c4c00 	cmpcc	ip, #0, 24
    95bc:	54000095 	strpl	r0, [r0], #-149	; 0xffffff6b
    95c0:	34e51000 	strbtcc	r1, [r5], #0
    95c4:	4c140000 	ldcmi	0, cr0, [r4], {-0}
    95c8:	00960acb 	addseq	r0, r6, fp, asr #21
    95cc:	58800f00 	stmpl	r0, {r8, r9, sl, fp}
    95d0:	cd4c0000 	stclgt	0, cr0, [ip, #-0]
    95d4:	00009619 	andeq	r9, r0, r9, lsl r6
    95d8:	56580f00 	ldrbpl	r0, [r8], -r0, lsl #30
    95dc:	cf4c0000 	svcgt	0x004c0000
    95e0:	0000962f 	andeq	r9, r0, pc, lsr #12
    95e4:	42fe0f04 	rscsmi	r0, lr, #4, 30
    95e8:	d34c0000 	movtle	r0, #49152	; 0xc000
    95ec:	00009640 	andeq	r9, r0, r0, asr #12
    95f0:	23c40f08 	biccs	r0, r4, #8, 30
    95f4:	d84c0000 	stmdale	ip, {}^	; <UNPREDICTABLE>
    95f8:	0000965a 	andeq	r9, r0, sl, asr r6
    95fc:	22600f0c 	rsbcs	r0, r0, #12, 30	; 0x30
    9600:	da4c0000 	ble	1309608 <unflatten_and_copy_device_tree+0x1308794>
    9604:	00009640 	andeq	r9, r0, r0, asr #12
    9608:	57150010 			; <UNDEFINED> instruction: 0x57150010
    960c:	19000000 	stmdbne	r0, {}	; <UNPREDICTABLE>
    9610:	0d000096 	stceq	0, cr0, [r0, #-600]	; 0xfffffda8
    9614:	000091f5 	strdeq	r9, [r0], -r5
    9618:	0a040800 	beq	10b620 <unflatten_and_copy_device_tree+0x10a7ac>
    961c:	0c000096 	stceq	0, cr0, [r0], {150}	; 0x96
    9620:	0000962f 	andeq	r9, r0, pc, lsr #12
    9624:	0091f50d 	addseq	pc, r1, sp, lsl #10
    9628:	00570d00 	subseq	r0, r7, r0, lsl #26
    962c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    9630:	00961f04 	addseq	r1, r6, r4, lsl #30
    9634:	96400c00 	strbls	r0, [r0], -r0, lsl #24
    9638:	f50d0000 			; <UNDEFINED> instruction: 0xf50d0000
    963c:	00000091 	muleq	r0, r1, r0
    9640:	96350408 	ldrtls	r0, [r5], -r8, lsl #8
    9644:	57150000 	ldrpl	r0, [r5, -r0]
    9648:	5a000000 	bpl	9650 <.debug_info+0x9650>
    964c:	0d000096 	stceq	0, cr0, [r0, #-600]	; 0xfffffda8
    9650:	000091f5 	strdeq	r9, [r0], -r5
    9654:	00492f0d 	subeq	r2, r9, sp, lsl #30
    9658:	04080000 	streq	r0, [r8], #-0
    965c:	00009646 	andeq	r9, r0, r6, asr #12
    9660:	96660408 	strbtls	r0, [r6], -r8, lsl #8
    9664:	c1090000 	mrsgt	r0, (UNDEF: 9)
    9668:	08000095 	stmdaeq	r0, {r0, r2, r4, r7}
    966c:	00948e04 	addseq	r8, r4, r4, lsl #28
    9670:	00570600 	subseq	r0, r7, r0, lsl #12
    9674:	96810000 	strls	r0, [r1], r0
    9678:	eb070000 	bl	1c9680 <unflatten_and_copy_device_tree+0x1c880c>
    967c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    9680:	00571500 	subseq	r1, r7, r0, lsl #10
    9684:	969f0000 	ldrls	r0, [pc], r0
    9688:	d40d0000 	strle	r0, [sp], #-0
    968c:	0d000000 	stceq	0, cr0, [r0, #-0]
    9690:	000000f2 	strdeq	r0, [r0], -r2
    9694:	0000570d 	andeq	r5, r0, sp, lsl #14
    9698:	03780d00 	cmneq	r8, #0, 26
    969c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    96a0:	00968104 	addseq	r8, r6, r4, lsl #2
    96a4:	2d983a00 	vldrcs	s6, [r8]
    96a8:	e16d0000 	cmn	sp, r0
    96ac:	00000057 	andeq	r0, r0, r7, asr r0
    96b0:	0096c803 	addseq	ip, r6, r3, lsl #16
    96b4:	00783b00 	rsbseq	r3, r8, r0, lsl #22
    96b8:	0057e16d 	subseq	lr, r7, sp, ror #2
    96bc:	723c0000 	eorsvc	r0, ip, #0
    96c0:	57e36d00 	strbpl	r6, [r3, r0, lsl #26]!
    96c4:	00000000 	andeq	r0, r0, r0
    96c8:	003c103d 	eorseq	r1, ip, sp, lsr r0
    96cc:	01046d00 	tsteq	r4, r0, lsl #26
    96d0:	00000069 	andeq	r0, r0, r9, rrx
    96d4:	0096f003 	addseq	pc, r6, r3
    96d8:	00783e00 	rsbseq	r3, r8, r0, lsl #28
    96dc:	6901046d 	stmdbvs	r1, {r0, r2, r3, r5, r6, sl}
    96e0:	3f000000 	svccc	0x00000000
    96e4:	00746572 	rsbseq	r6, r4, r2, ror r5
    96e8:	6901066d 	stmdbvs	r1, {r0, r2, r3, r5, r6, r9, sl}
    96ec:	00000000 	andeq	r0, r0, r0
    96f0:	00644d3a 	rsbeq	r4, r4, sl, lsr sp
    96f4:	5e390300 	cdppl	3, 3, cr0, cr9, cr0, {0}
    96f8:	03000000 	movweq	r0, #0
    96fc:	0000970c 	andeq	r9, r0, ip, lsl #14
    9700:	6c61763b 	stclvs	6, cr7, [r1], #-236	; 0xffffff14
    9704:	5e390300 	cdppl	3, 3, cr0, cr9, cr0, {0}
    9708:	00000000 	andeq	r0, r0, r0
    970c:	0047e33a 	subeq	lr, r7, sl, lsr r3
    9710:	5ea70300 	cdppl	3, 10, cr0, cr7, cr0, {0}
    9714:	03000000 	movweq	r0, #0
    9718:	00009726 	andeq	r9, r0, r6, lsr #14
    971c:	0300703b 	movweq	r7, #59	; 0x3b
    9720:	009726a7 	addseq	r2, r7, r7, lsr #13
    9724:	04080000 	streq	r0, [r8], #-0
    9728:	0000972c 	andeq	r9, r0, ip, lsr #14
    972c:	00005e09 	andeq	r5, r0, r9, lsl #28
    9730:	6c664000 	stclvs	0, cr4, [r6], #-0
    9734:	116d0073 	smcne	53251	; 0xd003
    9738:	00005701 	andeq	r5, r0, r1, lsl #14
    973c:	974d0300 	strbls	r0, [sp, -r0, lsl #6]
    9740:	783e0000 	ldmdavc	lr!, {}	; <UNPREDICTABLE>
    9744:	01116d00 	tsteq	r1, r0, lsl #26
    9748:	00000057 	andeq	r0, r0, r7, asr r0
    974c:	4d8b3a00 	vstrmi	s6, [fp]
    9750:	206e0000 	rsbcs	r0, lr, r0
    9754:	00000057 	andeq	r0, r0, r7, asr r0
    9758:	00976703 	addseq	r6, r7, r3, lsl #14
    975c:	006e3b00 	rsbeq	r3, lr, r0, lsl #22
    9760:	00b3206e 	adcseq	r2, r3, lr, rrx
    9764:	3a000000 	bcc	976c <.debug_info+0x976c>
    9768:	000016bd 			; <UNDEFINED> instruction: 0x000016bd
    976c:	00570d6f 	subseq	r0, r7, pc, ror #26
    9770:	8e030000 	cdphi	0, 0, cr0, cr3, cr0, {0}
    9774:	41000097 	swpmi	r0, r7, [r0]	; <UNPREDICTABLE>
    9778:	00000c6b 	andeq	r0, r0, fp, ror #24
    977c:	00d40d6f 	sbcseq	r0, r4, pc, ror #26
    9780:	42420000 	submi	r0, r2, #0
    9784:	6f00001b 	svcvs	0x0000001b
    9788:	0000570f 	andeq	r5, r0, pc, lsl #14
    978c:	8d3d0000 	ldchi	0, cr0, [sp, #-0]
    9790:	02000038 	andeq	r0, r0, #56	; 0x38
    9794:	0378018f 	cmneq	r8, #-1073741789	; 0xc0000023
    9798:	c4030000 	strgt	r0, [r3], #-0
    979c:	43000097 	movwmi	r0, #151	; 0x97
    97a0:	00000c6b 	andeq	r0, r0, fp, ror #24
    97a4:	2e018f02 	cdpcs	15, 0, cr8, cr1, cr2, {0}
    97a8:	43000002 	movwmi	r0, #2
    97ac:	0000596a 	andeq	r5, r0, sl, ror #18
    97b0:	7b018f02 	blvc	6d3c0 <unflatten_and_copy_device_tree+0x6c54c>
    97b4:	44000002 	strmi	r0, [r0], #-2
    97b8:	00001b42 	andeq	r1, r0, r2, asr #22
    97bc:	69019102 	stmdbvs	r1, {r1, r8, ip, pc}
    97c0:	00000000 	andeq	r0, r0, r0
    97c4:	00435b3d 	subeq	r5, r3, sp, lsr fp
    97c8:	01140200 	tsteq	r4, r0, lsl #4
    97cc:	00000057 	andeq	r0, r0, r7, asr r0
    97d0:	0097e203 	addseq	lr, r7, r3, lsl #4
    97d4:	0c6b4300 	stcleq	3, cr4, [fp], #-0
    97d8:	14020000 	strne	r0, [r2], #-0
    97dc:	00022e01 	andeq	r2, r2, r1, lsl #28
    97e0:	573d0000 	ldrpl	r0, [sp, -r0]!
    97e4:	0200000a 	andeq	r0, r0, #10
    97e8:	037801ca 	cmneq	r8, #-2147483598	; 0x80000032
    97ec:	1a030000 	bne	c97f4 <unflatten_and_copy_device_tree+0xc8980>
    97f0:	43000098 	movwmi	r0, #152	; 0x98
    97f4:	00000c6b 	andeq	r0, r0, fp, ror #24
    97f8:	2e01ca02 	vmlacs.f32	s24, s2, s4
    97fc:	43000002 	movwmi	r0, #2
    9800:	0000596a 	andeq	r5, r0, sl, ror #18
    9804:	7b01ca02 	blvc	7c014 <unflatten_and_copy_device_tree+0x7b1a0>
    9808:	45000002 	strmi	r0, [r0, #-2]
    980c:	0027ca44 	eoreq	ip, r7, r4, asr #20
    9810:	01d10200 	bicseq	r0, r1, r0, lsl #4
    9814:	00000057 	andeq	r0, r0, r7, asr r0
    9818:	953d0000 	ldrls	r0, [sp, #-0]!
    981c:	02000033 	andeq	r0, r0, #51	; 0x33
    9820:	03780264 	cmneq	r8, #100, 4	; 0x40000006
    9824:	44030000 	strmi	r0, [r3], #-0
    9828:	43000098 	movwmi	r0, #152	; 0x98
    982c:	00000c6b 	andeq	r0, r0, fp, ror #24
    9830:	2e026402 	cdpcs	4, 0, cr6, cr2, cr2, {0}
    9834:	43000002 	movwmi	r0, #2
    9838:	0000596a 	andeq	r5, r0, sl, ror #18
    983c:	7b026402 	blvc	a284c <unflatten_and_copy_device_tree+0xa19d8>
    9840:	00000002 	andeq	r0, r0, r2
    9844:	0057ac3a 	subseq	sl, r7, sl, lsr ip
    9848:	d4d80500 	ldrble	r0, [r8], #1280	; 0x500
    984c:	03000000 	movweq	r0, #0
    9850:	00009867 	andeq	r9, r0, r7, ror #16
    9854:	0500783b 	streq	r7, [r0, #-2107]	; 0xfffff7c5
    9858:	00029cd8 	ldrdeq	r9, [r2], -r8
    985c:	00743c00 	rsbseq	r3, r4, r0, lsl #24
    9860:	00d4da05 	sbcseq	sp, r4, r5, lsl #20
    9864:	46000000 	strmi	r0, [r0], -r0
    9868:	00003a18 	andeq	r3, r0, r8, lsl sl
    986c:	7f035604 	svcvc	0x00035604
    9870:	41000098 	swpmi	r0, r8, [r0]	; <UNPREDICTABLE>
    9874:	0000433d 	andeq	r4, r0, sp, lsr r3
    9878:	5bf45604 	blpl	ffd1f090 <__crc_of_fdt_unflatten_tree+0x78fddad3>
    987c:	3a000000 	bcc	9884 <.debug_info+0x9884>
    9880:	00005baf 	andeq	r5, r0, pc, lsr #23
    9884:	005e4f70 	subseq	r4, lr, r0, ror pc
    9888:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
    988c:	3b000098 	blcc	9af4 <.debug_info+0x9af4>
    9890:	4f700070 	svcmi	0x00700070
    9894:	00009899 	muleq	r0, r9, r8
    9898:	9f040800 	svcls	0x00040800
    989c:	09000098 	stmdbeq	r0, {r3, r4, r7}
    98a0:	000001b9 			; <UNDEFINED> instruction: 0x000001b9
    98a4:	0019503a 	andseq	r5, r9, sl, lsr r0
    98a8:	57707100 	ldrbpl	r7, [r0, -r0, lsl #2]!
    98ac:	03000000 	movweq	r0, #0
    98b0:	000098c1 	andeq	r9, r0, r1, asr #17
    98b4:	746d663b 	strbtvc	r6, [sp], #-1595	; 0xfffff9c5
    98b8:	f2707100 	vrhadd.s<illegal width 64>	d23, d0, d0
    98bc:	47000000 	strmi	r0, [r0, -r0]
    98c0:	549b3a00 	ldrpl	r3, [fp], #2560	; 0xa00
    98c4:	98010000 	stmdals	r1, {}	; <UNPREDICTABLE>
    98c8:	00000378 	andeq	r0, r0, r8, ror r3
    98cc:	0098fe01 	addseq	pc, r8, r1, lsl #28
    98d0:	656d3b00 	strbvs	r3, [sp, #-2816]!	; 0xfffff500
    98d4:	9801006d 	stmdals	r1, {r0, r2, r3, r5, r6}
    98d8:	00004169 	andeq	r4, r0, r9, ror #2
    98dc:	000c6b41 	andeq	r6, ip, r1, asr #22
    98e0:	d4980100 	ldrle	r0, [r8], #256	; 0x100
    98e4:	41000000 	mrsmi	r0, (UNDEF: 0)
    98e8:	00003095 	muleq	r0, r5, r0
    98ec:	00d49901 	sbcseq	r9, r4, r1, lsl #18
    98f0:	723c0000 	eorsvc	r0, ip, #0
    98f4:	01007365 	tsteq	r0, r5, ror #6
    98f8:	0003789b 	muleq	r3, fp, r8
    98fc:	1d480000 	stclne	0, cr0, [r8, #-0]
    9900:	01000053 	qaddeq	r0, r3, r0
    9904:	6e010181 	adfvsd	f0, f1, f1
    9908:	43000099 	movwmi	r0, #153	; 0x99
    990c:	00002ee7 	andeq	r2, r0, r7, ror #29
    9910:	dc018101 	stfled	f0, [r1], {1}
    9914:	43000030 	movwmi	r0, #48	; 0x30
    9918:	00004afb 	strdeq	r4, [r0], -fp
    991c:	6e018201 	cdpvs	2, 0, cr8, cr1, cr1, {0}
    9920:	43000099 	movwmi	r0, #153	; 0x99
    9924:	00003bc1 	andeq	r3, r0, r1, asr #23
    9928:	88018301 	stmdahi	r1, {r0, r8, r9, pc}
    992c:	44000099 	strmi	r0, [r0], #-153	; 0xffffff67
    9930:	00000c6b 	andeq	r0, r0, fp, ror #24
    9934:	d4018501 	strle	r8, [r1], #-1281	; 0xfffffaff
    9938:	44000000 	strmi	r0, [r0], #-0
    993c:	000048d4 	ldrdeq	r4, [r0], -r4	; <UNPREDICTABLE>
    9940:	57018601 	strpl	r8, [r1, -r1, lsl #12]
    9944:	3f000000 	svccc	0x00000000
    9948:	006d656d 	rsbeq	r6, sp, sp, ror #10
    994c:	78018701 	stmdavc	r1, {r0, r8, r9, sl, pc}
    9950:	45000003 	strmi	r0, [r0, #-3]
    9954:	705f5f3f 	subsvc	r5, pc, pc, lsr pc	; <UNPREDICTABLE>
    9958:	01a30100 			; <UNDEFINED> instruction: 0x01a30100
    995c:	00000378 	andeq	r0, r0, r8, ror r3
    9960:	6e5f5f3f 	mrcvs	15, 2, r5, cr15, cr15, {1}
    9964:	01a30100 			; <UNDEFINED> instruction: 0x01a30100
    9968:	0000022e 	andeq	r0, r0, lr, lsr #4
    996c:	04080000 	streq	r0, [r8], #-0
    9970:	00005bf4 	strdeq	r5, [r0], -r4
    9974:	00037815 	andeq	r7, r3, r5, lsl r8
    9978:	00998800 	addseq	r8, r9, r0, lsl #16
    997c:	00c90d00 	sbceq	r0, r9, r0, lsl #26
    9980:	c90d0000 	stmdbgt	sp, {}	; <UNPREDICTABLE>
    9984:	00000000 	andeq	r0, r0, r0
    9988:	99740408 	ldmdbls	r4!, {r3, sl}^
    998c:	873a0000 	ldrhi	r0, [sl, -r0]!
    9990:	06000040 	streq	r0, [r0], -r0, asr #32
    9994:	0000f2a3 	andeq	pc, r0, r3, lsr #5
    9998:	99b50300 	ldmibls	r5!, {r8, r9}
    999c:	26410000 	strbcs	r0, [r1], -r0
    99a0:	06000037 			; <UNDEFINED> instruction: 0x06000037
    99a4:	0000f2a3 	andeq	pc, r0, r3, lsr #5
    99a8:	21574200 	cmpcs	r7, r0, lsl #4
    99ac:	a5060000 	strge	r0, [r6, #-0]
    99b0:	000000f2 	strdeq	r0, [r0], -r2
    99b4:	55324900 	ldrpl	r4, [r2, #-2304]!	; 0xfffff700
    99b8:	64010000 	strvs	r0, [r1], #-0
    99bc:	00005703 	andeq	r5, r0, r3, lsl #14
    99c0:	9a030100 	bls	c9dc8 <unflatten_and_copy_device_tree+0xc8f54>
    99c4:	3d430000 	stclcc	0, cr0, [r3, #-0]
    99c8:	01000043 	tsteq	r0, r3, asr #32
    99cc:	00d40364 	sbcseq	r0, r4, r4, ror #6
    99d0:	2b430000 	blcs	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    99d4:	01000047 	tsteq	r0, r7, asr #32
    99d8:	00f20364 	rscseq	r0, r2, r4, ror #6
    99dc:	1b430000 	blne	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    99e0:	01000058 	qaddeq	r0, r8, r0
    99e4:	00570365 	subseq	r0, r7, r5, ror #6
    99e8:	ca430000 	bgt	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    99ec:	0100005d 	qaddeq	r0, sp, r0
    99f0:	03780365 	cmneq	r8, #-1811939327	; 0x94000001
    99f4:	ed440000 	stcl	0, cr0, [r4, #-0]
    99f8:	01000047 	tsteq	r0, r7, asr #32
    99fc:	98990367 	ldmls	r9, {r0, r1, r2, r5, r6, r8, r9}
    9a00:	3a000000 	bcc	9a08 <.debug_info+0x9a08>
    9a04:	0000015e 	andeq	r0, r0, lr, asr r1
    9a08:	00c9c704 	sbceq	ip, r9, r4, lsl #14
    9a0c:	33030000 	movwcc	r0, #12288	; 0x3000
    9a10:	4100009a 	swpmi	r0, sl, [r0]	; <UNPREDICTABLE>
    9a14:	000021de 	ldrdeq	r2, [r0], -lr
    9a18:	9899c704 	ldmls	r9, {r2, r8, r9, sl, lr, pc}
    9a1c:	6b410000 	blvs	1040008 <unflatten_and_copy_device_tree+0x103f194>
    9a20:	0400000c 	streq	r0, [r0], #-12
    9a24:	000057c7 	andeq	r5, r0, r7, asr #15
    9a28:	00723c00 	rsbseq	r3, r2, r0, lsl #24
    9a2c:	00c9c904 	sbceq	ip, r9, r4, lsl #18
    9a30:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    9a34:	00004204 	andeq	r4, r0, r4, lsl #4
    9a38:	0102fc01 	tsteq	r2, r1, lsl #24	; <UNPREDICTABLE>
    9a3c:	00009a59 	andeq	r9, r0, r9, asr sl
    9a40:	0048d443 	subeq	sp, r8, r3, asr #8
    9a44:	02fc0100 	rscseq	r0, ip, #0, 2
    9a48:	000000d4 	ldrdeq	r0, [r0], -r4
    9a4c:	646e653e 	strbtvs	r6, [lr], #-1342	; 0xfffffac2
    9a50:	02fd0100 	rscseq	r0, sp, #0, 2
    9a54:	000000d4 	ldrdeq	r0, [r0], -r4
    9a58:	2f534900 	svccs	0x00534900
    9a5c:	b5010000 	strlt	r0, [r1, #-0]
    9a60:	00005703 	andeq	r5, r0, r3, lsl #14
    9a64:	9ac90100 	bls	ff249e6c <__crc_of_fdt_unflatten_tree+0x785088af>
    9a68:	3d430000 	stclcc	0, cr0, [r3, #-0]
    9a6c:	01000043 	tsteq	r0, r3, asr #32
    9a70:	00d403b5 	ldrheq	r0, [r4], #53	; 0x35
    9a74:	2b430000 	blcs	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9a78:	01000047 	tsteq	r0, r7, asr #32
    9a7c:	00f203b5 	ldrhteq	r0, [r2], #53	; 0x35
    9a80:	1b430000 	blne	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9a84:	01000058 	qaddeq	r0, r8, r0
    9a88:	005703b6 	ldrheq	r0, [r7], #-54	; 0xffffffca
    9a8c:	ca430000 	bgt	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9a90:	0100005d 	qaddeq	r0, sp, r0
    9a94:	037803b6 	cmneq	r8, #-671088638	; 0xd8000002
    9a98:	6c3f0000 	ldcvs	0, cr0, [pc], #-0	; 9aa0 <.debug_info+0x9aa0>
    9a9c:	03b80100 			; <UNDEFINED> instruction: 0x03b80100
    9aa0:	00000057 	andeq	r0, r0, r7, asr r0
    9aa4:	0100703f 	tsteq	r0, pc, lsr r0
    9aa8:	00f203b9 	ldrhteq	r0, [r2], #57	; 0x39
    9aac:	44450000 	strbmi	r0, [r5], #-0
    9ab0:	00005fd2 	ldrdeq	r5, [r0], -r2
    9ab4:	5703c601 	strpl	ip, [r3, -r1, lsl #12]
    9ab8:	44000000 	strmi	r0, [r0], #-0
    9abc:	00005fd8 	ldrdeq	r5, [r0], -r8
    9ac0:	5703c601 	strpl	ip, [r3, -r1, lsl #12]
    9ac4:	00000000 	andeq	r0, r0, r0
    9ac8:	3f8b4a00 	svccc	0x008b4a00
    9acc:	8a010000 	bhi	49ad4 <unflatten_and_copy_device_tree+0x48c60>
    9ad0:	0000d402 	andeq	sp, r0, r2, lsl #8
    9ad4:	fc490100 	mcrr2	1, 0, r0, r9, cr0
    9ad8:	01000018 	tsteq	r0, r8, lsl r0
    9adc:	00f202be 	ldrhteq	r0, [r2], #46	; 0x2e
    9ae0:	00010000 	andeq	r0, r1, r0
    9ae4:	4400009b 	strmi	r0, [r0], #-155	; 0xffffff65
    9ae8:	0000059b 	muleq	r0, fp, r5
    9aec:	f202c001 	vhadd.s8	d12, d2, d1
    9af0:	44000000 	strmi	r0, [r0], #-0
    9af4:	00005aa6 	andeq	r5, r0, r6, lsr #21
    9af8:	d402c101 	strle	ip, [r2], #-257	; 0xfffffeff
    9afc:	00000000 	andeq	r0, r0, r0
    9b00:	002b263a 	eoreq	r2, fp, sl, lsr r6
    9b04:	9ccb0500 	cfstr64ls	mvdx0, [fp], {0}
    9b08:	03000002 	movweq	r0, #2
    9b0c:	00009b23 	andeq	r9, r0, r3, lsr #22
    9b10:	0500783b 	streq	r7, [r0, #-2107]	; 0xfffff7c5
    9b14:	0000d4cb 	andeq	sp, r0, fp, asr #9
    9b18:	00743c00 	rsbseq	r3, r4, r0, lsl #24
    9b1c:	029ccd05 	addseq	ip, ip, #320	; 0x140
    9b20:	49000000 	stmdbmi	r0, {}	; <UNPREDICTABLE>
    9b24:	00003e6d 	andeq	r3, r0, sp, ror #28
    9b28:	57038801 	strpl	r8, [r3, -r1, lsl #16]
    9b2c:	01000000 	mrseq	r0, (UNDEF: 0)
    9b30:	00009bad 	andeq	r9, r0, sp, lsr #23
    9b34:	00433d43 	subeq	r3, r3, r3, asr #26
    9b38:	03880100 	orreq	r0, r8, #0, 2
    9b3c:	000000d4 	ldrdeq	r0, [r0], -r4
    9b40:	00472b43 	subeq	r2, r7, r3, asr #22
    9b44:	03880100 	orreq	r0, r8, #0, 2
    9b48:	000000f2 	strdeq	r0, [r0], -r2
    9b4c:	00581b43 	subseq	r1, r8, r3, asr #22
    9b50:	03890100 	orreq	r0, r9, #0, 2
    9b54:	00000057 	andeq	r0, r0, r7, asr r0
    9b58:	005dca43 	subseq	ip, sp, r3, asr #20
    9b5c:	03890100 	orreq	r0, r9, #0, 2
    9b60:	00000378 	andeq	r0, r0, r8, ror r3
    9b64:	00357e44 	eorseq	r7, r5, r4, asr #28
    9b68:	038b0100 	orreq	r0, fp, #0, 2
    9b6c:	000000f2 	strdeq	r0, [r0], -r2
    9b70:	6765723f 			; <UNDEFINED> instruction: 0x6765723f
    9b74:	038c0100 	orreq	r0, ip, #0, 2
    9b78:	00009899 	muleq	r0, r9, r8
    9b7c:	00411344 	subeq	r1, r1, r4, asr #6
    9b80:	038c0100 	orreq	r0, ip, #0, 2
    9b84:	00009899 	muleq	r0, r9, r8
    9b88:	01006c3f 	tsteq	r0, pc, lsr ip
    9b8c:	0057038d 	subseq	r0, r7, sp, lsl #7
    9b90:	44450000 	strbmi	r0, [r5], #-0
    9b94:	00002f72 	andeq	r2, r0, r2, ror pc
    9b98:	c903a501 	stmdbgt	r3, {r0, r8, sl, sp, pc}
    9b9c:	44000000 	strmi	r0, [r0], #-0
    9ba0:	00000c6b 	andeq	r0, r0, fp, ror #24
    9ba4:	c903a501 	stmdbgt	r3, {r0, r8, sl, sp, pc}
    9ba8:	00000000 	andeq	r0, r0, r0
    9bac:	09ba3d00 	ldmibeq	sl!, {r8, sl, fp, ip, sp}
    9bb0:	1c010000 	stcne	0, cr0, [r1], {-0}
    9bb4:	00005702 	andeq	r5, r0, r2, lsl #14
    9bb8:	9c130100 	ldflss	f0, [r3], {-0}
    9bbc:	3d430000 	stclcc	0, cr0, [r3, #-0]
    9bc0:	01000043 	tsteq	r0, r3, asr #32
    9bc4:	00d4021c 	sbcseq	r0, r4, ip, lsl r2
    9bc8:	2b430000 	blcs	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9bcc:	01000047 	tsteq	r0, r7, asr #32
    9bd0:	00f2021c 	rscseq	r0, r2, ip, lsl r2
    9bd4:	1b430000 	blne	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9bd8:	01000058 	qaddeq	r0, r8, r0
    9bdc:	0057021d 	subseq	r0, r7, sp, lsl r2
    9be0:	ca430000 	bgt	10c0008 <unflatten_and_copy_device_tree+0x10bf194>
    9be4:	0100005d 	qaddeq	r0, sp, r0
    9be8:	0378021d 	cmneq	r8, #-805306367	; 0xd0000001
    9bec:	0d440000 	stcleq	0, cr0, [r4, #-0]
    9bf0:	01000000 	mrseq	r0, (UNDEF: 0)
    9bf4:	0057021f 	subseq	r0, r7, pc, lsl r2
    9bf8:	fe440000 	cdp2	0, 4, cr0, cr4, cr0, {0}
    9bfc:	0100001b 	tsteq	r0, fp, lsl r0
    9c00:	00f20220 	rscseq	r0, r2, r0, lsr #4
    9c04:	653f0000 	ldrvs	r0, [pc, #-0]!	; 9c0c <.debug_info+0x9c0c>
    9c08:	01007272 	tsteq	r0, r2, ror r2
    9c0c:	00570221 	subseq	r0, r7, r1, lsr #4
    9c10:	49000000 	stmdbmi	r0, {}	; <UNPREDICTABLE>
    9c14:	0000041c 	andeq	r0, r0, ip, lsl r4
    9c18:	fb043101 	blx	116026 <unflatten_and_copy_device_tree+0x1151b2>
    9c1c:	01000001 	tsteq	r0, r1
    9c20:	00009c31 	andeq	r9, r0, r1, lsr ip
    9c24:	000ea043 	andeq	sl, lr, r3, asr #32
    9c28:	04310100 	ldrteq	r0, [r1], #-256	; 0xffffff00
    9c2c:	00000378 	andeq	r0, r0, r8, ror r3
    9c30:	02b64b00 	adcseq	r4, r6, #0, 22
    9c34:	b3010000 	movwlt	r0, #4096	; 0x1000
    9c38:	00037801 	andeq	r7, r3, r1, lsl #16
    9c3c:	00000000 	andeq	r0, r0, r0
    9c40:	00002400 	andeq	r2, r0, r0, lsl #8
    9c44:	ab9c0100 	blge	fe70a04c <__crc_of_fdt_unflatten_tree+0x779c8a8f>
    9c48:	4c00009c 	stcmi	0, cr0, [r0], {156}	; 0x9c
    9c4c:	00000c6b 	andeq	r0, r0, fp, ror #24
    9c50:	c901b301 	stmdbgt	r1, {r0, r8, r9, ip, sp, pc}
    9c54:	00000000 	andeq	r0, r0, r0
    9c58:	4c000000 	stcmi	0, cr0, [r0], {-0}
    9c5c:	00003095 	muleq	r0, r5, r0
    9c60:	c901b301 	stmdbgt	r1, {r0, r8, r9, ip, sp, pc}
    9c64:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    9c68:	4d000000 	stcmi	0, cr0, [r0, #-0]
    9c6c:	0000981a 	andeq	r9, r0, sl, lsl r8
    9c70:	00000014 	andeq	r0, r0, r4, lsl r0
    9c74:	0000000c 	andeq	r0, r0, ip
    9c78:	4e01b501 	cfsh32mi	mvfx11, mvfx1, #1
    9c7c:	00009837 	andeq	r9, r0, r7, lsr r8
    9c80:	00982b4e 	addseq	r2, r8, lr, asr #22
    9c84:	97e24d00 	strbls	r4, [r2, r0, lsl #26]!
    9c88:	00140000 	andseq	r0, r4, r0
    9c8c:	000c0000 	andeq	r0, ip, r0
    9c90:	66020000 	strvs	r0, [r2], -r0
    9c94:	97ff4e02 	ldrbls	r4, [pc, r2, lsl #28]!
    9c98:	f34e0000 	vhadd.u8	d16, d14, d0
    9c9c:	4f000097 	svcmi	0x00000097
    9ca0:	00000020 	andeq	r0, r0, r0, lsr #32
    9ca4:	0000b8cd 	andeq	fp, r0, sp, asr #17
    9ca8:	4b000000 	blmi	9cb0 <.debug_info+0x9cb0>
    9cac:	000032eb 	andeq	r3, r0, fp, ror #5
    9cb0:	39048c01 	stmdbcc	r4, {r0, sl, fp, pc}
    9cb4:	24000002 	strcs	r0, [r0], #-2
    9cb8:	3c000000 	stccc	0, cr0, [r0], {-0}
    9cbc:	01000000 	mrseq	r0, (UNDEF: 0)
    9cc0:	009d2e9c 	umullseq	r2, sp, ip, lr
    9cc4:	46064c00 	strmi	r4, [r6], -r0, lsl #24
    9cc8:	8c010000 	stchi	0, cr0, [r1], {-0}
    9ccc:	0023cc04 	eoreq	ip, r3, r4, lsl #24
    9cd0:	00003000 	andeq	r3, r0, r0
    9cd4:	2fa14c00 	svccs	0x00a14c00
    9cd8:	8c010000 	stchi	0, cr0, [r1], {-0}
    9cdc:	00562e04 	subseq	r2, r6, r4, lsl #28
    9ce0:	00004300 	andeq	r4, r0, r0, lsl #6
    9ce4:	1b8a4c00 	blne	fe293008 <__crc_of_fdt_unflatten_tree+0x77551a4b>
    9ce8:	8d010000 	stchi	0, cr0, [r1, #-0]
    9cec:	0056e504 	subseq	lr, r6, r4, lsl #10
    9cf0:	00005600 	andeq	r5, r0, r0, lsl #12
    9cf4:	75625000 	strbvc	r5, [r2, #-0]!
    9cf8:	8e010066 	cdphi	0, 0, cr0, cr1, cr6, {3}
    9cfc:	0001b304 	andeq	fp, r1, r4, lsl #6
    9d00:	00006900 	andeq	r6, r0, r0, lsl #18
    9d04:	666f5000 	strbtvs	r5, [pc], -r0
    9d08:	8e010066 	cdphi	0, 0, cr0, cr1, cr6, {3}
    9d0c:	00022304 	andeq	r2, r2, r4, lsl #6
    9d10:	00007c00 	andeq	r7, r0, r0, lsl #24
    9d14:	3ba15100 	blcc	fe854408 <__crc_of_fdt_unflatten_tree+0x77b12e4b>
    9d18:	8e010000 	cdphi	0, 0, cr0, cr1, cr0, {0}
    9d1c:	00022e04 	andeq	r2, r2, r4, lsl #28
    9d20:	08910200 	ldmeq	r1, {r9}
    9d24:	0000584f 	andeq	r5, r0, pc, asr #16
    9d28:	00b8d900 	adcseq	sp, r8, r0, lsl #18
    9d2c:	65520000 	ldrbvs	r0, [r2, #-0]
    9d30:	01000037 	tsteq	r0, r7, lsr r0
    9d34:	000378af 	andeq	r7, r3, pc, lsr #17
    9d38:	00006000 	andeq	r6, r0, r0
    9d3c:	00053c00 	andeq	r3, r5, r0, lsl #24
    9d40:	cf9c0100 	svcgt	0x009c0100
    9d44:	530000a0 	movwpl	r0, #160	; 0xa0
    9d48:	00002ee7 	andeq	r2, r0, r7, ror #29
    9d4c:	30dcaf01 	sbcscc	sl, ip, r1, lsl #30
    9d50:	00900000 	addseq	r0, r0, r0
    9d54:	6d540000 	ldclvs	0, cr0, [r4, #-0]
    9d58:	01006d65 	tsteq	r0, r5, ror #26
    9d5c:	000378b0 			; <UNDEFINED> instruction: 0x000378b0
    9d60:	0000ae00 	andeq	sl, r0, r0, lsl #28
    9d64:	58a45300 	stmiapl	r4!, {r8, r9, ip, lr}
    9d68:	b1010000 	mrslt	r0, (UNDEF: 1)
    9d6c:	00001abb 			; <UNDEFINED> instruction: 0x00001abb
    9d70:	000001a8 	andeq	r0, r0, r8, lsr #3
    9d74:	64616454 	strbtvs	r6, [r1], #-1108	; 0xfffffbac
    9d78:	f4b20100 			; <UNDEFINED> instruction: 0xf4b20100
    9d7c:	1300005b 	movwne	r0, #91	; 0x5b
    9d80:	55000002 	strpl	r0, [r0, #-2]
    9d84:	000055a8 	andeq	r5, r0, r8, lsr #11
    9d88:	996eb301 	stmdbls	lr!, {r0, r8, r9, ip, sp, pc}^
    9d8c:	91020000 	mrsls	r0, (UNDEF: 2)
    9d90:	36da5300 	ldrbcc	r5, [sl], r0, lsl #6
    9d94:	b4010000 	strlt	r0, [r1], #-0
    9d98:	000000d4 	ldrdeq	r0, [r0], -r4
    9d9c:	00000247 	andeq	r0, r0, r7, asr #4
    9da0:	00344853 	eorseq	r4, r4, r3, asr r8
    9da4:	fbb50100 	blx	fed4a1ae <__crc_of_fdt_unflatten_tree+0x78008bf1>
    9da8:	ab000001 	blge	c <.debug_info+0xc>
    9dac:	56000002 	strpl	r0, [r0], -r2
    9db0:	b7010070 	smlsdxlt	r1, r0, r0, r0
    9db4:	00009899 	muleq	r0, r9, r8
    9db8:	00000338 	andeq	r0, r0, r8, lsr r3
    9dbc:	00706e3c 	rsbseq	r6, r0, ip, lsr lr
    9dc0:	5bf4b801 	blpl	ffd37dcc <__crc_of_fdt_unflatten_tree+0x78ff680f>
    9dc4:	703c0000 	eorsvc	r0, ip, r0
    9dc8:	b9010070 	stmdblt	r1, {r4, r5, r6}
    9dcc:	00005b45 	andeq	r5, r0, r5, asr #22
    9dd0:	001c7857 	andseq	r7, ip, r7, asr r8
    9dd4:	cfb90100 	svcgt	0x00b90100
    9dd8:	770000a0 	strvc	r0, [r0, -r0, lsr #1]
    9ddc:	42000003 	andmi	r0, r0, #3
    9de0:	00005e46 	andeq	r5, r0, r6, asr #28
    9de4:	00f2ba01 	rscseq	fp, r2, r1, lsl #20
    9de8:	6c560000 	mravs	r0, r6, acc0
    9dec:	69bb0100 	ldmibvs	fp!, {r8}
    9df0:	c1000000 	mrsgt	r0, (UNDEF: 0)
    9df4:	42000003 	andmi	r0, r0, #3
    9df8:	00002b43 	andeq	r2, r0, r3, asr #22
    9dfc:	0069bb01 	rsbeq	fp, r9, r1, lsl #22
    9e00:	1b580000 	blne	1600008 <unflatten_and_copy_device_tree+0x15ff194>
    9e04:	01000058 	qaddeq	r0, r8, r0
    9e08:	000057bc 			; <UNDEFINED> instruction: 0x000057bc
    9e0c:	04030500 	streq	r0, [r3], #-1280	; 0xfffffb00
    9e10:	57000000 	strpl	r0, [r0, -r0]
    9e14:	00001060 	andeq	r1, r0, r0, rrx
    9e18:	0057bd01 	subseq	fp, r7, r1, lsl #26
    9e1c:	03e10000 	mvneq	r0, #0
    9e20:	cf570000 	svcgt	0x00570000
    9e24:	01000050 	qaddeq	r0, r0, r0
    9e28:	000057be 			; <UNDEFINED> instruction: 0x000057be
    9e2c:	00040a00 	andeq	r0, r4, r0, lsl #20
    9e30:	52b55700 	adcspl	r5, r5, #0, 14
    9e34:	bf010000 	svclt	0x00010000
    9e38:	00000057 	andeq	r0, r0, r7, asr r0
    9e3c:	00000433 	andeq	r0, r0, r3, lsr r4
    9e40:	00096d57 	andeq	r6, r9, r7, asr sp
    9e44:	57c00100 	strbpl	r0, [r0, r0, lsl #2]
    9e48:	7d000000 	stcvc	0, cr0, [r0, #-0]
    9e4c:	59000004 	stmdbpl	r0, {r2}
    9e50:	000098c1 	andeq	r9, r0, r1, asr #17
    9e54:	00000100 	andeq	r0, r0, r0, lsl #2
    9e58:	00000000 	andeq	r0, r0, r0
    9e5c:	9e7de201 	cdpls	2, 7, cr14, cr13, cr1, {0}
    9e60:	e74e0000 	strb	r0, [lr, -r0]
    9e64:	4e000098 	mcrmi	0, 0, r0, cr0, cr8, {4}
    9e68:	000098dc 	ldrdeq	r9, [r0], -ip
    9e6c:	0098d14e 	addseq	sp, r8, lr, asr #2
    9e70:	00005a00 	andeq	r5, r0, r0, lsl #20
    9e74:	f25b0000 	vhadd.s16	d16, d11, d0
    9e78:	00000098 	muleq	r0, r8, r0
    9e7c:	00185c00 	andseq	r5, r8, r0, lsl #24
    9e80:	9f970000 	svcls	0x00970000
    9e84:	3e5d0000 	cdpcc	0, 5, cr0, cr13, cr0, {0}
    9e88:	01000017 	tsteq	r0, r7, lsl r0
    9e8c:	00f20104 	rscseq	r0, r2, r4, lsl #2
    9e90:	04d20000 	ldrbeq	r0, [r2], #0
    9e94:	735e0000 	cmpvc	lr, #0
    9e98:	0501007a 	streq	r0, [r1, #-122]	; 0xffffff86
    9e9c:	0000b301 	andeq	fp, r0, r1, lsl #6
    9ea0:	0004fe00 	andeq	pc, r4, r0, lsl #28
    9ea4:	98c15f00 	stmials	r1, {r8, r9, sl, fp, ip, lr}^
    9ea8:	01900000 	orrseq	r0, r0, r0
    9eac:	000c0000 	andeq	r0, ip, r0
    9eb0:	12010000 	andne	r0, r1, #0
    9eb4:	009ed801 	addseq	sp, lr, r1, lsl #16
    9eb8:	98e74e00 	stmials	r7!, {r9, sl, fp, lr}^
    9ebc:	dc4e0000 	marle	acc0, r0, lr
    9ec0:	4e000098 	mcrmi	0, 0, r0, cr0, cr8, {4}
    9ec4:	000098d1 	ldrdeq	r9, [r0], -r1
    9ec8:	00019060 	andeq	r9, r1, r0, rrx
    9ecc:	00000c00 	andeq	r0, r0, r0, lsl #24
    9ed0:	98f25b00 	ldmls	r2!, {r8, r9, fp, ip, lr}^
    9ed4:	00000000 	andeq	r0, r0, r0
    9ed8:	00987f61 	addseq	r7, r8, r1, ror #30
    9edc:	0001e000 	andeq	lr, r1, r0
    9ee0:	00005000 	andeq	r5, r0, r0
    9ee4:	011d0100 	tsteq	sp, r0, lsl #2
    9ee8:	00009f1c 	andeq	r9, r0, ip, lsl pc
    9eec:	00988f4e 	addseq	r8, r8, lr, asr #30
    9ef0:	970c6200 	strls	r6, [ip, -r0, lsl #4]
    9ef4:	01e00000 	mvneq	r0, r0
    9ef8:	00500000 	subseq	r0, r0, r0
    9efc:	51700000 	cmnpl	r0, r0
    9f00:	00971c4e 	addseq	r1, r7, lr, asr #24
    9f04:	96f06300 	ldrbtls	r6, [r0], r0, lsl #6
    9f08:	01e80000 	mvneq	r0, r0
    9f0c:	00040000 	andeq	r0, r4, r0
    9f10:	ac030000 	stcge	0, cr0, [r3], {-0}
    9f14:	0097004e 	addseq	r0, r7, lr, asr #32
    9f18:	00000000 	andeq	r0, r0, r0
    9f1c:	00987f61 	addseq	r7, r8, r1, ror #30
    9f20:	00020000 	andeq	r0, r2, r0
    9f24:	00006800 	andeq	r6, r0, r0, lsl #16
    9f28:	01230100 			; <UNDEFINED> instruction: 0x01230100
    9f2c:	00009f60 	andeq	r9, r0, r0, ror #30
    9f30:	00988f4e 	addseq	r8, r8, lr, asr #30
    9f34:	970c6200 	strls	r6, [ip, -r0, lsl #4]
    9f38:	02000000 	andeq	r0, r0, #0
    9f3c:	00680000 	rsbeq	r0, r8, r0
    9f40:	51700000 	cmnpl	r0, r0
    9f44:	00971c4e 	addseq	r1, r7, lr, asr #24
    9f48:	96f06200 	ldrbtls	r6, [r0], r0, lsl #4
    9f4c:	02000000 	andeq	r0, r0, #0
    9f50:	00800000 	addeq	r0, r0, r0
    9f54:	ac030000 	stcge	0, cr0, [r3], {-0}
    9f58:	0097004e 	addseq	r0, r7, lr, asr #32
    9f5c:	00000000 	andeq	r0, r0, r0
    9f60:	00018c4f 	andeq	r8, r1, pc, asr #24
    9f64:	00b8e200 	adcseq	lr, r8, r0, lsl #4
    9f68:	01b84f00 			; <UNDEFINED> instruction: 0x01b84f00
    9f6c:	b8e20000 	stmialt	r2!, {}^	; <UNPREDICTABLE>
    9f70:	cc4f0000 	margt	acc0, r0, pc
    9f74:	e2000001 	and	r0, r0, #1
    9f78:	4f0000b8 	svcmi	0x000000b8
    9f7c:	000001fc 	strdeq	r0, [r0], -ip
    9f80:	0000b8e2 	andeq	fp, r0, r2, ror #17
    9f84:	0002544f 	andeq	r5, r2, pc, asr #8
    9f88:	00b8ed00 	adcseq	lr, r8, r0, lsl #26
    9f8c:	05844f00 	streq	r4, [r4, #3840]	; 0xf00
    9f90:	b8f90000 	ldmlt	r9!, {}^	; <UNPREDICTABLE>
    9f94:	64000000 	strvs	r0, [r0], #-0
    9f98:	00000340 	andeq	r0, r0, r0, asr #6
    9f9c:	00000028 	andeq	r0, r0, r8, lsr #32
    9fa0:	00009fc3 	andeq	r9, r0, r3, asr #31
    9fa4:	00306944 	eorseq	r6, r0, r4, asr #18
    9fa8:	01650100 	cmneq	r5, r0, lsl #2
    9fac:	00005bf4 	strdeq	r5, [r0], -r4
    9fb0:	0000985a 	andeq	r9, r0, sl, asr r8
    9fb4:	22224400 	eorcs	r4, r2, #0, 8
    9fb8:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    9fbc:	005bf401 	subseq	pc, fp, r1, lsl #8
    9fc0:	5c000000 	stcpl	0, cr0, [r0], {-0}
    9fc4:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
    9fc8:	0000a035 	andeq	sl, r0, r5, lsr r0
    9fcc:	0031703f 	eorseq	r7, r1, pc, lsr r0
    9fd0:	f2012f01 	vmax.f32	d2, d1, d1
    9fd4:	3f000000 	svccc	0x00000000
    9fd8:	01007370 	tsteq	r0, r0, ror r3
    9fdc:	00f2012f 	rscseq	r0, r2, pc, lsr #2
    9fe0:	703f0000 	eorsvc	r0, pc, r0
    9fe4:	2f010061 	svccs	0x00010061
    9fe8:	0000f201 	andeq	pc, r0, r1, lsl #4
    9fec:	7a735e00 	bvc	1ce17f4 <unflatten_and_copy_device_tree+0x1ce0980>
    9ff0:	01300100 	teqeq	r0, r0, lsl #2
    9ff4:	00000057 	andeq	r0, r0, r7, asr r0
    9ff8:	0000052a 	andeq	r0, r0, sl, lsr #10
    9ffc:	0098c161 	addseq	ip, r8, r1, ror #2
    a000:	0003cc00 	andeq	ip, r3, r0, lsl #24
    a004:	0000c800 	andeq	ip, r0, r0, lsl #16
    a008:	013c0100 	teqeq	ip, r0, lsl #2
    a00c:	0000a02b 	andeq	sl, r0, fp, lsr #32
    a010:	0098e74e 	addseq	lr, r8, lr, asr #14
    a014:	98dc4e00 	ldmls	ip, {r9, sl, fp, lr}^
    a018:	d14e0000 	mrsle	r0, (UNDEF: 78)
    a01c:	5a000098 	bpl	a284 <.debug_info+0xa284>
    a020:	000000c8 	andeq	r0, r0, r8, asr #1
    a024:	0098f25b 	addseq	pc, r8, fp, asr r2	; <UNPREDICTABLE>
    a028:	4f000000 	svcmi	0x00000000
    a02c:	0000042c 	andeq	r0, r0, ip, lsr #8
    a030:	0000b8d9 	ldrdeq	fp, [r0], -r9
    a034:	00e05c00 	rsceq	r5, r0, r0, lsl #24
    a038:	a0860000 	addge	r0, r6, r0
    a03c:	663c0000 	ldrtvs	r0, [ip], -r0
    a040:	e501006e 	str	r0, [r1, #-110]	; 0xffffff92
    a044:	000001b3 			; <UNDEFINED> instruction: 0x000001b3
    a048:	00986759 	addseq	r6, r8, r9, asr r7
    a04c:	0004c000 	andeq	ip, r4, r0
    a050:	0000f800 	andeq	pc, r0, r0, lsl #16
    a054:	6ae60100 	bvs	ff98a45c <__crc_of_fdt_unflatten_tree+0x78c48e9f>
    a058:	4e0000a0 	cdpmi	0, 0, cr0, cr0, cr0, {5}
    a05c:	00009873 	andeq	r9, r0, r3, ror r8
    a060:	0004d44f 	andeq	sp, r4, pc, asr #8
    a064:	00b90400 	adcseq	r0, r9, r0, lsl #8
    a068:	084f0000 	stmdaeq	pc, {}^	; <UNPREDICTABLE>
    a06c:	0f000005 	svceq	0x00000005
    a070:	4f0000b9 	svcmi	0x000000b9
    a074:	00000510 	andeq	r0, r0, r0, lsl r5
    a078:	0000b91a 	andeq	fp, r0, sl, lsl r9
    a07c:	0005384f 	andeq	r3, r5, pc, asr #16
    a080:	00b8d900 	adcseq	sp, r8, r0, lsl #18
    a084:	a04f0000 	subge	r0, pc, r0
    a088:	25000000 	strcs	r0, [r0, #-0]
    a08c:	4f0000b9 	svcmi	0x000000b9
    a090:	0000012c 	andeq	r0, r0, ip, lsr #2
    a094:	0000b931 	andeq	fp, r0, r1, lsr r9
    a098:	0002384f 	andeq	r3, r2, pc, asr #16
    a09c:	00b93d00 	adcseq	r3, r9, r0, lsl #26
    a0a0:	02984f00 	addseq	r4, r8, #0, 30
    a0a4:	b9490000 	stmdblt	r9, {}^	; <UNPREDICTABLE>
    a0a8:	0c4f0000 	mareq	acc0, r0, pc
    a0ac:	2e000003 	cdpcs	0, 0, cr0, cr0, cr3, {0}
    a0b0:	4f00009d 	svcmi	0x0000009d
    a0b4:	0000045c 	andeq	r0, r0, ip, asr r4
    a0b8:	0000b954 	andeq	fp, r0, r4, asr r9
    a0bc:	0004744f 	andeq	r7, r4, pc, asr #8
    a0c0:	00b95400 	adcseq	r5, r9, r0, lsl #8
    a0c4:	05984f00 	ldreq	r4, [r8, #3840]	; 0xf00
    a0c8:	b8f90000 	ldmlt	r9!, {}^	; <UNPREDICTABLE>
    a0cc:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    a0d0:	005b4504 	subseq	r4, fp, r4, lsl #10
    a0d4:	120a3d00 	andne	r3, sl, #0, 26
    a0d8:	29010000 	stmdbcs	r1, {}	; <UNPREDICTABLE>
    a0dc:	00005703 	andeq	r5, r0, r3, lsl #14
    a0e0:	a12d0100 			; <UNDEFINED> instruction: 0xa12d0100
    a0e4:	cf440000 	svcgt	0x00440000
    a0e8:	01000050 	qaddeq	r0, r0, r0
    a0ec:	0057032b 	subseq	r0, r7, fp, lsr #6
    a0f0:	703f0000 	eorsvc	r0, pc, r0
    a0f4:	032c0100 			; <UNDEFINED> instruction: 0x032c0100
    a0f8:	000000f2 	strdeq	r0, [r0], -r2
    a0fc:	01006c3f 	tsteq	r0, pc, lsr ip
    a100:	0057032d 	subseq	r0, r7, sp, lsr #6
    a104:	c8440000 	stmdagt	r4, {}^	; <UNPREDICTABLE>
    a108:	01000029 	tsteq	r0, r9, lsr #32
    a10c:	a12d032e 			; <UNDEFINED> instruction: 0xa12d032e
    a110:	663f0000 	ldrtvs	r0, [pc], -r0
    a114:	01007464 	tsteq	r0, r4, ror #8
    a118:	30dc032f 	sbcscc	r0, ip, pc, lsr #6
    a11c:	44450000 	strbmi	r0, [r5], #-0
    a120:	00002f6d 	andeq	r2, r0, sp, ror #30
    a124:	c9034601 	stmdbgt	r3, {r0, r9, sl, lr}
    a128:	00000000 	andeq	r0, r0, r0
    a12c:	33040800 	movwcc	r0, #18432	; 0x4800
    a130:	090000a1 	stmdbeq	r0, {r0, r5, r7}
    a134:	00005a1c 	andeq	r5, r0, ip, lsl sl
    a138:	0042344b 	subeq	r3, r2, fp, asr #8
    a13c:	03570100 	cmpeq	r7, #0, 2
    a140:	00000057 	andeq	r0, r0, r7, asr r0
    a144:	00000000 	andeq	r0, r0, r0
    a148:	00000148 	andeq	r0, r0, r8, asr #2
    a14c:	a2079c01 	andge	r9, r7, #256	; 0x100
    a150:	62500000 	subsvs	r0, r0, #0
    a154:	01006675 	tsteq	r0, r5, ror r6
    a158:	01b30357 			; <UNDEFINED> instruction: 0x01b30357
    a15c:	05480000 	strbeq	r0, [r8, #-0]
    a160:	d54d0000 	strble	r0, [sp, #-0]
    a164:	1c0000a0 	stcne	0, cr0, [r0], {160}	; 0xa0
    a168:	20000000 	andcs	r0, r0, r0
    a16c:	01000001 	tsteq	r0, r1
    a170:	1c60035c 	stclne	3, cr0, [r0], #-368	; 0xfffffe90
    a174:	20000000 	andcs	r0, r0, r0
    a178:	5b000001 	blpl	a184 <.debug_info+0xa184>
    a17c:	0000a0e6 	andeq	sl, r0, r6, ror #1
    a180:	00a0f265 	adceq	pc, r0, r5, ror #4
    a184:	00056600 	andeq	r6, r5, r0, lsl #12
    a188:	a0fc6500 	rscsge	r6, ip, r0, lsl #10
    a18c:	058f0000 	streq	r0, [pc]	; 8 <.debug_info+0x8>
    a190:	06660000 	strbteq	r0, [r6], -r0
    a194:	010000a1 	smlatbeq	r0, r1, r0, r0
    a198:	a1126654 	tstge	r2, r4, asr r6
    a19c:	55010000 	strpl	r0, [r1, #-0]
    a1a0:	0001205c 	andeq	r2, r1, ip, asr r0
    a1a4:	00a1ce00 	adceq	ip, r1, r0, lsl #28
    a1a8:	a11f6500 	tstge	pc, r0, lsl #10
    a1ac:	05ae0000 	streq	r0, [lr, #0]!
    a1b0:	e84f0000 	stmda	pc, {}^	; <UNPREDICTABLE>
    a1b4:	60000000 	andvs	r0, r0, r0
    a1b8:	4f0000b9 	svcmi	0x000000b9
    a1bc:	0000011c 	andeq	r0, r0, ip, lsl r1
    a1c0:	0000b96c 	andeq	fp, r0, ip, ror #18
    a1c4:	00013c4f 	andeq	r3, r1, pc, asr #24
    a1c8:	00b97700 	adcseq	r7, r9, r0, lsl #14
    a1cc:	384f0000 	stmdacc	pc, {}^	; <UNPREDICTABLE>
    a1d0:	83000000 	movwhi	r0, #0
    a1d4:	4f0000b9 	svcmi	0x000000b9
    a1d8:	00000050 	andeq	r0, r0, r0, asr r0
    a1dc:	0000b983 	andeq	fp, r0, r3, lsl #19
    a1e0:	0000784f 	andeq	r7, r0, pc, asr #16
    a1e4:	00b98f00 	adcseq	r8, r9, r0, lsl #30
    a1e8:	00984f00 	addseq	r4, r8, r0, lsl #30
    a1ec:	b98f0000 	stmiblt	pc, {}	; <UNPREDICTABLE>
    a1f0:	b84f0000 	stmdalt	pc, {}^	; <UNPREDICTABLE>
    a1f4:	9b000000 	blls	a1fc <.debug_info+0xa1fc>
    a1f8:	4f0000b9 	svcmi	0x000000b9
    a1fc:	000000cc 	andeq	r0, r0, ip, asr #1
    a200:	0000b9a6 	andeq	fp, r0, r6, lsr #19
    a204:	67000000 	strvs	r0, [r0, -r0]
    a208:	000019d7 	ldrdeq	r1, [r0], -r7
    a20c:	78041801 	stmdavc	r4, {r0, fp, ip}
    a210:	48000003 	stmdami	r0, {r0, r1}
    a214:	18000001 	stmdane	r0, {r0}
    a218:	01000000 	mrseq	r0, (UNDEF: 0)
    a21c:	00a2789c 	umlaleq	r7, r2, ip, r8
    a220:	0c6b4c00 	stcleq	12, cr4, [fp], #-0
    a224:	18010000 	stmdane	r1, {}	; <UNPREDICTABLE>
    a228:	0000c904 	andeq	ip, r0, r4, lsl #18
    a22c:	0005d600 	andeq	sp, r5, r0, lsl #12
    a230:	30954c00 	addscc	r4, r5, r0, lsl #24
    a234:	18010000 	stmdane	r1, {}	; <UNPREDICTABLE>
    a238:	0000c904 	andeq	ip, r0, r4, lsl #18
    a23c:	0005ee00 	andeq	lr, r5, r0, lsl #28
    a240:	98445f00 	stmdals	r4, {r8, r9, sl, fp, ip, lr}^
    a244:	01580000 	cmpeq	r8, r0
    a248:	00040000 	andeq	r0, r4, r0
    a24c:	1a010000 	bne	4a254 <unflatten_and_copy_device_tree+0x493e0>
    a250:	00a26e04 	adceq	r6, r2, r4, lsl #28
    a254:	98544e00 	ldmdals	r4, {r9, sl, fp, lr}^
    a258:	58600000 	stmdapl	r0!, {}^	; <UNPREDICTABLE>
    a25c:	04000001 	streq	r0, [r0], #-1
    a260:	65000000 	strvs	r0, [r0, #-0]
    a264:	0000985d 	andeq	r9, r0, sp, asr r8
    a268:	00000606 	andeq	r0, r0, r6, lsl #12
    a26c:	584f0000 	stmdapl	pc, {}^	; <UNPREDICTABLE>
    a270:	b2000001 	andlt	r0, r0, #1
    a274:	000000b9 	strheq	r0, [r0], -r9
    a278:	00040c4b 	andeq	r0, r4, fp, asr #24
    a27c:	04940100 	ldreq	r0, [r4], #256	; 0x100
    a280:	00000057 	andeq	r0, r0, r7, asr r0
    a284:	00000160 	andeq	r0, r0, r0, ror #2
    a288:	00000078 	andeq	r0, r0, r8, ror r0
    a28c:	a2da9c01 	sbcsge	r9, sl, #256	; 0x100
    a290:	42680000 	rsbmi	r0, r8, #0
    a294:	01000045 	tsteq	r0, r5, asr #32
    a298:	56eb0496 	usatpl	r0, #11, r6, lsl #9
    a29c:	03050000 	movweq	r0, #20480	; 0x5000
    a2a0:	00000000 	andeq	r0, r0, r0
    a2a4:	0096f061 	addseq	pc, r6, r1, rrx
    a2a8:	00018000 	andeq	r8, r1, r0
    a2ac:	00014000 	andeq	r4, r1, r0
    a2b0:	049c0100 	ldreq	r0, [ip], #256	; 0x100
    a2b4:	0000a2be 			; <UNDEFINED> instruction: 0x0000a2be
    a2b8:	0097004e 	addseq	r0, r7, lr, asr #32
    a2bc:	944f0000 	strbls	r0, [pc], #-0	; 8 <.debug_info+0x8>
    a2c0:	be000001 	cdplt	0, 0, cr0, cr0, cr1, {0}
    a2c4:	4f0000b9 	svcmi	0x000000b9
    a2c8:	000001ac 	andeq	r0, r0, ip, lsr #3
    a2cc:	0000b8f9 	strdeq	fp, [r0], -r9
    a2d0:	0001d44f 	andeq	sp, r1, pc, asr #8
    a2d4:	00b9c900 	adcseq	ip, r9, r0, lsl #18
    a2d8:	fe690000 	cdp2	0, 6, cr0, cr9, cr0, {0}
    a2dc:	9c000098 	stcls	0, cr0, [r0], {152}	; 0x98
    a2e0:	38000005 	stmdacc	r0, {r0, r2}
    a2e4:	01000001 	tsteq	r0, r1
    a2e8:	00a3e99c 	umlaleq	lr, r3, ip, r9
    a2ec:	990b6a00 	stmdbls	fp, {r9, fp, sp, lr}
    a2f0:	06190000 	ldreq	r0, [r9], -r0
    a2f4:	176a0000 	strbne	r0, [sl, -r0]!
    a2f8:	37000099 			; <UNDEFINED> instruction: 0x37000099
    a2fc:	6a000006 	bvs	a31c <.debug_info+0xa31c>
    a300:	00009923 	andeq	r9, r0, r3, lsr #18
    a304:	00000655 	andeq	r0, r0, r5, asr r6
    a308:	00992f5b 	addseq	r2, r9, fp, asr pc
    a30c:	993b5b00 	ldmdbls	fp!, {r8, r9, fp, ip, lr}
    a310:	475b0000 	ldrbmi	r0, [fp, -r0]
    a314:	5c000099 	stcpl	0, cr0, [r0], {153}	; 0x99
    a318:	00000158 	andeq	r0, r0, r8, asr r1
    a31c:	0000a3d6 	ldrdeq	sl, [r0], -r6
    a320:	0099234e 	addseq	r2, r9, lr, asr #6
    a324:	99174e00 	ldmdbls	r7, {r9, sl, fp, lr}
    a328:	0b4e0000 	bleq	138a330 <unflatten_and_copy_device_tree+0x13894bc>
    a32c:	5a000099 	bpl	a598 <.debug_info+0xa598>
    a330:	00000158 	andeq	r0, r0, r8, asr r1
    a334:	00992f5b 	addseq	r2, r9, fp, asr pc
    a338:	993b6500 	ldmdbls	fp!, {r8, sl, sp, lr}
    a33c:	067e0000 	ldrbteq	r0, [lr], -r0
    a340:	475b0000 	ldrbmi	r0, [fp, -r0]
    a344:	5c000099 	stcpl	0, cr0, [r0], {153}	; 0x99
    a348:	00000170 	andeq	r0, r0, r0, ror r1
    a34c:	0000a36c 	andeq	sl, r0, ip, ror #6
    a350:	00995465 	addseq	r5, r9, r5, ror #8
    a354:	0006b600 	andeq	fp, r6, r0, lsl #12
    a358:	99606500 	stmdbls	r0!, {r8, sl, sp, lr}^
    a35c:	06c90000 	strbeq	r0, [r9], r0
    a360:	7c4f0000 	marvc	acc0, r0, pc
    a364:	d4000006 	strle	r0, [r0], #-6
    a368:	000000b9 	strheq	r0, [r0], -r9
    a36c:	00987f61 	addseq	r7, r8, r1, ror #30
    a370:	00065400 	andeq	r5, r6, r0, lsl #8
    a374:	00019000 	andeq	r9, r1, r0
    a378:	01ac0100 			; <UNDEFINED> instruction: 0x01ac0100
    a37c:	0000a3b0 			; <UNDEFINED> instruction: 0x0000a3b0
    a380:	00988f4e 	addseq	r8, r8, lr, asr #30
    a384:	970c6200 	strls	r6, [ip, -r0, lsl #4]
    a388:	06540000 	ldrbeq	r0, [r4], -r0
    a38c:	01900000 	orrseq	r0, r0, r0
    a390:	51700000 	cmnpl	r0, r0
    a394:	00971c4e 	addseq	r1, r7, lr, asr #24
    a398:	96f06300 	ldrbtls	r6, [r0], r0, lsl #6
    a39c:	06580000 	ldrbeq	r0, [r8], -r0
    a3a0:	00040000 	andeq	r0, r4, r0
    a3a4:	ac030000 	stcge	0, cr0, [r3], {-0}
    a3a8:	0097004e 	addseq	r0, r7, lr, asr #32
    a3ac:	00000000 	andeq	r0, r0, r0
    a3b0:	0005fc4f 	andeq	pc, r5, pc, asr #24
    a3b4:	009d2e00 	addseq	r2, sp, r0, lsl #28
    a3b8:	06544f00 	ldrbeq	r4, [r4], -r0, lsl #30
    a3bc:	9d2e0000 	stcls	0, cr0, [lr, #-0]
    a3c0:	ac4f0000 	marge	acc0, r0, pc
    a3c4:	2e000006 	cdpcs	0, 0, cr0, cr0, cr6, {0}
    a3c8:	4f00009d 	svcmi	0x0000009d
    a3cc:	000006c0 	andeq	r0, r0, r0, asr #13
    a3d0:	0000b8f9 	strdeq	fp, [r0], -r9
    a3d4:	c84f0000 	stmdagt	pc, {}^	; <UNPREDICTABLE>
    a3d8:	df000005 	svcle	0x00000005
    a3dc:	4f0000b9 	svcmi	0x000000b9
    a3e0:	000006d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    a3e4:	0000b8f9 	strdeq	fp, [r0], -r9
    a3e8:	2c256b00 	stccs	11, cr6, [r5], #-0
    a3ec:	c2010000 	andgt	r0, r1, #0
    a3f0:	0006d401 	andeq	sp, r6, r1, lsl #8
    a3f4:	00004c00 	andeq	r4, r0, r0, lsl #24
    a3f8:	3b9c0100 	blcc	fe70a800 <__crc_of_fdt_unflatten_tree+0x779c9243>
    a3fc:	4c0000a4 	stcmi	0, cr0, [r0], {164}	; 0xa4
    a400:	00002ee7 	andeq	r2, r0, r7, ror #29
    a404:	3b01c201 	blcc	7ac10 <unflatten_and_copy_device_tree+0x79d9c>
    a408:	dc0000a4 	stcle	0, cr0, [r0], {164}	; 0xa4
    a40c:	4c000006 	stcmi	0, cr0, [r0], {6}
    a410:	00004afb 	strdeq	r4, [r0], -fp
    a414:	6e01c301 	cdpvs	3, 0, cr12, cr1, cr1, {0}
    a418:	fa000099 	blx	26c <.debug_info+0x26c>
    a41c:	4f000006 	svcmi	0x00000006
    a420:	000006fc 	strdeq	r0, [r0], -ip
    a424:	0000b9ea 	andeq	fp, r0, sl, ror #19
    a428:	0007104f 	andeq	r1, r7, pc, asr #32
    a42c:	0098fe00 	addseq	pc, r8, r0, lsl #28
    a430:	07184f00 	ldreq	r4, [r8, -r0, lsl #30]
    a434:	b9f50000 	ldmiblt	r5!, {}^	; <UNPREDICTABLE>
    a438:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    a43c:	00a44104 	adceq	r4, r4, r4, lsl #2
    a440:	00d40900 	sbcseq	r0, r4, r0, lsl #18
    a444:	656c0000 	strbvs	r0, [ip, #-0]!
    a448:	0100004e 	tsteq	r0, lr, asr #32
    a44c:	00072028 	andeq	r2, r7, r8, lsr #32
    a450:	00013c00 	andeq	r3, r1, r0, lsl #24
    a454:	579c0100 	ldrpl	r0, [ip, r0, lsl #2]
    a458:	530000a5 	movwpl	r0, #165	; 0xa5
    a45c:	0000185c 	andeq	r1, r0, ip, asr r8
    a460:	00572801 	subseq	r2, r7, r1, lsl #16
    a464:	07180000 	ldreq	r0, [r8, -r0]
    a468:	55570000 	ldrbpl	r0, [r7, #-0]
    a46c:	01000060 	tsteq	r0, r0, rrx
    a470:	0000572a 	andeq	r5, r0, sl, lsr #14
    a474:	00073600 	andeq	r3, r7, r0, lsl #12
    a478:	656c5600 	strbvs	r5, [ip, #-1536]!	; 0xfffffa00
    a47c:	2b01006e 	blcs	4a63c <unflatten_and_copy_device_tree+0x497c8>
    a480:	00000057 	andeq	r0, r0, r7, asr r0
    a484:	00000749 	andeq	r0, r0, r9, asr #14
    a488:	6c617656 	stclvs	6, cr7, [r1], #-344	; 0xfffffea8
    a48c:	dc2c0100 	stfles	f0, [ip], #-0
    a490:	5d000030 	stcpl	0, cr0, [r0, #-192]	; 0xffffff40
    a494:	57000007 	strpl	r0, [r0, -r7]
    a498:	00003613 	andeq	r3, r0, r3, lsl r6
    a49c:	00572d01 	subseq	r2, r7, r1, lsl #26
    a4a0:	07700000 	ldrbeq	r0, [r0, -r0]!
    a4a4:	59420000 	stmdbpl	r2, {}^	; <UNPREDICTABLE>
    a4a8:	01000036 	tsteq	r0, r6, lsr r0
    a4ac:	0000572e 	andeq	r5, r0, lr, lsr #14
    a4b0:	26355700 	ldrtcs	r5, [r5], -r0, lsl #14
    a4b4:	2f010000 	svccs	0x00010000
    a4b8:	0000a557 	andeq	sl, r0, r7, asr r5
    a4bc:	00000799 	muleq	r0, r9, r7
    a4c0:	004c2442 	subeq	r2, ip, r2, asr #8
    a4c4:	57300100 	ldrpl	r0, [r0, -r0, lsl #2]!
    a4c8:	570000a5 	strpl	r0, [r0, -r5, lsr #1]
    a4cc:	00005d3b 	andeq	r5, r0, fp, lsr sp
    a4d0:	00573101 	subseq	r3, r7, r1, lsl #2
    a4d4:	07b70000 	ldreq	r0, [r7, r0]!
    a4d8:	1c420000 	marne	acc0, r0, r2
    a4dc:	01000007 	tsteq	r0, r7
    a4e0:	00005732 	andeq	r5, r0, r2, lsr r7
    a4e4:	96f05900 	ldrbtls	r5, [r0], r0, lsl #18
    a4e8:	077c0000 	ldrbeq	r0, [ip, -r0]!
    a4ec:	01a80000 			; <UNDEFINED> instruction: 0x01a80000
    a4f0:	3b010000 	blcc	4a4f8 <unflatten_and_copy_device_tree+0x49684>
    a4f4:	0000a4fe 	strdeq	sl, [r0], -lr
    a4f8:	0097004e 	addseq	r0, r7, lr, asr #32
    a4fc:	f06d0000 			; <UNDEFINED> instruction: 0xf06d0000
    a500:	b0000096 	mullt	r0, r6, r0
    a504:	0c000007 	stceq	0, cr0, [r0], {7}
    a508:	01000000 	mrseq	r0, (UNDEF: 0)
    a50c:	00a51740 	adceq	r1, r5, r0, asr #14
    a510:	97004e00 	strls	r4, [r0, -r0, lsl #28]
    a514:	4f000000 	svcmi	0x00000000
    a518:	00000754 	andeq	r0, r0, r4, asr r7
    a51c:	0000b983 	andeq	fp, r0, r3, lsl #19
    a520:	0007744f 	andeq	r7, r7, pc, asr #8
    a524:	00b98f00 	adcseq	r8, r9, r0, lsl #30
    a528:	079c4f00 	ldreq	r4, [ip, r0, lsl #30]
    a52c:	b98f0000 	stmiblt	pc, {}	; <UNPREDICTABLE>
    a530:	cc4f0000 	margt	acc0, r0, pc
    a534:	83000007 	movwhi	r0, #7
    a538:	4f0000b9 	svcmi	0x000000b9
    a53c:	000007ec 	andeq	r0, r0, ip, ror #15
    a540:	0000b98f 	andeq	fp, r0, pc, lsl #19
    a544:	0008284f 	andeq	r2, r8, pc, asr #16
    a548:	00ba0000 	adcseq	r0, sl, r0
    a54c:	08444f00 	stmdaeq	r4, {r8, r9, sl, fp, lr}^
    a550:	b98f0000 	stmiblt	pc, {}	; <UNPREDICTABLE>
    a554:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    a558:	00a55d04 	adceq	r5, r5, r4, lsl #26
    a55c:	025a0900 	subseq	r0, sl, #0, 18
    a560:	536e0000 	cmnpl	lr, #0
    a564:	01000042 	tsteq	r0, r2, asr #32
    a568:	0000575a 	andeq	r5, r0, sl, asr r7
    a56c:	00085c00 	andeq	r5, r8, r0, lsl #24
    a570:	00009800 	andeq	r9, r0, r0, lsl #16
    a574:	f89c0100 			; <UNDEFINED> instruction: 0xf89c0100
    a578:	530000a5 	movwpl	r0, #165	; 0xa5
    a57c:	00002ee7 	andeq	r2, r0, r7, ror #29
    a580:	30dc5a01 	sbcscc	r5, ip, r1, lsl #20
    a584:	07e00000 	strbeq	r0, [r0, r0]!
    a588:	3d530000 	ldclcc	0, cr0, [r3, #-0]
    a58c:	01000043 	tsteq	r0, r3, asr #32
    a590:	0000d45b 	andeq	sp, r0, fp, asr r4
    a594:	0007f300 	andeq	pc, r7, r0, lsl #6
    a598:	50855300 	addpl	r5, r5, r0, lsl #6
    a59c:	5b010000 	blpl	4a5a4 <unflatten_and_copy_device_tree+0x49730>
    a5a0:	000000f2 	strdeq	r0, [r0], -r2
    a5a4:	00000806 	andeq	r0, r0, r6, lsl #16
    a5a8:	0070636f 	rsbseq	r6, r0, pc, ror #6
    a5ac:	00f25d01 	rscseq	r5, r2, r1, lsl #26
    a5b0:	54010000 	strpl	r0, [r1], #-0
    a5b4:	001e4358 	andseq	r4, lr, r8, asr r3
    a5b8:	575e0100 	ldrbpl	r0, [lr, -r0, lsl #2]
    a5bc:	02000000 	andeq	r0, r0, #0
    a5c0:	6c565c91 	mrrcvs	12, 9, r5, r6, cr1
    a5c4:	d45f0100 	ldrble	r0, [pc], #-256	; a5cc <.debug_info+0xa5cc>
    a5c8:	24000000 	strcs	r0, [r0], #-0
    a5cc:	58000008 	stmdapl	r0, {r3}
    a5d0:	00000ff0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    a5d4:	00d45f01 	sbcseq	r5, r4, r1, lsl #30
    a5d8:	56010000 	strpl	r0, [r1], -r0
    a5dc:	0008884f 	andeq	r8, r8, pc, asr #16
    a5e0:	00b98f00 	adcseq	r8, r9, r0, lsl #30
    a5e4:	08a84f00 	stmiaeq	r8!, {r8, r9, sl, fp, lr}
    a5e8:	b91a0000 	ldmdblt	sl, {}	; <UNPREDICTABLE>
    a5ec:	cc4f0000 	margt	acc0, r0, pc
    a5f0:	0c000008 	stceq	0, cr0, [r0], {8}
    a5f4:	000000ba 	strheq	r0, [r0], -sl
    a5f8:	002d836e 	eoreq	r8, sp, lr, ror #6
    a5fc:	fb790100 	blx	1e4aa06 <unflatten_and_copy_device_tree+0x1e49b92>
    a600:	f4000001 	vst4.8	{d0-d3}, [r0], r1
    a604:	30000008 	andcc	r0, r0, r8
    a608:	01000000 	mrseq	r0, (UNDEF: 0)
    a60c:	00a6399c 	umlaleq	r3, r6, ip, r9
    a610:	2ee75300 	cdpcs	3, 14, cr5, cr7, cr0, {0}
    a614:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>
    a618:	000030dc 	ldrdeq	r3, [r0], -ip
    a61c:	00000842 	andeq	r0, r0, r2, asr #16
    a620:	00433d53 	subeq	r3, r3, r3, asr sp
    a624:	d4790100 	ldrbtle	r0, [r9], #-256	; 0xffffff00
    a628:	55000000 	strpl	r0, [r0, #-0]
    a62c:	4f000008 	svcmi	0x00000008
    a630:	00000918 	andeq	r0, r0, r8, lsl r9
    a634:	0000b98f 	andeq	fp, r0, pc, lsl #19
    a638:	476d6e00 	strbmi	r6, [sp, -r0, lsl #28]!
    a63c:	86010000 	strhi	r0, [r1], -r0
    a640:	00000057 	andeq	r0, r0, r7, asr r0
    a644:	00000924 	andeq	r0, r0, r4, lsr #18
    a648:	00000088 	andeq	r0, r0, r8, lsl #1
    a64c:	a69f9c01 	ldrge	r9, [pc], r1, lsl #24
    a650:	e7530000 	ldrb	r0, [r3, -r0]
    a654:	0100002e 	tsteq	r0, lr, lsr #32
    a658:	0030dc86 	eorseq	sp, r0, r6, lsl #25
    a65c:	00086800 	andeq	r6, r8, r0, lsl #16
    a660:	433d5300 	teqmi	sp, #0, 6
    a664:	86010000 	strhi	r0, [r1], -r0
    a668:	000000d4 	ldrdeq	r0, [r0], -r4
    a66c:	00000886 	andeq	r0, r0, r6, lsl #17
    a670:	00508553 	subseq	r8, r0, r3, asr r5
    a674:	9f870100 	svcls	0x00870100
    a678:	a40000a6 	strge	r0, [r0], #-166	; 0xffffff5a
    a67c:	3c000008 	stccc	0, cr0, [r0], {8}
    a680:	00706d74 	rsbseq	r6, r0, r4, ror sp
    a684:	00698901 	rsbeq	r8, r9, r1, lsl #18
    a688:	f0420000 			; <UNDEFINED> instruction: 0xf0420000
    a68c:	0100000f 	tsteq	r0, pc
    a690:	00006989 	andeq	r6, r0, r9, lsl #19
    a694:	09644f00 	stmdbeq	r4!, {r8, r9, sl, fp, lr}^
    a698:	a5620000 	strbge	r0, [r2, #-0]!
    a69c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    a6a0:	00a6a504 	adceq	sl, r6, r4, lsl #10
    a6a4:	00f20900 	rscseq	r0, r2, r0, lsl #18
    a6a8:	e3700000 	cmn	r0, #0
    a6ac:	01000015 	tsteq	r0, r5, lsl r0
    a6b0:	00570272 	subseq	r0, r7, r2, ror r2
    a6b4:	01d80000 	bicseq	r0, r8, r0
    a6b8:	00c80000 	sbceq	r0, r8, r0
    a6bc:	9c010000 	stcls	0, cr0, [r1], {-0}
    a6c0:	0000a780 	andeq	sl, r0, r0, lsl #15
    a6c4:	00746950 	rsbseq	r6, r4, r0, asr r9
    a6c8:	9f027201 	svcls	0x00027201
    a6cc:	c2000096 	andgt	r0, r0, #150	; 0x96
    a6d0:	4c000008 	stcmi	0, cr0, [r0], {8}
    a6d4:	00005dca 	andeq	r5, r0, sl, asr #27
    a6d8:	78027501 	stmdavc	r2, {r0, r8, sl, ip, sp, lr}
    a6dc:	e0000003 	and	r0, r0, r3
    a6e0:	68000008 	stmdavs	r0, {r3}
    a6e4:	00002ee7 	andeq	r2, r0, r7, ror #29
    a6e8:	dc027701 	stcle	7, cr7, [r2], {1}
    a6ec:	01000030 	tsteq	r0, r0, lsr r0
    a6f0:	5e465d57 	mcrpl	13, 2, r5, cr6, cr7, {2}
    a6f4:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    a6f8:	0000f202 	andeq	pc, r0, r2, lsl #4
    a6fc:	0008fe00 	andeq	pc, r8, r0, lsl #28
    a700:	50cf6800 	sbcpl	r6, pc, r0, lsl #16
    a704:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>
    a708:	00005702 	andeq	r5, r0, r2, lsl #14
    a70c:	5e540100 	rdfpls	f0, f4, f0
    a710:	01006372 	tsteq	r0, r2, ror r3
    a714:	00570279 	subseq	r0, r7, r9, ror r2
    a718:	091c0000 	ldmdbeq	ip, {}	; <UNPREDICTABLE>
    a71c:	1b5d0000 	blne	1740008 <unflatten_and_copy_device_tree+0x173f194>
    a720:	01000058 	qaddeq	r0, r8, r0
    a724:	00570279 	subseq	r0, r7, r9, ror r2
    a728:	093a0000 	ldmdbeq	sl!, {}	; <UNPREDICTABLE>
    a72c:	8e5f0000 	cdphi	0, 5, cr0, cr15, cr0, {0}
    a730:	58000099 	stmdapl	r0, {r0, r3, r4, r7}
    a734:	0c000002 	stceq	0, cr0, [r0], {2}
    a738:	01000000 	mrseq	r0, (UNDEF: 0)
    a73c:	a7640281 	strbge	r0, [r4, -r1, lsl #5]!
    a740:	9e4e0000 	cdpls	0, 4, cr0, cr14, cr0, {0}
    a744:	60000099 	mulvs	r0, r9, r0
    a748:	00000258 	andeq	r0, r0, r8, asr r2
    a74c:	0000000c 	andeq	r0, r0, ip
    a750:	0099a965 	addseq	sl, r9, r5, ror #18
    a754:	00095a00 	andeq	r5, r9, r0, lsl #20
    a758:	025c4f00 	subseq	r4, ip, #0, 30
    a75c:	ba170000 	blt	5ca764 <unflatten_and_copy_device_tree+0x5c98f0>
    a760:	00000000 	andeq	r0, r0, r0
    a764:	00021c4f 	andeq	r1, r2, pc, asr #24
    a768:	00b94900 	adcseq	r4, r9, r0, lsl #18
    a76c:	02484f00 	subeq	r4, r8, #0, 30
    a770:	b9250000 	stmdblt	r5!, {}	; <UNPREDICTABLE>
    a774:	8c4f0000 	marhi	acc0, r0, pc
    a778:	49000002 	stmdbmi	r0, {r1}
    a77c:	000000b9 	strheq	r0, [r0], -r9
    a780:	009ac971 	addseq	ip, sl, r1, ror r9
    a784:	0002a000 	andeq	sl, r2, r0
    a788:	00001400 	andeq	r1, r0, r0, lsl #8
    a78c:	679c0100 	ldrvs	r0, [ip, r0, lsl #2]
    a790:	000052a1 	andeq	r5, r0, r1, lsr #5
    a794:	57029201 	strpl	r9, [r2, -r1, lsl #4]
    a798:	b4000000 	strlt	r0, [r0], #-0
    a79c:	24000002 	strcs	r0, [r0], #-2
    a7a0:	01000000 	mrseq	r0, (UNDEF: 0)
    a7a4:	00a7c09c 	umlaleq	ip, r7, ip, r0
    a7a8:	96f04d00 	ldrbtls	r4, [r0], r0, lsl #26
    a7ac:	02cc0000 	sbceq	r0, ip, #0
    a7b0:	00040000 	andeq	r0, r4, r0
    a7b4:	94010000 	strls	r0, [r1], #-0
    a7b8:	97004e02 	strls	r4, [r0, -r2, lsl #28]
    a7bc:	00000000 	andeq	r0, r0, r0
    a7c0:	0017e267 	andseq	lr, r7, r7, ror #4
    a7c4:	029d0100 	addseq	r0, sp, #0, 2
    a7c8:	000030dc 	ldrdeq	r3, [r0], -ip
    a7cc:	000002d8 	ldrdeq	r0, [r0], -r8
    a7d0:	0000002c 	andeq	r0, r0, ip, lsr #32
    a7d4:	a8149c01 	ldmdage	r4, {r0, sl, fp, ip, pc}
    a7d8:	3d4c0000 	stclcc	0, cr0, [ip, #-0]
    a7dc:	01000043 	tsteq	r0, r3, asr #32
    a7e0:	00d4029d 	smullseq	r0, r4, sp, r2
    a7e4:	096d0000 	stmdbeq	sp!, {}^	; <UNPREDICTABLE>
    a7e8:	9b4c0000 	blls	1300008 <unflatten_and_copy_device_tree+0x12ff194>
    a7ec:	01000005 	tsteq	r0, r5
    a7f0:	00f2029d 	smlalseq	r0, r2, sp, r2
    a7f4:	09800000 	stmibeq	r0, {}	; <UNPREDICTABLE>
    a7f8:	6b4c0000 	blvs	1300008 <unflatten_and_copy_device_tree+0x12ff194>
    a7fc:	0100000c 	tsteq	r0, ip
    a800:	1abb029e 	bne	feecb280 <__crc_of_fdt_unflatten_tree+0x78189cc3>
    a804:	09930000 	ldmibeq	r3, {}	; <UNPREDICTABLE>
    a808:	004f0000 	subeq	r0, pc, r0
    a80c:	8f000003 	svchi	0x00000003
    a810:	000000b9 	strheq	r0, [r0], -r9
    a814:	0099b572 	addseq	fp, r9, r2, ror r5
    a818:	00030400 	andeq	r0, r3, r0, lsl #8
    a81c:	00008800 	andeq	r8, r0, r0, lsl #16
    a820:	109c0100 	addsne	r0, ip, r0, lsl #2
    a824:	6a0000a9 	bvs	aad0 <.debug_info+0xaad0>
    a828:	000099c6 	andeq	r9, r0, r6, asr #19
    a82c:	000009a6 	andeq	r0, r0, r6, lsr #19
    a830:	0099d26a 	addseq	sp, r9, sl, ror #4
    a834:	0009c400 	andeq	ip, r9, r0, lsl #8
    a838:	99de6a00 	ldmibls	lr, {r9, fp, sp, lr}^
    a83c:	09e20000 	stmibeq	r2!, {}^	; <UNPREDICTABLE>
    a840:	ea6a0000 	b	1a8a848 <unflatten_and_copy_device_tree+0x1a899d4>
    a844:	00000099 	muleq	r0, r9, r0
    a848:	5b00000a 	blpl	a878 <.debug_info+0xa878>
    a84c:	000099f6 	strdeq	r9, [r0], -r6
    a850:	0001c05a 	andeq	ip, r1, sl, asr r0
    a854:	99d24e00 	ldmibls	r2, {r9, sl, fp, lr}^
    a858:	de4e0000 	cdple	0, 4, cr0, cr14, cr0, {0}
    a85c:	4e000099 	mcrmi	0, 0, r0, cr0, cr9, {4}
    a860:	000099ea 	andeq	r9, r0, sl, ror #19
    a864:	0099c64e 	addseq	ip, r9, lr, asr #12
    a868:	01c05a00 	biceq	r5, r0, r0, lsl #20
    a86c:	f65b0000 			; <UNDEFINED> instruction: 0xf65b0000
    a870:	61000099 	swpvs	r0, r9, [r0]	; <UNPREDICTABLE>
    a874:	0000987f 	andeq	r9, r0, pc, ror r8
    a878:	0000034c 	andeq	r0, r0, ip, asr #6
    a87c:	000001d8 	ldrdeq	r0, [r0], -r8
    a880:	b7037101 	strlt	r7, [r3, -r1, lsl #2]
    a884:	4e0000a8 	cdpmi	0, 0, cr0, cr0, cr8, {5}
    a888:	0000988f 	andeq	r9, r0, pc, lsl #17
    a88c:	00970c62 	addseq	r0, r7, r2, ror #24
    a890:	00034c00 	andeq	r4, r3, r0, lsl #24
    a894:	0001d800 	andeq	sp, r1, r0, lsl #16
    a898:	4e517000 	cdpmi	0, 5, cr7, cr1, cr0, {0}
    a89c:	0000971c 	andeq	r9, r0, ip, lsl r7
    a8a0:	0096f062 	addseq	pc, r6, r2, rrx
    a8a4:	00034c00 	andeq	r4, r3, r0, lsl #24
    a8a8:	0001f000 	andeq	pc, r1, r0
    a8ac:	4eac0300 	cdpmi	3, 10, cr0, cr12, cr0, {0}
    a8b0:	00009700 	andeq	r9, r0, r0, lsl #14
    a8b4:	61000000 	mrsvs	r0, (UNDEF: 0)
    a8b8:	0000987f 	andeq	r9, r0, pc, ror r8
    a8bc:	00000368 	andeq	r0, r0, r8, ror #6
    a8c0:	00000208 	andeq	r0, r0, r8, lsl #4
    a8c4:	fb037601 	blx	e80d2 <unflatten_and_copy_device_tree+0xe725e>
    a8c8:	4e0000a8 	cdpmi	0, 0, cr0, cr0, cr8, {5}
    a8cc:	0000988f 	andeq	r9, r0, pc, lsl #17
    a8d0:	00970c62 	addseq	r0, r7, r2, ror #24
    a8d4:	00036800 	andeq	r6, r3, r0, lsl #16
    a8d8:	00020800 	andeq	r0, r2, r0, lsl #16
    a8dc:	4e517000 	cdpmi	0, 5, cr7, cr1, cr0, {0}
    a8e0:	0000971c 	andeq	r9, r0, ip, lsl r7
    a8e4:	0096f062 	addseq	pc, r6, r2, rrx
    a8e8:	00036800 	andeq	r6, r3, r0, lsl #16
    a8ec:	00022000 	andeq	r2, r2, r0
    a8f0:	4eac0300 	cdpmi	3, 10, cr0, cr12, cr0, {0}
    a8f4:	00009700 	andeq	r9, r0, r0, lsl #14
    a8f8:	4f000000 	svcmi	0x00000000
    a8fc:	0000033c 	andeq	r0, r0, ip, lsr r3
    a900:	0000a7c0 	andeq	sl, r0, r0, asr #15
    a904:	0003604f 	andeq	r6, r3, pc, asr #32
    a908:	00a7c000 	adceq	ip, r7, r0
    a90c:	00000000 	andeq	r0, r0, r0
    a910:	0001e348 	andeq	lr, r1, r8, asr #6
    a914:	03090100 	movweq	r0, #37120	; 0x9100
    a918:	00a95a01 	adceq	r5, r9, r1, lsl #20
    a91c:	433d4300 	teqmi	sp, #0, 6
    a920:	09010000 	stmdbeq	r1, {}	; <UNPREDICTABLE>
    a924:	0000d403 	andeq	sp, r0, r3, lsl #8
    a928:	48d44400 	ldmmi	r4, {sl, lr}^
    a92c:	0b010000 	bleq	4a934 <unflatten_and_copy_device_tree+0x49ac0>
    a930:	0000c903 	andeq	ip, r0, r3, lsl #18
    a934:	6e653f00 	cdpvs	15, 6, cr3, cr5, cr0, {0}
    a938:	0b010064 	bleq	4aad0 <unflatten_and_copy_device_tree+0x49c5c>
    a93c:	0000c903 	andeq	ip, r0, r3, lsl #18
    a940:	656c3f00 	strbvs	r3, [ip, #-3840]!	; 0xfffff100
    a944:	0c01006e 	stceq	0, cr0, [r1], {110}	; 0x6e
    a948:	00005703 	andeq	r5, r0, r3, lsl #14
    a94c:	47ed4400 	strbmi	r4, [sp, r0, lsl #8]!
    a950:	0d010000 	stceq	0, cr0, [r1, #-0]
    a954:	00989903 	addseq	r9, r8, r3, lsl #18
    a958:	59720000 	ldmdbpl	r2!, {}^	; <UNPREDICTABLE>
    a95c:	8c00009a 	stchi	0, cr0, [r0], {154}	; 0x9a
    a960:	b0000003 	andlt	r0, r0, r3
    a964:	01000001 	tsteq	r0, r1
    a968:	00ab4f9c 	umlaleq	r4, fp, ip, pc	; <UNPREDICTABLE>
    a96c:	9a6a6a00 	bls	1aa5174 <unflatten_and_copy_device_tree+0x1aa4300>
    a970:	0a1e0000 	beq	780008 <unflatten_and_copy_device_tree+0x77f194>
    a974:	766a0000 	strbtvc	r0, [sl], -r0
    a978:	3c00009a 	stccc	0, cr0, [r0], {154}	; 0x9a
    a97c:	6a00000a 	bvs	a9ac <.debug_info+0xa9ac>
    a980:	00009a82 	andeq	r9, r0, r2, lsl #21
    a984:	00000a5a 	andeq	r0, r0, sl, asr sl
    a988:	009a8e6a 	addseq	r8, sl, sl, ror #28
    a98c:	000a7800 	andeq	r7, sl, r0, lsl #16
    a990:	9a9a5b00 	bls	fe6a1598 <__crc_of_fdt_unflatten_tree+0x7795ffdb>
    a994:	a45b0000 	ldrbge	r0, [fp], #-0
    a998:	6400009a 	strvs	r0, [r0], #-154	; 0xffffff66
    a99c:	000003f8 	strdeq	r0, [r0], -r8
    a9a0:	0000013c 	andeq	r0, r0, ip, lsr r1
    a9a4:	0000ab3c 	andeq	sl, r0, ip, lsr fp
    a9a8:	009a764e 	addseq	r7, sl, lr, asr #12
    a9ac:	9a824e00 	bls	fe09e1b4 <__crc_of_fdt_unflatten_tree+0x7735cbf7>
    a9b0:	8e4e0000 	cdphi	0, 4, cr0, cr14, cr0, {0}
    a9b4:	4e00009a 	mcrmi	0, 0, r0, cr0, cr10, {4}
    a9b8:	00009a6a 	andeq	r9, r0, sl, ror #20
    a9bc:	0003f860 	andeq	pc, r3, r0, ror #16
    a9c0:	00013c00 	andeq	r3, r1, r0, lsl #24
    a9c4:	9a9a6600 	bls	fe6a41cc <__crc_of_fdt_unflatten_tree+0x77962c0f>
    a9c8:	91020000 	mrsls	r0, (UNDEF: 2)
    a9cc:	9aa46554 	bls	fe923f24 <__crc_of_fdt_unflatten_tree+0x77be2967>
    a9d0:	0a960000 	beq	fe580008 <__crc_of_fdt_unflatten_tree+0x7783ea4b>
    a9d4:	105f0000 	subsne	r0, pc, r0
    a9d8:	f80000a9 			; <UNDEFINED> instruction: 0xf80000a9
    a9dc:	e0000003 	and	r0, r0, r3
    a9e0:	01000000 	mrseq	r0, (UNDEF: 0)
    a9e4:	ab1f03c1 	blge	7cb8f0 <unflatten_and_copy_device_tree+0x7caa7c>
    a9e8:	1d4e0000 	stclne	0, cr0, [lr, #-0]
    a9ec:	600000a9 	andvs	r0, r0, r9, lsr #1
    a9f0:	000003f8 	strdeq	r0, [r0], -r8
    a9f4:	000000e0 	andeq	r0, r0, r0, ror #1
    a9f8:	00a9295b 	adceq	r2, r9, fp, asr r9
    a9fc:	a9356500 	ldmdbge	r5!, {r8, sl, sp, lr}
    aa00:	0abf0000 	beq	fefc0008 <__crc_of_fdt_unflatten_tree+0x7827ea4b>
    aa04:	41650000 	cmnmi	r5, r0
    aa08:	d70000a9 	strle	r0, [r0, -r9, lsr #1]
    aa0c:	5b00000a 	blpl	aa3c <.debug_info+0xaa3c>
    aa10:	0000a94d 	andeq	sl, r0, sp, asr #18
    aa14:	009a0361 	addseq	r0, sl, r1, ror #6
    aa18:	00041800 	andeq	r1, r4, r0, lsl #16
    aa1c:	00023800 	andeq	r3, r2, r0, lsl #16
    aa20:	03140100 	tsteq	r4, #0, 2
    aa24:	0000aa57 	andeq	sl, r0, r7, asr sl
    aa28:	009a1e6a 	addseq	r1, sl, sl, ror #28
    aa2c:	000b0d00 	andeq	r0, fp, r0, lsl #26
    aa30:	9a134e00 	bls	4de238 <unflatten_and_copy_device_tree+0x4dd3c4>
    aa34:	385a0000 	ldmdacc	sl, {}^	; <UNPREDICTABLE>
    aa38:	5b000002 	blpl	aa48 <.debug_info+0xaa48>
    aa3c:	00009a29 	andeq	r9, r0, r9, lsr #20
    aa40:	0096f063 	addseq	pc, r6, r3, rrx
    aa44:	00043800 	andeq	r3, r4, r0, lsl #16
    aa48:	00000800 	andeq	r0, r0, r0, lsl #16
    aa4c:	4ecb0400 	cdpmi	4, 12, cr0, cr11, cr0, {0}
    aa50:	00009700 	andeq	r9, r0, r0, lsl #14
    aa54:	61000000 	mrsvs	r0, (UNDEF: 0)
    aa58:	00009a03 	andeq	r9, r0, r3, lsl #20
    aa5c:	00000468 	andeq	r0, r0, r8, ror #8
    aa60:	00000250 	andeq	r0, r0, r0, asr r2
    aa64:	9a031901 	bls	d0e70 <unflatten_and_copy_device_tree+0xcfffc>
    aa68:	6a0000aa 	bvs	ad18 <.debug_info+0xad18>
    aa6c:	00009a1e 	andeq	r9, r0, lr, lsl sl
    aa70:	00000b20 	andeq	r0, r0, r0, lsr #22
    aa74:	009a134e 	addseq	r1, sl, lr, asr #6
    aa78:	02505a00 	subseq	r5, r0, #0, 20
    aa7c:	295b0000 	ldmdbcs	fp, {}^	; <UNPREDICTABLE>
    aa80:	6200009a 	andvs	r0, r0, #154	; 0x9a
    aa84:	000096f0 	strdeq	r9, [r0], -r0
    aa88:	00000494 	muleq	r0, r4, r4
    aa8c:	00000268 	andeq	r0, r0, r8, ror #4
    aa90:	004ecb04 	subeq	ip, lr, r4, lsl #22
    aa94:	00000097 	muleq	r0, r7, r0
    aa98:	335f0000 	cmpcc	pc, #0
    aa9c:	a800009a 	stmdage	r0, {r1, r3, r4, r7}
    aaa0:	30000004 	andcc	r0, r0, r4
    aaa4:	01000000 	mrseq	r0, (UNDEF: 0)
    aaa8:	ab0b031b 	blge	2cb71c <unflatten_and_copy_device_tree+0x2ca8a8>
    aaac:	4c4e0000 	marmi	acc0, r0, lr
    aab0:	4e00009a 	mcrmi	0, 0, r0, cr0, cr10, {4}
    aab4:	00009a40 	andeq	r9, r0, r0, asr #20
    aab8:	0098445f 	addseq	r4, r8, pc, asr r4
    aabc:	0004c000 	andeq	ip, r4, r0
    aac0:	00000400 	andeq	r0, r0, r0, lsl #8
    aac4:	02ff0100 	rscseq	r0, pc, #0, 2
    aac8:	0000aae3 	andeq	sl, r0, r3, ror #21
    aacc:	0098544e 	addseq	r5, r8, lr, asr #8
    aad0:	04c06000 	strbeq	r6, [r0], #0
    aad4:	00040000 	andeq	r0, r4, r0
    aad8:	5d660000 	stclpl	0, cr0, [r6, #-0]
    aadc:	01000098 	swpeq	r0, r8, [r0]	; <UNPREDICTABLE>
    aae0:	4d000054 	stcmi	0, cr0, [r0, #-336]	; 0xfffffeb0
    aae4:	00009844 	andeq	r9, r0, r4, asr #16
    aae8:	000004c4 	andeq	r0, r0, r4, asr #9
    aaec:	00000004 	andeq	r0, r0, r4
    aaf0:	4e030001 	cdpmi	0, 0, cr0, cr3, cr1, {0}
    aaf4:	00009854 	andeq	r9, r0, r4, asr r8
    aaf8:	0004c460 	andeq	ip, r4, r0, ror #8
    aafc:	00000400 	andeq	r0, r0, r0, lsl #8
    ab00:	985d6600 	ldmdals	sp, {r9, sl, sp, lr}^
    ab04:	56010000 	strpl	r0, [r1], -r0
    ab08:	4f000000 	svcmi	0x00000000
    ab0c:	0000040c 	andeq	r0, r0, ip, lsl #8
    ab10:	0000a7c0 	andeq	sl, r0, r0, asr #15
    ab14:	00045c4f 	andeq	r5, r4, pc, asr #24
    ab18:	00a7c000 	adceq	ip, r7, r0
    ab1c:	4f000000 	svcmi	0x00000000
    ab20:	000004ec 	andeq	r0, r0, ip, ror #9
    ab24:	0000a7c0 	andeq	sl, r0, r0, asr #15
    ab28:	0005104f 	andeq	r1, r5, pc, asr #32
    ab2c:	00ba2200 	adcseq	r2, sl, r0, lsl #4
    ab30:	05304f00 	ldreq	r4, [r0, #-3840]!	; 0xfffff100
    ab34:	ba220000 	blt	88ab3c <unflatten_and_copy_device_tree+0x889cc8>
    ab38:	00000000 	andeq	r0, r0, r0
    ab3c:	0003d44f 	andeq	sp, r3, pc, asr #8
    ab40:	00b8e200 	adcseq	lr, r8, r0, lsl #4
    ab44:	03ec4f00 	mvneq	r4, #0, 30
    ab48:	b8e20000 	stmialt	r2!, {}^	; <UNPREDICTABLE>
    ab4c:	67000000 	strvs	r0, [r0, -r0]
    ab50:	0000309b 	muleq	r0, fp, r0
    ab54:	5702a801 	strpl	sl, [r2, -r1, lsl #16]
    ab58:	3c000000 	stccc	0, cr0, [r0], {-0}
    ab5c:	28000005 	stmdacs	r0, {r0, r2}
    ab60:	01000000 	mrseq	r0, (UNDEF: 0)
    ab64:	00ab939c 	umlaleq	r9, fp, ip, r3
    ab68:	433d4c00 	teqmi	sp, #0, 24
    ab6c:	a8010000 	stmdage	r1, {}	; <UNPREDICTABLE>
    ab70:	0000d402 	andeq	sp, r0, r2, lsl #8
    ab74:	000b3300 	andeq	r3, fp, r0, lsl #6
    ab78:	50854c00 	addpl	r4, r5, r0, lsl #24
    ab7c:	a8010000 	stmdage	r1, {}	; <UNPREDICTABLE>
    ab80:	0000f202 	andeq	pc, r0, r2, lsl #4
    ab84:	000b4600 	andeq	r4, fp, r0, lsl #12
    ab88:	05604f00 	strbeq	r4, [r0, #-3840]!	; 0xfffff100
    ab8c:	a5620000 	strbge	r0, [r2, #-0]!
    ab90:	67000000 	strvs	r0, [r0, -r0]
    ab94:	00004176 	andeq	r4, r0, r6, ror r1
    ab98:	5702b001 	strpl	fp, [r2, -r1]
    ab9c:	64000000 	strvs	r0, [r0], #-0
    aba0:	28000005 	stmdacs	r0, {r0, r2}
    aba4:	01000000 	mrseq	r0, (UNDEF: 0)
    aba8:	00abd79c 	umlaleq	sp, fp, ip, r7
    abac:	433d4c00 	teqmi	sp, #0, 24
    abb0:	b0010000 	andlt	r0, r1, r0
    abb4:	0000d402 	andeq	sp, r0, r2, lsl #8
    abb8:	000b5900 	andeq	r5, fp, r0, lsl #18
    abbc:	50854c00 	addpl	r4, r5, r0, lsl #24
    abc0:	b0010000 	andlt	r0, r1, r0
    abc4:	00a69f02 	adceq	r9, r6, r2, lsl #30
    abc8:	000b6c00 	andeq	r6, fp, r0, lsl #24
    abcc:	05884f00 	streq	r4, [r8, #3840]	; 0xf00
    abd0:	a6390000 	ldrtge	r0, [r9], -r0
    abd4:	72000000 	andvc	r0, r0, #0
    abd8:	00009ad6 	ldrdeq	r9, [r0], -r6
    abdc:	0000058c 	andeq	r0, r0, ip, lsl #11
    abe0:	00000040 	andeq	r0, r0, r0, asr #32
    abe4:	ac239c01 	stcge	12, cr9, [r3], #-4
    abe8:	e7650000 	strb	r0, [r5, -r0]!
    abec:	7f00009a 	svcvc	0x0000009a
    abf0:	5b00000b 	blpl	ac24 <.debug_info+0xac24>
    abf4:	00009af3 	strdeq	r9, [r0], -r3
    abf8:	0005b464 	andeq	fp, r5, r4, ror #8
    abfc:	00001000 	andeq	r1, r0, r0
    ac00:	00ac1900 	adceq	r1, ip, r0, lsl #18
    ac04:	9ae75b00 	bls	ff9e180c <__crc_of_fdt_unflatten_tree+0x78ca024f>
    ac08:	f35b0000 	vhadd.u16	d16, d11, d0
    ac0c:	4f00009a 	svcmi	0x0000009a
    ac10:	000005c0 	andeq	r0, r0, r0, asr #11
    ac14:	0000a7c0 	andeq	sl, r0, r0, asr #15
    ac18:	05ac4f00 	streq	r4, [ip, #3840]!	; 0xf00
    ac1c:	a7c00000 	strbge	r0, [r0, r0]
    ac20:	70000000 	andvc	r0, r0, r0
    ac24:	000033c5 	andeq	r3, r0, r5, asr #7
    ac28:	dc02d201 	sfmle	f5, 1, [r2], {1}
    ac2c:	cc000030 	stcgt	0, cr0, [r0], {48}	; 0x30
    ac30:	0c000005 	stceq	0, cr0, [r0], {5}
    ac34:	01000001 	tsteq	r0, r1
    ac38:	00ad269c 	umlaleq	r2, sp, ip, r6
    ac3c:	456b4c00 	strbmi	r4, [fp, #-3072]!	; 0xfffff400
    ac40:	d2010000 	andle	r0, r1, #0
    ac44:	0030dc02 	eorseq	sp, r0, r2, lsl #24
    ac48:	000b9d00 	andeq	r9, fp, r0, lsl #26
    ac4c:	608b5100 	addvs	r5, fp, r0, lsl #2
    ac50:	d3010000 	movwle	r0, #4096	; 0x1000
    ac54:	00ad3b02 	adceq	r3, sp, r2, lsl #22
    ac58:	44510100 	ldrbmi	r0, [r1], #-256	; 0xffffff00
    ac5c:	00005dca 	andeq	r5, r0, sl, asr #27
    ac60:	dc02d501 	cfstr32le	mvfx13, [r2], {1}
    ac64:	44000030 	strmi	r0, [r0], #-48	; 0xffffffd0
    ac68:	0000329c 	muleq	r0, ip, r2
    ac6c:	dc02d601 	stcle	6, cr13, [r2], {1}
    ac70:	68000030 	stmdavs	r0, {r4, r5}
    ac74:	00005085 	andeq	r5, r0, r5, lsl #1
    ac78:	9f02d701 	svcls	0x0002d701
    ac7c:	020000a6 	andeq	r0, r0, #166	; 0xa6
    ac80:	a6445891 			; <UNDEFINED> instruction: 0xa6445891
    ac84:	0100005a 	qaddeq	r0, sl, r0
    ac88:	00d402d8 	ldrsbeq	r0, [r4], #40	; 0x28
    ac8c:	33440000 	movtcc	r0, #16384	; 0x4000
    ac90:	01000017 	tsteq	r0, r7, lsl r0
    ac94:	006902d9 	ldrdeq	r0, [r9], #-41	; 0xffffffd7	; <UNPREDICTABLE>
    ac98:	f0440000 			; <UNDEFINED> instruction: 0xf0440000
    ac9c:	0100000f 	tsteq	r0, pc
    aca0:	006902d9 	ldrdeq	r0, [r9], #-41	; 0xffffffd7	; <UNPREDICTABLE>
    aca4:	30640000 	rsbcc	r0, r4, r0
    aca8:	88000006 	stmdahi	r0, {r1, r2}
    acac:	0a000000 	beq	acb4 <.debug_info+0xacb4>
    acb0:	5d0000ad 	stcpl	0, cr0, [r0, #-692]	; 0xfffffd4c
    acb4:	000047ed 	andeq	r4, r0, sp, ror #15
    acb8:	f202e401 	vshl.s8	d14, d1, d2
    acbc:	e7000000 	str	r0, [r0, -r0]
    acc0:	5d00000b 	stcpl	0, cr0, [r0, #-44]	; 0xffffffd4
    acc4:	00000c6b 	andeq	r0, r0, fp, ror #24
    acc8:	5702e501 	strpl	lr, [r2, -r1, lsl #10]
    accc:	05000000 	streq	r0, [r0, #-0]
    acd0:	4f00000c 	svcmi	0x0000000c
    acd4:	0000063c 	andeq	r0, r0, ip, lsr r6
    acd8:	0000b8f9 	strdeq	fp, [r0], -r9
    acdc:	0006504f 	andeq	r5, r6, pc, asr #32
    ace0:	00a7c000 	adceq	ip, r7, r0
    ace4:	066c4f00 	strbteq	r4, [ip], -r0, lsl #30
    ace8:	b8f90000 	ldmlt	r9!, {}^	; <UNPREDICTABLE>
    acec:	8c4f0000 	marhi	acc0, r0, pc
    acf0:	f9000006 			; <UNDEFINED> instruction: 0xf9000006
    acf4:	4f0000b8 	svcmi	0x000000b8
    acf8:	00000694 	muleq	r0, r4, r6
    acfc:	0000b91a 	andeq	fp, r0, sl, lsl r9
    ad00:	0006ac4f 	andeq	sl, r6, pc, asr #24
    ad04:	00b91a00 	adcseq	r1, r9, r0, lsl #20
    ad08:	044f0000 	strbeq	r0, [pc], #-0	; 8 <.debug_info+0x8>
    ad0c:	93000006 	movwls	r0, #6
    ad10:	4f0000ab 	svcmi	0x000000ab
    ad14:	000006bc 			; <UNDEFINED> instruction: 0x000006bc
    ad18:	00009ad6 	ldrdeq	r9, [r0], -r6
    ad1c:	0006cc4f 	andeq	ip, r6, pc, asr #24
    ad20:	00b8f900 	adcseq	pc, r8, r0, lsl #18
    ad24:	dc150000 	ldcle	0, cr0, [r5], {-0}
    ad28:	35000030 	strcc	r0, [r0, #-48]	; 0xffffffd0
    ad2c:	0d0000ad 	stceq	0, cr0, [r0, #-692]	; 0xfffffd4c
    ad30:	0000ad35 	andeq	sl, r0, r5, lsr sp
    ad34:	9f040800 	svcls	0x00040800
    ad38:	080000a6 	stmdaeq	r0, {r1, r2, r5, r7}
    ad3c:	00ad2604 	adceq	r2, sp, r4, lsl #12
    ad40:	29e46700 	stmibcs	r4!, {r8, r9, sl, sp, lr}^
    ad44:	7d010000 	stcvc	0, cr0, [r1, #-0]
    ad48:	0000c903 	andeq	ip, r0, r3, lsl #18
    ad4c:	0006d800 	andeq	sp, r6, r0, lsl #16
    ad50:	00005400 	andeq	r5, r0, r0, lsl #8
    ad54:	c59c0100 	ldrgt	r0, [ip, #256]	; 0x100
    ad58:	500000ad 	andpl	r0, r0, sp, lsr #1
    ad5c:	7d010073 	stcvc	0, cr0, [r1, #-460]	; 0xfffffe34
    ad60:	00005703 	andeq	r5, r0, r3, lsl #14
    ad64:	000c4700 	andeq	r4, ip, r0, lsl #14
    ad68:	2c194c00 	ldccs	12, cr4, [r9], {-0}
    ad6c:	7d010000 	stcvc	0, cr0, [r1, #-0]
    ad70:	00adc503 	adceq	ip, sp, r3, lsl #10
    ad74:	000c6500 	andeq	r6, ip, r0, lsl #10
    ad78:	00707300 	rsbseq	r7, r0, r0, lsl #6
    ad7c:	99037f01 	stmdbls	r3, {r0, r8, r9, sl, fp, ip, sp, lr}
    ad80:	01000098 	swpeq	r0, r8, [r0]	; <UNPREDICTABLE>
    ad84:	9a037452 	bls	e7ed4 <unflatten_and_copy_device_tree+0xe7060>
    ad88:	06f00000 	ldrbteq	r0, [r0], r0
    ad8c:	02800000 	addeq	r0, r0, #0
    ad90:	82010000 	andhi	r0, r1, #0
    ad94:	9a1e4e03 	bls	79e5a8 <unflatten_and_copy_device_tree+0x79d734>
    ad98:	134e0000 	movtne	r0, #57344	; 0xe000
    ad9c:	5a00009a 	bpl	b00c <.debug_info+0xb00c>
    ada0:	00000280 	andeq	r0, r0, r0, lsl #5
    ada4:	009a2965 	addseq	r2, sl, r5, ror #18
    ada8:	000c8e00 	andeq	r8, ip, r0, lsl #28
    adac:	96f06200 	ldrbtls	r6, [r0], r0, lsl #4
    adb0:	07140000 	ldreq	r0, [r4, -r0]
    adb4:	02980000 	addseq	r0, r8, #0
    adb8:	cb040000 	blgt	10adc0 <unflatten_and_copy_device_tree+0x109f4c>
    adbc:	0097004e 	addseq	r0, r7, lr, asr #32
    adc0:	00000000 	andeq	r0, r0, r0
    adc4:	99040800 	stmdbls	r4, {fp}
    adc8:	6b000098 	blvs	b030 <.debug_info+0xb030>
    adcc:	00004060 	andeq	r4, r0, r0, rrx
    add0:	2c03e201 	sfmcs	f6, 1, [r3], {1}
    add4:	90000007 	andls	r0, r0, r7
    add8:	01000001 	tsteq	r0, r1
    addc:	00ae779c 	umlaleq	r7, lr, ip, r7
    ade0:	2f724c00 	svccs	0x00724c00
    ade4:	e2010000 	and	r0, r1, #0
    ade8:	0000c903 	andeq	ip, r0, r3, lsl #18
    adec:	000ca600 	andeq	sl, ip, r0, lsl #12
    adf0:	0c6b4c00 	stcleq	12, cr4, [fp], #-0
    adf4:	e2010000 	and	r0, r1, #0
    adf8:	0000c903 	andeq	ip, r0, r3, lsl #18
    adfc:	000d3e00 	andeq	r3, sp, r0, lsl #28
    ae00:	17fe4400 	ldrbne	r4, [lr, r0, lsl #8]!
    ae04:	e4010000 	str	r0, [r1], #-0
    ae08:	00ae7703 	adceq	r7, lr, r3, lsl #14
    ae0c:	533a7500 	teqpl	sl, #0, 10
    ae10:	ae8c0000 	cdpge	0, 8, cr0, cr12, cr0, {0}
    ae14:	03050000 	movweq	r0, #20480	; 0x5000
    ae18:	00000000 	andeq	r0, r0, r0
    ae1c:	009b005f 	addseq	r0, fp, pc, asr r0
    ae20:	00074c00 	andeq	r4, r7, r0, lsl #24
    ae24:	00001000 	andeq	r1, r0, r0
    ae28:	03e40100 	mvneq	r0, #0, 2
    ae2c:	0000ae49 	andeq	sl, r0, r9, asr #28
    ae30:	009b104e 	addseq	r1, fp, lr, asr #32
    ae34:	074c6000 	strbeq	r6, [ip, -r0]
    ae38:	00100000 	andseq	r0, r0, r0
    ae3c:	19650000 	stmdbne	r5!, {}^	; <UNPREDICTABLE>
    ae40:	a600009b 			; <UNDEFINED> instruction: 0xa600009b
    ae44:	0000000d 	andeq	r0, r0, sp
    ae48:	07784f00 	ldrbeq	r4, [r8, -r0, lsl #30]!
    ae4c:	b8f90000 	ldmlt	r9!, {}^	; <UNPREDICTABLE>
    ae50:	d44f0000 	strble	r0, [pc], #-0	; 8 <.debug_info+0x8>
    ae54:	f9000007 			; <UNDEFINED> instruction: 0xf9000007
    ae58:	4f0000b8 	svcmi	0x000000b8
    ae5c:	00000860 	andeq	r0, r0, r0, ror #16
    ae60:	0000b8f9 	strdeq	fp, [r0], -r9
    ae64:	0008884f 	andeq	r8, r8, pc, asr #16
    ae68:	00b8f900 	adcseq	pc, r8, r0, lsl #18
    ae6c:	08b44f00 	ldmeq	r4!, {r8, r9, sl, fp, lr}
    ae70:	ba2d0000 	blt	b4ae78 <unflatten_and_copy_device_tree+0xb4a004>
    ae74:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    ae78:	000000c9 	andeq	r0, r0, r9, asr #1
    ae7c:	0000ff06 	andeq	pc, r0, r6, lsl #30
    ae80:	00ae8c00 	adceq	r8, lr, r0, lsl #24
    ae84:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    ae88:	001d0000 	andseq	r0, sp, r0
    ae8c:	00ae7c09 	adceq	r7, lr, r9, lsl #24
    ae90:	9b237200 	blls	8e7698 <unflatten_and_copy_device_tree+0x8e6824>
    ae94:	08bc0000 	ldmeq	ip!, {}	; <UNPREDICTABLE>
    ae98:	00fc0000 	rscseq	r0, ip, r0
    ae9c:	9c010000 	stcls	0, cr0, [r1], {-0}
    aea0:	0000af88 	andeq	sl, r0, r8, lsl #31
    aea4:	009b346a 	addseq	r3, fp, sl, ror #8
    aea8:	000dbe00 	andeq	fp, sp, r0, lsl #28
    aeac:	9b406a00 	blls	10256b4 <unflatten_and_copy_device_tree+0x1024840>
    aeb0:	0de70000 	stcleq	0, cr0, [r7]
    aeb4:	4c6a0000 	stclmi	0, cr0, [sl], #-0
    aeb8:	fa00009b 	blx	274 <.debug_info+0x274>
    aebc:	6a00000d 	bvs	aef8 <.debug_info+0xaef8>
    aec0:	00009b58 	andeq	r9, r0, r8, asr fp
    aec4:	00000e0d 	andeq	r0, r0, sp, lsl #28
    aec8:	009b645b 	addseq	r6, fp, fp, asr r4
    aecc:	9b705b00 	blls	1c21ad4 <unflatten_and_copy_device_tree+0x1c20c60>
    aed0:	7c5b0000 	mravc	r0, fp, acc0
    aed4:	5b00009b 	blpl	b148 <.debug_info+0xb148>
    aed8:	00009b88 	andeq	r9, r0, r8, lsl #23
    aedc:	0008fc64 	andeq	pc, r8, r4, ror #24
    aee0:	0000b000 	andeq	fp, r0, r0
    aee4:	00af7500 	adceq	r7, pc, r0, lsl #10
    aee8:	9b404e00 	blls	101e6f0 <unflatten_and_copy_device_tree+0x101d87c>
    aeec:	4c4e0000 	marmi	acc0, r0, lr
    aef0:	4e00009b 	mcrmi	0, 0, r0, cr0, cr11, {4}
    aef4:	00009b58 	andeq	r9, r0, r8, asr fp
    aef8:	009b344e 	addseq	r3, fp, lr, asr #8
    aefc:	08fc6000 	ldmeq	ip!, {sp, lr}^
    af00:	00b00000 	adcseq	r0, r0, r0
    af04:	645b0000 	ldrbvs	r0, [fp], #-0
    af08:	6500009b 	strvs	r0, [r0, #-155]	; 0xffffff65
    af0c:	00009b70 	andeq	r9, r0, r0, ror fp
    af10:	00000e20 	andeq	r0, r0, r0, lsr #28
    af14:	009b7c66 	addseq	r7, fp, r6, ror #24
    af18:	66550100 	ldrbvs	r0, [r5], -r0, lsl #2
    af1c:	00009b88 	andeq	r9, r0, r8, lsl #23
    af20:	645c9102 	ldrbvs	r9, [ip], #-258	; 0xfffffefe
    af24:	00000970 	andeq	r0, r0, r0, ror r9
    af28:	0000003c 	andeq	r0, r0, ip, lsr r0
    af2c:	0000af61 	andeq	sl, r0, r1, ror #30
    af30:	009b9366 	addseq	r9, fp, r6, ror #6
    af34:	93560600 	cmpls	r6, #0, 12
    af38:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    af3c:	009b9f65 	addseq	r9, fp, r5, ror #30
    af40:	000e4b00 	andeq	r4, lr, r0, lsl #22
    af44:	09784f00 	ldmdbeq	r8!, {r8, r9, sl, fp, lr}^
    af48:	ad410000 	stclge	0, cr0, [r1, #-0]
    af4c:	8c4f0000 	marhi	acc0, r0, pc
    af50:	41000009 	tstmi	r0, r9
    af54:	4f0000ad 	svcmi	0x000000ad
    af58:	000009a8 	andeq	r0, r0, r8, lsr #19
    af5c:	0000adcb 	andeq	sl, r0, fp, asr #27
    af60:	09104f00 	ldmdbeq	r0, {r8, r9, sl, fp, lr}
    af64:	a7c00000 	strbge	r0, [r0, r0]
    af68:	304f0000 	subcc	r0, pc, r0
    af6c:	c0000009 	andgt	r0, r0, r9
    af70:	000000a7 	andeq	r0, r0, r7, lsr #1
    af74:	08e04f00 	stmiaeq	r0!, {r8, r9, sl, fp, lr}^
    af78:	a7c00000 	strbge	r0, [r0, r0]
    af7c:	f44f0000 	vst4.8	{d16-d19}, [pc], r0
    af80:	e2000008 	and	r0, r0, #8
    af84:	000000b8 	strheq	r0, [r0], -r8
    af88:	00022767 	andeq	r2, r2, r7, ror #14
    af8c:	040c0100 	streq	r0, [ip], #-256	; 0xffffff00
    af90:	00000057 	andeq	r0, r0, r7, asr r0
    af94:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
    af98:	00000028 	andeq	r0, r0, r8, lsr #32
    af9c:	afe59c01 	svcge	0x00e59c01
    afa0:	724c0000 	subvc	r0, ip, #0
    afa4:	0100002f 	tsteq	r0, pc, lsr #32
    afa8:	029c040c 	addseq	r0, ip, #12, 8	; 0xc000000
    afac:	0e730000 	cdpeq	0, 7, cr0, cr3, cr0, {0}
    afb0:	6b4c0000 	blvs	1300008 <unflatten_and_copy_device_tree+0x12ff194>
    afb4:	0100000c 	tsteq	r0, ip
    afb8:	029c040d 	addseq	r0, ip, #218103808	; 0xd000000
    afbc:	0e9b0000 	cdpeq	0, 9, cr0, cr11, cr0, {0}
    afc0:	d04c0000 	suble	r0, ip, r0
    afc4:	01000051 	qaddeq	r0, r1, r0
    afc8:	01fb040d 	mvnseq	r0, sp, lsl #8
    afcc:	0ec30000 	cdpeq	0, 12, cr0, cr3, cr0, {0}
    afd0:	d44f0000 	strble	r0, [pc], #-0	; 8 <.debug_info+0x8>
    afd4:	38000009 	stmdacc	r0, {r0, r3}
    afd8:	4f0000ba 	svcmi	0x000000ba
    afdc:	000009dc 	ldrdeq	r0, [r0], -ip
    afe0:	0000ba43 	andeq	fp, r0, r3, asr #20
    afe4:	550b6b00 	strpl	r6, [fp, #-2816]	; 0xfffff500
    afe8:	47010000 	strmi	r0, [r1, -r0]
    afec:	0009e002 	andeq	lr, r9, r2
    aff0:	00008000 	andeq	r8, r0, r0
    aff4:	4a9c0100 	bmi	fe70b3fc <__crc_of_fdt_unflatten_tree+0x779c9e3f>
    aff8:	730000b0 	movwvc	r0, #176	; 0xb0
    affc:	4901006e 	stmdbmi	r1, {r1, r2, r3, r5, r6}
    b000:	00005702 	andeq	r5, r0, r2, lsl #14
    b004:	68550100 	ldmdavs	r5, {r8}^
    b008:	00002f72 	andeq	r2, r0, r2, ror pc
    b00c:	c9024a01 	stmdbgt	r2, {r0, r9, fp, lr}
    b010:	02000000 	andeq	r0, r0, #0
    b014:	6b685891 	blvs	1a1624c <unflatten_and_copy_device_tree+0x1a153d8>
    b018:	0100000c 	tsteq	r0, ip
    b01c:	00c9024a 	sbceq	r0, r9, sl, asr #4
    b020:	91020000 	mrsls	r0, (UNDEF: 2)
    b024:	0a204f60 	beq	813d88 <unflatten_and_copy_device_tree+0x812f14>
    b028:	ba4e0000 	blt	138b030 <unflatten_and_copy_device_tree+0x138a1bc>
    b02c:	404f0000 	submi	r0, pc, r0
    b030:	8800000a 	stmdahi	r0, {r1, r3}
    b034:	4f0000af 	svcmi	0x000000af
    b038:	00000a54 	andeq	r0, r0, r4, asr sl
    b03c:	0000a6aa 	andeq	sl, r0, sl, lsr #13
    b040:	000a584f 	andeq	r5, sl, pc, asr #16
    b044:	00ba5a00 	adcseq	r5, sl, r0, lsl #20
    b048:	af3d0000 	svcge	0x003d0000
    b04c:	01000017 	tsteq	r0, r7, lsl r0
    b050:	00570207 	subseq	r0, r7, r7, lsl #4
    b054:	74010000 	strvc	r0, [r1], #-0
    b058:	430000b0 	movwmi	r0, #176	; 0xb0
    b05c:	0000433d 	andeq	r4, r0, sp, lsr r3
    b060:	d4020701 	strle	r0, [r2], #-1793	; 0xfffff8ff
    b064:	44000000 	strmi	r0, [r0], #-0
    b068:	000047ed 	andeq	r4, r0, sp, ror #15
    b06c:	99020901 	stmdbls	r2, {r0, r8, fp}
    b070:	00000098 	muleq	r0, r8, r0
    b074:	0038f93d 	eorseq	pc, r8, sp, lsr r9	; <UNPREDICTABLE>
    b078:	01d80100 	bicseq	r0, r8, r0, lsl #2
    b07c:	00000057 	andeq	r0, r0, r7, asr r0
    b080:	00b0f201 	adcseq	pc, r0, r1, lsl #4
    b084:	433d4300 	teqmi	sp, #0, 6
    b088:	d8010000 	stmdale	r1, {}	; <UNPREDICTABLE>
    b08c:	0000d401 	andeq	sp, r0, r1, lsl #8
    b090:	472b4300 	strmi	r4, [fp, -r0, lsl #6]!
    b094:	d9010000 	stmdble	r1, {}	; <UNPREDICTABLE>
    b098:	0000f201 	andeq	pc, r0, r1, lsl #4
    b09c:	47124400 	ldrmi	r4, [r2, -r0, lsl #8]
    b0a0:	db010000 	blle	4b0a8 <unflatten_and_copy_device_tree+0x4a234>
    b0a4:	00005701 	andeq	r5, r0, r1, lsl #14
    b0a8:	2f724400 	svccs	0x00724400
    b0ac:	dc010000 	stcle	0, cr0, [r1], {-0}
    b0b0:	00029c01 	andeq	r9, r2, r1, lsl #24
    b0b4:	0c6b4400 	cfstrdeq	mvd4, [fp], #-0
    b0b8:	dc010000 	stcle	0, cr0, [r1], {-0}
    b0bc:	00029c01 	andeq	r9, r2, r1, lsl #24
    b0c0:	656c3f00 	strbvs	r3, [ip, #-3840]!	; 0xfffff100
    b0c4:	dd01006e 	stcle	0, cr0, [r1, #-440]	; 0xfffffe48
    b0c8:	00005701 	andeq	r5, r0, r1, lsl #14
    b0cc:	47ed4400 	strbmi	r4, [sp, r0, lsl #8]!
    b0d0:	de010000 	cdple	0, 0, cr0, cr1, cr0, {0}
    b0d4:	00989901 	addseq	r9, r8, r1, lsl #18
    b0d8:	51d04400 	bicspl	r4, r0, r0, lsl #8
    b0dc:	df010000 	svcle	0x00010000
    b0e0:	00005701 	andeq	r5, r0, r1, lsl #14
    b0e4:	0cb84400 	cfldrseq	mvf4, [r8]
    b0e8:	df010000 	svcle	0x00010000
    b0ec:	00005701 	andeq	r5, r0, r1, lsl #14
    b0f0:	ad690000 	stclge	0, cr0, [r9, #-0]
    b0f4:	6000009b 	mulvs	r0, fp, r0
    b0f8:	cc00000a 	stcgt	0, cr0, [r0], {10}
    b0fc:	01000002 	tsteq	r0, r2
    b100:	00b3379c 	umlalseq	r3, r3, ip, r7	; <UNPREDICTABLE>
    b104:	9bbe6a00 	blls	fefa590c <__crc_of_fdt_unflatten_tree+0x7826434f>
    b108:	0eed0000 	cdpeq	0, 14, cr0, cr13, cr0, {0}
    b10c:	ca6a0000 	bgt	1a8b114 <unflatten_and_copy_device_tree+0x1a8a2a0>
    b110:	0b00009b 	bleq	274 <.debug_info+0x274>
    b114:	6a00000f 	bvs	b158 <.debug_info+0xb158>
    b118:	00009bd6 	ldrdeq	r9, [r0], -r6
    b11c:	00000f29 	andeq	r0, r0, r9, lsr #30
    b120:	009be26a 	addseq	lr, fp, sl, ror #4
    b124:	000f5200 	andeq	r5, pc, r0, lsl #4
    b128:	9bee6600 	blls	ffba4930 <__crc_of_fdt_unflatten_tree+0x78e63373>
    b12c:	03050000 	movweq	r0, #20480	; 0x5000
    b130:	0000000c 	andeq	r0, r0, ip
    b134:	009bfa5b 	addseq	pc, fp, fp, asr sl	; <UNPREDICTABLE>
    b138:	9c065b00 	stcls	11, cr5, [r6], {-0}
    b13c:	4a610000 	bmi	184b144 <unflatten_and_copy_device_tree+0x184a2d0>
    b140:	b80000b0 	stmdalt	r0, {r4, r5, r7}
    b144:	b000000a 	andlt	r0, r0, sl
    b148:	01000002 	tsteq	r0, r2
    b14c:	b2060224 	andlt	r0, r6, #36, 4	; 0x40000002
    b150:	5b4e0000 	blpl	138b158 <unflatten_and_copy_device_tree+0x138a2e4>
    b154:	5a0000b0 	bpl	b41c <.debug_info+0xb41c>
    b158:	000002b0 			; <UNDEFINED> instruction: 0x000002b0
    b15c:	00b0675b 	adcseq	r6, r0, fp, asr r7
    b160:	987f6100 	ldmdals	pc!, {r8, sp, lr}^	; <UNPREDICTABLE>
    b164:	0adc0000 	beq	ff700008 <__crc_of_fdt_unflatten_tree+0x789bea4b>
    b168:	02c80000 	sbceq	r0, r8, #0
    b16c:	0c010000 	stceq	0, cr0, [r1], {-0}
    b170:	00b1a502 	adcseq	sl, r1, r2, lsl #10
    b174:	988f4e00 	stmls	pc, {r9, sl, fp, lr}	; <UNPREDICTABLE>
    b178:	0c620000 	stcleq	0, cr0, [r2], #-0
    b17c:	dc000097 	stcle	0, cr0, [r0], {151}	; 0x97
    b180:	c800000a 	stmdagt	r0, {r1, r3}
    b184:	70000002 	andvc	r0, r0, r2
    b188:	971c4e51 			; <UNDEFINED> instruction: 0x971c4e51
    b18c:	f0620000 			; <UNDEFINED> instruction: 0xf0620000
    b190:	dc000096 	stcle	0, cr0, [r0], {150}	; 0x96
    b194:	e000000a 	and	r0, r0, sl
    b198:	03000002 	movweq	r0, #2
    b19c:	97004eac 	strls	r4, [r0, -ip, lsr #29]
    b1a0:	00000000 	andeq	r0, r0, r0
    b1a4:	987f6100 	ldmdals	pc!, {r8, sp, lr}^	; <UNPREDICTABLE>
    b1a8:	0b0c0000 	bleq	300008 <unflatten_and_copy_device_tree+0x2ff194>
    b1ac:	02f80000 	rscseq	r0, r8, #0
    b1b0:	10010000 	andne	r0, r1, r0
    b1b4:	00b1e902 	adcseq	lr, r1, r2, lsl #18
    b1b8:	988f4e00 	stmls	pc, {r9, sl, fp, lr}	; <UNPREDICTABLE>
    b1bc:	0c620000 	stcleq	0, cr0, [r2], #-0
    b1c0:	0c000097 	stceq	0, cr0, [r0], {151}	; 0x97
    b1c4:	f800000b 			; <UNDEFINED> instruction: 0xf800000b
    b1c8:	70000002 	andvc	r0, r0, r2
    b1cc:	971c4e51 			; <UNDEFINED> instruction: 0x971c4e51
    b1d0:	f0620000 			; <UNDEFINED> instruction: 0xf0620000
    b1d4:	0c000096 	stceq	0, cr0, [r0], {150}	; 0x96
    b1d8:	1000000b 	andne	r0, r0, fp
    b1dc:	03000003 	movweq	r0, #3
    b1e0:	97004eac 	strls	r4, [r0, -ip, lsr #29]
    b1e4:	00000000 	andeq	r0, r0, r0
    b1e8:	0acc4f00 	beq	ff313c08 <__crc_of_fdt_unflatten_tree+0x785d264b>
    b1ec:	a7c00000 	strbge	r0, [r0, r0]
    b1f0:	044f0000 	strbeq	r0, [pc], #-0	; 8 <.debug_info+0x8>
    b1f4:	c000000b 	andgt	r0, r0, fp
    b1f8:	4f0000a7 	svcmi	0x000000a7
    b1fc:	00000b34 	andeq	r0, r0, r4, lsr fp
    b200:	0000a7c0 	andeq	sl, r0, r0, asr #15
    b204:	4c640000 	stclmi	0, cr0, [r4], #-0
    b208:	c400000b 	strgt	r0, [r0], #-11
    b20c:	24000001 	strcs	r0, [r0], #-1
    b210:	4e0000b3 	mcrmi	0, 0, r0, cr0, cr3, {5}
    b214:	00009bd6 	ldrdeq	r9, [r0], -r6
    b218:	009be24e 	addseq	lr, fp, lr, asr #4
    b21c:	9bca4e00 	blls	ff29ea24 <__crc_of_fdt_unflatten_tree+0x7855d467>
    b220:	be4e0000 	cdplt	0, 4, cr0, cr14, cr0, {0}
    b224:	6000009b 	mulvs	r0, fp, r0
    b228:	00000b4c 	andeq	r0, r0, ip, asr #22
    b22c:	000001c4 	andeq	r0, r0, r4, asr #3
    b230:	009bfa65 	addseq	pc, fp, r5, ror #20
    b234:	000f6500 	andeq	r6, pc, r0, lsl #10
    b238:	9c065b00 	stcls	11, cr5, [r6], {-0}
    b23c:	ee660000 	cdp	0, 6, cr0, cr6, cr0, {0}
    b240:	0500009b 	streq	r0, [r0, #-155]	; 0xffffff65
    b244:	00000c03 	andeq	r0, r0, r3, lsl #24
    b248:	b0745f00 	rsbslt	r5, r4, r0, lsl #30
    b24c:	0b900000 	bleq	fe400008 <__crc_of_fdt_unflatten_tree+0x776bea4b>
    b250:	01440000 	mrseq	r0, (UNDEF: 68)
    b254:	38010000 	stmdacc	r1, {}	; <UNPREDICTABLE>
    b258:	00b2f502 	adcseq	pc, r2, r2, lsl #10
    b25c:	b0914e00 	addslt	r4, r1, r0, lsl #28
    b260:	854e0000 	strbhi	r0, [lr, #-0]
    b264:	600000b0 	strhvs	r0, [r0], -r0	; <UNPREDICTABLE>
    b268:	00000b90 	muleq	r0, r0, fp
    b26c:	00000144 	andeq	r0, r0, r4, asr #2
    b270:	00b09d65 	adcseq	r9, r0, r5, ror #26
    b274:	000f8300 	andeq	r8, pc, r0, lsl #6
    b278:	b0a96500 	adclt	r6, r9, r0, lsl #10
    b27c:	0fac0000 	svceq	0x00ac0000
    b280:	b5650000 	strblt	r0, [r5, #-0]!
    b284:	f40000b0 	vst4.32	{d0-d3}, [r0 :256], r0
    b288:	6500000f 	strvs	r0, [r0, #-15]
    b28c:	0000b0c1 	andeq	fp, r0, r1, asr #1
    b290:	0000104c 	andeq	r1, r0, ip, asr #32
    b294:	00b0cd65 	adcseq	ip, r0, r5, ror #26
    b298:	00108f00 	andseq	r8, r0, r0, lsl #30
    b29c:	b0d95b00 	sbcslt	r5, r9, r0, lsl #22
    b2a0:	e5650000 	strb	r0, [r5, #-0]!
    b2a4:	bb0000b0 	bllt	2c8 <.debug_info+0x2c8>
    b2a8:	4f000010 	svcmi	0x00000010
    b2ac:	00000bb8 			; <UNDEFINED> instruction: 0x00000bb8
    b2b0:	0000a7c0 	andeq	sl, r0, r0, asr #15
    b2b4:	000bf84f 	andeq	pc, fp, pc, asr #16
    b2b8:	00b8f900 	adcseq	pc, r8, r0, lsl #18
    b2bc:	0c104f00 	ldceq	15, cr4, [r0], {-0}
    b2c0:	a7c00000 	strbge	r0, [r0, r0]
    b2c4:	444f0000 	strbmi	r0, [pc], #-0	; 8 <.debug_info+0x8>
    b2c8:	4100000c 	tstmi	r0, ip
    b2cc:	4f0000ad 	svcmi	0x000000ad
    b2d0:	00000c54 	andeq	r0, r0, r4, asr ip
    b2d4:	0000ad41 	andeq	sl, r0, r1, asr #26
    b2d8:	000c804f 	andeq	r8, ip, pc, asr #32
    b2dc:	00b8f900 	adcseq	pc, r8, r0, lsl #18
    b2e0:	0c944f00 	ldceq	15, cr4, [r4], {0}
    b2e4:	af880000 	svcge	0x00880000
    b2e8:	d04f0000 	suble	r0, pc, r0
    b2ec:	6500000c 	strvs	r0, [r0, #-12]
    b2f0:	000000ba 	strheq	r0, [r0], -sl
    b2f4:	0b5c4f00 	bleq	1713c08 <unflatten_and_copy_device_tree+0x1712d94>
    b2f8:	a7c00000 	strbge	r0, [r0, r0]
    b2fc:	704f0000 	subvc	r0, pc, r0
    b300:	e200000b 	and	r0, r0, #11
    b304:	4f0000b8 	svcmi	0x000000b8
    b308:	00000b88 	andeq	r0, r0, r8, lsl #23
    b30c:	0000b8e2 	andeq	fp, r0, r2, ror #17
    b310:	000ce84f 	andeq	lr, ip, pc, asr #16
    b314:	00a7c000 	adceq	ip, r7, r0
    b318:	0d0c4f00 	stceq	15, cr4, [ip, #-0]
    b31c:	ba650000 	blt	194b324 <unflatten_and_copy_device_tree+0x194a4b0>
    b320:	00000000 	andeq	r0, r0, r0
    b324:	000ab04f 	andeq	fp, sl, pc, asr #32
    b328:	00b8e200 	adcseq	lr, r8, r0, lsl #4
    b32c:	0d1c4f00 	ldceq	15, cr4, [ip, #-0]
    b330:	b8f90000 	ldmlt	r9!, {}^	; <UNPREDICTABLE>
    b334:	6b000000 	blvs	b33c <.debug_info+0xb33c>
    b338:	000044c2 	andeq	r4, r0, r2, asr #9
    b33c:	2c025e01 	stccs	14, cr5, [r2], {1}
    b340:	4c00000d 	stcmi	0, cr0, [r0], {13}
    b344:	01000000 	mrseq	r0, (UNDEF: 0)
    b348:	00b39e9c 	umlalseq	r9, r3, ip, lr
    b34c:	9b005f00 	blls	22f54 <unflatten_and_copy_device_tree+0x220e0>
    b350:	0d500000 	ldcleq	0, cr0, [r0, #-0]
    b354:	000c0000 	andeq	r0, ip, r0
    b358:	64010000 	strvs	r0, [r1], #-0
    b35c:	00b37a02 	adcseq	r7, r3, r2, lsl #20
    b360:	9b104e00 	blls	41eb68 <unflatten_and_copy_device_tree+0x41dcf4>
    b364:	50600000 	rsbpl	r0, r0, r0
    b368:	0c00000d 	stceq	0, cr0, [r0], {13}
    b36c:	65000000 	strvs	r0, [r0, #-0]
    b370:	00009b19 	andeq	r9, r0, r9, lsl fp
    b374:	000010e4 	andeq	r1, r0, r4, ror #1
    b378:	f05f0000 			; <UNDEFINED> instruction: 0xf05f0000
    b37c:	5c000096 	stcpl	0, cr0, [r0], {150}	; 0x96
    b380:	0400000d 	streq	r0, [r0], #-13
    b384:	01000000 	mrseq	r0, (UNDEF: 0)
    b388:	b3940265 	orrslt	r0, r4, #1342177286	; 0x50000006
    b38c:	004e0000 	subeq	r0, lr, r0
    b390:	00000097 	muleq	r0, r7, r0
    b394:	000d704f 	andeq	r7, sp, pc, asr #32
    b398:	00af8800 	adceq	r8, pc, r0, lsl #16
    b39c:	13720000 	cmnne	r2, #0
    b3a0:	7800009c 	stmdavc	r0, {r2, r3, r4, r7}
    b3a4:	5800000d 	stmdapl	r0, {r0, r2, r3}
    b3a8:	01000000 	mrseq	r0, (UNDEF: 0)
    b3ac:	00b3fa9c 	umlalseq	pc, r3, ip, sl	; <UNPREDICTABLE>
    b3b0:	9c246a00 	stcls	10, cr6, [r4], #-0
    b3b4:	10fc0000 	rscsne	r0, ip, r0
    b3b8:	a0640000 	rsbge	r0, r4, r0
    b3bc:	2800000d 	stmdacs	r0, {r0, r2, r3}
    b3c0:	f0000000 			; <UNDEFINED> instruction: 0xf0000000
    b3c4:	4e0000b3 	mcrmi	0, 0, r0, cr0, cr3, {5}
    b3c8:	00009c24 	andeq	r9, r0, r4, lsr #24
    b3cc:	0096f05f 	addseq	pc, r6, pc, asr r0	; <UNPREDICTABLE>
    b3d0:	000da000 	andeq	sl, sp, r0
    b3d4:	00000400 	andeq	r0, r0, r0, lsl #8
    b3d8:	043c0100 	ldrteq	r0, [ip], #-256	; 0xffffff00
    b3dc:	0000b3e6 	andeq	fp, r0, r6, ror #7
    b3e0:	0097004e 	addseq	r0, r7, lr, asr #32
    b3e4:	c04f0000 	subgt	r0, pc, r0
    b3e8:	be00000d 	cdplt	0, 0, cr0, cr0, cr13, {0}
    b3ec:	000000b9 	strheq	r0, [r0], -r9
    b3f0:	000d984f 	andeq	r9, sp, pc, asr #16
    b3f4:	00b9df00 	adcseq	sp, r9, r0, lsl #30
    b3f8:	a86b0000 	stmdage	fp!, {}^	; <UNPREDICTABLE>
    b3fc:	01000013 	tsteq	r0, r3, lsl r0
    b400:	0dd00442 	cfldrdeq	mvd0, [r0, #264]	; 0x108
    b404:	00440000 	subeq	r0, r4, r0
    b408:	9c010000 	stcls	0, cr0, [r1], {-0}
    b40c:	0000b42c 	andeq	fp, r0, ip, lsr #8
    b410:	000df04f 	andeq	pc, sp, pc, asr #32
    b414:	00a6aa00 	adceq	sl, r6, r0, lsl #20
    b418:	0e004f00 	cdpeq	15, 0, cr4, cr0, cr0, {0}
    b41c:	a6aa0000 	strtge	r0, [sl], r0
    b420:	104f0000 	subne	r0, pc, r0
    b424:	aa00000e 	bge	b464 <.debug_info+0xb464>
    b428:	000000a6 	andeq	r0, r0, r6, lsr #1
    b42c:	0025ab67 	eoreq	sl, r5, r7, ror #22
    b430:	044e0100 	strbeq	r0, [lr], #-256	; 0xffffff00
    b434:	000001fb 	strdeq	r0, [r0], -fp
    b438:	00000e14 	andeq	r0, r0, r4, lsl lr
    b43c:	00000024 	andeq	r0, r0, r4, lsr #32
    b440:	b4759c01 	ldrbtlt	r9, [r5], #-3073	; 0xfffff3ff
    b444:	a04c0000 	subge	r0, ip, r0
    b448:	0100000e 	tsteq	r0, lr
    b44c:	0378044e 	cmneq	r8, #1308622848	; 0x4e000000
    b450:	111a0000 	tstne	sl, r0
    b454:	fe440000 	cdp2	0, 4, cr0, cr4, cr0, {0}
    b458:	0100001b 	tsteq	r0, fp, lsl r0
    b45c:	01fb0450 	mvnseq	r0, r0, asr r4
    b460:	244f0000 	strbcs	r0, [pc], #-0	; 8 <.debug_info+0x8>
    b464:	1300000e 	movwne	r0, #14
    b468:	4f00009c 	svcmi	0x0000009c
    b46c:	00000e30 	andeq	r0, r0, r0, lsr lr
    b470:	0000b3fa 	strdeq	fp, [r0], -sl
    b474:	363c6b00 	ldrtcc	r6, [ip], -r0, lsl #22
    b478:	62010000 	andvs	r0, r1, #0
    b47c:	000e3804 	andeq	r3, lr, r4, lsl #16
    b480:	00003c00 	andeq	r3, r0, r0, lsl #24
    b484:	9e9c0100 	fmllse	f0, f4, f0
    b488:	4f0000b4 	svcmi	0x000000b4
    b48c:	00000e68 	andeq	r0, r0, r8, ror #28
    b490:	000098fe 	strdeq	r9, [r0], -lr
    b494:	000e704f 	andeq	r7, lr, pc, asr #32
    b498:	00ba7000 	adcseq	r7, sl, r0
    b49c:	0c6b0000 	stcleq	0, cr0, [fp], #-0
    b4a0:	01000029 	tsteq	r0, r9, lsr #32
    b4a4:	0e740476 	mrceq	4, 3, r0, cr4, cr6, {3}
    b4a8:	006c0000 	rsbeq	r0, ip, r0
    b4ac:	9c010000 	stcls	0, cr0, [r1], {-0}
    b4b0:	0000b50c 	andeq	fp, r0, ip, lsl #10
    b4b4:	000c6b44 	andeq	r6, ip, r4, asr #22
    b4b8:	04780100 	ldrbteq	r0, [r8], #-256	; 0xffffff00
    b4bc:	00000057 	andeq	r0, r0, r7, asr r0
    b4c0:	00746473 	rsbseq	r6, r4, r3, ror r4
    b4c4:	78047901 	stmdavc	r4, {r0, r8, fp, ip, sp, lr}
    b4c8:	01000003 	tsteq	r0, r3
    b4cc:	96f06156 	usatls	r6, #16, r6, asr #2
    b4d0:	0ea40000 	cdpeq	0, 10, cr0, cr4, cr0, {0}
    b4d4:	03280000 			; <UNDEFINED> instruction: 0x03280000
    b4d8:	80010000 	andhi	r0, r1, r0
    b4dc:	00b4e704 	adcseq	lr, r4, r4, lsl #14
    b4e0:	97004e00 	strls	r4, [r0, -r0, lsl #28]
    b4e4:	4f000000 	svcmi	0x00000000
    b4e8:	00000ea0 	andeq	r0, r0, r0, lsr #29
    b4ec:	0000b8f9 	strdeq	fp, [r0], -r9
    b4f0:	000ec04f 	andeq	ip, lr, pc, asr #32
    b4f4:	00a20700 	adceq	r0, r2, r0, lsl #14
    b4f8:	0ed44f00 	cdpeq	15, 13, cr4, cr4, cr0, {0}
    b4fc:	b8d90000 	ldmlt	r9, {}^	; <UNPREDICTABLE>
    b500:	dc4f0000 	marle	acc0, r0, pc
    b504:	7500000e 	strvc	r0, [r0, #-14]
    b508:	000000b4 	strheq	r0, [r0], -r4
    b50c:	0047f268 	subeq	pc, r7, r8, ror #4
    b510:	01b80100 			; <UNDEFINED> instruction: 0x01b80100
    b514:	00001940 	andeq	r1, r0, r0, asr #18
    b518:	001c0305 	andseq	r0, ip, r5, lsl #6
    b51c:	81680000 	cmnhi	r8, r0
    b520:	01000003 	tsteq	r0, r3
    b524:	a44101c9 	strbge	r0, [r1], #-457	; 0xfffffe37
    b528:	03050000 	movweq	r0, #20480	; 0x5000
    b52c:	00000000 	andeq	r0, r0, r0
    b530:	0000ff06 	andeq	pc, r0, r6, lsl #30
    b534:	00b54000 	adcseq	r4, r5, r0
    b538:	00eb0700 	rsceq	r0, fp, r0, lsl #14
    b53c:	00150000 	andseq	r0, r5, r0
    b540:	0051a068 	subseq	sl, r1, r8, rrx
    b544:	01c90100 	biceq	r0, r9, r0, lsl #2
    b548:	0000b552 	andeq	fp, r0, r2, asr r5
    b54c:	00000305 	andeq	r0, r0, r5, lsl #6
    b550:	30090000 	andcc	r0, r9, r0
    b554:	680000b5 	stmdavs	r0, {r0, r2, r4, r5, r7}
    b558:	000010e6 	andeq	r1, r0, r6, ror #1
    b55c:	b301d301 	movwlt	sp, #4865	; 0x1301
    b560:	05000000 	streq	r0, [r0, #-0]
    b564:	00000803 	andeq	r0, r0, r3, lsl #16
    b568:	00ff0600 	rscseq	r0, pc, r0, lsl #12
    b56c:	b5790000 	ldrblt	r0, [r9, #-0]!
    b570:	eb070000 	bl	1cb578 <unflatten_and_copy_device_tree+0x1ca704>
    b574:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    b578:	61056800 	tstvs	r5, r0, lsl #16
    b57c:	5e010000 	cdppl	0, 0, cr0, cr1, cr0, {0}
    b580:	00b58b03 	adcseq	r8, r5, r3, lsl #22
    b584:	00030500 	andeq	r0, r3, r0, lsl #10
    b588:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    b58c:	0000b569 	andeq	fp, r0, r9, ror #10
    b590:	001e7d68 	andseq	r7, lr, r8, ror #26
    b594:	035e0100 	cmpeq	lr, #0, 2
    b598:	000003bc 			; <UNDEFINED> instruction: 0x000003bc
    b59c:	00000305 	andeq	r0, r0, r5, lsl #6
    b5a0:	85680000 	strbhi	r0, [r8, #-0]!
    b5a4:	01000063 	tsteq	r0, r3, rrx
    b5a8:	039f04a4 	orrseq	r0, pc, #164, 8	; 0xa4000000
    b5ac:	03050000 	movweq	r0, #20480	; 0x5000
    b5b0:	00000000 	andeq	r0, r0, r0
    b5b4:	0012fe76 	andseq	pc, r2, r6, ror lr	; <UNPREDICTABLE>
    b5b8:	690d7200 	stmdbvs	sp, {r9, ip, sp, lr}
    b5bc:	06000000 	streq	r0, [r0], -r0
    b5c0:	000000f8 	strdeq	r0, [r0], -r8
    b5c4:	0000b5ca 	andeq	fp, r0, sl, asr #11
    b5c8:	8f760077 	svchi	0x00760077
    b5cc:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    b5d0:	00b5bf87 	adcseq	fp, r5, r7, lsl #31
    b5d4:	00570600 	subseq	r0, r7, r0, lsl #12
    b5d8:	b5e00000 	strblt	r0, [r0, #0]!
    b5dc:	00770000 	rsbseq	r0, r7, r0
    b5e0:	00006076 	andeq	r6, r0, r6, ror r0
    b5e4:	d52e7100 	strle	r7, [lr, #-256]!	; 0xffffff00
    b5e8:	780000b5 	stmdavc	r0, {r0, r2, r4, r5, r7}
    b5ec:	00000b06 	andeq	r0, r0, r6, lsl #22
    b5f0:	5701b973 	smlsdxpl	r1, r3, r9, fp
    b5f4:	06000000 	streq	r0, [r0], -r0
    b5f8:	000000ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    b5fc:	0000b602 	andeq	fp, r0, r2, lsl #12
    b600:	96780077 			; <UNDEFINED> instruction: 0x96780077
    b604:	73000019 	movwvc	r0, #25
    b608:	b60e01f1 			; <UNDEFINED> instruction: 0xb60e01f1
    b60c:	f7090000 			; <UNDEFINED> instruction: 0xf7090000
    b610:	780000b5 	stmdavc	r0, {r0, r2, r4, r5, r7}
    b614:	00004465 	andeq	r4, r0, r5, ror #8
    b618:	1f01fc73 	svcne	0x0001fc73
    b61c:	090000b6 	stmdbeq	r0, {r1, r2, r4, r5, r7}
    b620:	0000b5f7 	strdeq	fp, [r0], -r7
    b624:	001b9976 	andseq	r9, fp, r6, ror r9
    b628:	570e7400 	strpl	r7, [lr, -r0, lsl #8]
    b62c:	76000000 	strvc	r0, [r0], -r0
    b630:	00003830 	andeq	r3, r0, r0, lsr r8
    b634:	00d41174 	sbcseq	r1, r4, r4, ror r1
    b638:	85760000 	ldrbhi	r0, [r6, #-0]!
    b63c:	74000052 	strvc	r0, [r0], #-82	; 0xffffffae
    b640:	0000d411 	andeq	sp, r0, r1, lsl r4
    b644:	57157600 	ldrpl	r7, [r5, -r0, lsl #12]
    b648:	a2050000 	andge	r0, r5, #0
    b64c:	000000d4 	ldrdeq	r0, [r0], -r4
    b650:	001d2178 	andseq	r2, sp, r8, ror r1
    b654:	01140500 	tsteq	r4, r0, lsl #10
    b658:	00000070 	andeq	r0, r0, r0, ror r0
    b65c:	0037c679 	eorseq	ip, r7, r9, ror r6
    b660:	d4547500 	ldrble	r7, [r4], #-1280	; 0xfffffb00
    b664:	01000000 	mrseq	r0, (UNDEF: 0)
    b668:	124d765d 	subne	r7, sp, #97517568	; 0x5d00000
    b66c:	4e1d0000 	cdpmi	0, 1, cr0, cr13, cr0, {0}
    b670:	00000057 	andeq	r0, r0, r7, asr r0
    b674:	004bb678 	subeq	fp, fp, r8, ror r6
    b678:	02701d00 	rsbseq	r1, r0, #0, 26
    b67c:	00000564 	andeq	r0, r0, r4, ror #10
    b680:	00460b76 	subeq	r0, r6, r6, ror fp
    b684:	57252100 	strpl	r2, [r5, -r0, lsl #2]!
    b688:	76000000 	strvc	r0, [r0], -r0
    b68c:	000004ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    b690:	b6965921 	ldrlt	r5, [r6], r1, lsr #18
    b694:	d2090000 	andle	r0, r9, #0
    b698:	06000049 	streq	r0, [r0], -r9, asr #32
    b69c:	0000a441 	andeq	sl, r0, r1, asr #8
    b6a0:	0000b6b1 			; <UNDEFINED> instruction: 0x0000b6b1
    b6a4:	0000eb07 	andeq	lr, r0, r7, lsl #22
    b6a8:	eb072000 	bl	1d36b0 <unflatten_and_copy_device_tree+0x1d283c>
    b6ac:	00000000 	andeq	r0, r0, r0
    b6b0:	41437800 	cmpmi	r3, r0, lsl #16
    b6b4:	f2210000 	vhadd.s32	d0, d1, d0
    b6b8:	00b6bd02 	adcseq	fp, r6, r2, lsl #26
    b6bc:	b69b0900 	ldrlt	r0, [fp], r0, lsl #18
    b6c0:	2c780000 	ldclcs	0, cr0, [r8], #-0
    b6c4:	2500001a 	strcs	r0, [r0, #-26]	; 0xffffffe6
    b6c8:	1b300160 	blne	c0bc50 <unflatten_and_copy_device_tree+0xc0addc>
    b6cc:	d9780000 	ldmdble	r8!, {}^	; <UNPREDICTABLE>
    b6d0:	1d000060 	stcne	0, cr0, [r0, #-384]	; 0xfffffe80
    b6d4:	17b80354 	sbfxne	r0, r4, #6, #25
    b6d8:	68760000 	ldmdavs	r6!, {}^	; <UNPREDICTABLE>
    b6dc:	76000017 			; <UNDEFINED> instruction: 0x76000017
    b6e0:	0000db12 	andeq	sp, r0, r2, lsl fp
    b6e4:	56757600 	ldrbtpl	r7, [r5], -r0, lsl #12
    b6e8:	0a770000 	beq	1dcb6f0 <unflatten_and_copy_device_tree+0x1dca87c>
    b6ec:	00000057 	andeq	r0, r0, r7, asr r0
    b6f0:	00086376 	andeq	r6, r8, r6, ror r3
    b6f4:	d4222d00 	strtle	r2, [r2], #-3328	; 0xfffff300
    b6f8:	76000000 	strvc	r0, [r0], -r0
    b6fc:	000058dd 	ldrdeq	r5, [r0], -sp
    b700:	03782d2d 	cmneq	r8, #2880	; 0xb40
    b704:	b5760000 	ldrblt	r0, [r6, #-0]!
    b708:	30000022 	andcc	r0, r0, r2, lsr #32
    b70c:	0026c74e 	eoreq	ip, r6, lr, asr #14
    b710:	02f77600 	rscseq	r7, r7, #0, 12
    b714:	22780000 	rsbscs	r0, r8, #0
    b718:	00000057 	andeq	r0, r0, r7, asr r0
    b71c:	00066176 	andeq	r6, r6, r6, ror r1
    b720:	57237800 	strpl	r7, [r3, -r0, lsl #16]!
    b724:	76000000 	strvc	r0, [r0], -r0
    b728:	00002807 	andeq	r2, r0, r7, lsl #16
    b72c:	25bc984b 	ldrcs	r9, [ip, #2123]!	; 0x84b
    b730:	a7780000 	ldrbge	r0, [r8, -r0]!
    b734:	1200000e 	andne	r0, r0, #14
    b738:	2d1c0983 	ldccs	9, cr0, [ip, #-524]	; 0xfffffdf4
    b73c:	85760000 	ldrbhi	r0, [r6, #-0]!
    b740:	3c000022 	stccc	0, cr0, [r0], {34}	; 0x22
    b744:	0000571c 	andeq	r5, r0, ip, lsl r7
    b748:	33507800 	cmpcc	r0, #0, 16
    b74c:	32400000 	subcc	r0, r0, #0
    b750:	00006901 	andeq	r6, r0, r1, lsl #18
    b754:	45e27800 	strbmi	r7, [r2, #2048]!	; 0x800
    b758:	f1490000 			; <UNDEFINED> instruction: 0xf1490000
    b75c:	0036ca01 	eorseq	ip, r6, r1, lsl #20
    b760:	24687800 	strbtcs	r7, [r8], #-2048	; 0xfffff800
    b764:	ee120000 	cdp	0, 1, cr0, cr2, cr0, {0}
    b768:	002db507 	eoreq	fp, sp, r7, lsl #10
    b76c:	119e7600 	orrsne	r7, lr, r0, lsl #12
    b770:	e64d0000 	strb	r0, [sp], -r0
    b774:	00004f7f 	andeq	r4, r0, pc, ror pc
    b778:	00044978 	andeq	r4, r4, r8, ror r9
    b77c:	02a34d00 	adceq	r4, r3, #0, 26
    b780:	000026c1 	andeq	r2, r0, r1, asr #13
    b784:	005ef878 	subseq	pc, lr, r8, ror r8	; <UNPREDICTABLE>
    b788:	02627900 	rsbeq	r7, r2, #0, 18
    b78c:	000000d4 	ldrdeq	r0, [r0], -r4
    b790:	00b7a106 	adcseq	sl, r7, r6, lsl #2
    b794:	00b79b00 	adcseq	r9, r7, r0, lsl #22
    b798:	08007700 	stmdaeq	r0, {r8, r9, sl, ip, sp, lr}
    b79c:	00512004 	subseq	r2, r1, r4
    b7a0:	b79b0900 	ldrlt	r0, [fp, r0, lsl #18]
    b7a4:	d5780000 	ldrble	r0, [r8, #-0]!
    b7a8:	2d00002b 	stccs	0, cr0, [r0, #-172]	; 0xffffff54
    b7ac:	b7b2021a 			; <UNDEFINED> instruction: 0xb7b2021a
    b7b0:	90090000 	andls	r0, r9, r0
    b7b4:	760000b7 			; <UNDEFINED> instruction: 0x760000b7
    b7b8:	00002844 	andeq	r2, r0, r4, asr #16
    b7bc:	52c21c4f 	sbcpl	r1, r2, #20224	; 0x4f00
    b7c0:	bd760000 	ldcllt	0, cr0, [r6, #-0]
    b7c4:	4f000033 	svcmi	0x00000033
    b7c8:	0018a46f 	andseq	sl, r8, pc, ror #8
    b7cc:	22157800 	andscs	r7, r5, #0, 16
    b7d0:	c02d0000 	eorgt	r0, sp, r0
    b7d4:	00b5bf06 	adcseq	fp, r5, r6, lsl #30
    b7d8:	630b7800 	movwvs	r7, #47104	; 0xb800
    b7dc:	c02d0000 	eorgt	r0, sp, r0
    b7e0:	00b5bf06 	adcseq	fp, r5, r6, lsl #30
    b7e4:	54d87600 	ldrbpl	r7, [r8], #1536	; 0x600
    b7e8:	397a0000 	ldmdbcc	sl!, {}^	; <UNPREDICTABLE>
    b7ec:	00000057 	andeq	r0, r0, r7, asr r0
    b7f0:	00455276 	subeq	r5, r5, r6, ror r2
    b7f4:	2ed55300 	cdpcs	3, 13, cr5, cr5, cr0, {0}
    b7f8:	76000056 			; <UNDEFINED> instruction: 0x76000056
    b7fc:	00001527 	andeq	r1, r0, r7, lsr #10
    b800:	585c5504 	ldmdapl	ip, {r2, r8, sl, ip, lr}^
    b804:	b8760000 	ldmdalt	r6!, {}^	; <UNPREDICTABLE>
    b808:	0400003a 	streq	r0, [r0], #-58	; 0xffffffc6
    b80c:	005bf475 	subseq	pc, fp, r5, ror r4	; <UNPREDICTABLE>
    b810:	46287a00 	strtmi	r7, [r8], -r0, lsl #20
    b814:	cc010000 	stcgt	0, cr0, [r1], {-0}
    b818:	00005701 	andeq	r5, r0, r1, lsl #14
    b81c:	00030500 	andeq	r0, r3, r0, lsl #10
    b820:	7a000000 	bvc	b828 <.debug_info+0xb828>
    b824:	000022a2 	andeq	r2, r0, r2, lsr #5
    b828:	5701cd01 	strpl	ip, [r1, -r1, lsl #26]
    b82c:	05000000 	streq	r0, [r0, #-0]
    b830:	00000003 	andeq	r0, r0, r3
    b834:	477a7a00 	ldrbmi	r7, [sl, -r0, lsl #20]!
    b838:	cf010000 	svcgt	0x00010000
    b83c:	00037801 	andeq	r7, r3, r1, lsl #16
    b840:	00030500 	andeq	r0, r3, r0, lsl #10
    b844:	06000000 	streq	r0, [r0], -r0
    b848:	00002292 	muleq	r0, r2, r2
    b84c:	0000b857 	andeq	fp, r0, r7, asr r8
    b850:	0000eb07 	andeq	lr, r0, r7, lsl #22
    b854:	78000d00 	stmdavc	r0, {r8, sl, fp}
    b858:	00005e2f 	andeq	r5, r0, pc, lsr #28
    b85c:	47010702 	strmi	r0, [r1, -r2, lsl #14]
    b860:	780000b8 	stmdavc	r0, {r3, r4, r5, r7}
    b864:	00000bff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    b868:	57020c5b 	smlsdpl	r2, fp, ip, r0
    b86c:	78000000 	stmdavc	r0, {}	; <UNPREDICTABLE>
    b870:	00003d11 	andeq	r3, r0, r1, lsl sp
    b874:	1b010561 	blne	4ce00 <unflatten_and_copy_device_tree+0x4bf8c>
    b878:	7800006d 	stmdavc	r0, {r0, r2, r3, r5, r6}
    b87c:	000017c9 	andeq	r1, r0, r9, asr #15
    b880:	7b09122b 	blvc	250134 <unflatten_and_copy_device_tree+0x24f2c0>
    b884:	78000064 	stmdavc	r0, {r2, r5, r6}
    b888:	00000ab3 			; <UNDEFINED> instruction: 0x00000ab3
    b88c:	2701cc66 	strcs	ip, [r1, -r6, ror #24]
    b890:	78000010 	stmdavc	r0, {r4}
    b894:	00001123 	andeq	r1, r0, r3, lsr #2
    b898:	7801c901 	stmdavc	r1, {r0, r8, fp, lr, pc}
    b89c:	7a000003 	bvc	b8b0 <.debug_info+0xb8b0>
    b8a0:	00002329 	andeq	r2, r0, r9, lsr #6
    b8a4:	b101c901 	tstlt	r1, r1, lsl #18
    b8a8:	050000b8 	streq	r0, [r0, #-184]	; 0xffffff48
    b8ac:	00000003 	andeq	r0, r0, r3
    b8b0:	037a0900 	cmneq	sl, #0, 18
    b8b4:	1c060000 	stcne	0, cr0, [r6], {-0}
    b8b8:	c100005a 	qaddgt	r0, sl, r0
    b8bc:	770000b8 			; <UNDEFINED> instruction: 0x770000b8
    b8c0:	51fe7800 	mvnspl	r7, r0, lsl #16
    b8c4:	27010000 	strcs	r0, [r1, -r0]
    b8c8:	00b8b603 	adcseq	fp, r8, r3, lsl #12
    b8cc:	122b7b00 	eorne	r7, fp, #0, 22
    b8d0:	122b0000 	eorne	r0, fp, #0
    b8d4:	3f020000 	svccc	0x00020000
    b8d8:	23cd7c01 	biccs	r7, sp, #256	; 0x100
    b8dc:	23cd0000 	biccs	r0, sp, #0
    b8e0:	817d0000 	cmnhi	sp, r0
    b8e4:	8100000a 	tsthi	r0, sl
    b8e8:	0600000a 	streq	r0, [r0], -sl
    b8ec:	5a547b29 	bpl	151ecac <unflatten_and_copy_device_tree+0x151de38>
    b8f0:	5a540000 	bpl	1500008 <unflatten_and_copy_device_tree+0x14ff194>
    b8f4:	187b0000 	ldmdane	fp!, {}^	; <UNPREDICTABLE>
    b8f8:	2fb87d02 	svccs	0x00b87d02
    b8fc:	2fb80000 	svccs	0x00b80000
    b900:	8e710000 	cdphi	0, 7, cr0, cr1, cr0, {0}
    b904:	000d717d 	andeq	r7, sp, sp, ror r1
    b908:	000d7100 	andeq	r7, sp, r0, lsl #2
    b90c:	7d5c5300 	ldclvc	3, cr5, [ip, #-0]
    b910:	00000ccb 	andeq	r0, r0, fp, asr #25
    b914:	00000ccb 	andeq	r0, r0, fp, asr #25
    b918:	dc7d1406 	cfldrdle	mvd1, [sp], #-24	; 0xffffffe8
    b91c:	dc000062 	stcle	0, cr0, [r0], {98}	; 0x62
    b920:	06000062 	streq	r0, [r0], -r2, rrx
    b924:	51867b50 	orrpl	r7, r6, r0, asr fp
    b928:	51860000 	orrpl	r0, r6, r0
    b92c:	7d7b0000 	ldclvc	0, cr0, [fp, #-0]
    b930:	3fc97b01 	svccc	0x00c97b01
    b934:	3fc90000 	svccc	0x00c90000
    b938:	917b0000 	cmnls	fp, r0
    b93c:	61737b01 	cmnvs	r3, r1, lsl #22
    b940:	61730000 	cmnvs	r3, r0
    b944:	a67b0000 	ldrbtge	r0, [fp], -r0
    b948:	603b7d01 	eorsvs	r7, fp, r1, lsl #26
    b94c:	603b0000 	eorsvs	r0, fp, r0
    b950:	8e7b0000 	cdphi	0, 7, cr0, cr11, cr0, {0}
    b954:	002ca87b 	eoreq	sl, ip, fp, ror r8
    b958:	002ca800 	eoreq	sl, ip, r0, lsl #16
    b95c:	01380400 	teqeq	r8, r0, lsl #8
    b960:	004dd27b 	subeq	sp, sp, fp, ror r2
    b964:	004dd200 	subeq	sp, sp, r0, lsl #4
    b968:	03317b00 	teqeq	r1, #0, 22
    b96c:	005c6e7d 	subseq	r6, ip, sp, ror lr
    b970:	005c6e00 	subseq	r6, ip, r0, lsl #28
    b974:	7b5b7c00 	blvc	16ea97c <unflatten_and_copy_device_tree+0x16e9b08>
    b978:	00000d57 	andeq	r0, r0, r7, asr sp
    b97c:	00000d57 	andeq	r0, r0, r7, asr sp
    b980:	7b015c7d 	blvc	62b7c <unflatten_and_copy_device_tree+0x61d08>
    b984:	0000497e 	andeq	r4, r0, lr, ror r9
    b988:	0000497e 	andeq	r4, r0, lr, ror r9
    b98c:	7b01667b 	blvc	65380 <unflatten_and_copy_device_tree+0x6450c>
    b990:	00003572 	andeq	r3, r0, r2, ror r5
    b994:	00003572 	andeq	r3, r0, r2, ror r5
    b998:	7d02447b 	cfstrsvc	mvf4, [r2, #-492]	; 0xfffffe14
    b99c:	00003930 	andeq	r3, r0, r0, lsr r9
    b9a0:	00003930 	andeq	r3, r0, r0, lsr r9
    b9a4:	7a7b3806 	bvc	1ece020 <unflatten_and_copy_device_tree+0x1ecd1ac>
    b9a8:	7a00005f 	bvc	184 <.debug_info+0x184>
    b9ac:	7b00005f 	blvc	bb30 <unflatten_and_copy_device_tree+0xacbc>
    b9b0:	7c7b014e 	ldfvce	f0, [fp], #-312	; 0xfffffec8
    b9b4:	7c000059 	stcvc	0, cr0, [r0], {89}	; 0x59
    b9b8:	7a000059 	bvc	bb24 <unflatten_and_copy_device_tree+0xacb0>
    b9bc:	a67d0118 			; <UNDEFINED> instruction: 0xa67d0118
    b9c0:	a600005b 			; <UNDEFINED> instruction: 0xa600005b
    b9c4:	7e00005b 	mcrvc	0, 0, r0, cr0, cr11, {2}
    b9c8:	170e7d0c 	strne	r7, [lr, -ip, lsl #26]
    b9cc:	170e0000 	strne	r0, [lr, -r0]
    b9d0:	f0520000 			; <UNDEFINED> instruction: 0xf0520000
    b9d4:	003e5b7d 	eorseq	r5, lr, sp, ror fp
    b9d8:	003e5b00 	eorseq	r5, lr, r0, lsl #22
    b9dc:	7d1b7f00 	ldcvc	15, cr7, [fp, #-0]
    b9e0:	0000489e 	muleq	r0, lr, r8
    b9e4:	0000489e 	muleq	r0, lr, r8
    b9e8:	277dd77b 			; <UNDEFINED> instruction: 0x277dd77b
    b9ec:	2700005f 	smlsdcs	r0, pc, r0, r0	; <UNPREDICTABLE>
    b9f0:	1f00005f 	svcne	0x0000005f
    b9f4:	27697d9d 			; <UNDEFINED> instruction: 0x27697d9d
    b9f8:	27690000 	strbcs	r0, [r9, -r0]!
    b9fc:	ae1f0000 	cdpge	0, 1, cr0, cr15, cr0, {0}
    ba00:	00339d7b 	eorseq	r9, r3, fp, ror sp
    ba04:	00339d00 	eorseq	r9, r3, r0, lsl #26
    ba08:	04cf7b00 	strbeq	r7, [pc], #2816	; ba10 <.debug_info+0xba10>
    ba0c:	001aa07d 	andseq	sl, sl, sp, ror r0
    ba10:	001aa000 	andseq	sl, sl, r0
    ba14:	7d2f0600 	stcvc	6, cr0, [pc, #-0]	; ba1c <.debug_info+0xba1c>
    ba18:	0000570d 	andeq	r5, r0, sp, lsl #14
    ba1c:	0000570d 	andeq	r5, r0, sp, lsl #14
    ba20:	397d0a7f 	ldmdbcc	sp!, {r0, r1, r2, r3, r4, r5, r6, r9, fp}^
    ba24:	3900001f 	stmdbcc	r0, {r0, r1, r2, r3, r4}
    ba28:	0600001f 			; <UNDEFINED> instruction: 0x0600001f
    ba2c:	1d417d1a 	stclne	13, cr7, [r1, #-104]	; 0xffffff98
    ba30:	1d410000 	stclne	0, cr0, [r1, #-0]
    ba34:	4b7a0000 	blmi	1e8ba3c <unflatten_and_copy_device_tree+0x1e8abc8>
    ba38:	0055987d 	subseq	r9, r5, sp, ror r8
    ba3c:	00559800 	subseq	r9, r5, r0, lsl #16
    ba40:	7d4c7a00 	vstrvc	s15, [ip, #-0]
    ba44:	0000573a 	andeq	r5, r0, sl, lsr r7
    ba48:	0000573a 	andeq	r5, r0, sl, lsr r7
    ba4c:	ba7b4e7a 	blt	1ed39f0 <unflatten_and_copy_device_tree+0x1ed2b7c>
    ba50:	ba00005d 	blt	17c <.debug_info+0x17c>
    ba54:	7b00005d 	blvc	bbd0 <unflatten_and_copy_device_tree+0xad5c>
    ba58:	417d011c 	cmnmi	sp, ip, lsl r1
    ba5c:	4100004d 	tstmi	r0, sp, asr #32
    ba60:	8000004d 	andhi	r0, r0, sp, asr #32
    ba64:	609b7d22 	addsvs	r7, fp, r2, lsr #26
    ba68:	609b0000 	addsvs	r0, fp, r0
    ba6c:	23800000 	orrcs	r0, r0, #0
    ba70:	002d137b 	eoreq	r1, sp, fp, ror r3
    ba74:	002d1300 	eoreq	r1, sp, r0, lsl #6
    ba78:	01510400 	cmpeq	r1, r0, lsl #8
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	25011101 	strcs	r1, [r1, #-257]	; 0xfffffeff
   4:	030b130e 	movweq	r1, #45838	; 0xb30e
   8:	550e1b0e 	strpl	r1, [lr, #-2830]	; 0xfffff4f2
   c:	10011117 	andne	r1, r1, r7, lsl r1
  10:	02000017 	andeq	r0, r0, #23
  14:	0b0b0024 	bleq	2c00ac <unflatten_and_copy_device_tree+0x2bf238>
  18:	0e030b3e 	vmoveq.16	d3[0], r0
  1c:	16030000 	strne	r0, [r3], -r0
	return kzalloc(size, GFP_KERNEL);
}
  20:	3a0e0300 	bcc	380c28 <unflatten_and_copy_device_tree+0x37fdb4>

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  28:	04000013 	streq	r0, [r0], #-19	; 0xffffffed
  2c:	0b0b0024 	bleq	2c00c4 <unflatten_and_copy_device_tree+0x2bf250>
  30:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
  34:	16050000 	strne	r0, [r5], -r0
	memcpy(buf, initial_boot_params + off, count);
  38:	3a080300 	bcc	200c40 <unflatten_and_copy_device_tree+0x1ffdcc>
  3c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  40:	06000013 			; <UNDEFINED> instruction: 0x06000013

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	13490101 	movtne	r0, #37121	; 0x9101
	memcpy(buf, initial_boot_params + off, count);
  48:	00001301 	andeq	r1, r0, r1, lsl #6
  4c:	49002107 	stmdbmi	r0, {r0, r1, r2, r8, sp}
  50:	000b2f13 	andeq	r2, fp, r3, lsl pc
  54:	000f0800 	andeq	r0, pc, r0, lsl #16
	return count;
}
  58:	13490b0b 	movtne	r0, #39691	; 0x9b0b
  5c:	26090000 	strcs	r0, [r9], -r0
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	00134900 	andseq	r4, r3, r0, lsl #18
  64:	01040a00 	tsteq	r4, r0, lsl #20
  68:	13490b0b 	movtne	r0, #39691	; 0x9b0b
  6c:	0b3b0b3a 	bleq	ec2d5c <unflatten_and_copy_device_tree+0xec1ee8>
  70:	00001301 	andeq	r1, r0, r1, lsl #6
  74:	0300280b 	movweq	r2, #2059	; 0x80b
  78:	000b1c0e 	andeq	r1, fp, lr, lsl #24
  7c:	01150c00 	tsteq	r5, r0, lsl #24
  80:	13011927 	movwne	r1, #6439	; 0x1927
  84:	050d0000 	streq	r0, [sp, #-0]
  88:	00134900 	andseq	r4, r3, r0, lsl #18
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	01130e00 	tsteq	r3, r0, lsl #28
  90:	0b3a0b0b 	bleq	e82cc4 <unflatten_and_copy_device_tree+0xe81e50>
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	13010b3b 	movwne	r0, #6971	; 0x1b3b
  98:	0d0f0000 	stceq	0, cr0, [pc, #-0]	; a0 <.debug_abbrev+0xa0>
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	3a0e0300 	bcc	380ca4 <unflatten_and_copy_device_tree+0x37fe30>
	if (!pathp)
  a0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  a4:	000b3813 	andeq	r3, fp, r3, lsl r8
  a8:	01131000 	tsteq	r3, r0
  ac:	0b0b0e03 	bleq	2c38c0 <unflatten_and_copy_device_tree+0x2c2a4c>
		return mem;

	allocl = ++l;
  b0:	0b3b0b3a 	bleq	ec2da0 <unflatten_and_copy_device_tree+0xec1f2c>
  b4:	00001301 	andeq	r1, r0, r1, lsl #6
  b8:	0b000f11 	bleq	3d04 <unflatten_and_copy_device_tree+0x2e90>
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	1200000b 	andne	r0, r0, #11
  c0:	19270015 	stmdbne	r7!, {r0, r2, r4}
  c4:	00001349 	andeq	r1, r0, r9, asr #6
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	27001513 	smladcs	r0, r3, r5, r1
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	14000019 	strne	r0, [r0], #-25	; 0xffffffe7
		new_format = 1;
		if (fpsize == 0) {
  d0:	0803000d 	stmdaeq	r3, {r0, r2, r3}
  d4:	0b3b0b3a 	bleq	ec2dc4 <unflatten_and_copy_device_tree+0xec1f50>
  d8:	0b381349 	bleq	e04e04 <unflatten_and_copy_device_tree+0xe03f90>
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	15150000 	ldrne	r0, [r5, #-0]
  e0:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	00130113 	andseq	r0, r3, r3, lsl r1
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	00131600 	andseq	r1, r3, r0, lsl #12
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	193c0e03 	ldmdbne	ip!, {r0, r1, r9, sl, fp}
			pathp = "";
  f0:	17170000 	ldrne	r0, [r7, -r0]
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	3a0b0b01 	bcc	2c2d00 <unflatten_and_copy_device_tree+0x2c1e8c>
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	010b3b0b 	tsteq	fp, fp, lsl #22
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	18000013 	stmdane	r0, {r0, r1, r4}
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
 104:	0b3b0b3a 	bleq	ec2df4 <unflatten_and_copy_device_tree+0xec1f80>
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	00001349 	andeq	r1, r0, r9, asr #6
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	49000d19 	stmdbmi	r0, {r0, r3, r4, r8, sl, fp}
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	000b3813 	andeq	r3, fp, r3, lsl r8
 114:	01131a00 	tsteq	r3, r0, lsl #20
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	0b0b0e03 	bleq	2c392c <unflatten_and_copy_device_tree+0x2c2ab8>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 120:	00001301 	andeq	r1, r0, r1, lsl #6
 124:	03000d1b 	movweq	r0, #3355	; 0xd1b
 128:	3b0b3a0e 	blcc	2ce968 <unflatten_and_copy_device_tree+0x2cdaf4>
 12c:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
 130:	1c00000b 	stcne	0, cr0, [r0], {11}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
 138:	0b3a050b 	bleq	e8156c <unflatten_and_copy_device_tree+0xe806f8>
 13c:	1301053b 	movwne	r0, #5435	; 0x153b
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	0d1d0000 	ldceq	0, cr0, [sp, #-0]
 144:	3a080300 	bcc	200d4c <unflatten_and_copy_device_tree+0x1ffed8>
 148:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	000b3813 	andeq	r3, fp, r3, lsl r8
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	000d1e00 	andeq	r1, sp, r0, lsl #28
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	0b3a0803 	bleq	e82168 <unflatten_and_copy_device_tree+0xe812f4>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	1349053b 	movtne	r0, #38203	; 0x953b
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	00000538 	andeq	r0, r0, r8, lsr r5
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	03000d1f 	movweq	r0, #3359	; 0xd1f
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	3b0b3a0e 	blcc	2ce9a4 <unflatten_and_copy_device_tree+0x2cdb30>
 168:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
 16c:	20000005 	andcs	r0, r0, r5
 170:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 178:	0b0b1349 	bleq	2c4ea4 <unflatten_and_copy_device_tree+0x2c4030>
 17c:	0b0c0b0d 	bleq	302db8 <unflatten_and_copy_device_tree+0x301f44>
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	00000538 	andeq	r0, r0, r8, lsr r5
 184:	03001321 	movweq	r1, #801	; 0x321
 188:	3a0b0b0e 	bcc	2c2dc8 <unflatten_and_copy_device_tree+0x2c1f54>
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	00053b0b 	andeq	r3, r5, fp, lsl #22
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	01132200 	tsteq	r3, r0, lsl #4
 194:	0b3a0b0b 	bleq	e82dc8 <unflatten_and_copy_device_tree+0xe81f54>
	res = *mem;
	*mem += size;
 198:	1301053b 	movwne	r0, #5435	; 0x153b
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	16230000 	strtne	r0, [r3], -r0
 1a0:	3a0e0300 	bcc	380da8 <unflatten_and_copy_device_tree+0x37ff34>
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 1a8:	24000013 	strcs	r0, [r0], #-19	; 0xffffffed
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	0e030104 	adfeqs	f0, f3, f4
 1b0:	13490b0b 	movtne	r0, #39691	; 0x9b0b
 1b4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 1b8:	00001301 	andeq	r1, r0, r1, lsl #6
 1bc:	49002125 	stmdbmi	r0, {r0, r2, r5, r8, sp}
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	26000013 			; <UNDEFINED> instruction: 0x26000013
 1c4:	0e030104 	adfeqs	f0, f3, f4
 1c8:	13490b0b 	movtne	r0, #39691	; 0x9b0b
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	0b3b0b3a 	bleq	ec2ebc <unflatten_and_copy_device_tree+0xec2048>
 1d0:	00001301 	andeq	r1, r0, r1, lsl #6
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	03011727 	movweq	r1, #5927	; 0x1727
 1d8:	3a0b0b0e 	bcc	2c2e18 <unflatten_and_copy_device_tree+0x2c1fa4>
 1dc:	010b3b0b 	tsteq	fp, fp, lsl #22
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	28000013 	stmdacs	r0, {r0, r1, r4}
					np->phandle = be32_to_cpup(p);
 1e4:	1349000d 	movtne	r0, #36877	; 0x900d
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	0d290000 	stceq	0, cr0, [r9, #-0]
 1ec:	3a0e0300 	bcc	380df4 <unflatten_and_copy_device_tree+0x37ff80>
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 1f4:	0d0b0b13 	vstreq	d0, [fp, #-76]	; 0xffffffb4
 1f8:	380b0c0b 	stmdacc	fp, {r0, r1, r3, sl, fp}
 1fc:	2a00000b 	bcs	230 <.debug_abbrev+0x230>
 200:	0803000d 	stmdaeq	r3, {r0, r2, r3}
				np->phandle = be32_to_cpup(p);
 204:	0b3b0b3a 	bleq	ec2ef4 <unflatten_and_copy_device_tree+0xec2080>
 208:	00001349 	andeq	r1, r0, r9, asr #6
 20c:	0b01042b 	bleq	412c0 <unflatten_and_copy_device_tree+0x4044c>
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	3a13490b 	bcc	4d2644 <unflatten_and_copy_device_tree+0x4d17d0>
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	01053b0b 	tsteq	r5, fp, lsl #22
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	2c000013 	stccs	0, cr0, [r0], {19}
			pp->length = sz;
 21c:	13490035 	movtne	r0, #36917	; 0x9035
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	132d0000 			; <UNDEFINED> instruction: 0x132d0000
			prev_pp = &pp->next;
 224:	0b080301 	bleq	200e30 <unflatten_and_copy_device_tree+0x1fffbc>
 228:	3b0b3a0b 	blcc	2cea5c <unflatten_and_copy_device_tree+0x2cdbe8>
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	0013010b 	andseq	r0, r3, fp, lsl #2
 230:	00132e00 	andseq	r2, r3, r0, lsl #28
 234:	0b0b0e03 	bleq	2c3a48 <unflatten_and_copy_device_tree+0x2c2bd4>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	0b3b0b3a 	bleq	ec2f28 <unflatten_and_copy_device_tree+0xec20b4>
 23c:	262f0000 	strtcs	r0, [pc], -r0
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	30000000 	andcc	r0, r0, r0
 244:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
 248:	0b3a050b 	bleq	e8167c <unflatten_and_copy_device_tree+0xe80808>
 24c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
 250:	0d310000 	ldceq	0, cr0, [r1, #-0]
 254:	3a0e0300 	bcc	380e5c <unflatten_and_copy_device_tree+0x37ffe8>
 258:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 25c:	00053813 	andeq	r3, r5, r3, lsl r8
 260:	000d3200 	andeq	r3, sp, r0, lsl #4
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	05381349 	ldreq	r1, [r8, #-841]!	; 0xfffffcb7
 268:	21330000 	teqcs	r3, r0
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	2f134900 	svccs	0x00134900
 270:	34000005 	strcc	r0, [r0], #-5
 274:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	0b0b1349 	bleq	2c4fa8 <unflatten_and_copy_device_tree+0x2c4134>
 280:	0b0c0b0d 	bleq	302ebc <unflatten_and_copy_device_tree+0x302048>
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	00000b38 	andeq	r0, r0, r8, lsr fp
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	03011735 	movweq	r1, #5941	; 0x1735
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	3a0b0b0e 	bcc	2c2ecc <unflatten_and_copy_device_tree+0x2c2058>
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	01053b0b 	tsteq	r5, fp, lsl #22
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	36000013 			; <UNDEFINED> instruction: 0x36000013
 298:	0803000d 	stmdaeq	r3, {r0, r2, r3}
	if (depth < 0)
 29c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 2a0:	00001349 	andeq	r1, r0, r9, asr #6
		depth = 0;
 2a4:	03002837 	movweq	r2, #2103	; 0x837
 2a8:	000d1c0e 	andeq	r1, sp, lr, lsl #24
 2ac:	01173800 	tsteq	r7, r0, lsl #16
 2b0:	0b3a0b0b 	bleq	e82ee4 <unflatten_and_copy_device_tree+0xe82070>
	while (*poffset > 0 && depth > old_depth)
 2b4:	1301053b 	movwne	r0, #5435	; 0x153b
 2b8:	0d390000 	ldceq	0, cr0, [r9, #-0]
 2bc:	3a0e0300 	bcc	380ec4 <unflatten_and_copy_device_tree+0x380050>
 2c0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 2c4:	3a000013 	bcc	318 <.debug_abbrev+0x318>
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	0e03012e 	adfeqsp	f0, f3, #0.5
 2cc:	0b3b0b3a 	bleq	ec2fbc <unflatten_and_copy_device_tree+0xec2148>
 2d0:	13491927 	movtne	r1, #39207	; 0x9927
 2d4:	13010b20 	movwne	r0, #6944	; 0x1b20
 2d8:	053b0000 	ldreq	r0, [fp, #-0]!
 2dc:	3a080300 	bcc	200ee4 <unflatten_and_copy_device_tree+0x200070>

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 2e4:	3c000013 	stccc	0, cr0, [r0], {19}
 2e8:	08030034 	stmdaeq	r3, {r2, r4, r5}
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	0b3b0b3a 	bleq	ec2fdc <unflatten_and_copy_device_tree+0xec2168>
 2f0:	00001349 	andeq	r1, r0, r9, asr #6
 2f4:	03012e3d 	movweq	r2, #7741	; 0x1e3d
 2f8:	3b0b3a0e 	blcc	2ceb38 <unflatten_and_copy_device_tree+0x2cdcc4>
 2fc:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
 300:	010b2013 	tsteq	fp, r3, lsl r0
 304:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
 308:	08030005 	stmdaeq	r3, {r0, r2}
 30c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	00001349 	andeq	r1, r0, r9, asr #6
 314:	0300343f 	movweq	r3, #1087	; 0x43f
 318:	3b0b3a08 	blcc	2ceb40 <unflatten_and_copy_device_tree+0x2cdccc>
 31c:	00134905 	andseq	r4, r3, r5, lsl #18
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	012e4000 			; <UNDEFINED> instruction: 0x012e4000
 324:	0b3a0803 	bleq	e82338 <unflatten_and_copy_device_tree+0xe814c4>

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
 32c:	0b201349 	bleq	805058 <unflatten_and_copy_device_tree+0x8041e4>
 330:	00001301 	andeq	r1, r0, r1, lsl #6
 334:	03000541 	movweq	r0, #1345	; 0x541
 338:	3b0b3a0e 	blcc	2ceb78 <unflatten_and_copy_device_tree+0x2cdd04>
 33c:	0013490b 	andseq	r4, r3, fp, lsl #18
		struct device_node *child = np->child;
		np->child = NULL;
 340:	00344200 	eorseq	r4, r4, r0, lsl #4
 344:	0b3a0e03 	bleq	e83b58 <unflatten_and_copy_device_tree+0xe82ce4>
 348:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		while (child) {
			struct device_node *next = child->sibling;
 34c:	05430000 	strbeq	r0, [r3, #-0]
			child->sibling = np->child;
 350:	3a0e0300 	bcc	380f58 <unflatten_and_copy_device_tree+0x3800e4>
 354:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	44000013 	strmi	r0, [r0], #-19	; 0xffffffed
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 360:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	00001349 	andeq	r1, r0, r9, asr #6
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	00010b45 	andeq	r0, r1, r5, asr #22
		*nodepp = np;
 36c:	012e4600 			; <UNDEFINED> instruction: 0x012e4600
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	0b3a0e03 	bleq	e83b84 <unflatten_and_copy_device_tree+0xe82d10>
		*nodepp = np;
 374:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
 378:	13010b20 	movwne	r0, #6944	; 0x1b20

	return mem;
}
 37c:	18470000 	stmdane	r7, {}^	; <UNPREDICTABLE>
 380:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	0e03012e 	adfeqsp	f0, f3, #0.5
 388:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 38c:	0b201927 	bleq	806830 <unflatten_and_copy_device_tree+0x8059bc>
 390:	00001301 	andeq	r1, r0, r1, lsl #6
 394:	3f012e49 	svccc	0x00012e49
 398:	3a0e0319 	bcc	381004 <unflatten_and_copy_device_tree+0x380190>
			if ((*p1) == '@')
 39c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
 3a0:	20134919 	andscs	r4, r3, r9, lsl r9
				pa = p1;
			if ((*p1) == '/')
 3a4:	0013010b 	andseq	r0, r3, fp, lsl #2
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	002e4a00 	eoreq	r4, lr, r0, lsl #20
 3ac:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
				pa = p1;
			if ((*p1) == '/')
 3b0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 3b4:	13491927 	movtne	r1, #39207	; 0x9927
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	00000b20 	andeq	r0, r0, r0, lsr #22
 3bc:	03012e4b 	movweq	r2, #7755	; 0x1e4b
 3c0:	3b0b3a0e 	blcc	2cec00 <unflatten_and_copy_device_tree+0x2cdd8c>
 3c4:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	97184006 	ldrls	r4, [r8, -r6]
 3d0:	13011942 	movwne	r1, #6466	; 0x1942
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	054c0000 	strbeq	r0, [ip, #-0]
 3d8:	3a0e0300 	bcc	380fe0 <unflatten_and_copy_device_tree+0x38016c>
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	00170213 	andseq	r0, r7, r3, lsl r2
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	011d4d00 	tsteq	sp, r0, lsl #26
 3e8:	01111331 	tsteq	r1, r1, lsr r3
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	0b580612 	bleq	1601c3c <unflatten_and_copy_device_tree+0x1600dc8>
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	00000559 	andeq	r0, r0, r9, asr r5
 3f4:	3100054e 	tstcc	r0, lr, asr #10
			pp->name = "name";
 3f8:	4f000013 	svcmi	0x00000013
 3fc:	00018289 	andeq	r8, r1, r9, lsl #5
 400:	13310111 	teqne	r1, #1073741828	; 0x40000004
			pp->length = sz;
			pp->value = pp + 1;
 404:	05500000 	ldrbeq	r0, [r0, #-0]
 408:	3a080300 	bcc	201010 <unflatten_and_copy_device_tree+0x20019c>
			*prev_pp = pp;
 40c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
 410:	00170213 	andseq	r0, r7, r3, lsl r2
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
 414:	00055100 	andeq	r5, r5, r0, lsl #2
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
 418:	0b3a0e03 	bleq	e83c2c <unflatten_and_copy_device_tree+0xe82db8>
			prev_pp = &pp->next;
 41c:	1349053b 	movtne	r0, #38203	; 0x953b
			memcpy(pp->value, ps, sz - 1);
 420:	00001802 	andeq	r1, r0, r2, lsl #16
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
 424:	03012e52 	movweq	r2, #7762	; 0x1e52
			memcpy(pp->value, ps, sz - 1);
 428:	3b0b3a0e 	blcc	2cec68 <unflatten_and_copy_device_tree+0x2cddf4>
			((char *)pp->value)[sz - 1] = 0;
 42c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 430:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
 434:	97184006 	ldrls	r4, [r8, -r6]
 438:	13011942 	movwne	r1, #6466	; 0x1942
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 43c:	05530000 	ldrbeq	r0, [r3, #-0]
 440:	3a0e0300 	bcc	381048 <unflatten_and_copy_device_tree+0x3801d4>
		np->name = of_get_property(np, "name", NULL);
 444:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 448:	00170213 	andseq	r0, r7, r3, lsl r2
 44c:	00055400 	andeq	r5, r5, r0, lsl #8
 450:	0b3a0803 	bleq	e82464 <unflatten_and_copy_device_tree+0xe815f0>
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 454:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		np->name = of_get_property(np, "name", NULL);
 458:	00001702 	andeq	r1, r0, r2, lsl #14
		np->type = of_get_property(np, "device_type", NULL);
 45c:	03000555 	movweq	r0, #1365	; 0x555
 460:	3b0b3a0e 	blcc	2ceca0 <unflatten_and_copy_device_tree+0x2cde2c>
 464:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
 468:	56000018 			; <UNDEFINED> instruction: 0x56000018
		np->type = of_get_property(np, "device_type", NULL);
 46c:	08030034 	stmdaeq	r3, {r2, r4, r5}
 470:	0b3b0b3a 	bleq	ec3160 <unflatten_and_copy_device_tree+0xec22ec>

		if (!np->name)
 474:	17021349 	strne	r1, [r2, -r9, asr #6]
 478:	34570000 	ldrbcc	r0, [r7], #-0
			np->name = "<NULL>";
 47c:	3a0e0300 	bcc	381084 <unflatten_and_copy_device_tree+0x380210>
 480:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 484:	00170213 	andseq	r0, r7, r3, lsl r2
		if (!np->type)
 488:	00345800 	eorseq	r5, r4, r0, lsl #16
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
 48c:	0b3a0e03 	bleq	e83ca0 <unflatten_and_copy_device_tree+0xe82e2c>

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
 490:	13490b3b 	movtne	r0, #39739	; 0x9b3b
 494:	00001802 	andeq	r1, r0, r2, lsl #16
 498:	31011d59 	tstcc	r1, r9, asr sp
 49c:	55015213 	strpl	r5, [r1, #-531]	; 0xfffffded
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a0:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
 4a4:	0013010b 	andseq	r0, r3, fp, lsl #2
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a8:	010b5a00 	tsteq	fp, r0, lsl #20
 4ac:	00001755 	andeq	r1, r0, r5, asr r7
 4b0:	3100345b 	tstcc	r0, fp, asr r4
 4b4:	5c000013 	stcpl	0, cr0, [r0], {19}
 4b8:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
 4bc:	00001301 	andeq	r1, r0, r1, lsl #6

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
 4c0:	0300345d 	movweq	r3, #1117	; 0x45d
 4c4:	3b0b3a0e 	blcc	2ced04 <unflatten_and_copy_device_tree+0x2cde90>
 4c8:	02134905 	andseq	r4, r3, #81920	; 0x14000
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4cc:	5e000017 	mcrpl	0, 0, r0, cr0, cr7, {0}
 4d0:	08030034 	stmdaeq	r3, {r2, r4, r5}
		if (new_format) {
 4d4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
	node->fwnode.type = FWNODE_OF;
 4d8:	17021349 	strne	r1, [r2, -r9, asr #6]
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4dc:	1d5f0000 	ldclne	0, cr0, [pc, #-0]	; 4e4 <.debug_abbrev+0x4e4>
 4e0:	11133101 	tstne	r3, r1, lsl #2
		if (new_format) {
 4e4:	58061201 	stmdapl	r6, {r0, r9, ip}
			/* rebuild full path for new format */
			if (dad && dad->parent) {
 4e8:	0105590b 	tsteq	r5, fp, lsl #18
 4ec:	60000013 	andvs	r0, r0, r3, lsl r0
 4f0:	0111010b 	tsteq	r1, fp, lsl #2
 4f4:	00000612 	andeq	r0, r0, r2, lsl r6
 4f8:	31011d61 	tstcc	r1, r1, ror #26
				strcpy(fn, dad->full_name);
 4fc:	55015213 	strpl	r5, [r1, #-531]	; 0xfffffded
 500:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
 504:	00130105 	andseq	r0, r3, r5, lsl #2
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
 508:	011d6200 	tsteq	sp, r0, lsl #4
 50c:	01521331 	cmpeq	r2, r1, lsr r3
 510:	0b581755 	bleq	160626c <unflatten_and_copy_device_tree+0x16053f8>
			}
			*(fn++) = '/';
 514:	00000b59 	andeq	r0, r0, r9, asr fp
 518:	31011d63 	tstcc	r1, r3, ror #26
 51c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
		}
		memcpy(fn, pathp, l);
 520:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
 524:	6400000b 	strvs	r0, [r0], #-11
 528:	0111010b 	tsteq	r1, fp, lsl #2

		prev_pp = &np->properties;
 52c:	13010612 	movwne	r0, #5650	; 0x1612
 530:	34650000 	strbtcc	r0, [r5], #-0
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
 534:	02133100 	andseq	r3, r3, #0, 2

		prev_pp = &np->properties;
		if (dad != NULL) {
 538:	66000017 			; <UNDEFINED> instruction: 0x66000017
			np->parent = dad;
 53c:	13310034 	teqne	r1, #52	; 0x34
			np->sibling = dad->child;
 540:	00001802 	andeq	r1, r0, r2, lsl #16
 544:	3f012e67 	svccc	0x00012e67
			dad->child = np;
 548:	3a0e0319 	bcc	3811b4 <unflatten_and_copy_device_tree+0x380340>
 54c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
 550:	11134919 	tstne	r3, r9, lsl r9

	if (nodepp)
		*nodepp = np;

	return mem;
}
 554:	40061201 	andmi	r1, r6, r1, lsl #4
 558:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 55c:	00001301 	andeq	r1, r0, r1, lsl #6
 560:	03003468 	movweq	r3, #1128	; 0x468
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 564:	3b0b3a0e 	blcc	2ceda4 <unflatten_and_copy_device_tree+0x2cdf30>
 568:	02134905 	andseq	r4, r3, #81920	; 0x14000
 56c:	69000018 	stmdbvs	r0, {r3, r4}
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
 570:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
 574:	06120111 			; <UNDEFINED> instruction: 0x06120111
 578:	42961840 	addsmi	r1, r6, #64, 16	; 0x400000
 57c:	00130119 	andseq	r0, r3, r9, lsl r1
 580:	00056a00 	andeq	r6, r5, r0, lsl #20
			break;
 584:	17021331 	smladxne	r2, r1, r3, r1
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
 588:	2e6b0000 	cdpcs	0, 6, cr0, cr11, cr0, {0}
 58c:	03193f01 	tsteq	r9, #1, 30
 590:	3b0b3a0e 	blcc	2cedd0 <unflatten_and_copy_device_tree+0x2cdf5c>
 594:	11192705 	tstne	r9, r5, lsl #14
 598:	40061201 	andmi	r1, r6, r1, lsl #4
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 59c:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
 5a0:	00001301 	andeq	r1, r0, r1, lsl #6
 5a4:	3f012e6c 	svccc	0x00012e6c
 5a8:	3a0e0319 	bcc	381214 <unflatten_and_copy_device_tree+0x3803a0>
 5ac:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
 5b0:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5b4:	97184006 	ldrls	r4, [r8, -r6]
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 5b8:	13011942 	movwne	r1, #6466	; 0x1942
 5bc:	1d6d0000 	stclne	0, cr0, [sp, #-0]
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5c0:	11133101 	tstne	r3, r1, lsl #2
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
 5c4:	58061201 	stmdapl	r6, {r0, r9, ip}
 5c8:	010b590b 	tsteq	fp, fp, lsl #18
 5cc:	6e000013 	mcrvs	0, 0, r0, cr0, cr3, {0}
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5d0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5d4:	0b3a0e03 	bleq	e83de8 <unflatten_and_copy_device_tree+0xe82f74>
 5d8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
 5dc:	01111349 	tsteq	r1, r9, asr #6
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5e0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5e4:	01194297 			; <UNDEFINED> instruction: 0x01194297
 5e8:	6f000013 	svcvs	0x00000013
 5ec:	08030034 	stmdaeq	r3, {r2, r4, r5}
 5f0:	0b3b0b3a 	bleq	ec32e0 <unflatten_and_copy_device_tree+0xec246c>
 5f4:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 5f8:	2e700000 	cdpcs	0, 7, cr0, cr0, cr0, {0}
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 5fc:	03193f01 	tsteq	r9, #1, 30
 600:	3b0b3a0e 	blcc	2cee40 <unflatten_and_copy_device_tree+0x2cdfcc>
 604:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
 608:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
 60c:	96184006 	ldrls	r4, [r8], -r6

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 610:	13011942 	movwne	r1, #6466	; 0x1942
 614:	2e710000 	cdpcs	0, 7, cr0, cr1, cr0, {0}
	memset(mem, 0, size);
 618:	11133100 	tstne	r3, r0, lsl #2
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 61c:	40061201 	andmi	r1, r6, r1, lsl #4
	memset(mem, 0, size);
 620:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 624:	2e720000 	cdpcs	0, 7, cr0, cr2, cr0, {0}
 628:	11133101 	tstne	r3, r1, lsl #2

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 62c:	40061201 	andmi	r1, r6, r1, lsl #4

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 630:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 634:	00001301 	andeq	r1, r0, r1, lsl #6
 638:	03003473 	movweq	r3, #1139	; 0x473

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 63c:	3b0b3a08 	blcc	2cee64 <unflatten_and_copy_device_tree+0x2cdff0>
 640:	02134905 	andseq	r4, r3, #81920	; 0x14000
 644:	74000018 	strvc	r0, [r0], #-24	; 0xffffffe8
 648:	1331011d 	teqne	r1, #1073741831	; 0x40000007
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 64c:	17550152 			; <UNDEFINED> instruction: 0x17550152
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 650:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xfffff4a8
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 654:	34750000 	ldrbtcc	r0, [r5], #-0
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 658:	490e0300 	stmdbmi	lr, {r8, r9}
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 65c:	02193413 	andseq	r3, r9, #318767104	; 0x13000000
 660:	76000018 			; <UNDEFINED> instruction: 0x76000018
 664:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 668:	0b3b0b3a 	bleq	ec3358 <unflatten_and_copy_device_tree+0xec24e4>
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
 66c:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
 670:	0000193c 	andeq	r1, r0, ip, lsr r9

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
 674:	00002177 	andeq	r2, r0, r7, ror r1
 678:	00347800 	eorseq	r7, r4, r0, lsl #16

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 67c:	0b3a0e03 	bleq	e83e90 <unflatten_and_copy_device_tree+0xe8301c>
 680:	1349053b 	movtne	r0, #38203	; 0x953b

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 684:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 688:	34790000 	ldrbtcc	r0, [r9], #-0

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 68c:	3a0e0300 	bcc	381294 <unflatten_and_copy_device_tree+0x380420>
 690:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 694:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 698:	7a000018 	bvc	700 <dt_mem_next_cell+0x28>
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 69c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 6a0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xfffff4c6
 6a4:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
 6a8:	00001802 	andeq	r1, r0, r2, lsl #16
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 6ac:	3f002e7b 	svccc	0x00002e7b
 6b0:	6e193c19 	mrcvs	12, 0, r3, cr9, cr9, {0}
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
 6b4:	3a0e030e 	bcc	3812f4 <unflatten_and_copy_device_tree+0x380480>
 6b8:	00053b0b 	andeq	r3, r5, fp, lsl #22
 6bc:	002e7c00 	eoreq	r7, lr, r0, lsl #24
 6c0:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
 6c4:	0e030e6e 	cdpeq	14, 0, cr0, cr3, cr14, {3}
 6c8:	2e7d0000 	cdpcs	0, 7, cr0, cr13, cr0, {0}
 6cc:	3c193f00 	ldccc	15, cr3, [r9], {-0}
		return;
 6d0:	030e6e19 	movweq	r6, #60953	; 0xee19
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6d4:	3b0b3a0e 	blcc	2cef14 <unflatten_and_copy_device_tree+0x2ce0a0>
 6d8:	0000000b 	andeq	r0, r0, fp

Disassembly of section .debug_loc:

00000000 <.debug_loc>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
       0:	00000000 	andeq	r0, r0, r0
       4:	0000001f 	andeq	r0, r0, pc, lsl r0
       8:	93500006 	cmpls	r0, #6
       c:	04935104 	ldreq	r5, [r3], #260	; 0x104
	...
      1c:	0000001f 	andeq	r0, r0, pc, lsl r0
	return kzalloc(size, GFP_KERNEL);
}
      20:	93520006 	cmpls	r2, #6

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      24:	04935304 	ldreq	r5, [r3], #772	; 0x304
	...
      30:	00000024 	andeq	r0, r0, r4, lsr #32
      34:	00000044 	andeq	r0, r0, r4, asr #32
	memcpy(buf, initial_boot_params + off, count);
      38:	00500001 	subseq	r0, r0, r1
      3c:	00000000 	andeq	r0, r0, r0
      40:	24000000 	strcs	r0, [r0], #-0

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      44:	4c000000 	stcmi	0, cr0, [r0], {-0}
	memcpy(buf, initial_boot_params + off, count);
      48:	01000000 	mrseq	r0, (UNDEF: 0)
      4c:	00005100 	andeq	r5, r0, r0, lsl #2
      50:	00000000 	andeq	r0, r0, r0
      54:	00240000 	eoreq	r0, r4, r0
	return count;
}
      58:	003c0000 	eorseq	r0, ip, r0
      5c:	00010000 	andeq	r0, r1, r0
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      60:	00000052 	andeq	r0, r0, r2, asr r0
      64:	00000000 	andeq	r0, r0, r0
      68:	00002400 	andeq	r2, r0, r0, lsl #8
      6c:	00004800 	andeq	r4, r0, r0, lsl #16
      70:	53000100 	movwpl	r0, #256	; 0x100
	...
      7c:	00000024 	andeq	r0, r0, r4, lsr #32
      80:	00000048 	andeq	r0, r0, r8, asr #32
      84:	00910002 	addseq	r0, r1, r2
	...
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      90:	00000060 	andeq	r0, r0, r0, rrx
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      94:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
      98:	9f500001 	svcls	0x00500001
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      9c:	9c000000 	stcls	0, cr0, [r0], {-0}
	if (!pathp)
      a0:	01000005 	tsteq	r0, r5
      a4:	00005600 	andeq	r5, r0, r0, lsl #12
      a8:	00000000 	andeq	r0, r0, r0
      ac:	00600000 	rsbeq	r0, r0, r0
		return mem;

	allocl = ++l;
      b0:	00940000 	addseq	r0, r4, r0
      b4:	00010000 	andeq	r0, r1, r0
      b8:	00009451 	andeq	r9, r0, r1, asr r4
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      bc:	00010400 	andeq	r0, r1, r0, lsl #8
      c0:	58000100 	stmdapl	r0, {r8}
      c4:	00000108 	andeq	r0, r0, r8, lsl #2
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
      c8:	00000110 	andeq	r0, r0, r0, lsl r1
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      cc:	10580001 	subsne	r0, r8, r1
		new_format = 1;
		if (fpsize == 0) {
      d0:	d8000001 	stmdale	r0, {r0}
      d4:	01000001 	tsteq	r0, r1
      d8:	01d85400 	bicseq	r5, r8, r0, lsl #8
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      dc:	01f00000 	mvnseq	r0, r0
      e0:	00010000 	andeq	r0, r1, r0
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
      e4:	0001f053 	andeq	pc, r1, r3, asr r0	; <UNPREDICTABLE>
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
      e8:	00020800 	andeq	r0, r2, r0, lsl #16
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      ec:	54000100 	strpl	r0, [r0], #-256	; 0xffffff00
			pathp = "";
      f0:	00000208 	andeq	r0, r0, r8, lsl #4
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
      f4:	00000214 	andeq	r0, r0, r4, lsl r2
			allocl = 2;
			l = 1;
			pathp = "";
      f8:	18530001 	ldmdane	r3, {r0}^
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
      fc:	2c000002 	stccs	0, cr0, [r0], {2}
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     100:	01000002 	tsteq	r0, r2
     104:	022c5800 	eoreq	r5, ip, #0, 16
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     108:	02600000 	rsbeq	r0, r0, #0
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     10c:	00010000 	andeq	r0, r1, r0
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
     110:	00026054 	andeq	r6, r2, r4, asr r0
     114:	00027800 	andeq	r7, r2, r0, lsl #16
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     118:	58000100 	stmdapl	r0, {r8}
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     11c:	00000278 	andeq	r0, r0, r8, ror r2
     120:	000002d4 	ldrdeq	r0, [r0], -r4
     124:	d4540001 	ldrble	r0, [r4], #-1
     128:	0b000002 	bleq	10 <.debug_loc+0x10>
     12c:	01000003 	tsteq	r0, r3
     130:	030b5100 	movweq	r5, #45312	; 0xb100

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     134:	03100000 	tsteq	r0, #0
     138:	00010000 	andeq	r0, r1, r0
     13c:	00031058 	andeq	r1, r3, r8, asr r0
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     140:	00032000 	andeq	r2, r3, r0
     144:	51000100 	mrspl	r0, (UNDEF: 16)
     148:	00000320 	andeq	r0, r0, r0, lsr #6
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     14c:	00000334 	andeq	r0, r0, r4, lsr r3
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     150:	34540001 	ldrbcc	r0, [r4], #-1
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     154:	ec000003 	stc	0, cr0, [r0], {3}
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     158:	01000003 	tsteq	r0, r3
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     15c:	03ec5800 	mvneq	r5, #0, 16
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     160:	043c0000 	ldrteq	r0, [ip], #-0
			    (strcmp(pname, "linux,phandle") == 0)) {
     164:	00010000 	andeq	r0, r1, r0
     168:	00043c54 	andeq	r3, r4, r4, asr ip
     16c:	0004b800 	andeq	fp, r4, r0, lsl #16
     170:	58000100 	stmdapl	r0, {r8}
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
     174:	000004b8 			; <UNDEFINED> instruction: 0x000004b8
     178:	000004c0 	andeq	r0, r0, r0, asr #9
     17c:	c0510001 	subsgt	r0, r1, r1
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     180:	50000004 	andpl	r0, r0, r4
     184:	01000005 	tsteq	r0, r5
     188:	05505400 	ldrbeq	r5, [r0, #-1024]	; 0xfffffc00
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     18c:	05880000 	streq	r0, [r8]
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     190:	00010000 	andeq	r0, r1, r0
     194:	00058858 	andeq	r8, r5, r8, asr r8
	res = *mem;
	*mem += size;
     198:	00059c00 	andeq	r9, r5, r0, lsl #24
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
     19c:	54000100 	strpl	r0, [r0], #-256	; 0xffffff00
	...
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     1a8:	00000060 	andeq	r0, r0, r0, rrx
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1ac:	00000090 	muleq	r0, r0, r0
     1b0:	90520001 	subsls	r0, r2, r1
     1b4:	9f000000 	svcls	0x00000000
     1b8:	01000000 	mrseq	r0, (UNDEF: 0)
     1bc:	01205c00 			; <UNDEFINED> instruction: 0x01205c00
			    (strcmp(pname, "linux,phandle") == 0)) {
     1c0:	012b0000 			; <UNDEFINED> instruction: 0x012b0000
     1c4:	00010000 	andeq	r0, r1, r0
     1c8:	00027c53 	andeq	r7, r2, r3, asr ip
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1cc:	0002b000 	andeq	fp, r2, r0
     1d0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
     1d4:	000002b0 			; <UNDEFINED> instruction: 0x000002b0
     1d8:	000002c0 	andeq	r0, r0, r0, asr #5
     1dc:	d8530001 	ldmdale	r3, {r0}^
     1e0:	48000002 	stmdami	r0, {r1}
					np->phandle = be32_to_cpup(p);
     1e4:	01000003 	tsteq	r0, r3
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     1e8:	03685700 	cmneq	r8, #0, 14
     1ec:	03840000 	orreq	r0, r4, #0
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     1f0:	00010000 	andeq	r0, r1, r0
     1f4:	0004b857 	andeq	fp, r4, r7, asr r8
     1f8:	0004c000 	andeq	ip, r4, r0
     1fc:	57000100 	strpl	r0, [r0, -r0, lsl #2]
     200:	00000588 	andeq	r0, r0, r8, lsl #11
				np->phandle = be32_to_cpup(p);
     204:	0000059c 	muleq	r0, ip, r5
     208:	00570001 	subseq	r0, r7, r1
     20c:	00000000 	andeq	r0, r0, r0
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     210:	60000000 	andvs	r0, r0, r0
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
     214:	80000000 	andhi	r0, r0, r0
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
     218:	01000000 	mrseq	r0, (UNDEF: 0)
			pp->length = sz;
     21c:	00805300 	addeq	r5, r0, r0, lsl #6
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     220:	01300000 	teqeq	r0, r0
			prev_pp = &pp->next;
     224:	00010000 	andeq	r0, r1, r0
     228:	0004a055 	andeq	sl, r4, r5, asr r0
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
     22c:	0004b800 	andeq	fp, r4, r0, lsl #16
     230:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
     234:	000004c0 	andeq	r0, r0, r0, asr #9
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     238:	00000564 	andeq	r0, r0, r4, ror #10
     23c:	00550001 	subseq	r0, r5, r1
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
     240:	00000000 	andeq	r0, r0, r0
     244:	60000000 	andvs	r0, r0, r0
     248:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
     24c:	02000000 	andeq	r0, r0, #0
     250:	b8049100 	stmdalt	r4, {r8, ip, pc}
     254:	d0000000 	andle	r0, r0, r0
     258:	01000000 	mrseq	r0, (UNDEF: 0)
     25c:	00d05300 	sbcseq	r5, r0, r0, lsl #6
     260:	02dc0000 	sbcseq	r0, ip, #0
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
     264:	00020000 	andeq	r0, r2, r0
     268:	02dc0491 	sbcseq	r0, ip, #-1862270976	; 0x91000000
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
     26c:	04a00000 	strteq	r0, [r0], #0
     270:	00010000 	andeq	r0, r1, r0
     274:	0004a055 	andeq	sl, r4, r5, asr r0
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
     278:	0004b800 	andeq	fp, r4, r0, lsl #16
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     27c:	91000200 	mrsls	r0, R8_usr
     280:	0004b804 	andeq	fp, r4, r4, lsl #16
	*poffset = fdt_next_node(blob, *poffset, &depth);
     284:	0004c000 	andeq	ip, r4, r0
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     288:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
	*poffset = fdt_next_node(blob, *poffset, &depth);
     28c:	000004c0 	andeq	r0, r0, r0, asr #9
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     290:	00000588 	andeq	r0, r0, r8, lsl #11
	*poffset = fdt_next_node(blob, *poffset, &depth);
     294:	04910002 	ldreq	r0, [r1], #2
     298:	00000588 	andeq	r0, r0, r8, lsl #11
	if (depth < 0)
     29c:	0000059c 	muleq	r0, ip, r5
     2a0:	00550001 	subseq	r0, r5, r1
		depth = 0;
     2a4:	00000000 	andeq	r0, r0, r0
     2a8:	60000000 	andvs	r0, r0, r0
     2ac:	80000000 	andhi	r0, r0, r0
     2b0:	02000000 	andeq	r0, r0, #0
	while (*poffset > 0 && depth > old_depth)
     2b4:	80089100 	andhi	r9, r8, r0, lsl #2
     2b8:	9f000000 	svcls	0x00000000
     2bc:	01000000 	mrseq	r0, (UNDEF: 0)
     2c0:	01005300 	mrseq	r5, LR_irq
     2c4:	01140000 	tsteq	r4, r0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2c8:	00010000 	andeq	r0, r1, r0
     2cc:	00019053 	andeq	r9, r1, r3, asr r0
     2d0:	0001b700 	andeq	fp, r1, r0, lsl #14
     2d4:	53000100 	movwpl	r0, #256	; 0x100
     2d8:	0000022c 	andeq	r0, r0, ip, lsr #4
     2dc:	00000237 	andeq	r0, r0, r7, lsr r2

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     2e0:	70530001 	subsvc	r0, r3, r1
     2e4:	97000002 	strls	r0, [r0, -r2]
     2e8:	01000002 	tsteq	r0, r2
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2ec:	02f05300 	rscseq	r5, r0, #0, 6
     2f0:	03080000 	movweq	r0, #32768	; 0x8000
     2f4:	00010000 	andeq	r0, r1, r0
     2f8:	00032c53 	andeq	r2, r3, r3, asr ip
     2fc:	00033800 	andeq	r3, r3, r0, lsl #16
     300:	53000100 	movwpl	r0, #256	; 0x100
     304:	00000344 	andeq	r0, r0, r4, asr #6
     308:	00000350 	andeq	r0, r0, r0, asr r3
     30c:	68520001 	ldmdavs	r2, {r0}^

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     310:	6c000003 	stcvs	0, cr0, [r0], {3}
     314:	01000003 	tsteq	r0, r3
     318:	03e45300 	mvneq	r5, #0, 6
     31c:	03fc0000 	mvnseq	r0, #0
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
     320:	00010000 	andeq	r0, r1, r0
     324:	00043c53 	andeq	r3, r4, r3, asr ip

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
     328:	00044000 	andeq	r4, r4, r0
     32c:	53000100 	movwpl	r0, #256	; 0x100
	...
     338:	00000174 	andeq	r0, r0, r4, ror r1
     33c:	00000220 	andeq	r0, r0, r0, lsr #4
		struct device_node *child = np->child;
		np->child = NULL;
     340:	2c590001 	mrrccs	0, 0, r0, r9, cr1
     344:	94000002 	strls	r0, [r0], #-2
     348:	01000002 	tsteq	r0, r2
		while (child) {
			struct device_node *next = child->sibling;
     34c:	03845900 	orreq	r5, r4, #0, 18
			child->sibling = np->child;
     350:	03f00000 	mvnseq	r0, #0
     354:	00010000 	andeq	r0, r1, r0
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     358:	00043c59 	andeq	r3, r4, r9, asr ip
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
     35c:	0004a000 	andeq	sl, r4, r0
     360:	59000100 	stmdbpl	r0, {r8}
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     364:	00000564 	andeq	r0, r0, r4, ror #10
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     368:	00000588 	andeq	r0, r0, r8, lsl #11
		*nodepp = np;
     36c:	00590001 	subseq	r0, r9, r1
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     370:	00000000 	andeq	r0, r0, r0
		*nodepp = np;
     374:	14000000 	strne	r0, [r0], #-0
     378:	20000001 	andcs	r0, r0, r1

	return mem;
}
     37c:	01000001 	tsteq	r0, r1
     380:	02145300 	andseq	r5, r4, #0, 6
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     384:	02370000 	eorseq	r0, r7, #0
     388:	00010000 	andeq	r0, r1, r0
     38c:	00041053 	andeq	r1, r4, r3, asr r0
     390:	00042b00 	andeq	r2, r4, r0, lsl #22
     394:	53000100 	movwpl	r0, #256	; 0x100
     398:	00000440 	andeq	r0, r0, r0, asr #8
			if ((*p1) == '@')
     39c:	0000045b 	andeq	r0, r0, fp, asr r4
     3a0:	c0530001 	subsgt	r0, r3, r1
				pa = p1;
			if ((*p1) == '/')
     3a4:	d3000004 	movwle	r0, #4
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
     3a8:	01000004 	tsteq	r0, r4
     3ac:	05305300 	ldreq	r5, [r0, #-768]!	; 0xfffffd00
				pa = p1;
			if ((*p1) == '/')
     3b0:	05370000 	ldreq	r0, [r7, #-0]!
     3b4:	00010000 	andeq	r0, r1, r0
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     3b8:	00000053 	andeq	r0, r0, r3, asr r0
     3bc:	00000000 	andeq	r0, r0, r0
     3c0:	0000b000 	andeq	fp, r0, r0
     3c4:	00055000 	andeq	r5, r5, r0
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3c8:	91000200 	mrsls	r0, R8_usr
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     3cc:	00055c44 	andeq	r5, r5, r4, asr #24
     3d0:	00059c00 	andeq	r9, r5, r0, lsl #24
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3d4:	91000200 	mrsls	r0, R8_usr
     3d8:	00000044 	andeq	r0, r0, r4, asr #32
			pa = p1;
		sz = (pa - ps) + 1;
     3dc:	00000000 	andeq	r0, r0, r0
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3e0:	00029400 	andeq	r9, r2, r0, lsl #8
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     3e4:	00038400 	andeq	r8, r3, r0, lsl #8
     3e8:	59000100 	stmdbpl	r0, {r8}
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
     3ec:	000004b8 			; <UNDEFINED> instruction: 0x000004b8
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3f0:	000004c0 	andeq	r0, r0, r0, asr #9
     3f4:	88590001 	ldmdahi	r9, {r0}^
			pp->name = "name";
     3f8:	9c000005 	stcls	0, cr0, [r0], {5}
     3fc:	01000005 	tsteq	r0, r5
     400:	00005900 	andeq	r5, r0, r0, lsl #18
			pp->length = sz;
			pp->value = pp + 1;
     404:	00000000 	andeq	r0, r0, r0
     408:	01300000 	teqeq	r0, r0
			*prev_pp = pp;
     40c:	02640000 	rsbeq	r0, r4, #0
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
     410:	00010000 	andeq	r0, r1, r0
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
     414:	00038455 	andeq	r8, r3, r5, asr r4
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
     418:	0003d400 	andeq	sp, r3, r0, lsl #8
			prev_pp = &pp->next;
     41c:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
			memcpy(pp->value, ps, sz - 1);
     420:	00000564 	andeq	r0, r0, r4, ror #10
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
     424:	0000057c 	andeq	r0, r0, ip, ror r5
			memcpy(pp->value, ps, sz - 1);
     428:	00550001 	subseq	r0, r5, r1
			((char *)pp->value)[sz - 1] = 0;
     42c:	00000000 	andeq	r0, r0, r0
     430:	50000000 	andpl	r0, r0, r0
     434:	74000001 	strvc	r0, [r0], #-1
     438:	01000001 	tsteq	r0, r1
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     43c:	01745300 	cmneq	r4, r0, lsl #6
     440:	02800000 	addeq	r0, r0, #0
		np->name = of_get_property(np, "name", NULL);
     444:	00010000 	andeq	r0, r1, r0
     448:	00038457 	andeq	r8, r3, r7, asr r4
     44c:	0003d400 	andeq	sp, r3, r0, lsl #8
     450:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     454:	000003d4 	ldrdeq	r0, [r0], -r4
		np->name = of_get_property(np, "name", NULL);
     458:	000004a0 	andeq	r0, r0, r0, lsr #9
		np->type = of_get_property(np, "device_type", NULL);
     45c:	64570001 	ldrbvs	r0, [r7], #-1
     460:	70000005 	andvc	r0, r0, r5
     464:	01000005 	tsteq	r0, r5
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
     468:	05705500 	ldrbeq	r5, [r0, #-1280]!	; 0xfffffb00
		np->type = of_get_property(np, "device_type", NULL);
     46c:	05880000 	streq	r0, [r8]
     470:	00010000 	andeq	r0, r1, r0

		if (!np->name)
     474:	00000057 	andeq	r0, r0, r7, asr r0
     478:	00000000 	andeq	r0, r0, r0
			np->name = "<NULL>";
     47c:	0000cc00 	andeq	ip, r0, r0, lsl #24
     480:	0000f400 	andeq	pc, r0, r0, lsl #8
     484:	59000100 	stmdbpl	r0, {r8}
		if (!np->type)
     488:	000000f4 	strdeq	r0, [r0], -r4
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
     48c:	00000174 	andeq	r0, r0, r4, ror r1

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
     490:	40530001 	subsmi	r0, r3, r1
     494:	58000002 	stmdapl	r0, {r1}
     498:	01000002 	tsteq	r0, r2
     49c:	03845900 	orreq	r5, r4, #0, 18
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a0:	03f00000 	mvnseq	r0, #0
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
     4a4:	00010000 	andeq	r0, r1, r0
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a8:	0004a059 	andeq	sl, r4, r9, asr r0
     4ac:	0004b800 	andeq	fp, r4, r0, lsl #16
     4b0:	59000100 	stmdbpl	r0, {r8}
     4b4:	000004c0 	andeq	r0, r0, r0, asr #9
     4b8:	00000550 	andeq	r0, r0, r0, asr r5
     4bc:	5c590001 	mrrcpl	0, 0, r0, r9, cr1

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
     4c0:	70000005 	andvc	r0, r0, r5
     4c4:	01000005 	tsteq	r0, r5
     4c8:	00005900 	andeq	r5, r0, r0, lsl #18
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4cc:	00000000 	andeq	r0, r0, r0
     4d0:	01740000 	cmneq	r4, r0
		if (new_format) {
     4d4:	04a00000 	strteq	r0, [r0], #0
	node->fwnode.type = FWNODE_OF;
     4d8:	00020000 	andeq	r0, r2, r0
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4dc:	04b84891 	ldrteq	r4, [r8], #2193	; 0x891
     4e0:	04c00000 	strbeq	r0, [r0], #0
		if (new_format) {
     4e4:	00020000 	andeq	r0, r2, r0
			/* rebuild full path for new format */
			if (dad && dad->parent) {
     4e8:	05644891 	strbeq	r4, [r4, #-2193]!	; 0xfffff76f
     4ec:	059c0000 	ldreq	r0, [ip]
     4f0:	00020000 	andeq	r0, r2, r0
     4f4:	00004891 	muleq	r0, r1, r8
     4f8:	00000000 	andeq	r0, r0, r0
				strcpy(fn, dad->full_name);
     4fc:	01740000 	cmneq	r4, r0
     500:	04a00000 	strteq	r0, [r0], #0
     504:	00020000 	andeq	r0, r2, r0
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
     508:	04b84c91 	ldrteq	r4, [r8], #3217	; 0xc91
     50c:	04c00000 	strbeq	r0, [r0], #0
     510:	00020000 	andeq	r0, r2, r0
			}
			*(fn++) = '/';
     514:	05644c91 	strbeq	r4, [r4, #-3217]!	; 0xfffff36f
     518:	059c0000 	ldreq	r0, [ip]
     51c:	00020000 	andeq	r0, r2, r0
		}
		memcpy(fn, pathp, l);
     520:	00004c91 	muleq	r0, r1, ip
     524:	00000000 	andeq	r0, r0, r0
     528:	02780000 	rsbseq	r0, r8, #0

		prev_pp = &np->properties;
     52c:	02940000 	addseq	r0, r4, #0
     530:	00010000 	andeq	r0, r1, r0
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
     534:	0003f059 	andeq	pc, r3, r9, asr r0	; <UNPREDICTABLE>

		prev_pp = &np->properties;
		if (dad != NULL) {
     538:	00043400 	andeq	r3, r4, r0, lsl #8
			np->parent = dad;
     53c:	59000100 	stmdbpl	r0, {r8}
	...
			np->sibling = dad->child;
			dad->child = np;
     54c:	00000034 	andeq	r0, r0, r4, lsr r0
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
     550:	3c500001 	mrrccc	0, 0, r0, r0, cr1	; <UNPREDICTABLE>

	if (nodepp)
		*nodepp = np;

	return mem;
}
     554:	40000001 	andmi	r0, r0, r1
     558:	01000001 	tsteq	r0, r1
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     55c:	00005000 	andeq	r5, r0, r0
     560:	00000000 	andeq	r0, r0, r0
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     564:	00580000 	subseq	r0, r8, r0
     568:	00600000 	rsbeq	r0, r0, r0
     56c:	00010000 	andeq	r0, r1, r0
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
     570:	00007c54 	andeq	r7, r0, r4, asr ip
     574:	0000d400 	andeq	sp, r0, r0, lsl #8
     578:	54000100 	strpl	r0, [r0], #-256	; 0xffffff00
     57c:	0000013c 	andeq	r0, r0, ip, lsr r1
     580:	00000148 	andeq	r0, r0, r8, asr #2
			break;
     584:	00540001 	subseq	r0, r4, r1
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
     588:	00000000 	andeq	r0, r0, r0
     58c:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
     590:	60000000 	andvs	r0, r0, r0
     594:	01000000 	mrseq	r0, (UNDEF: 0)
     598:	00a05300 	adceq	r5, r0, r0, lsl #6
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     59c:	01480000 	mrseq	r0, (UNDEF: 72)
     5a0:	00020000 	andeq	r0, r2, r0
     5a4:	00005c91 	muleq	r0, r1, ip
     5a8:	00000000 	andeq	r0, r0, r0
     5ac:	01280000 			; <UNDEFINED> instruction: 0x01280000
     5b0:	01380000 	teqeq	r8, r0
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5b4:	00060000 	andeq	r0, r6, r0
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     5b8:	51049350 	tstpl	r4, r0, asr r3
     5bc:	013c0493 	teqeq	ip, r3	; <illegal shifter operand>
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5c0:	01400000 	mrseq	r0, (UNDEF: 64)
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
     5c4:	00060000 	andeq	r0, r6, r0
     5c8:	51049350 	tstpl	r4, r0, asr r3
     5cc:	00000493 	muleq	r0, r3, r4
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5d0:	00000000 	andeq	r0, r0, r0
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5d4:	01480000 	mrseq	r0, (UNDEF: 72)
     5d8:	01570000 	cmpeq	r7, r0
     5dc:	00060000 	andeq	r0, r6, r0
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5e0:	51049350 	tstpl	r4, r0, asr r3
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5e4:	00000493 	muleq	r0, r3, r4
     5e8:	00000000 	andeq	r0, r0, r0
     5ec:	01480000 	mrseq	r0, (UNDEF: 72)
     5f0:	01570000 	cmpeq	r7, r0
     5f4:	00060000 	andeq	r0, r6, r0
     5f8:	53049352 	movwpl	r9, #17234	; 0x4352
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     5fc:	00000493 	muleq	r0, r3, r4
     600:	00000000 	andeq	r0, r0, r0
     604:	015c0000 	cmpeq	ip, r0
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
     608:	015c0000 	cmpeq	ip, r0
     60c:	00010000 	andeq	r0, r1, r0

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     610:	00000050 	andeq	r0, r0, r0, asr r0
     614:	00000000 	andeq	r0, r0, r0
	memset(mem, 0, size);
     618:	00059c00 	andeq	r9, r5, r0, lsl #24
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     61c:	00066c00 	andeq	r6, r6, r0, lsl #24
	memset(mem, 0, size);
     620:	50000100 	andpl	r0, r0, r0, lsl #2

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     624:	0000066c 	andeq	r0, r0, ip, ror #12
     628:	000006d4 	ldrdeq	r0, [r0], -r4

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     62c:	00580001 	subseq	r0, r8, r1

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     630:	00000000 	andeq	r0, r0, r0

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     634:	9c000000 	stcls	0, cr0, [r0], {-0}
     638:	6c000005 	stcvs	0, cr0, [r0], {5}

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     63c:	01000006 	tsteq	r0, r6
     640:	066c5100 	strbteq	r5, [ip], -r0, lsl #2
     644:	06d40000 	ldrbeq	r0, [r4], r0
     648:	00010000 	andeq	r0, r1, r0
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     64c:	00000059 	andeq	r0, r0, r9, asr r0
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     650:	00000000 	andeq	r0, r0, r0
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     654:	00059c00 	andeq	r9, r5, r0, lsl #24
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     658:	00062000 	andeq	r2, r6, r0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
     65c:	52000100 	andpl	r0, r0, #0, 2
     660:	0000066c 	andeq	r0, r0, ip, ror #12
     664:	00000674 	andeq	r0, r0, r4, ror r6
     668:	c4570001 	ldrbgt	r0, [r7], #-1
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
     66c:	d4000006 	strle	r0, [r0], #-6
     670:	01000006 	tsteq	r0, r6

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
     674:	00005700 	andeq	r5, r0, r0, lsl #14
     678:	00000000 	andeq	r0, r0, r0

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     67c:	05e40000 	strbeq	r0, [r4, #0]!
     680:	06500000 	ldrbeq	r0, [r0], -r0

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     684:	00020000 	andeq	r0, r2, r0

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     688:	06507c76 			; <UNDEFINED> instruction: 0x06507c76

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     68c:	06740000 	ldrbteq	r0, [r4], -r0
     690:	00020000 	andeq	r0, r2, r0

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     694:	06745491 			; <UNDEFINED> instruction: 0x06745491
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     698:	069c0000 	ldreq	r0, [ip], r0
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     69c:	00020000 	andeq	r0, r2, r0
     6a0:	069c7c76 			; <UNDEFINED> instruction: 0x069c7c76
     6a4:	06c40000 	strbeq	r0, [r4], r0
     6a8:	00020000 	andeq	r0, r2, r0
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     6ac:	00005491 	muleq	r0, r1, r4
     6b0:	00000000 	andeq	r0, r0, r0
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
     6b4:	06200000 	strteq	r0, [r0], -r0
     6b8:	06c40000 	strbeq	r0, [r4], r0
     6bc:	00010000 	andeq	r0, r1, r0
     6c0:	00000057 	andeq	r0, r0, r7, asr r0
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
     6c4:	00000000 	andeq	r0, r0, r0
     6c8:	00061000 	andeq	r1, r6, r0
     6cc:	0006c400 	andeq	ip, r6, r0, lsl #8
		return;
     6d0:	54000100 	strpl	r0, [r0], #-256	; 0xffffff00
	...
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6dc:	000006d4 	ldrdeq	r0, [r0], -r4
     6e0:	000006f8 	strdeq	r0, [r0], -r8
     6e4:	f8500001 			; <UNDEFINED> instruction: 0xf8500001
	mutex_lock(&of_fdt_unflatten_mutex);
     6e8:	20000006 	andcs	r0, r0, r6
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6ec:	01000007 	tsteq	r0, r7
     6f0:	00005500 	andeq	r5, r0, r0, lsl #10
	mutex_lock(&of_fdt_unflatten_mutex);
     6f4:	00000000 	andeq	r0, r0, r0
     6f8:	06d40000 	ldrbeq	r0, [r4], r0
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
     6fc:	06fb0000 	ldrbteq	r0, [fp], r0
     700:	00010000 	andeq	r0, r1, r0
     704:	0006fb51 	andeq	pc, r6, r1, asr fp	; <UNPREDICTABLE>
     708:	00072000 	andeq	r2, r7, r0
     70c:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
	mutex_unlock(&of_fdt_unflatten_mutex);
     718:	00000720 	andeq	r0, r0, r0, lsr #14
     71c:	0000074c 	andeq	r0, r0, ip, asr #14
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     720:	4c500001 	mrrcmi	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
     724:	5c000007 	stcpl	0, cr0, [r0], {7}
     728:	01000008 	tsteq	r0, r8
     72c:	00005700 	andeq	r5, r0, r0, lsl #14
     730:	00000000 	andeq	r0, r0, r0
     734:	07d00000 	ldrbeq	r0, [r0, r0]
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     738:	08300000 	ldmdaeq	r0!, {}	; <UNPREDICTABLE>
     73c:	00010000 	andeq	r0, r1, r0
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     740:	00000056 	andeq	r0, r0, r6, asr r0
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     744:	00000000 	andeq	r0, r0, r0
     748:	0007f000 	andeq	pc, r7, r0
     74c:	00083000 	andeq	r3, r8, r0
     750:	91000200 	mrsls	r0, R8_usr
	if (root_offset < 0)
     754:	0000005c 	andeq	r0, r0, ip, asr r0
     758:	00000000 	andeq	r0, r0, r0
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
     75c:	00080800 	andeq	r0, r8, r0, lsl #16
     760:	00082000 	andeq	r2, r8, r0
     764:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     770:	00000798 	muleq	r0, r8, r7
				"#address-cells", NULL);
	if (addr_prop)
     774:	000007a8 	andeq	r0, r0, r8, lsr #15
     778:	b0550001 	subslt	r0, r5, r1
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     77c:	bc000007 	stclt	0, cr0, [r0], {7}
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     780:	01000007 	tsteq	r0, r7
     784:	08585500 	ldmdaeq	r8, {r8, sl, ip, lr}^
     788:	085c0000 	ldmdaeq	ip, {}^	; <UNPREDICTABLE>
     78c:	00010000 	andeq	r0, r1, r0
     790:	00000055 	andeq	r0, r0, r5, asr r0
     794:	00000000 	andeq	r0, r0, r0
     798:	00077800 	andeq	r7, r7, r0, lsl #16
				"#size-cells", NULL);
	if (size_prop)
     79c:	00078c00 	andeq	r8, r7, r0, lsl #24
     7a0:	53000100 	movwpl	r0, #256	; 0x100
     7a4:	00000830 	andeq	r0, r0, r0, lsr r8
     7a8:	00000843 	andeq	r0, r0, r3, asr #16
		nr_size_cells = fdt32_to_cpu(*size_prop);
     7ac:	00530001 	subseq	r0, r3, r1
     7b0:	00000000 	andeq	r0, r0, r0
     7b4:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
     7b8:	d0000007 	andle	r0, r0, r7

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
     7bc:	01000007 	tsteq	r0, r7
     7c0:	07fc5600 	ldrbeq	r5, [ip, r0, lsl #12]!
     7c4:	08040000 	stmdaeq	r4, {}	; <UNPREDICTABLE>
     7c8:	00010000 	andeq	r0, r1, r0
	if (memory > 0) {
     7cc:	00083056 	andeq	r3, r8, r6, asr r0
     7d0:	00085c00 	andeq	r5, r8, r0, lsl #24
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
     7d4:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
     7e0:	0000085c 	andeq	r0, r0, ip, asr r8
     7e4:	00000887 	andeq	r0, r0, r7, lsl #17
     7e8:	00500001 	subseq	r0, r0, r1
		if (len > limit*cell_size) {
     7ec:	00000000 	andeq	r0, r0, r0
     7f0:	5c000000 	stcpl	0, cr0, [r0], {-0}
     7f4:	87000008 	strhi	r0, [r0, -r8]
     7f8:	01000008 	tsteq	r0, r8
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
     7fc:	00005100 	andeq	r5, r0, r0, lsl #2
     800:	00000000 	andeq	r0, r0, r0
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
     804:	085c0000 	ldmdaeq	ip, {}^	; <UNPREDICTABLE>
     808:	08800000 	stmeq	r0, {}	; <UNPREDICTABLE>
     80c:	00010000 	andeq	r0, r1, r0
     810:	00088052 	andeq	r8, r8, r2, asr r0
     814:	0008f400 	andeq	pc, r8, r0, lsl #8
     818:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
     824:	000008ac 	andeq	r0, r0, ip, lsr #17
					len);
		}
	}
}
     828:	000008c8 	andeq	r0, r0, r8, asr #17
     82c:	e8500001 	ldmda	r0, {r0}^
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     830:	ec000008 	stc	0, cr0, [r0], {8}
     834:	01000008 	tsteq	r0, r8
     838:	00005000 	andeq	r5, r0, r0
     83c:	00000000 	andeq	r0, r0, r0
     840:	08f40000 	ldmeq	r4!, {}^	; <UNPREDICTABLE>
				"#size-cells", NULL);
	if (size_prop)
     844:	09170000 	ldmdbeq	r7, {}	; <UNPREDICTABLE>
     848:	00010000 	andeq	r0, r1, r0
     84c:	00000050 	andeq	r0, r0, r0, asr r0
		nr_size_cells = fdt32_to_cpu(*size_prop);
     850:	00000000 	andeq	r0, r0, r0
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     854:	0008f400 	andeq	pc, r8, r0, lsl #8
     858:	00091700 	andeq	r1, r9, r0, lsl #14
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
     85c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
     868:	00000924 	andeq	r0, r0, r4, lsr #18
     86c:	0000099c 	muleq	r0, ip, r9
     870:	9c500001 	mrrcls	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
     874:	ac000009 	stcge	0, cr0, [r0], {9}
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
     878:	01000009 	tsteq	r0, r9
     87c:	00005600 	andeq	r5, r0, r0, lsl #12
     880:	00000000 	andeq	r0, r0, r0
     884:	09240000 	stmdbeq	r4!, {}	; <UNPREDICTABLE>
	if (cp == NULL)
     888:	099c0000 	ldmibeq	ip, {}	; <UNPREDICTABLE>
     88c:	00010000 	andeq	r0, r1, r0
		return 0;
	while (cplen > 0) {
     890:	00099c51 	andeq	r9, r9, r1, asr ip
     894:	0009ac00 	andeq	sl, r9, r0, lsl #24
     898:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
     8a4:	00000924 	andeq	r0, r0, r4, lsr #18
     8a8:	0000099c 	muleq	r0, ip, r9
		cp += l;
		cplen -= l;
     8ac:	9c520001 	mrrcls	0, 0, r0, r2, cr1
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
     8b0:	ac000009 	stcge	0, cr0, [r0], {9}
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8b4:	01000009 	tsteq	r0, r9
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
     8b8:	00005500 	andeq	r5, r0, r0, lsl #10
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8bc:	00000000 	andeq	r0, r0, r0
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8c0:	01d80000 	bicseq	r0, r8, r0
     8c4:	02180000 	andseq	r0, r8, #0
     8c8:	00010000 	andeq	r0, r1, r0

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
     8cc:	00021850 	andeq	r1, r2, r0, asr r8
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8d0:	0002a000 	andeq	sl, r2, r0
			return score;
		l = strlen(cp) + 1;
     8d4:	59000100 	stmdbpl	r0, {r8}
	...
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8e0:	000001d8 	ldrdeq	r0, [r0], -r8
     8e4:	0000020c 	andeq	r0, r0, ip, lsl #4
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
     8e8:	0c510001 	mrrceq	0, 0, r0, r1, cr1
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8ec:	a0000002 	andge	r0, r0, r2
     8f0:	01000002 	tsteq	r0, r2
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
     8f4:	00005800 	andeq	r5, r0, r0, lsl #16
     8f8:	00000000 	andeq	r0, r0, r0
     8fc:	02480000 	subeq	r0, r8, #0
     900:	02500000 	subseq	r0, r0, #0
     904:	00010000 	andeq	r0, r1, r0
	if (fdt_getprop(blob, node, "big-endian", NULL))
     908:	00025050 	andeq	r5, r2, r0, asr r0
     90c:	00028400 	andeq	r8, r2, r0, lsl #8
     910:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
     91c:	00000214 	andeq	r0, r0, r4, lsl r2
     920:	00000250 	andeq	r0, r0, r0, asr r2
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     924:	84560001 	ldrbhi	r0, [r6], #-1
     928:	a0000002 	andge	r0, r0, r2
     92c:	01000002 	tsteq	r0, r2
     930:	00005600 	andeq	r5, r0, r0, lsl #12
     934:	00000000 	andeq	r0, r0, r0
	unsigned int tmp, score = 0;

	if (!compat)
     938:	02080000 	andeq	r0, r8, #0
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     93c:	02940000 	addseq	r0, r4, #0
     940:	00020000 	andeq	r0, r2, r0
	unsigned int tmp, score = 0;

	if (!compat)
     944:	02947c75 	addseq	r7, r4, #29952	; 0x7500
		return 0;

	while (*compat) {
     948:	02a00000 	adceq	r0, r0, #0
     94c:	00020000 	andeq	r0, r2, r0
     950:	00005491 	muleq	r0, r1, r4
     954:	00000000 	andeq	r0, r0, r0
		tmp = of_fdt_is_compatible(blob, node, *compat);
     958:	02600000 	rsbeq	r0, r0, #0
     95c:	02740000 	rsbseq	r0, r4, #0
     960:	00010000 	andeq	r0, r1, r0
		if (tmp && (score == 0 || (tmp < score)))
     964:	00000050 	andeq	r0, r0, r0, asr r0
     968:	00000000 	andeq	r0, r0, r0
     96c:	0002d800 	andeq	sp, r2, r0, lsl #16
     970:	0002fc00 	andeq	pc, r2, r0, lsl #24
     974:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     980:	000002d8 	ldrdeq	r0, [r0], -r8
     984:	000002f8 	strdeq	r0, [r0], -r8
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     988:	00510001 	subseq	r0, r1, r1
     98c:	00000000 	andeq	r0, r0, r0
     990:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
     994:	f4000002 	vst4.8	{d0-d3}, [r0], r2
     998:	01000002 	tsteq	r0, r2
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
     99c:	00005200 	andeq	r5, r0, r0, lsl #4
			score = tmp;
		compat++;
	}

	return score;
}
     9a0:	00000000 	andeq	r0, r0, r0
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     9a4:	03040000 	movweq	r0, #16384	; 0x4000
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
     9a8:	037c0000 	cmneq	ip, #0
	}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
     9ac:	00010000 	andeq	r0, r1, r0
     9b0:	00037c50 	andeq	r7, r3, r0, asr ip
     9b4:	00038c00 	andeq	r8, r3, r0, lsl #24
     9b8:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
	...
	if (buf)
     9c4:	00000304 	andeq	r0, r0, r4, lsl #6
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9c8:	00000328 	andeq	r0, r0, r8, lsr #6
     9cc:	7c510001 	mrrcvc	0, 0, r0, r1, cr1

	offset = fdt_path_offset(fdt, "/chosen");
     9d0:	84000003 	strhi	r0, [r0], #-3
     9d4:	01000003 	tsteq	r0, r3
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9d8:	00005100 	andeq	r5, r0, r0, lsl #2

	offset = fdt_path_offset(fdt, "/chosen");
     9dc:	00000000 	andeq	r0, r0, r0
     9e0:	03040000 	movweq	r0, #16384	; 0x4000
	if (offset < 0)
     9e4:	033b0000 	teqeq	fp, #0
     9e8:	00010000 	andeq	r0, r1, r0
		offset = fdt_path_offset(fdt, "/chosen@0");
     9ec:	00037c52 	andeq	r7, r3, r2, asr ip
     9f0:	00038400 	andeq	r8, r3, r0, lsl #8
     9f4:	52000100 	andpl	r0, r0, #0, 2
	...
	if (offset < 0)
     a00:	00000304 	andeq	r0, r0, r4, lsl #6
		return -ENOENT;
     a04:	00000330 	andeq	r0, r0, r0, lsr r3
     a08:	7c530001 	mrrcvc	0, 0, r0, r3, cr1

	p = fdt_getprop(fdt, offset, "stdout-path", &l);
     a0c:	84000003 	strhi	r0, [r0], #-3
     a10:	01000003 	tsteq	r0, r3
     a14:	00005300 	andeq	r5, r0, r0, lsl #6
     a18:	00000000 	andeq	r0, r0, r0
     a1c:	038c0000 	orreq	r0, ip, #0
     a20:	03c00000 	biceq	r0, r0, #0
	if (!p)
     a24:	00010000 	andeq	r0, r1, r0
     a28:	0003c050 	andeq	ip, r3, r0, asr r0
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
     a2c:	00053c00 	andeq	r3, r5, r0, lsl #24
     a30:	59000100 	stmdbpl	r0, {r8}
	...
     a3c:	0000038c 	andeq	r0, r0, ip, lsl #7
     a40:	00000534 	andeq	r0, r0, r4, lsr r5
	if (!p || !l)
     a44:	34510001 	ldrbcc	r0, [r1], #-1
     a48:	3c000005 	stccc	0, cr0, [r0], {5}
     a4c:	01000005 	tsteq	r0, r5
     a50:	00005500 	andeq	r5, r0, r0, lsl #10
     a54:	00000000 	andeq	r0, r0, r0
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a58:	038c0000 	orreq	r0, ip, #0
     a5c:	03d30000 	bicseq	r0, r3, #0
     a60:	00010000 	andeq	r0, r1, r0

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a64:	00053452 	andeq	r3, r5, r2, asr r4
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a68:	00053c00 	andeq	r3, r5, r0, lsl #24

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a6c:	52000100 	andpl	r0, r0, #0, 2
	...
	if (offset < 0)
     a78:	0000038c 	andeq	r0, r0, ip, lsl #7
     a7c:	00000534 	andeq	r0, r0, r4, lsr r5
     a80:	34530001 	ldrbcc	r0, [r3], #-1
     a84:	3c000005 	stccc	0, cr0, [r0], {5}
		return -ENODEV;
     a88:	01000005 	tsteq	r0, r5
     a8c:	00005800 	andeq	r5, r0, r0, lsl #16

	while (match->compatible[0]) {
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     a90:	00000000 	andeq	r0, r0, r0
     a94:	04f00000 	ldrbteq	r0, [r0], #0
     a98:	050f0000 	streq	r0, [pc, #-0]	; 8 <.debug_loc+0x8>
			match++;
     a9c:	00010000 	andeq	r0, r1, r0
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     aa0:	00051051 	andeq	r1, r5, r1, asr r0
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     aa4:	00052000 	andeq	r2, r5, r0
     aa8:	51000100 	mrspl	r0, (UNDEF: 16)
     aac:	00000530 	andeq	r0, r0, r0, lsr r5
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     ab0:	0000053c 	andeq	r0, r0, ip, lsr r5
     ab4:	00510001 	subseq	r0, r1, r1
     ab8:	00000000 	andeq	r0, r0, r0
		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
     abc:	9c000000 	stcls	0, cr0, [r0], {-0}
     ac0:	c8000004 	stmdagt	r0, {r2}
     ac4:	06000004 	streq	r0, [r0], -r4
		if (addr == OF_BAD_ADDR)
     ac8:	04935600 	ldreq	r5, [r3], #1536	; 0x600
     acc:	00049357 	andeq	r9, r4, r7, asr r3
     ad0:	00000000 	andeq	r0, r0, r0
     ad4:	14000000 	strne	r0, [r0], #-0
			return -ENXIO;
     ad8:	28000004 	stmdacs	r0, {r2}
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
		if (addr == OF_BAD_ADDR)
     adc:	02000004 	andeq	r0, r0, #4
			return -ENXIO;

		of_setup_earlycon(addr, match->data);
     ae0:	28549100 	ldmdacs	r4, {r8, ip, pc}^
     ae4:	2c000004 	stccs	0, cr0, [r0], {4}
{
	if (buf)
		return 0;

	return early_init_dt_scan_chosen_serial();
}
     ae8:	01000004 	tsteq	r0, r4
     aec:	04645300 	strbteq	r5, [r4], #-768	; 0xfffffd00
     af0:	04780000 	ldrbteq	r0, [r8], #-0
/*
 * called from unflatten_device_tree() to bootstrap devicetree itself
 * Architectures can override this definition if memblock isn't used
 */
void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
{
     af4:	00020000 	andeq	r0, r2, r0
     af8:	04785491 	ldrbteq	r5, [r8], #-1169	; 0xfffffb6f
     afc:	047c0000 	ldrbteq	r0, [ip], #-0
	return __va(memblock_alloc(size, align));
     b00:	00010000 	andeq	r0, r1, r0
	 * 'unsigned long' cast discard upper word when
	 * phys_addr_t is 64 bit, and makes sure that inline
	 * assembler expression receives 32 bit argument
	 * in place where 'r' 32 bit operand is expected.
	 */
	__pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);
     b04:	00000053 	andeq	r0, r0, r3, asr r0
}
     b08:	00000000 	andeq	r0, r0, r0
	memcpy(buf, initial_boot_params + off, count);
	return count;
}

static int __init of_fdt_raw_init(void)
{
     b0c:	00042c00 	andeq	r2, r4, r0, lsl #24
     b10:	00045b00 	andeq	r5, r4, r0, lsl #22
     b14:	53000100 	movwpl	r0, #256	; 0x100
	...
	static struct bin_attribute of_fdt_raw_attr =
		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);

	if (!initial_boot_params)
     b20:	0000047c 	andeq	r0, r0, ip, ror r4
     b24:	000004bc 			; <UNDEFINED> instruction: 0x000004bc
     b28:	00530001 	subseq	r0, r3, r1
     b2c:	00000000 	andeq	r0, r0, r0
		return 0;

	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
     b30:	3c000000 	stccc	0, cr0, [r0], {-0}
     b34:	5c000005 	stcpl	0, cr0, [r0], {5}
     b38:	01000005 	tsteq	r0, r5
     b3c:	00005000 	andeq	r5, r0, r0
     b40:	00000000 	andeq	r0, r0, r0
     b44:	053c0000 	ldreq	r0, [ip, #-0]!
     b48:	05580000 	ldrbeq	r0, [r8, #-0]
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
     b4c:	00010000 	andeq	r0, r1, r0
     b50:	00000051 	andeq	r0, r0, r1, asr r0
     b54:	00000000 	andeq	r0, r0, r0
		return 0;
     b58:	00056400 	andeq	r6, r5, r0, lsl #8
     b5c:	00058400 	andeq	r8, r5, r0, lsl #8
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b60:	50000100 	andpl	r0, r0, r0, lsl #2
	...
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b6c:	00000564 	andeq	r0, r0, r4, ror #10
     b70:	00000580 	andeq	r0, r0, r0, lsl #11
     b74:	00510001 	subseq	r0, r1, r1
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b78:	00000000 	andeq	r0, r0, r0
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b7c:	b0000000 	andlt	r0, r0, r0
     b80:	bf000005 	svclt	0x00000005
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     b84:	01000005 	tsteq	r0, r5
     b88:	05c45200 	strbeq	r5, [r4, #512]	; 0x200
     b8c:	05cc0000 	strbeq	r0, [ip]
     b90:	00010000 	andeq	r0, r1, r0
	const void *blob = initial_boot_params;
     b94:	00000052 	andeq	r0, r0, r2, asr r0
     b98:	00000000 	andeq	r0, r0, r0
	const char *pathp;
	int offset, rc = 0, depth = -1;
     b9c:	0005cc00 	andeq	ip, r5, r0, lsl #24
     ba0:	0005e800 	andeq	lr, r5, r0, lsl #16
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     ba4:	50000100 	andpl	r0, r0, r0, lsl #2
	const void *blob = initial_boot_params;
     ba8:	000005e8 	andeq	r0, r0, r8, ror #11
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     bac:	000005f4 	strdeq	r0, [r0], -r4
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bb0:	f4540001 			; <UNDEFINED> instruction: 0xf4540001

        for (offset = fdt_next_node(blob, -1, &depth);
     bb4:	24000005 	strcs	r0, [r0], #-5
     bb8:	01000006 	tsteq	r0, r6
				     void *data),
			   void *data)
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bbc:	06245700 	strteq	r5, [r4], -r0, lsl #14

        for (offset = fdt_next_node(blob, -1, &depth);
     bc0:	06280000 	strteq	r0, [r8], -r0
     bc4:	00010000 	andeq	r0, r1, r0
     bc8:	00062854 	andeq	r2, r6, r4, asr r8
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bcc:	0006b800 	andeq	fp, r6, r0, lsl #16
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bd0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bd4:	000006b8 			; <UNDEFINED> instruction: 0x000006b8
     bd8:	000006d8 	ldrdeq	r0, [r0], -r8
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bdc:	00540001 	subseq	r0, r4, r1
             offset >= 0 && depth >= 0 && !rc;
     be0:	00000000 	andeq	r0, r0, r0
     be4:	54000000 	strpl	r0, [r0], #-0
     be8:	b8000006 	stmdalt	r0, {r1, r2}
     bec:	01000006 	tsteq	r0, r6
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf0:	06d05400 	ldrbeq	r5, [r0], r0, lsl #8
		if (*pathp == '/')
     bf4:	06d80000 	ldrbeq	r0, [r8], r0

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf8:	00010000 	andeq	r0, r1, r0
		if (*pathp == '/')
     bfc:	00000054 	andeq	r0, r0, r4, asr r0
     c00:	00000000 	andeq	r0, r0, r0
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
	const char *tail = strrchr(path, '/');
     c04:	00066000 	andeq	r6, r6, r0
	return tail ? tail + 1 : path;
     c08:	00066b00 	andeq	r6, r6, r0, lsl #22
     c0c:	53000100 	movwpl	r0, #256	; 0x100
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c10:	0000066b 	andeq	r0, r0, fp, ror #12
     c14:	00000678 	andeq	r0, r0, r8, ror r6
     c18:	5c910002 	ldcpl	0, cr0, [r1], {2}
     c1c:	00000678 	andeq	r0, r0, r8, ror r6
     c20:	0000068b 	andeq	r0, r0, fp, lsl #13
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c24:	8b530001 	blhi	14c000c <unflatten_and_copy_device_tree+0x14bf198>
     c28:	b8000006 	stmdalt	r0, {r1, r2}

		pathp = fdt_get_name(blob, offset, NULL);
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c2c:	02000006 	andeq	r0, r0, #6
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c30:	d05c9100 	subsle	r9, ip, r0, lsl #2
     c34:	d8000006 	stmdale	r0, {r1, r2}
     c38:	02000006 	andeq	r0, r0, #6
     c3c:	005c9100 	subseq	r9, ip, r0, lsl #2
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
	}
	return rc;
}
     c40:	00000000 	andeq	r0, r0, r0
     c44:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
     c48:	f8000006 			; <UNDEFINED> instruction: 0xf8000006

/**
 * of_get_flat_dt_root - find the root node in the flat blob
 */
unsigned long __init of_get_flat_dt_root(void)
{
     c4c:	01000006 	tsteq	r0, r6
     c50:	06f85000 	ldrbteq	r5, [r8], r0
     c54:	072c0000 	streq	r0, [ip, -r0]!
	return 0;
}
     c58:	00010000 	andeq	r0, r1, r0
     c5c:	00000053 	andeq	r0, r0, r3, asr r0

/**
 * of_get_flat_dt_size - Return the total size of the FDT
 */
int __init of_get_flat_dt_size(void)
{
     c60:	00000000 	andeq	r0, r0, r0
     c64:	0006d800 	andeq	sp, r6, r0, lsl #16
     c68:	0006f400 	andeq	pc, r6, r0, lsl #8
	return fdt_totalsize(initial_boot_params);
     c6c:	51000100 	mrspl	r0, (UNDEF: 16)
     c70:	000006f4 	strdeq	r0, [r0], -r4
     c74:	00000718 	andeq	r0, r0, r8, lsl r7
     c78:	285c0001 	ldmdacs	ip, {r0}^
}
     c7c:	2c000007 	stccs	0, cr0, [r0], {7}
     c80:	01000007 	tsteq	r0, r7
 * This function can be used within scan_flattened_dt callback to get
 * access to properties
 */
const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
				       int *size)
{
     c84:	00005c00 	andeq	r5, r0, r0, lsl #24
     c88:	00000000 	andeq	r0, r0, r0
     c8c:	06f80000 	ldrbteq	r0, [r8], r0
	return fdt_getprop(initial_boot_params, node, name, size);
     c90:	072c0000 	streq	r0, [ip, -r0]!
     c94:	00060000 	andeq	r0, r6, r0
     c98:	51049350 	tstpl	r4, r0, asr r3
     c9c:	00000493 	muleq	r0, r3, r4
     ca0:	00000000 	andeq	r0, r0, r0
     ca4:	072c0000 	streq	r0, [ip, -r0]!
     ca8:	075c0000 	ldrbeq	r0, [ip, -r0]
}
     cac:	00060000 	andeq	r0, r6, r0
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cb0:	51049350 	tstpl	r4, r0, asr r3
     cb4:	075c0493 			; <UNDEFINED> instruction: 0x075c0493
     cb8:	08100000 	ldmdaeq	r0, {}	; <UNPREDICTABLE>
	const __be32 *prop;

	if (depth != 0)
     cbc:	00060000 	andeq	r0, r6, r0
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cc0:	57049356 	smlsdpl	r4, r6, r3, r9
	const __be32 *prop;

	if (depth != 0)
     cc4:	08180493 	ldmdaeq	r8, {r0, r1, r4, r7, sl}
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cc8:	08500000 	ldmdaeq	r0, {}^	; <UNPREDICTABLE>
     ccc:	00060000 	andeq	r0, r6, r0
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     cd0:	55049354 	strpl	r9, [r4, #-852]	; 0xfffffcac
     cd4:	08500493 	ldmdaeq	r0, {r0, r1, r4, r7, sl}^
	const __be32 *prop;

	if (depth != 0)
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cd8:	08640000 	stmdaeq	r4!, {}^	; <UNPREDICTABLE>
     cdc:	00060000 	andeq	r0, r6, r0
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     ce0:	57049354 	smlsdpl	r4, r4, r3, r9

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     ce4:	08640493 	stmdaeq	r4!, {r0, r1, r4, r7, sl}^
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     ce8:	08740000 	ldmdaeq	r4!, {}^	; <UNPREDICTABLE>
     cec:	00060000 	andeq	r0, r6, r0
     cf0:	55049356 	strpl	r9, [r4, #-854]	; 0xfffffcaa

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
     cf4:	08740493 	ldmdaeq	r4!, {r0, r1, r4, r7, sl}^
     cf8:	088c0000 	stmeq	ip, {}	; <UNPREDICTABLE>
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     cfc:	00060000 	andeq	r0, r6, r0
     d00:	55049354 	strpl	r9, [r4, #-852]	; 0xfffffcac
	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
     d04:	088c0493 	stmeq	ip, {r0, r1, r4, r7, sl}
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     d08:	08900000 	ldmeq	r0, {}	; <UNPREDICTABLE>
	if (prop)
     d0c:	00060000 	andeq	r0, r6, r0
     d10:	55049356 	strpl	r9, [r4, #-854]	; 0xfffffcaa
     d14:	08900493 	ldmeq	r0, {r0, r1, r4, r7, sl}
		dt_root_addr_cells = be32_to_cpup(prop);
     d18:	08ac0000 	stmiaeq	ip!, {}	; <UNPREDICTABLE>
     d1c:	00060000 	andeq	r0, r6, r0
     d20:	57049356 	smlsdpl	r4, r6, r3, r9
     d24:	08ac0493 	stmiaeq	ip!, {r0, r1, r4, r7, sl}
				   int depth, void *data)
{
	const __be32 *prop;

	if (depth != 0)
		return 0;
     d28:	08bc0000 	ldmeq	ip!, {}	; <UNPREDICTABLE>
     d2c:	00060000 	andeq	r0, r6, r0
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (prop)
     d30:	55049354 	strpl	r9, [r4, #-852]	; 0xfffffcac
		dt_root_addr_cells = be32_to_cpup(prop);
	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);

	/* break now */
	return 1;
}
     d34:	00000493 	muleq	r0, r3, r4
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d38:	00000000 	andeq	r0, r0, r0
     d3c:	072c0000 	streq	r0, [ip, -r0]!
     d40:	07700000 	ldrbeq	r0, [r0, -r0]!
     d44:	00060000 	andeq	r0, r6, r0
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d48:	53049352 	movwpl	r9, #17234	; 0x4352
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d4c:	07700493 			; <UNDEFINED> instruction: 0x07700493
     d50:	07b80000 	ldreq	r0, [r8, r0]!
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d54:	00060000 	andeq	r0, r6, r0
     d58:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
     d5c:	07d80493 	bfieq	r0, r3, #9, #16
     d60:	07dc0000 	ldrbeq	r0, [ip, r0]
     d64:	00060000 	andeq	r0, r6, r0
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
		return 0;
     d68:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d6c:	07e00493 			; <UNDEFINED> instruction: 0x07e00493
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d70:	07f80000 	ldrbeq	r0, [r8, r0]!
     d74:	00060000 	andeq	r0, r6, r0
     d78:	51049350 	tstpl	r4, r0, asr r3
     d7c:	07fc0493 			; <UNDEFINED> instruction: 0x07fc0493
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d80:	082c0000 	stmdaeq	ip!, {}	; <UNPREDICTABLE>
     d84:	00060000 	andeq	r0, r6, r0
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d88:	51049350 	tstpl	r4, r0, asr r3
     d8c:	082c0493 	stmdaeq	ip!, {r0, r1, r4, r7, sl}
     d90:	08bc0000 	ldmeq	ip!, {}	; <UNPREDICTABLE>
     d94:	00060000 	andeq	r0, r6, r0
     d98:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
		return 0;
     d9c:	00000493 	muleq	r0, r3, r4
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     da0:	00000000 	andeq	r0, r0, r0
	int len;
	const __be32 *prop;

	pr_debug("Looking for initrd properties... ");

	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
     da4:	07500000 	ldrbeq	r0, [r0, -r0]
     da8:	075c0000 	ldrbeq	r0, [ip, -r0]
     dac:	00060000 	andeq	r0, r6, r0
     db0:	57049356 	smlsdpl	r4, r6, r3, r9
     db4:	00000493 	muleq	r0, r3, r4
	if (!prop)
     db8:	00000000 	andeq	r0, r0, r0
     dbc:	08bc0000 	ldmeq	ip!, {}	; <UNPREDICTABLE>
		return;
	start = of_read_number(prop, len/4);
     dc0:	08df0000 	ldmeq	pc, {}^	; <UNPREDICTABLE>
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     dc4:	00010000 	andeq	r0, r1, r0
     dc8:	0008df50 	andeq	sp, r8, r0, asr pc
     dcc:	00094800 	andeq	r4, r9, r0, lsl #16
     dd0:	54000100 	strpl	r0, [r0], #-256	; 0xffffff00
     dd4:	000009ac 	andeq	r0, r0, ip, lsr #19
	while (size--)
     dd8:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
		r = (r << 32) | be32_to_cpu(*(cell++));
     ddc:	00540001 	subseq	r0, r4, r1

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     de0:	00000000 	andeq	r0, r0, r0
     de4:	bc000000 	stclt	0, cr0, [r0], {-0}
     de8:	d0000008 	andle	r0, r0, r8
		r = (r << 32) | be32_to_cpu(*(cell++));
     dec:	01000008 	tsteq	r0, r8
     df0:	00005100 	andeq	r5, r0, r0, lsl #2

	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
     df4:	00000000 	andeq	r0, r0, r0
     df8:	08bc0000 	ldmeq	ip!, {}	; <UNPREDICTABLE>
     dfc:	08d40000 	ldmeq	r4, {}^	; <UNPREDICTABLE>
     e00:	00010000 	andeq	r0, r1, r0
     e04:	00000052 	andeq	r0, r0, r2, asr r0
	if (!prop)
     e08:	00000000 	andeq	r0, r0, r0
     e0c:	0008bc00 	andeq	fp, r8, r0, lsl #24
		return;
	end = of_read_number(prop, len/4);
     e10:	0008df00 	andeq	sp, r8, r0, lsl #30
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     e14:	53000100 	movwpl	r0, #256	; 0x100
	...
     e20:	00000918 	andeq	r0, r0, r8, lsl r9
     e24:	00000958 	andeq	r0, r0, r8, asr r9
	while (size--)
     e28:	58910002 	ldmpl	r1, {r1}
		r = (r << 32) | be32_to_cpu(*(cell++));
     e2c:	00000958 	andeq	r0, r0, r8, asr r9

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e30:	00000964 	andeq	r0, r0, r4, ror #18
		r = (r << 32) | be32_to_cpu(*(cell++));
     e34:	64520001 	ldrbvs	r0, [r2], #-1
     e38:	b8000009 	stmdalt	r0, {r0, r3}

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e3c:	02000009 	andeq	r0, r0, #9
     e40:	00589100 	subseq	r9, r8, r0, lsl #2
		r = (r << 32) | be32_to_cpu(*(cell++));
     e44:	00000000 	andeq	r0, r0, r0
     e48:	54000000 	strpl	r0, [r0], #-0
     e4c:	58000009 	stmdapl	r0, {r0, r3}
     e50:	06000009 	streq	r0, [r0], -r9
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e54:	04935200 	ldreq	r5, [r3], #512	; 0x200
	initrd_end = (unsigned long)__va(end);
     e58:	94049353 	strls	r9, [r4], #-851	; 0xfffffcad
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e5c:	a7000009 	strge	r0, [r0, -r9]
	initrd_end = (unsigned long)__va(end);
     e60:	06000009 	streq	r0, [r0], -r9
	initrd_below_start_ok = 1;
     e64:	04935200 	ldreq	r5, [r3], #512	; 0x200
     e68:	00049353 	andeq	r9, r4, r3, asr r3
     e6c:	00000000 	andeq	r0, r0, r0
     e70:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e74:	d3000009 	movwle	r0, #9
	initrd_end = (unsigned long)__va(end);
	initrd_below_start_ok = 1;
     e78:	06000009 	streq	r0, [r0], -r9
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
	initrd_end = (unsigned long)__va(end);
     e7c:	04935000 	ldreq	r5, [r3], #0
	initrd_below_start_ok = 1;
     e80:	d8049351 	stmdale	r4, {r0, r4, r6, r8, r9, ip, pc}
		return 0;

	early_init_dt_check_for_initrd(node);

	/* Retrieve command line */
	p = of_get_flat_dt_prop(node, "bootargs", &l);
     e84:	db000009 	blle	2c <.debug_loc+0x2c>
     e88:	06000009 	streq	r0, [r0], -r9
     e8c:	04935000 	ldreq	r5, [r3], #0
     e90:	00049351 	andeq	r9, r4, r1, asr r3
     e94:	00000000 	andeq	r0, r0, r0
	if (p != NULL && l > 0)
     e98:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
     e9c:	d3000009 	movwle	r0, #9
     ea0:	06000009 	streq	r0, [r0], -r9
     ea4:	04935200 	ldreq	r5, [r3], #512	; 0x200
     ea8:	d8049353 	stmdale	r4, {r0, r1, r4, r6, r8, r9, ip, pc}
		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
     eac:	db000009 	blle	2c <.debug_loc+0x2c>
     eb0:	06000009 	streq	r0, [r0], -r9
     eb4:	04935200 	ldreq	r5, [r3], #512	; 0x200
     eb8:	00049353 	andeq	r9, r4, r3, asr r3
	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE
	 * is set in which case we override whatever was found earlier.
	 */
#ifdef CONFIG_CMDLINE
#ifndef CONFIG_CMDLINE_FORCE
	if (!((char *)data)[0])
     ebc:	00000000 	andeq	r0, r0, r0
     ec0:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
     ec4:	c8000009 	stmdagt	r0, {r0, r3}
#endif
		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
     ec8:	02000009 	andeq	r0, r0, #9
     ecc:	c8009100 	stmdagt	r0, {r8, ip, pc}
     ed0:	d3000009 	movwle	r0, #9
     ed4:	01000009 	tsteq	r0, r9
     ed8:	09d85c00 	ldmibeq	r8, {sl, fp, ip, lr}^
     edc:	09db0000 	ldmibeq	fp, {}^	; <UNPREDICTABLE>

	pr_debug("Command line is: %s\n", (char*)data);

	/* break now */
	return 1;
}
     ee0:	00010000 	andeq	r0, r1, r0
     ee4:	0000005c 	andeq	r0, r0, ip, asr r0
 * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
 * @node: node to test
 * @compat: compatible string to compare with compatible list.
 */
int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
{
     ee8:	00000000 	andeq	r0, r0, r0
     eec:	000a6000 	andeq	r6, sl, r0
     ef0:	000b4400 	andeq	r4, fp, r0, lsl #8
	return of_fdt_is_compatible(initial_boot_params, node, compat);
     ef4:	50000100 	andpl	r0, r0, r0, lsl #2
     ef8:	00000b44 	andeq	r0, r0, r4, asr #22
     efc:	00000d2c 	andeq	r0, r0, ip, lsr #26
     f00:	00540001 	subseq	r0, r4, r1
     f04:	00000000 	andeq	r0, r0, r0
     f08:	60000000 	andvs	r0, r0, r0
}
     f0c:	a800000a 	stmdage	r0, {r1, r3}

/**
 * of_flat_dt_match - Return true if node matches a list of compatible values
 */
int __init of_flat_dt_match(unsigned long node, const char *const *compat)
{
     f10:	0100000a 	tsteq	r0, sl
     f14:	0aa85100 	beq	fea14408 <__crc_of_fdt_unflatten_tree+0x77cd2e4b>
     f18:	0d2c0000 	stceq	0, cr0, [ip, #-0]
	return of_fdt_match(initial_boot_params, node, compat);
     f1c:	00010000 	andeq	r0, r1, r0
     f20:	00000059 	andeq	r0, r0, r9, asr r0
     f24:	00000000 	andeq	r0, r0, r0
     f28:	000a6000 	andeq	r6, sl, r0
     f2c:	000b4400 	andeq	r4, fp, r0, lsl #8
     f30:	52000100 	andpl	r0, r0, #0, 2
}
     f34:	00000b44 	andeq	r0, r0, r4, asr #22
	int (*iterator)(unsigned long node, const char *uname, int depth, void *data);
	void *data;
};

const char * __init of_flat_dt_get_machine_name(void)
{
     f38:	00000ba4 	andeq	r0, r0, r4, lsr #23
     f3c:	10580001 	subsne	r0, r8, r1
     f40:	2c00000d 	stccs	0, cr0, [r0], {13}
	const char *name;
	unsigned long dt_root = of_get_flat_dt_root();

	name = of_get_flat_dt_prop(dt_root, "model", NULL);
     f44:	0100000d 	tsteq	r0, sp
     f48:	00005800 	andeq	r5, r0, r0, lsl #16
     f4c:	00000000 	andeq	r0, r0, r0
     f50:	0a600000 	beq	1800008 <unflatten_and_copy_device_tree+0x17ff194>
     f54:	0a880000 	beq	fe200008 <__crc_of_fdt_unflatten_tree+0x774bea4b>
	if (!name)
     f58:	00010000 	andeq	r0, r1, r0
     f5c:	00000053 	andeq	r0, r0, r3, asr r0
		name = of_get_flat_dt_prop(dt_root, "compatible", NULL);
     f60:	00000000 	andeq	r0, r0, r0
     f64:	000a9800 	andeq	r9, sl, r0, lsl #16
     f68:	000a9c00 	andeq	r9, sl, r0, lsl #24
     f6c:	55000100 	strpl	r0, [r0, #-256]	; 0xffffff00
	return name;
}
     f70:	00000b60 	andeq	r0, r0, r0, ror #22
     f74:	00000b94 	muleq	r0, r4, fp
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f78:	00550001 	subseq	r0, r5, r1
     f7c:	00000000 	andeq	r0, r0, r0
     f80:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
     f84:	a000000a 	andge	r0, r0, sl
	const void *data = NULL;
	const void *best_data = default_match;
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;
     f88:	0100000a 	tsteq	r0, sl
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f8c:	0bbc5800 	bleq	fef16008 <__crc_of_fdt_unflatten_tree+0x781d4a4b>
     f90:	0d100000 	ldceq	0, cr0, [r0, #-0]
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;

	dt_root = of_get_flat_dt_root();
	while ((data = get_next_compat(&compat))) {
     f94:	00010000 	andeq	r0, r1, r0
     f98:	000d2058 	andeq	r2, sp, r8, asr r0
     f9c:	000d2c00 	andeq	r2, sp, r0, lsl #24
     fa0:	58000100 	stmdapl	r0, {r8}
	...
		score = of_flat_dt_match(dt_root, compat);
     fac:	00000a98 	muleq	r0, r8, sl
		if (score > 0 && score < best_score) {
     fb0:	00000aa0 	andeq	r0, r0, r0, lsr #21
     fb4:	48910002 	ldmmi	r1, {r1}
     fb8:	00000c2c 	andeq	r0, r0, ip, lsr #24
     fbc:	00000c8c 	andeq	r0, r0, ip, lsl #25
     fc0:	48910002 	ldmmi	r1, {r1}
     fc4:	00000c8c 	andeq	r0, r0, ip, lsl #25
     fc8:	00000c93 	muleq	r0, r3, ip
     fcc:	93500006 	cmpls	r0, #6
     fd0:	04935104 	ldreq	r5, [r3], #260	; 0x104
			best_data = data;
			best_score = score;
		}
	}
	if (!best_data) {
     fd4:	00000c93 	muleq	r0, r3, ip
     fd8:	00000cd4 	ldrdeq	r0, [r0], -r4
		const char *prop;
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");
     fdc:	48910002 	ldmmi	r1, {r1}
     fe0:	00000d20 	andeq	r0, r0, r0, lsr #26
     fe4:	00000d2c 	andeq	r0, r0, ip, lsr #26

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
     fe8:	48910002 	ldmmi	r1, {r1}
	...
     ff4:	00000a98 	muleq	r0, r8, sl
     ff8:	00000aa0 	andeq	r0, r0, r0, lsr #21
		if (prop) {
     ffc:	93560006 	cmpls	r6, #6
			while (size > 0) {
				printk("'%s' ", prop);
    1000:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    1004:	00000c2c 	andeq	r0, r0, ip, lsr #24
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
    1008:	00000c84 	andeq	r0, r0, r4, lsl #25
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
				prop += strlen(prop) + 1;
			}
		}
		printk("]\n\n");
    100c:	93560006 	cmpls	r6, #6
    1010:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    1014:	00000c84 	andeq	r0, r0, r4, lsl #25
		return NULL;
    1018:	00000c8c 	andeq	r0, r0, ip, lsl #25
    101c:	93500006 	cmpls	r0, #6

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
    1020:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    1024:	00000c8c 	andeq	r0, r0, ip, lsl #25
    1028:	00000cd4 	ldrdeq	r0, [r0], -r4
				printk("'%s' ", prop);
    102c:	93560006 	cmpls	r6, #6
    1030:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    1034:	00000d20 	andeq	r0, r0, r0, lsr #26
				size -= strlen(prop) + 1;
    1038:	00000d2c 	andeq	r0, r0, ip, lsr #26
    103c:	93560006 	cmpls	r6, #6
    1040:	04935704 	ldreq	r5, [r3], #1796	; 0x704
	...
				prop += strlen(prop) + 1;
    104c:	00000a98 	muleq	r0, r8, sl

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
    1050:	00000aa0 	andeq	r0, r0, r0, lsr #21
				prop += strlen(prop) + 1;
    1054:	40910002 	addsmi	r0, r1, r2
    1058:	00000bcc 	andeq	r0, r0, ip, asr #23
    105c:	00000c30 	andeq	r0, r0, r0, lsr ip
    1060:	40910002 	addsmi	r0, r1, r2
		}
		printk("]\n\n");
		return NULL;
	}

	pr_info("Machine model: %s\n", of_flat_dt_get_machine_name());
    1064:	00000c30 	andeq	r0, r0, r0, lsr ip
    1068:	00000cac 	andeq	r0, r0, ip, lsr #25
    106c:	ac530001 	mrrcge	0, 0, r0, r3, cr1
    1070:	d400000c 	strle	r0, [r0], #-12
    1074:	0200000c 	andeq	r0, r0, #12

	return best_data;
    1078:	20409100 	subcs	r9, r0, r0, lsl #2
}
    107c:	2c00000d 	stccs	0, cr0, [r0], {13}
    1080:	0200000d 	andeq	r0, r0, #13
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1084:	00409100 	subeq	r9, r0, r0, lsl #2
    1088:	00000000 	andeq	r0, r0, r0
    108c:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
	const __be32 *p = *cellp;
    1090:	a000000a 	andge	r0, r0, sl
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1094:	0200000a 	andeq	r0, r0, #10
    1098:	c8449100 	stmdagt	r4, {r8, ip, pc}^
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
    109c:	1000000b 	andne	r0, r0, fp
    10a0:	0200000d 	andeq	r0, r0, #13
	const __be32 *p = *cellp;

	*cellp = p + s;
    10a4:	20449100 	subcs	r9, r4, r0, lsl #2
    10a8:	2c00000d 	stccs	0, cr0, [r0], {13}
	while (size--)
    10ac:	0200000d 	andeq	r0, r0, #13
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b0:	00449100 	subeq	r9, r4, r0, lsl #2

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10b4:	00000000 	andeq	r0, r0, r0
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b8:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10bc:	2400000c 	strcs	r0, [r0], #-12
    10c0:	0100000c 	tsteq	r0, ip
		r = (r << 32) | be32_to_cpu(*(cell++));
    10c4:	0ca05300 	stceq	3, cr5, [r0]
    10c8:	0ca80000 	stceq	0, cr0, [r8]
    10cc:	00010000 	andeq	r0, r1, r0
    10d0:	000cc853 	andeq	ip, ip, r3, asr r8
	return of_read_number(p, s);
}
    10d4:	000ccf00 	andeq	ip, ip, r0, lsl #30
#ifndef MAX_MEMBLOCK_ADDR
#define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)
#endif

void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
{
    10d8:	5c000100 	stfpls	f0, [r0], {-0}
	...
    10e4:	00000d54 	andeq	r0, r0, r4, asr sp
    10e8:	00000d6f 	andeq	r0, r0, pc, ror #26
    10ec:	93500006 	cmpls	r0, #6
    10f0:	04935104 	ldreq	r5, [r3], #260	; 0x104
	...

	if (sizeof(phys_addr_t) == 4) {
		__pv_stub(x, t, "add", __PV_BITS_31_24);
	} else {
		__pv_stub_mov_hi(t);
		__pv_add_carry_stub(x, t);
    10fc:	00000d78 	andeq	r0, r0, r8, ror sp
    1100:	00000dc8 	andeq	r0, r0, r8, asr #27
    1104:	c8500001 	ldmdagt	r0, {r0}^
	const u64 phys_offset = MIN_MEMBLOCK_ADDR;
	printk("lwg:%s:%d:phys_offset = %llx\n", __func__, __LINE__, phys_offset);
    1108:	d000000d 	andle	r0, r0, sp
    110c:	0100000d 	tsteq	r0, sp
    1110:	00005500 	andeq	r5, r0, r0, lsl #10
    1114:	00000000 	andeq	r0, r0, r0
    1118:	0e140000 	cdpeq	0, 1, cr0, cr4, cr0, {0}
    111c:	0e230000 	cdpeq	0, 2, cr0, cr3, cr0, {0}
    1120:	00010000 	andeq	r0, r1, r0

	if (!PAGE_ALIGNED(base)) {
    1124:	00000050 	andeq	r0, r0, r0, asr r0
    1128:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	000000e4 	andeq	r0, r0, r4, ror #1
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
	...
  14:	000009ac 	andeq	r0, r0, ip, lsr #19
  18:	00000000 	andeq	r0, r0, r0
  1c:	00000148 	andeq	r0, r0, r8, asr #2
	return kzalloc(size, GFP_KERNEL);
}
  20:	00000148 	andeq	r0, r0, r8, asr #2

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	00000018 	andeq	r0, r0, r8, lsl r0
  28:	00000160 	andeq	r0, r0, r0, ror #2
  2c:	00000078 	andeq	r0, r0, r8, ror r0
  30:	000001d8 	ldrdeq	r0, [r0], -r8
  34:	000000c8 	andeq	r0, r0, r8, asr #1
	memcpy(buf, initial_boot_params + off, count);
  38:	000002a0 	andeq	r0, r0, r0, lsr #5
  3c:	00000014 	andeq	r0, r0, r4, lsl r0
  40:	000002b4 			; <UNDEFINED> instruction: 0x000002b4

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	00000024 	andeq	r0, r0, r4, lsr #32
	memcpy(buf, initial_boot_params + off, count);
  48:	000002d8 	ldrdeq	r0, [r0], -r8
  4c:	0000002c 	andeq	r0, r0, ip, lsr #32
  50:	00000304 	andeq	r0, r0, r4, lsl #6
  54:	00000088 	andeq	r0, r0, r8, lsl #1
	return count;
}
  58:	0000038c 	andeq	r0, r0, ip, lsl #7
  5c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	0000053c 	andeq	r0, r0, ip, lsr r5
  64:	00000028 	andeq	r0, r0, r8, lsr #32
  68:	00000564 	andeq	r0, r0, r4, ror #10
  6c:	00000028 	andeq	r0, r0, r8, lsr #32
  70:	0000058c 	andeq	r0, r0, ip, lsl #11
  74:	00000040 	andeq	r0, r0, r0, asr #32
  78:	000005cc 	andeq	r0, r0, ip, asr #11
  7c:	0000010c 	andeq	r0, r0, ip, lsl #2
  80:	000006d8 	ldrdeq	r0, [r0], -r8
  84:	00000054 	andeq	r0, r0, r4, asr r0
  88:	0000072c 	andeq	r0, r0, ip, lsr #14
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	00000190 	muleq	r0, r0, r1
  90:	000008bc 			; <UNDEFINED> instruction: 0x000008bc
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	000000fc 	strdeq	r0, [r0], -ip
  98:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	00000028 	andeq	r0, r0, r8, lsr #32
	if (!pathp)
  a0:	000009e0 	andeq	r0, r0, r0, ror #19
  a4:	00000080 	andeq	r0, r0, r0, lsl #1
  a8:	00000a60 	andeq	r0, r0, r0, ror #20
  ac:	000002cc 	andeq	r0, r0, ip, asr #5
		return mem;

	allocl = ++l;
  b0:	00000d2c 	andeq	r0, r0, ip, lsr #26
  b4:	0000004c 	andeq	r0, r0, ip, asr #32
  b8:	00000d78 	andeq	r0, r0, r8, ror sp
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	00000058 	andeq	r0, r0, r8, asr r0
  c0:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  c4:	00000044 	andeq	r0, r0, r4, asr #32
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	00000e14 	andeq	r0, r0, r4, lsl lr
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	00000024 	andeq	r0, r0, r4, lsr #32
		new_format = 1;
		if (fpsize == 0) {
  d0:	00000e38 	andeq	r0, r0, r8, lsr lr
  d4:	0000003c 	andeq	r0, r0, ip, lsr r0
  d8:	00000e74 	andeq	r0, r0, r4, ror lr
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	0000006c 	andeq	r0, r0, ip, rrx
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00000100 	andeq	r0, r0, r0, lsl #2
   4:	00000108 	andeq	r0, r0, r8, lsl #2
   8:	0000010c 	andeq	r0, r0, ip, lsl #2
   c:	00000110 	andeq	r0, r0, r0, lsl r1
	...
  18:	00000134 	andeq	r0, r0, r4, lsr r1
  1c:	0000014c 	andeq	r0, r0, ip, asr #2
	return kzalloc(size, GFP_KERNEL);
}
  20:	00000150 	andeq	r0, r0, r0, asr r1

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	00000154 	andeq	r0, r0, r4, asr r1
  28:	00000158 	andeq	r0, r0, r8, asr r1
  2c:	0000015c 	andeq	r0, r0, ip, asr r1
  30:	00000160 	andeq	r0, r0, r0, ror #2
  34:	0000022c 	andeq	r0, r0, ip, lsr #4
	memcpy(buf, initial_boot_params + off, count);
  38:	00000240 	andeq	r0, r0, r0, asr #4
  3c:	00000264 	andeq	r0, r0, r4, ror #4
  40:	00000570 	andeq	r0, r0, r0, ror r5

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	00000588 	andeq	r0, r0, r8, lsl #11
	...
	memcpy(buf, initial_boot_params + off, count);
  50:	000001e0 	andeq	r0, r0, r0, ror #3
  54:	000001e4 	andeq	r0, r0, r4, ror #3
	return count;
}
  58:	000001e8 	andeq	r0, r0, r8, ror #3
  5c:	000001ec 	andeq	r0, r0, ip, ror #3
	...
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  68:	00000200 	andeq	r0, r0, r0, lsl #4
  6c:	00000204 	andeq	r0, r0, r4, lsl #4
  70:	00000208 	andeq	r0, r0, r8, lsl #4
  74:	0000020c 	andeq	r0, r0, ip, lsl #4
	...
  80:	00000200 	andeq	r0, r0, r0, lsl #4
  84:	00000204 	andeq	r0, r0, r4, lsl #4
  88:	00000208 	andeq	r0, r0, r8, lsl #4
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	0000020c 	andeq	r0, r0, ip, lsl #4
	...
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  98:	0000034c 	andeq	r0, r0, ip, asr #6
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	00000358 	andeq	r0, r0, r8, asr r3
	if (!pathp)
  a0:	0000035c 	andeq	r0, r0, ip, asr r3
  a4:	00000360 	andeq	r0, r0, r0, ror #6
	...
		return mem;

	allocl = ++l;
  b0:	00000384 	andeq	r0, r0, r4, lsl #7
  b4:	0000043c 	andeq	r0, r0, ip, lsr r4
  b8:	00000564 	andeq	r0, r0, r4, ror #10
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	00000570 	andeq	r0, r0, r0, ror r5
	...
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	000003cc 	andeq	r0, r0, ip, asr #7
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	000003d4 	ldrdeq	r0, [r0], -r4
		new_format = 1;
		if (fpsize == 0) {
  d0:	000003e4 	andeq	r0, r0, r4, ror #7
  d4:	000003ec 	andeq	r0, r0, ip, ror #7
	...
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  e0:	000004c0 	andeq	r0, r0, r0, asr #9
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	00000550 	andeq	r0, r0, r0, asr r5
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	0000055c 	andeq	r0, r0, ip, asr r5
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	00000564 	andeq	r0, r0, r4, ror #10
	...
			pathp = "";
  f8:	000004c0 	andeq	r0, r0, r0, asr #9
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	000004cc 	andeq	r0, r0, ip, asr #9
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	000004d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
 104:	000004d4 	ldrdeq	r0, [r0], -r4
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	000004d8 	ldrdeq	r0, [r0], -r8
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	000004dc 	ldrdeq	r0, [r0], -ip
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	000004e0 	andeq	r0, r0, r0, ror #9
 114:	000004e4 	andeq	r0, r0, r4, ror #9
	...
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 120:	000000e4 	andeq	r0, r0, r4, ror #1
 124:	000000f4 	strdeq	r0, [r0], -r4
 128:	000000f8 	strdeq	r0, [r0], -r8
 12c:	00000104 	andeq	r0, r0, r4, lsl #2
 130:	00000110 	andeq	r0, r0, r0, lsl r1

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	0000013c 	andeq	r0, r0, ip, lsr r1
	...
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	00000180 	andeq	r0, r0, r0, lsl #3
 144:	00000184 	andeq	r0, r0, r4, lsl #3
 148:	00000188 	andeq	r0, r0, r8, lsl #3
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	0000018c 	andeq	r0, r0, ip, lsl #3
	...
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	0000066c 	andeq	r0, r0, ip, ror #12
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	00000674 	andeq	r0, r0, r4, ror r6
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	000006c4 	andeq	r0, r0, r4, asr #13
	...
 170:	00000618 	andeq	r0, r0, r8, lsl r6
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	0000061c 	andeq	r0, r0, ip, lsl r6
 178:	00000620 	andeq	r0, r0, r0, lsr #12
 17c:	00000624 	andeq	r0, r0, r4, lsr #12
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	00000674 	andeq	r0, r0, r4, ror r6
 184:	0000067c 	andeq	r0, r0, ip, ror r6
	...
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	00000654 	andeq	r0, r0, r4, asr r6
 194:	0000065c 	andeq	r0, r0, ip, asr r6
	res = *mem;
	*mem += size;
 198:	000006ac 	andeq	r0, r0, ip, lsr #13
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	000006b4 			; <UNDEFINED> instruction: 0x000006b4
	...
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a8:	0000077c 	andeq	r0, r0, ip, ror r7
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	00000780 	andeq	r0, r0, r0, lsl #15
 1b0:	00000794 	muleq	r0, r4, r7
 1b4:	00000798 	muleq	r0, r8, r7
	...
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	0000031c 	andeq	r0, r0, ip, lsl r3
 1c4:	0000037c 	andeq	r0, r0, ip, ror r3
 1c8:	00000384 	andeq	r0, r0, r4, lsl #7
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	00000388 	andeq	r0, r0, r8, lsl #7
	...
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d8:	0000034c 	andeq	r0, r0, ip, asr #6
 1dc:	00000350 	andeq	r0, r0, r0, asr r3
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	00000354 	andeq	r0, r0, r4, asr r3
					np->phandle = be32_to_cpup(p);
 1e4:	00000358 	andeq	r0, r0, r8, asr r3
	...
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	0000034c 	andeq	r0, r0, ip, asr #6
 1f4:	00000350 	andeq	r0, r0, r0, asr r3
 1f8:	00000354 	andeq	r0, r0, r4, asr r3
 1fc:	00000358 	andeq	r0, r0, r8, asr r3
	...
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 208:	00000368 	andeq	r0, r0, r8, ror #6
				np->phandle = be32_to_cpup(p);
 20c:	0000036c 	andeq	r0, r0, ip, ror #6
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	00000370 	andeq	r0, r0, r0, ror r3
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	00000374 	andeq	r0, r0, r4, ror r3
	...
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	00000368 	andeq	r0, r0, r8, ror #6
			prev_pp = &pp->next;
 224:	0000036c 	andeq	r0, r0, ip, ror #6
 228:	00000370 	andeq	r0, r0, r0, ror r3
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	00000374 	andeq	r0, r0, r4, ror r3
	...
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	00000418 	andeq	r0, r0, r8, lsl r4
 23c:	0000041c 	andeq	r0, r0, ip, lsl r4
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	0000042c 	andeq	r0, r0, ip, lsr #8
 244:	00000448 	andeq	r0, r0, r8, asr #8
	...
 250:	00000468 	andeq	r0, r0, r8, ror #8
 254:	0000046c 	andeq	r0, r0, ip, ror #8
 258:	0000047c 	andeq	r0, r0, ip, ror r4
 25c:	000004a8 	andeq	r0, r0, r8, lsr #9
	...
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 268:	00000494 	muleq	r0, r4, r4
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	00000498 	muleq	r0, r8, r4
 270:	0000049c 	muleq	r0, ip, r4
 274:	000004a0 	andeq	r0, r0, r0, lsr #9
	...
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 280:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	000006f8 	strdeq	r0, [r0], -r8
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	00000700 	andeq	r0, r0, r0, lsl #14
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	00000728 	andeq	r0, r0, r8, lsr #14
	...
 298:	00000714 	andeq	r0, r0, r4, lsl r7
	if (depth < 0)
 29c:	00000718 	andeq	r0, r0, r8, lsl r7
 2a0:	0000071c 	andeq	r0, r0, ip, lsl r7
		depth = 0;
 2a4:	00000720 	andeq	r0, r0, r0, lsr #14
	...
 2b0:	00000ab8 			; <UNDEFINED> instruction: 0x00000ab8
	while (*poffset > 0 && depth > old_depth)
 2b4:	00000b38 	andeq	r0, r0, r8, lsr fp
 2b8:	00000b3c 	andeq	r0, r0, ip, lsr fp
 2bc:	00000b44 	andeq	r0, r0, r4, asr #22
	...
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	00000adc 	ldrdeq	r0, [r0], -ip
 2cc:	00000ae0 	andeq	r0, r0, r0, ror #21
 2d0:	00000ae4 	andeq	r0, r0, r4, ror #21
 2d4:	00000ae8 	andeq	r0, r0, r8, ror #21
	...

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	00000adc 	ldrdeq	r0, [r0], -ip
 2e4:	00000ae0 	andeq	r0, r0, r0, ror #21
 2e8:	00000ae4 	andeq	r0, r0, r4, ror #21
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	00000ae8 	andeq	r0, r0, r8, ror #21
	...
 2f8:	00000b0c 	andeq	r0, r0, ip, lsl #22
 2fc:	00000b10 	andeq	r0, r0, r0, lsl fp
 300:	00000b14 	andeq	r0, r0, r4, lsl fp
 304:	00000b18 	andeq	r0, r0, r8, lsl fp
	...

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	00000b0c 	andeq	r0, r0, ip, lsl #22
 314:	00000b10 	andeq	r0, r0, r0, lsl fp
 318:	00000b14 	andeq	r0, r0, r4, lsl fp
 31c:	00000b18 	andeq	r0, r0, r8, lsl fp
	...

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	00000ea4 	andeq	r0, r0, r4, lsr #29
 32c:	00000ea8 	andeq	r0, r0, r8, lsr #29
 330:	00000eb0 			; <UNDEFINED> instruction: 0x00000eb0
 334:	00000eb4 			; <UNDEFINED> instruction: 0x00000eb4
	...
		struct device_node *child = np->child;
		np->child = NULL;
 344:	000009ac 	andeq	r0, r0, ip, lsr #19
 348:	00000000 	andeq	r0, r0, r0
		while (child) {
			struct device_node *next = child->sibling;
 34c:	00000148 	andeq	r0, r0, r8, asr #2
			child->sibling = np->child;
 350:	00000148 	andeq	r0, r0, r8, asr #2
 354:	00000160 	andeq	r0, r0, r0, ror #2
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	00000160 	andeq	r0, r0, r0, ror #2
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	000001d8 	ldrdeq	r0, [r0], -r8
 360:	000001d8 	ldrdeq	r0, [r0], -r8
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	000002a0 	andeq	r0, r0, r0, lsr #5
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	000002a0 	andeq	r0, r0, r0, lsr #5
		*nodepp = np;
 36c:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	000002b4 			; <UNDEFINED> instruction: 0x000002b4
		*nodepp = np;
 374:	000002d8 	ldrdeq	r0, [r0], -r8
 378:	000002d8 	ldrdeq	r0, [r0], -r8

	return mem;
}
 37c:	00000304 	andeq	r0, r0, r4, lsl #6
 380:	00000304 	andeq	r0, r0, r4, lsl #6
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	0000038c 	andeq	r0, r0, ip, lsl #7
 388:	0000038c 	andeq	r0, r0, ip, lsl #7
 38c:	0000053c 	andeq	r0, r0, ip, lsr r5
 390:	0000053c 	andeq	r0, r0, ip, lsr r5
 394:	00000564 	andeq	r0, r0, r4, ror #10
 398:	00000564 	andeq	r0, r0, r4, ror #10
			if ((*p1) == '@')
 39c:	0000058c 	andeq	r0, r0, ip, lsl #11
 3a0:	0000058c 	andeq	r0, r0, ip, lsl #11
				pa = p1;
			if ((*p1) == '/')
 3a4:	000005cc 	andeq	r0, r0, ip, asr #11
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	000005cc 	andeq	r0, r0, ip, asr #11
 3ac:	000006d8 	ldrdeq	r0, [r0], -r8
				pa = p1;
			if ((*p1) == '/')
 3b0:	000006d8 	ldrdeq	r0, [r0], -r8
 3b4:	0000072c 	andeq	r0, r0, ip, lsr #14
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	0000072c 	andeq	r0, r0, ip, lsr #14
 3bc:	000008bc 			; <UNDEFINED> instruction: 0x000008bc
 3c0:	000008bc 			; <UNDEFINED> instruction: 0x000008bc
 3c4:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	000009e0 	andeq	r0, r0, r0, ror #19
 3d0:	000009e0 	andeq	r0, r0, r0, ror #19
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	00000a60 	andeq	r0, r0, r0, ror #20
 3d8:	00000a60 	andeq	r0, r0, r0, ror #20
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	00000d2c 	andeq	r0, r0, ip, lsr #26
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	00000d2c 	andeq	r0, r0, ip, lsr #26
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	00000d78 	andeq	r0, r0, r8, ror sp
 3e8:	00000d78 	andeq	r0, r0, r8, ror sp
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
 3f4:	00000e14 	andeq	r0, r0, r4, lsl lr
			pp->name = "name";
 3f8:	00000e14 	andeq	r0, r0, r4, lsl lr
 3fc:	00000e38 	andeq	r0, r0, r8, lsr lr
 400:	00000e38 	andeq	r0, r0, r8, lsr lr
			pp->length = sz;
			pp->value = pp + 1;
 404:	00000e74 	andeq	r0, r0, r4, ror lr
 408:	00000e74 	andeq	r0, r0, r4, ror lr
			*prev_pp = pp;
 40c:	00000ee0 	andeq	r0, r0, r0, ror #29
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00000d8e 	andeq	r0, r0, lr, lsl #27
   4:	07a60002 	streq	r0, [r6, r2]!
   8:	01020000 	mrseq	r0, (UNDEF: 2)
   c:	000d0efb 	strdeq	r0, [sp], -fp
  10:	01010101 	tsteq	r1, r1, lsl #2
  14:	01000000 	mrseq	r0, (UNDEF: 0)
  18:	64010000 	strvs	r0, [r1], #-0
  1c:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e
	return kzalloc(size, GFP_KERNEL);
}
  20:	6f2f7372 	svcvs	0x002f7372

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	6e690066 	cdpvs	0, 6, cr0, cr9, cr6, {3}
  28:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
  2c:	696c2f65 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, fp, sp}^
  30:	0078756e 	rsbseq	r7, r8, lr, ror #10
  34:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
	memcpy(buf, initial_boot_params + off, count);
  38:	2f656475 	svccs	0x00656475
  3c:	69706175 	ldmdbvs	r0!, {r0, r2, r4, r5, r6, r8, sp, lr}^
  40:	6e696c2f 	cdpvs	12, 6, cr6, cr9, cr15, {1}

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  44:	2e007875 	mcrcs	8, 0, r7, cr0, cr5, {3}
	memcpy(buf, initial_boot_params + off, count);
  48:	6372612f 	cmnvs	r2, #-1073741813	; 0xc000000b
  4c:	72612f68 	rsbvc	r2, r1, #104, 30	; 0x1a0
  50:	6e692f6d 	cdpvs	15, 6, cr2, cr9, cr13, {3}
  54:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
	return count;
}
  58:	73612f65 	cmnvc	r1, #404	; 0x194
  5c:	6e69006d 	cdpvs	0, 6, cr0, cr9, cr13, {3}
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  60:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
  64:	61752f65 	cmnvs	r5, r5, ror #30
  68:	612f6970 			; <UNDEFINED> instruction: 0x612f6970
  6c:	672d6d73 			; <UNDEFINED> instruction: 0x672d6d73
  70:	72656e65 	rsbvc	r6, r5, #1616	; 0x650
  74:	69006369 	stmdbvs	r0, {r0, r3, r5, r6, r8, r9, sp, lr}
  78:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
  7c:	612f6564 			; <UNDEFINED> instruction: 0x612f6564
  80:	672d6d73 			; <UNDEFINED> instruction: 0x672d6d73
  84:	72656e65 	rsbvc	r6, r5, #1616	; 0x650
  88:	2e006369 	cdpcs	3, 0, cr6, cr0, cr9, {3}
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  8c:	636e692f 	cmnvs	lr, #770048	; 0xbc000
  90:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0xfffffa94
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
  94:	7061752f 	rsbvc	r7, r1, pc, lsr #10
  98:	73612f69 	cmnvc	r1, #420	; 0x1a4
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
  9c:	65672d6d 	strbvs	r2, [r7, #-3437]!	; 0xfffff293
	if (!pathp)
  a0:	6972656e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
  a4:	6e690063 	cdpvs	0, 6, cr0, cr9, cr3, {3}
  a8:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
  ac:	696c2f65 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, fp, sp}^
		return mem;

	allocl = ++l;
  b0:	2f78756e 	svccs	0x0078756e
  b4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
  b8:	63732f2e 	cmnvs	r3, #46, 30	; 0xb8
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  bc:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0xfffff68e
  c0:	74642f73 	strbtvc	r2, [r4], #-3955	; 0xfffff08d
  c4:	696c2f63 	stmdbvs	ip!, {r0, r1, r5, r6, r8, r9, sl, fp, sp}^
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
  c8:	74646662 	strbtvc	r6, [r4], #-1634	; 0xfffff99e
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
  cc:	692f2e00 	stmdbvs	pc!, {r9, sl, fp, sp}	; <UNPREDICTABLE>
		new_format = 1;
		if (fpsize == 0) {
  d0:	756c636e 	strbvc	r6, [ip, #-878]!	; 0xfffffc92
  d4:	752f6564 	strvc	r6, [pc, #-1380]!	; fffffb78 <__crc_of_fdt_unflatten_tree+0x792be5bb>
  d8:	2f697061 	svccs	0x00697061
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  dc:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
  e0:	6e690078 	mcrvs	0, 3, r0, cr9, cr8, {3}
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
  e4:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xfffff39d
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
  e8:	61752f65 	cmnvs	r5, r5, ror #30
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
  ec:	6c2f6970 	stcvs	9, cr6, [pc], #-448	; ffffff34 <__crc_of_fdt_unflatten_tree+0x792be977>
			pathp = "";
  f0:	78756e69 	ldmdavc	r5!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
  f4:	7479622f 	ldrbtvc	r6, [r9], #-559	; 0xfffffdd1
			allocl = 2;
			l = 1;
			pathp = "";
  f8:	64726f65 	ldrbtvs	r6, [r2], #-3941	; 0xfffff09b
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
  fc:	00007265 	andeq	r7, r0, r5, ror #4
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 100:	2e746466 	cdpcs	4, 7, cr6, cr4, cr6, {3}
 104:	00010063 	andeq	r0, r1, r3, rrx
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 108:	616c7300 	cmnvs	ip, r0, lsl #6
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 10c:	00682e62 	rsbeq	r2, r8, r2, ror #28
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
 110:	73000002 	movwvc	r0, #2
 114:	2e626177 	mcrcs	1, 3, r6, cr2, cr7, {3}
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
 118:	00030068 	andeq	r0, r3, r8, rrx
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 11c:	2e666f00 	cdpcs	15, 6, cr6, cr6, cr0, {0}
 120:	00020068 	andeq	r0, r2, r8, rrx
 124:	6d656d00 	stclvs	13, cr6, [r5, #-0]
 128:	2e79726f 	cdpcs	2, 7, cr7, cr9, cr15, {3}
 12c:	00040068 	andeq	r0, r4, r8, rrx
 130:	72747300 	rsbsvc	r7, r4, #0, 6

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 134:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
 138:	00020068 	andeq	r0, r2, r8, rrx
 13c:	746e6900 	strbtvc	r6, [lr], #-2304	; 0xfffff700
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 140:	366c6c2d 	strbtcc	r6, [ip], -sp, lsr #24
 144:	00682e34 	rsbeq	r2, r8, r4, lsr lr
 148:	69000005 	stmdbvs	r0, {r0, r2}
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 14c:	6c2d746e 	cfstrsvs	mvf7, [sp], #-440	; 0xfffffe48
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 150:	2e34366c 	cfmsuba32cs	mvax3, mvax3, mvfx4, mvfx12
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 154:	00060068 	andeq	r0, r6, r8, rrx
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 158:	736f7000 	cmnvc	pc, #0
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 15c:	745f7869 	ldrbvc	r7, [pc], #-2153	; 164 <.debug_line+0x164>
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 160:	73657079 	cmnvc	r5, #121	; 0x79
			    (strcmp(pname, "linux,phandle") == 0)) {
 164:	0700682e 	streq	r6, [r0, -lr, lsr #16]
 168:	79740000 	ldmdbvc	r4!, {}^	; <UNPREDICTABLE>
 16c:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
 170:	00030068 	andeq	r0, r3, r8, rrx
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
 174:	70797400 	rsbsvc	r7, r9, r0, lsl #8
 178:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
 17c:	00000200 	andeq	r0, r0, r0, lsl #4
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
 180:	6f707865 	svcvs	0x00707865
 184:	682e7472 	stmdavs	lr!, {r1, r4, r5, r6, sl, ip, sp, lr}
 188:	00000200 	andeq	r0, r0, r0, lsl #4
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 18c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 190:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 194:	68740000 	ldmdavs	r4!, {}^	; <UNPREDICTABLE>
	res = *mem;
	*mem += size;
 198:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
 19c:	666e695f 			; <UNDEFINED> instruction: 0x666e695f
 1a0:	00682e6f 	rsbeq	r2, r8, pc, ror #28
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
 1a4:	74000002 	strvc	r0, [r0], #-2
 1a8:	2e656d69 	cdpcs	13, 6, cr6, cr5, cr9, {3}
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1ac:	00030068 	andeq	r0, r3, r8, rrx
 1b0:	5f6d6d00 	svcpl	0x006d6d00
 1b4:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
 1b8:	00682e73 	rsbeq	r2, r8, r3, ror lr
 1bc:	70000002 	andvc	r0, r0, r2
			    (strcmp(pname, "linux,phandle") == 0)) {
 1c0:	62617467 	rsbvs	r7, r1, #1728053248	; 0x67000000
 1c4:	332d656c 			; <UNDEFINED> instruction: 0x332d656c
 1c8:	6576656c 	ldrbvs	r6, [r6, #-1388]!	; 0xfffffa94
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
 1cc:	79742d6c 	ldmdbvc	r4!, {r2, r3, r5, r6, r8, sl, fp, sp}^
 1d0:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
 1d4:	00040068 	andeq	r0, r4, r8, rrx
 1d8:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
 1dc:	682e6465 	stmdavs	lr!, {r0, r2, r5, r6, sl, sp, lr}
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 1e0:	00000200 	andeq	r0, r0, r0, lsl #4
					np->phandle = be32_to_cpup(p);
 1e4:	6e697073 	mcrvs	0, 3, r7, cr9, cr3, {3}
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 1e8:	6b636f6c 	blvs	18dbfa0 <unflatten_and_copy_device_tree+0x18db12c>
 1ec:	7079745f 	rsbsvc	r7, r9, pc, asr r4
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
 1f0:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
 1f4:	00000400 	andeq	r0, r0, r0, lsl #8
 1f8:	6e697073 	mcrvs	0, 3, r7, cr9, cr3, {3}
 1fc:	6b636f6c 	blvs	18dbfb4 <unflatten_and_copy_device_tree+0x18db140>
 200:	7079745f 	rsbsvc	r7, r9, pc, asr r4
				np->phandle = be32_to_cpup(p);
 204:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
 208:	00000200 	andeq	r0, r0, r0, lsl #4
 20c:	6f6c7772 	svcvs	0x006c7772
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 210:	745f6b63 	ldrbvc	r6, [pc], #-2915	; 218 <.debug_line+0x218>
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
 214:	73657079 	cmnvc	r5, #121	; 0x79
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
 218:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
			pp->length = sz;
 21c:	72700000 	rsbsvc	r0, r0, #0
			pp->value = (__be32 *)p;
			*prev_pp = pp;
 220:	7365636f 	cmnvc	r5, #-1140850687	; 0xbc000001
			prev_pp = &pp->next;
 224:	2e726f73 	mrccs	15, 3, r6, cr2, cr3, {3}
 228:	00040068 	andeq	r0, r4, r8, rrx
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
 22c:	6f746100 	svcvs	0x00746100
 230:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
 234:	00040068 	andeq	r0, r4, r8, rrx
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
 238:	6f746100 	svcvs	0x00746100
 23c:	2d63696d 	stclcs	9, cr6, [r3, #-436]!	; 0xfffffe4c
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
 240:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
 244:	0600682e 	streq	r6, [r0], -lr, lsr #16
 248:	61770000 	cmnvs	r7, r0
 24c:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
 250:	00000200 	andeq	r0, r0, r0, lsl #4
 254:	6c716573 	cfldr64vs	mvdx6, [r1], #-460	; 0xfffffe34
 258:	2e6b636f 	cdpcs	3, 6, cr6, cr11, cr15, {3}
 25c:	00020068 	andeq	r0, r2, r8, rrx
 260:	646f6e00 	strbtvs	r6, [pc], #-3584	; 268 <.debug_line+0x268>
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
 264:	73616d65 	cmnvc	r1, #6464	; 0x1940
 268:	00682e6b 	rsbeq	r2, r8, fp, ror #28
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
 26c:	73000002 	movwvc	r0, #2
 270:	65646474 	strbvs	r6, [r4, #-1140]!	; 0xfffffb8c
 274:	00682e66 	rsbeq	r2, r8, r6, ror #28
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
 278:	6d000002 	stcvs	0, cr0, [r0, #-8]
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 27c:	6e6f7a6d 	vnmulvs.f32	s15, s30, s27
 280:	00682e65 	rsbeq	r2, r8, r5, ror #28
	*poffset = fdt_next_node(blob, *poffset, &depth);
 284:	6f000002 	svcvs	0x00000002
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 288:	6c5f7173 	ldfvse	f7, [pc], {115}	; 0x73
	*poffset = fdt_next_node(blob, *poffset, &depth);
 28c:	2e6b636f 	cdpcs	3, 6, cr6, cr11, cr15, {3}
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
 290:	00020068 	andeq	r0, r2, r8, rrx
	*poffset = fdt_next_node(blob, *poffset, &depth);
 294:	74756d00 	ldrbtvc	r6, [r5], #-3328	; 0xfffff300
 298:	682e7865 	stmdavs	lr!, {r0, r2, r5, r6, fp, ip, sp, lr}
	if (depth < 0)
 29c:	00000200 	andeq	r0, r0, r0, lsl #4
 2a0:	65737772 	ldrbvs	r7, [r3, #-1906]!	; 0xfffff88e
		depth = 0;
 2a4:	00682e6d 	rsbeq	r2, r8, sp, ror #28
 2a8:	63000002 	movwvs	r0, #2
 2ac:	616d7570 	smcvs	55120	; 0xd750
 2b0:	682e6b73 	stmdavs	lr!, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}
	while (*poffset > 0 && depth > old_depth)
 2b4:	00000200 	andeq	r0, r0, r0, lsl #4
 2b8:	706d6f63 	rsbvc	r6, sp, r3, ror #30
 2bc:	6974656c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, sp, lr}^
 2c0:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
 2c4:	00000200 	andeq	r0, r0, r0, lsl #4
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2c8:	6d69746b 	cfstrdvs	mvd7, [r9, #-428]!	; 0xfffffe54
 2cc:	00682e65 	rsbeq	r2, r8, r5, ror #28
 2d0:	72000002 	andvc	r0, r0, #2
 2d4:	65727462 	ldrbvs	r7, [r2, #-1122]!	; 0xfffffb9e
 2d8:	00682e65 	rsbeq	r2, r8, r5, ror #28
 2dc:	77000002 	strvc	r0, [r0, -r2]

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 2e0:	716b726f 	cmnvc	fp, pc, ror #4
 2e4:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0xfffffa8b
 2e8:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
 2ec:	6c6c0000 	stclvs	0, cr0, [ip], #-0
 2f0:	2e747369 	cdpcs	3, 7, cr7, cr4, cr9, {3}
 2f4:	00020068 	andeq	r0, r2, r8, rrx
 2f8:	72657000 	rsbvc	r7, r5, #0
 2fc:	2e757063 	cdpcs	0, 7, cr7, cr5, cr3, {3}
 300:	00020068 	andeq	r0, r2, r8, rrx
 304:	72707500 	rsbsvc	r7, r0, #0, 10
 308:	7365626f 	cmnvc	r5, #-268435450	; 0xf0000006
 30c:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
 310:	70750000 	rsbsvc	r0, r5, r0
 314:	65626f72 	strbvs	r6, [r2, #-3954]!	; 0xfffff08e
 318:	00682e73 	rsbeq	r2, r8, r3, ror lr
 31c:	6d000002 	stcvs	0, cr0, [r0, #-8]
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 320:	682e756d 	stmdavs	lr!, {r0, r2, r3, r5, r6, r8, sl, ip, sp, lr}
 324:	00000400 	andeq	r0, r0, r0, lsl #8

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
 328:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
 32c:	00000200 	andeq	r0, r0, r0, lsl #4
 330:	6b636f6c 	blvs	18dc0e8 <unflatten_and_copy_device_tree+0x18db274>
 334:	2e706564 	cdpcs	5, 7, cr6, cr0, cr4, {3}
 338:	00020068 	andeq	r0, r2, r8, rrx
 33c:	2e6d6d00 	cdpcs	13, 6, cr6, cr13, cr0, {0}
		struct device_node *child = np->child;
		np->child = NULL;
 340:	00020068 	andeq	r0, r2, r8, rrx
 344:	72687300 	rsbvc	r7, r8, #0, 6
 348:	656b6e69 	strbvs	r6, [fp, #-3689]!	; 0xfffff197
		while (child) {
			struct device_node *next = child->sibling;
 34c:	00682e72 	rsbeq	r2, r8, r2, ror lr
			child->sibling = np->child;
 350:	72000002 	andvc	r0, r0, #2
 354:	756f7365 	strbvc	r7, [pc, #-869]!	; fffffff7 <__crc_of_fdt_unflatten_tree+0x792bea3a>
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 358:	2e656372 	mcrcs	3, 3, r6, cr5, cr2, {3}
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
 35c:	00030068 	andeq	r0, r3, r8, rrx
 360:	6f727000 	svcvs	0x00727000
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
 364:	6e662d63 	cdpvs	13, 6, cr2, cr6, cr3, {3}
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 368:	00682e73 	rsbeq	r2, r8, r3, ror lr
		*nodepp = np;
 36c:	63000004 	movwvs	r0, #4
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
 370:	62617061 	rsbvs	r7, r1, #97	; 0x61
		*nodepp = np;
 374:	74696c69 	strbtvc	r6, [r9], #-3177	; 0xfffff397
 378:	00682e79 	rsbeq	r2, r8, r9, ror lr

	return mem;
}
 37c:	70000002 	andvc	r0, r0, r2
 380:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 384:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 388:	70630000 	rsbvc	r0, r3, r0
 38c:	6d697475 	cfstrdvs	mvd7, [r9, #-468]!	; 0xfffffe2c
 390:	696a5f65 	stmdbvs	sl!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
 394:	65696666 	strbvs	r6, [r9, #-1638]!	; 0xfffff99a
 398:	00682e73 	rsbeq	r2, r8, r3, ror lr
			if ((*p1) == '@')
 39c:	75000006 	strvc	r0, [r0, #-6]
 3a0:	69676469 	stmdbvs	r7!, {r0, r3, r5, r6, sl, sp, lr}^
				pa = p1;
			if ((*p1) == '/')
 3a4:	00682e64 	rsbeq	r2, r8, r4, ror #28
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
 3a8:	73000002 	movwvc	r0, #2
 3ac:	682e6d65 	stmdavs	lr!, {r0, r2, r5, r6, r8, sl, fp, sp, lr}
				pa = p1;
			if ((*p1) == '/')
 3b0:	00000200 	andeq	r0, r0, r0, lsl #4
 3b4:	2e6d6873 	mcrcs	8, 3, r6, cr13, cr3, {3}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 3b8:	00020068 	andeq	r0, r2, r8, rrx
 3bc:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
 3c0:	2d6c616e 	stfcse	f6, [ip, #-440]!	; 0xfffffe48
 3c4:	73666564 	cmnvc	r6, #100, 10	; 0x19000000
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3c8:	0700682e 	streq	r6, [r0, -lr, lsr #16]
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
 3cc:	69730000 	ldmdbvs	r3!, {}^	; <UNPREDICTABLE>
 3d0:	6c616e67 	stclvs	14, cr6, [r1], #-412	; 0xfffffe64
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
 3d4:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
 3d8:	69730000 	ldmdbvs	r3!, {}^	; <UNPREDICTABLE>
			pa = p1;
		sz = (pa - ps) + 1;
 3dc:	666e6967 	strbtvs	r6, [lr], -r7, ror #18
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3e0:	00682e6f 	rsbeq	r2, r8, pc, ror #28
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
 3e4:	73000005 	movwvc	r0, #5
 3e8:	616e6769 	cmnvs	lr, r9, ror #14
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
 3ec:	00682e6c 	rsbeq	r2, r8, ip, ror #28
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
 3f0:	70000002 	andvc	r0, r0, r2
 3f4:	682e6469 	stmdavs	lr!, {r0, r3, r5, r6, sl, sp, lr}
			pp->name = "name";
 3f8:	00000200 	andeq	r0, r0, r0, lsl #4
 3fc:	63726570 	cmnvs	r2, #112, 10	; 0x1c000000
 400:	635f7570 	cmpvs	pc, #112, 10	; 0x1c000000
			pp->length = sz;
			pp->value = pp + 1;
 404:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
 408:	682e7265 	stmdavs	lr!, {r0, r2, r5, r6, r9, ip, sp, lr}
			*prev_pp = pp;
 40c:	00000200 	andeq	r0, r0, r0, lsl #4
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
 410:	63636573 	cmnvs	r3, #482344960	; 0x1cc00000
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
 414:	2e706d6f 	cdpcs	13, 7, cr6, cr0, cr15, {3}
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
 418:	00020068 	andeq	r0, r2, r8, rrx
			prev_pp = &pp->next;
 41c:	6d697400 	cfstrdvs	mvd7, [r9, #-0]
			memcpy(pp->value, ps, sz - 1);
 420:	75717265 	ldrbvc	r7, [r1, #-613]!	; 0xfffffd9b
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
 424:	2e657565 	cdpcs	5, 6, cr7, cr5, cr5, {3}
			memcpy(pp->value, ps, sz - 1);
 428:	00020068 	andeq	r0, r2, r8, rrx
			((char *)pp->value)[sz - 1] = 0;
 42c:	6d697400 	cfstrdvs	mvd7, [r9, #-0]
 430:	682e7265 	stmdavs	lr!, {r0, r2, r5, r6, r9, ip, sp, lr}
 434:	00000200 	andeq	r0, r0, r0, lsl #4
 438:	69747268 	ldmdbvs	r4!, {r3, r5, r6, r9, ip, sp, lr}^
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 43c:	2e72656d 	cdpcs	5, 7, cr6, cr2, cr13, {3}
 440:	00020068 	andeq	r0, r2, r8, rrx
		np->name = of_get_property(np, "name", NULL);
 444:	73617400 	cmnvc	r1, #0, 8
 448:	6f695f6b 	svcvs	0x00695f6b
 44c:	6363615f 	cmnvs	r3, #-1073741801	; 0xc0000017
 450:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
 454:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
		np->name = of_get_property(np, "name", NULL);
 458:	00020068 	andeq	r0, r2, r8, rrx
		np->type = of_get_property(np, "device_type", NULL);
 45c:	73736100 	cmnvc	r3, #0, 2
 460:	615f636f 	cmpvs	pc, pc, ror #6
 464:	79617272 	stmdbvc	r1!, {r1, r4, r5, r6, r9, ip, sp, lr}^
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
 468:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
		np->type = of_get_property(np, "device_type", NULL);
 46c:	656b0000 	strbvs	r0, [fp, #-0]!
 470:	00682e79 	rsbeq	r2, r8, r9, ror lr

		if (!np->name)
 474:	63000002 	movwvs	r0, #2
 478:	2e646572 	mcrcs	5, 3, r6, cr4, cr2, {3}
			np->name = "<NULL>";
 47c:	00020068 	andeq	r0, r2, r8, rrx
 480:	72646900 	rsbvc	r6, r4, #0, 18
 484:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
		if (!np->type)
 488:	65700000 	ldrbvs	r0, [r0, #-0]!
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
 48c:	75706372 	ldrbvc	r6, [r0, #-882]!	; 0xfffffc8e

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
 490:	6665722d 	strbtvs	r7, [r5], -sp, lsr #4
 494:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
 498:	00682e74 	rsbeq	r2, r8, r4, ror lr
 49c:	72000002 	andvc	r0, r0, #2
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a0:	735f7563 	cmpvc	pc, #415236096	; 0x18c00000
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
 4a4:	2e636e79 	mcrcs	14, 3, r6, cr3, cr9, {3}
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
 4a8:	00020068 	andeq	r0, r2, r8, rrx
 4ac:	72657000 	rsbvc	r7, r5, #0
 4b0:	2d757063 	ldclcs	0, cr7, [r5, #-396]!	; 0xfffffe74
 4b4:	65737772 	ldrbvs	r7, [r3, #-1906]!	; 0xfffff88e
 4b8:	00682e6d 	rsbeq	r2, r8, sp, ror #28
 4bc:	63000002 	movwvs	r0, #2

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
 4c0:	756f7267 	strbvc	r7, [pc, #-615]!	; 261 <.debug_line+0x261>
 4c4:	65642d70 	strbvs	r2, [r4, #-3440]!	; 0xfffff290
 4c8:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4cc:	00000200 	andeq	r0, r0, r0, lsl #4
 4d0:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
		if (new_format) {
 4d4:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
	node->fwnode.type = FWNODE_OF;
 4d8:	00000200 	andeq	r0, r0, r0, lsl #4
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 4dc:	5f716573 	svcpl	0x00716573
 4e0:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
		if (new_format) {
 4e4:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
			/* rebuild full path for new format */
			if (dad && dad->parent) {
 4e8:	74740000 	ldrbtvc	r0, [r4], #-0
 4ec:	00682e79 	rsbeq	r2, r8, r9, ror lr
 4f0:	74000002 	strvc	r0, [r0], #-2
 4f4:	6c66626c 	sfmvs	f6, 2, [r6], #-432	; 0xfffffe50
 4f8:	2e687375 	mcrcs	3, 3, r7, cr8, cr5, {3}
				strcpy(fn, dad->full_name);
 4fc:	00040068 	andeq	r0, r4, r8, rrx
 500:	5f6d7600 	svcpl	0x006d7600
 504:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
 508:	74695f74 	strbtvc	r5, [r9], #-3956	; 0xfffff08c
 50c:	682e6d65 	stmdavs	lr!, {r0, r2, r5, r6, r8, sl, fp, sp, lr}
 510:	00000200 	andeq	r0, r0, r0, lsl #4
			}
			*(fn++) = '/';
 514:	74736d76 	ldrbtvc	r6, [r3], #-3446	; 0xfffff28a
 518:	682e7461 	stmdavs	lr!, {r0, r5, r6, sl, ip, sp, lr}
 51c:	00000200 	andeq	r0, r0, r0, lsl #4
		}
		memcpy(fn, pathp, l);
 520:	6a626f6b 	bvs	189c2d4 <unflatten_and_copy_device_tree+0x189b460>
 524:	5f746365 	svcpl	0x00746365
 528:	682e736e 	stmdavs	lr!, {r1, r2, r3, r5, r6, r8, r9, ip, sp, lr}

		prev_pp = &np->properties;
 52c:	00000200 	andeq	r0, r0, r0, lsl #4
 530:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
 534:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

		prev_pp = &np->properties;
		if (dad != NULL) {
 538:	79730000 	ldmdbvc	r3!, {}^	; <UNPREDICTABLE>
			np->parent = dad;
 53c:	2e736673 	mrccs	6, 3, r6, cr3, cr3, {3}
			np->sibling = dad->child;
 540:	00020068 	andeq	r0, r2, r8, rrx
 544:	626f6b00 	rsbvs	r6, pc, #0, 22
			dad->child = np;
 548:	7463656a 	strbtvc	r6, [r3], #-1386	; 0xfffffa96
 54c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
 550:	726b0000 	rsbvc	r0, fp, #0

	if (nodepp)
		*nodepp = np;

	return mem;
}
 554:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
 558:	00000200 	andeq	r0, r0, r0, lsl #4
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
 55c:	5f646f6d 	svcpl	0x00646f6d
 560:	69766564 	ldmdbvs	r6!, {r2, r5, r6, r8, sl, sp, lr}^
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
 564:	61746563 	cmnvs	r4, r3, ror #10
 568:	2e656c62 	cdpcs	12, 6, cr6, cr5, cr2, {3}
 56c:	00020068 	andeq	r0, r2, r8, rrx
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
 570:	6e776600 	cdpvs	6, 7, cr6, cr7, cr0, {0}
 574:	2e65646f 	cdpcs	4, 6, cr6, cr5, cr15, {3}
 578:	00020068 	andeq	r0, r2, r8, rrx
 57c:	62696c00 	rsbvs	r6, r9, #0, 24
 580:	5f746466 	svcpl	0x00746466
			break;
 584:	2e766e65 	cdpcs	14, 7, cr6, cr6, cr5, {3}
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
 588:	00020068 	andeq	r0, r2, r8, rrx
 58c:	74646600 	strbtvc	r6, [r4], #-1536	; 0xfffffa00
 590:	0800682e 	stmdaeq	r0, {r1, r2, r3, r5, fp, sp, lr}
 594:	696c0000 	stmdbvs	ip!, {}^	; <UNPREDICTABLE>
 598:	625f7473 	subsvs	r7, pc, #1929379840	; 0x73000000
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 59c:	00682e6c 	rsbeq	r2, r8, ip, ror #28
 5a0:	6c000002 	stcvs	0, cr0, [r0], {2}
 5a4:	726b636f 	rsbvc	r6, fp, #-1140850687	; 0xbc000001
 5a8:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
 5ac:	00000200 	andeq	r0, r0, r0, lsl #4
 5b0:	63616364 	cmnvs	r1, #100, 6	; 0x90000001
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5b4:	682e6568 	stmdavs	lr!, {r3, r5, r6, r8, sl, sp, lr}
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
 5b8:	00000200 	andeq	r0, r0, r0, lsl #4
 5bc:	68746170 	ldmdavs	r4!, {r4, r5, r6, r8, sp, lr}^
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
 5c0:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
 5c4:	696c0000 	stmdbvs	ip!, {}^	; <UNPREDICTABLE>
 5c8:	6c5f7473 	cfldrdvs	mvd7, [pc], {115}	; 0x73
 5cc:	682e7572 	stmdavs	lr!, {r1, r4, r5, r6, r8, sl, ip, sp, lr}
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5d0:	00000200 	andeq	r0, r0, r0, lsl #4
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5d4:	69646172 	stmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
 5d8:	72742d78 	rsbsvc	r2, r4, #120, 26	; 0x1e00
 5dc:	682e6565 	stmdavs	lr!, {r0, r2, r5, r6, r8, sl, sp, lr}
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
 5e0:	00000200 	andeq	r0, r0, r0, lsl #4
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 5e4:	6d656966 	stclvs	9, cr6, [r5, #-408]!	; 0xfffffe68
 5e8:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
 5ec:	00000900 	andeq	r0, r0, r0, lsl #18
 5f0:	7267696d 	rsbvc	r6, r7, #1785856	; 0x1b4000
 5f4:	5f657461 	svcpl	0x00657461
 5f8:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 5fc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 600:	75710000 	ldrbvc	r0, [r1, #-0]!
 604:	2e61746f 	cdpcs	4, 6, cr7, cr1, cr15, {3}
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
 608:	00020068 	andeq	r0, r2, r8, rrx
 60c:	6f727000 	svcvs	0x00727000

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 610:	2e64696a 	cdpcs	9, 6, cr6, cr4, cr10, {3}
 614:	00020068 	andeq	r0, r2, r8, rrx
	memset(mem, 0, size);
 618:	6f757100 	svcvs	0x00757100
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 61c:	682e6174 	stmdavs	lr!, {r2, r4, r5, r6, r8, sp, lr}
	memset(mem, 0, size);
 620:	00000300 	andeq	r0, r0, r0, lsl #6

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 624:	76656463 	strbtvc	r6, [r5], -r3, ror #8
 628:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 62c:	666e0000 	strbtvs	r0, [lr], -r0

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 630:	73665f73 	cmnvc	r6, #460	; 0x1cc

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 634:	682e695f 	stmdavs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}
 638:	00000200 	andeq	r0, r0, r0, lsl #4

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 63c:	65746e69 	ldrbvs	r6, [r4, #-3689]!	; 0xfffff197
 640:	70757272 	rsbsvc	r7, r5, r2, ror r2
 644:	00682e74 	rsbeq	r2, r8, r4, ror lr
 648:	74000002 	strvc	r0, [r0], #-2
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 64c:	626d7265 	rsbvs	r7, sp, #1342177286	; 0x50000006
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 650:	2e737469 	cdpcs	4, 7, cr7, cr3, cr9, {3}
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 654:	00070068 	andeq	r0, r7, r8, rrx
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 658:	72657400 	rsbvc	r7, r5, #0, 8
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 65c:	736f696d 	cmnvc	pc, #1785856	; 0x1b4000
 660:	0500682e 	streq	r6, [r0, #-2094]	; 0xfffff7d2
 664:	65740000 	ldrbvs	r0, [r4, #-0]!
 668:	6f696d72 	svcvs	0x00696d72
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
 66c:	00682e73 	rsbeq	r2, r8, r3, ror lr
 670:	74000009 	strvc	r0, [r0], #-9

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
 674:	645f7974 	ldrbvs	r7, [pc], #-2420	; 67c <.debug_line+0x67c>
 678:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 67c:	00682e72 	rsbeq	r2, r8, r2, ror lr
 680:	73000002 	movwvc	r0, #2

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 684:	61697265 	cmnvs	r9, r5, ror #4

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 688:	00682e6c 	rsbeq	r2, r8, ip, ror #28

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 68c:	74000003 	strvc	r0, [r0], #-3
 690:	6c5f7974 	mrrcvs	9, 7, r7, pc, cr4	; <UNPREDICTABLE>

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 694:	63736964 	cmnvs	r3, #100, 18	; 0x190000
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
 698:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 69c:	69620000 	stmdbvs	r2!, {}^	; <UNPREDICTABLE>
 6a0:	73706f74 	cmnvc	r0, #116, 30	; 0x1d0
 6a4:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
 6a8:	6f6c0000 	svcvs	0x006c0000
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
 6ac:	682e3267 	stmdavs	lr!, {r0, r1, r2, r5, r6, r9, ip, sp}
 6b0:	00000200 	andeq	r0, r0, r0, lsl #4
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
 6b4:	6f746567 	svcvs	0x00746567
 6b8:	72656472 	rsbvc	r6, r5, #1912602624	; 0x72000000
 6bc:	0600682e 	streq	r6, [r0], -lr, lsr #16
 6c0:	696c0000 	stmdbvs	ip!, {}^	; <UNPREDICTABLE>
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
 6c4:	656c7474 	strbvs	r7, [ip, #-1140]!	; 0xfffffb8c
 6c8:	646e655f 	strbtvs	r6, [lr], #-1375	; 0xfffffaa1
 6cc:	2e6e6169 	powcsez	f6, f6, #1.0
		return;
 6d0:	000a0068 	andeq	r0, sl, r8, rrx
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6d4:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
 6d8:	2e6b746e 	cdpcs	4, 6, cr7, cr11, cr14, {3}
 6dc:	00020068 	andeq	r0, r2, r8, rrx
 6e0:	63776800 	cmnvs	r7, #0, 16
 6e4:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
	mutex_lock(&of_fdt_unflatten_mutex);
 6e8:	00000400 	andeq	r0, r0, r0, lsl #8
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
 6ec:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
 6f0:	682e6c65 	stmdavs	lr!, {r0, r2, r5, r6, sl, fp, sp, lr}
	mutex_lock(&of_fdt_unflatten_mutex);
 6f4:	00000200 	andeq	r0, r0, r0, lsl #4
 6f8:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
 6fc:	682e6472 	stmdavs	lr!, {r1, r4, r5, r6, sl, sp, lr}
 700:	00000200 	andeq	r0, r0, r0, lsl #4
 704:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
 708:	695f6461 	ldmdbvs	pc, {r0, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
 70c:	2e6f666e 	cdpcs	6, 6, cr6, cr15, cr14, {3}
	mutex_unlock(&of_fdt_unflatten_mutex);
 710:	00040068 	andeq	r0, r4, r8, rrx
 714:	72657000 	rsbvc	r7, r5, #0
 718:	2e757063 	cdpcs	0, 7, cr7, cr5, cr3, {3}
 71c:	00060068 	andeq	r0, r6, r8, rrx
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 720:	62656400 	rsbvs	r6, r5, #0, 8
 724:	6c5f6775 	mrrcvs	7, 7, r6, pc, cr5	; <UNPREDICTABLE>
 728:	736b636f 	cmnvc	fp, #-1140850687	; 0xbc000001
 72c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 730:	69680000 	stmdbvs	r8!, {}^	; <UNPREDICTABLE>
 734:	69756867 	ldmdbvs	r5!, {r0, r1, r2, r5, r6, fp, sp, lr}^
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 738:	00682e64 	rsbeq	r2, r8, r4, ror #28
 73c:	70000002 	andvc	r0, r0, r2
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
 740:	62617467 	rsbvs	r7, r1, #1728053248	; 0x67000000
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
 744:	682e656c 	stmdavs	lr!, {r2, r3, r5, r6, r8, sl, sp, lr}
 748:	00000600 	andeq	r0, r0, r0, lsl #12
 74c:	626d656d 	rsbvs	r6, sp, #457179136	; 0x1b400000
 750:	6b636f6c 	blvs	18dc508 <unflatten_and_copy_device_tree+0x18db694>
	if (root_offset < 0)
 754:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 758:	696c0000 	stmdbvs	ip!, {}^	; <UNPREDICTABLE>
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
 75c:	74646662 	strbtvc	r6, [r4], #-1634	; 0xfffff99e
 760:	0800682e 	stmdaeq	r0, {r1, r2, r3, r5, fp, sp, lr}
 764:	666f0000 	strbtvs	r0, [pc], -r0
 768:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
 76c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 770:	65730000 	ldrbvs	r0, [r3, #-0]!
				"#address-cells", NULL);
	if (addr_prop)
 774:	6c616972 	stclvs	9, cr6, [r1], #-456	; 0xfffffe38
 778:	726f635f 	rsbvc	r6, pc, #2080374785	; 0x7c000001
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
 77c:	00682e65 	rsbeq	r2, r8, r5, ror #28
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 780:	63000002 	movwvs	r0, #2
 784:	32336372 	eorscc	r6, r3, #-939524095	; 0xc8000001
 788:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
 78c:	74730000 	ldrbtvc	r0, [r3], #-0
 790:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
 794:	0400682e 	streq	r6, [r0], #-2094	; 0xfffff7d2
 798:	666f0000 	strbtvs	r0, [pc], -r0
				"#size-cells", NULL);
	if (size_prop)
 79c:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
 7a0:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
 7a4:	656d5f64 	strbvs	r5, [sp, #-3940]!	; 0xfffff09c
 7a8:	00682e6d 	rsbeq	r2, r8, sp, ror #28
		nr_size_cells = fdt32_to_cpu(*size_prop);
 7ac:	00000002 	andeq	r0, r0, r2
 7b0:	00020500 	andeq	r0, r2, r0, lsl #10
 7b4:	03000000 	movweq	r0, #0
 7b8:	9e0103b3 	mcrls	3, 0, r0, cr1, cr3, {5}

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
 7bc:	27030204 	strcs	r0, [r3, -r4, lsl #4]
 7c0:	03010401 	movweq	r0, #5121	; 0x1401
 7c4:	d903665b 	stmdble	r3, {r0, r1, r3, r4, r6, r9, sl, sp, lr}
 7c8:	139e2e05 	orrsne	r2, lr, #5, 28	; 0x50
	if (memory > 0) {
 7cc:	03842f65 	orreq	r2, r4, #404	; 0x194
 7d0:	ba4a78a4 	blt	129ea68 <unflatten_and_copy_device_tree+0x129dbf4>
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
 7d4:	039e0c03 	orrseq	r0, lr, #768	; 0x300
 7d8:	0c034a74 	stceq	10, cr4, [r3], {116}	; 0x74
 7dc:	6d852f4a 	stcvs	15, cr2, [r5, #296]	; 0x128
 7e0:	03667303 	cmneq	r6, #201326592	; 0xc000000
 7e4:	6e302e0d 	cdpvs	14, 3, cr2, cr0, cr13, {0}
 7e8:	034a7703 	movteq	r7, #42755	; 0xa703
		if (len > limit*cell_size) {
 7ec:	2f2d2e0a 	svccs	0x002d2e0a
 7f0:	0c03312b 	stfeqs	f3, [r3], {43}	; 0x2b
 7f4:	7fb9032e 	svcvc	0x00b9032e
 7f8:	00c7032e 	sbceq	r0, r7, lr, lsr #6
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
 7fc:	7fbb034a 	svcvc	0x00bb034a
 800:	2e1a032e 	cdpcs	3, 1, cr0, cr10, cr14, {1}
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 804:	034a2b03 	movteq	r2, #43779	; 0xab03
 808:	0f032e1d 	svceq	0x00032e1d
 80c:	661203ba 			; <UNDEFINED> instruction: 0x661203ba
 810:	03665f03 	cmneq	r6, #3, 30
 814:	67032e19 	smladvs	r3, r9, lr, r2
 818:	2e19032e 	cdpcs	3, 1, cr0, cr9, cr14, {1}
 81c:	032e6703 			; <UNDEFINED> instruction: 0x032e6703

	memory = fdt_path_offset(initial_boot_params, "/memory");
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
 820:	032f2e19 			; <UNDEFINED> instruction: 0x032f2e19
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
 824:	6a6a8271 	bvs	1aa11f0 <unflatten_and_copy_device_tree+0x1aa037c>
					len);
		}
	}
}
 828:	2e7f8903 	cdpcs	9, 7, cr8, cr15, cr3, {0}
 82c:	00f2034c 	rscseq	r0, r2, ip, asr #6
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
 830:	00504d2e 	subseq	r4, r0, lr, lsr #26
 834:	9f010402 	svcls	0x00010402
 838:	01040200 	mrseq	r0, R12_usr
 83c:	03044c65 	movweq	r4, #19557	; 0x4c65
 840:	667f9003 	ldrbtvs	r9, [pc], -r3
				"#size-cells", NULL);
	if (size_prop)
 844:	f1030104 			; <UNDEFINED> instruction: 0xf1030104
 848:	03042e00 	movweq	r2, #19968	; 0x4e00
 84c:	2e7e9f03 	cdpcs	15, 7, cr9, cr14, cr3, {0}
		nr_size_cells = fdt32_to_cpu(*size_prop);
 850:	e1030104 	tst	r3, r4, lsl #2
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 854:	04332e01 	ldrteq	r2, [r3], #-3585	; 0xfffff1ff
 858:	7e9a0303 	cdpvc	3, 9, cr0, cr10, cr3, {0}
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
 85c:	03010482 	movweq	r0, #5250	; 0x1482
 860:	042e01e7 	strteq	r0, [lr], #-487	; 0xfffffe19
 864:	7e990303 	cdpvc	3, 9, cr0, cr9, cr3, {0}
 868:	0301042e 	movweq	r0, #5166	; 0x142e
 86c:	322e01e7 	eorcc	r0, lr, #-1073741767	; 0xc0000039
 870:	302f2d2c 	eorcc	r2, pc, ip, lsr #26
 874:	4a5b032f 	bmi	16c1538 <unflatten_and_copy_device_tree+0x16c06c4>
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
 878:	27035064 	strcs	r5, [r3, -r4, rrx]
 87c:	1c032008 	stcne	0, cr2, [r3], {8}
 880:	660c034a 	strvs	r0, [ip], -sl, asr #6
 884:	2f2d4b2d 	svccs	0x002d4b2d
	if (cp == NULL)
 888:	4b4b2f2d 	blmi	12cc544 <unflatten_and_copy_device_tree+0x12cb6d0>
 88c:	02009f83 	andeq	r9, r0, #524	; 0x20c
		return 0;
	while (cplen > 0) {
 890:	67b90104 	ldrvs	r0, [r9, r4, lsl #2]!
 894:	51861f08 	orrpl	r1, r6, r8, lsl #30
 898:	01040200 	mrseq	r0, R12_usr
 89c:	68066606 	stmdavs	r6, {r1, r2, r9, sl, sp, lr}
 8a0:	31482f68 	cmpcc	r8, r8, ror #30
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
 8a4:	2d2f3647 	stccs	6, cr3, [pc, #-284]!	; 790 <.debug_line+0x790>
 8a8:	bf034d2f 	svclt	0x00034d2f
		cp += l;
		cplen -= l;
 8ac:	4cbb4a7f 	vldmiami	fp!, {s8-s134}
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
 8b0:	89474c2c 	stmdbhi	r7, {r2, r3, r5, sl, fp, lr}^
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8b4:	2e7ee403 	cdpcs	4, 7, cr14, cr14, cr3, {0}
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
 8b8:	4a019c03 	bmi	678cc <unflatten_and_copy_device_tree+0x66a58>
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
 8bc:	e103314c 	tst	r3, ip, asr #2
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8c0:	9c032e7e 	stcls	14, cr2, [r3], {126}	; 0x7e
 8c4:	4b314a01 	blmi	c530d0 <unflatten_and_copy_device_tree+0xc5225c>
 8c8:	322c4b68 	eorcc	r4, ip, #104, 22	; 0x1a000

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
 8cc:	2d2f2f2c 	stccs	15, cr2, [pc, #-176]!	; 824 <.debug_line+0x824>
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d0:	4b882f2f 	blmi	fe20c594 <__crc_of_fdt_unflatten_tree+0x774cafd7>
			return score;
		l = strlen(cp) + 1;
 8d4:	652f2f81 	strvs	r2, [pc, #-3969]!	; fffff95b <__crc_of_fdt_unflatten_tree+0x792be39e>
	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 8d8:	674b4c2f 	strbvs	r4, [fp, -pc, lsr #24]
			return score;
 8dc:	8b03332a 	blhi	cd58c <unflatten_and_copy_device_tree+0xcc718>
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8e0:	7103827f 	tstvc	r3, pc, ror r2
 8e4:	2e0f032e 	cdpcs	3, 0, cr0, cr15, cr14, {1}
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
 8e8:	fb030404 	blx	c1902 <unflatten_and_copy_device_tree+0xc0a8e>
		cp += l;
		cplen -= l;
	}

	return 0;
}
 8ec:	0104ba7e 	tsteq	r4, lr, ror sl
 8f0:	66018f03 	strvs	r8, [r1], -r3, lsl #30
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
 8f4:	f1030404 			; <UNDEFINED> instruction: 0xf1030404
 8f8:	01042e7e 	tsteq	r4, lr, ror lr
 8fc:	2e019003 	cdpcs	0, 0, cr9, cr1, cr3, {0}
 900:	f1030404 			; <UNDEFINED> instruction: 0xf1030404
 904:	01042e7e 	tsteq	r4, lr, ror lr
	if (fdt_getprop(blob, node, "big-endian", NULL))
 908:	2e018e03 	cdpcs	14, 0, cr8, cr1, cr3, {0}
 90c:	f2030404 	vshl.s8	d0, d4, d3
 910:	01042e7e 	tsteq	r4, lr, ror lr
 914:	2e018f03 	cdpcs	15, 0, cr8, cr1, cr3, {0}
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
 918:	04020030 	streq	r0, [r2], #-48	; 0xffffffd0
 91c:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
 920:	68686e67 	stmdavs	r8!, {r0, r1, r2, r5, r6, r9, sl, fp, sp, lr}^
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 924:	2f314868 	svccs	0x00314868
 928:	47034b2f 	strmi	r4, [r3, -pc, lsr #22]
 92c:	01af034a 			; <UNDEFINED> instruction: 0x01af034a
 930:	7ef4032e 	cdpvc	3, 15, cr0, cr4, cr14, {1}
 934:	00cb034a 	sbceq	r0, fp, sl, asr #6
	unsigned int tmp, score = 0;

	if (!compat)
 938:	665b034a 	ldrbvs	r0, [fp], -sl, asr #6
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
 93c:	00d0039f 	smullseq	r0, r0, pc, r3	; <UNPREDICTABLE>
 940:	9e26032e 	cdpls	3, 2, cr0, cr6, cr14, {1}
	unsigned int tmp, score = 0;

	if (!compat)
 944:	790319ba 	stmdbvc	r3, {r1, r3, r4, r5, r7, r8, fp, ip}
		return 0;

	while (*compat) {
 948:	0200512e 	andeq	r5, r0, #-2147483637	; 0x8000000b
 94c:	0a030404 	beq	c1964 <unflatten_and_copy_device_tree+0xc0af0>
 950:	652f6c2e 	strvs	r6, [pc, #-3118]!	; fffffd2a <__crc_of_fdt_unflatten_tree+0x792be76d>
 954:	4f61c02f 	svcmi	0x0061c02f
		tmp = of_fdt_is_compatible(blob, node, *compat);
 958:	362f2d4b 	strtcc	r2, [pc], -fp, asr #26
 95c:	344a7a03 	strbcc	r7, [sl], #-2563	; 0xfffff5fd
 960:	502e7a03 	eorpl	r7, lr, r3, lsl #20
		if (tmp && (score == 0 || (tmp < score)))
 964:	03042f81 	movweq	r2, #20353	; 0x4f81
 968:	2e7e8103 	expcse	f0, f3
 96c:	2e7f9003 	cdpcs	0, 7, cr9, cr15, cr3, {0}
 970:	f0030104 			; <UNDEFINED> instruction: 0xf0030104
 974:	03872e02 	orreq	r2, r7, #2, 28
 978:	03524a72 	cmpeq	r2, #466944	; 0x72000
 97c:	03344a7a 	teqeq	r4, #499712	; 0x7a000
 980:	2d502e7a 	ldclcs	14, cr2, [r0, #-488]	; 0xfffffe18
 984:	0303042f 	movweq	r0, #13359	; 0x342f
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 988:	04827e81 	streq	r7, [r2], #3713	; 0xe81
 98c:	02810301 	addeq	r0, r1, #67108864	; 0x4000000
 990:	8269034a 	rsbhi	r0, r9, #671088641	; 0x28000001
 994:	2e2d0367 	cdpcs	3, 2, cr0, cr13, cr7, {3}
 998:	4b2d139e 	blmi	b45818 <unflatten_and_copy_device_tree+0xb449a4>
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
 99c:	e2039f4b 	and	r9, r3, #300	; 0x12c
			score = tmp;
		compat++;
	}

	return score;
}
 9a0:	03ba827c 			; <UNDEFINED> instruction: 0x03ba827c
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
 9a4:	7503010b 	strvc	r0, [r3, #-267]	; 0xfffffef5
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
 9a8:	2e0b034a 	cdpcs	3, 0, cr0, cr11, cr10, {2}
	}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
 9ac:	04bc4d83 	ldrteq	r4, [ip], #3459	; 0xd83
 9b0:	01044c03 	tsteq	r4, r3, lsl #24
 9b4:	9d03042f 	cfstrsls	mvf0, [r3, #-188]	; 0xffffff44
 9b8:	302f0104 	eorcc	r0, pc, r4, lsl #2
	if (buf)
 9bc:	00030483 	andeq	r0, r3, r3, lsl #9
		return 0;
 9c0:	2a020402 	bcs	819d0 <unflatten_and_copy_device_tree+0x80b5c>
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
	if (buf)
 9c4:	836e0104 	cmnhi	lr, #4, 2
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
 9c8:	4689bb4b 	strmi	fp, [r9], fp, asr #22
 9cc:	033230d4 	teqeq	r2, #212	; 0xd4

	offset = fdt_path_offset(fdt, "/chosen");
 9d0:	67a04a6f 	strvs	r4, [r0, pc, ror #20]!
 9d4:	032e6d03 			; <UNDEFINED> instruction: 0x032e6d03
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
 9d8:	33ba4a2f 			; <UNDEFINED> instruction: 0x33ba4a2f

	offset = fdt_path_offset(fdt, "/chosen");
 9dc:	4ca24c83 	stcmi	12, cr4, [r2], #524	; 0x20c
 9e0:	0334292d 	teqeq	r4, #737280	; 0xb4000
	if (offset < 0)
 9e4:	65302e7a 	ldrvs	r2, [r0, #-3706]!	; 0xfffff186
 9e8:	2f2c302f 	svccs	0x002c302f
		offset = fdt_path_offset(fdt, "/chosen@0");
 9ec:	4a750335 	bmi	1d416c8 <unflatten_and_copy_device_tree+0x1d40854>
 9f0:	032e0b03 			; <UNDEFINED> instruction: 0x032e0b03
 9f4:	139e4a0c 	orrsne	r4, lr, #12, 20	; 0xc000
 9f8:	159e6d88 	ldrne	r6, [lr, #3464]	; 0xd88
	if (offset < 0)
 9fc:	83314d2b 	teqhi	r1, #2752	; 0xac0
 a00:	04020067 	streq	r0, [r2], #-103	; 0xffffff99
		return -ENOENT;
 a04:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
 a08:	0a039cd4 	beq	e7d60 <unflatten_and_copy_device_tree+0xe6eec>

	p = fdt_getprop(fdt, offset, "stdout-path", &l);
 a0c:	2e78032e 	cdpcs	3, 7, cr0, cr8, cr14, {1}
 a10:	00020235 	andeq	r0, r2, r5, lsr r2
 a14:	05000101 	streq	r0, [r0, #-257]	; 0xfffffeff
 a18:	00000002 	andeq	r0, r0, r2
 a1c:	06d70300 	ldrbeq	r0, [r7], r0, lsl #6
 a20:	2d2f8301 	stccs	3, cr8, [pc, #-4]!	; a24 <.debug_line+0xa24>
	if (!p)
 a24:	4c2e5603 	stcmi	6, cr5, [lr], #-12
 a28:	4b4b3048 	blmi	12ccb50 <unflatten_and_copy_device_tree+0x12cbcdc>
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
 a2c:	bb4c4b83 	bllt	1313840 <unflatten_and_copy_device_tree+0x13129cc>
 a30:	69a2bb4b 	stmibvs	r2!, {r0, r1, r3, r6, r8, r9, fp, ip, sp, pc}
 a34:	312b312b 			; <UNDEFINED> instruction: 0x312b312b
 a38:	674f832f 	strbvs	r8, [pc, -pc, lsr #6]
 a3c:	6e63312a 	powvssp	f3, f3, #2.0
 a40:	312d8367 			; <UNDEFINED> instruction: 0x312d8367
	if (!p || !l)
 a44:	034a0c03 	movteq	r0, #44035	; 0xac03
 a48:	676601bc 			; <UNDEFINED> instruction: 0x676601bc
 a4c:	c8030504 	stmdagt	r3, {r2, r8, sl}
 a50:	01042e79 	tsteq	r4, r9, ror lr
 a54:	2e06b903 	cdpcs	9, 0, cr11, cr6, cr3, {0}
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a58:	2e00fa03 	vmlacs.f32	s30, s0, s6
 a5c:	0303046a 	movweq	r0, #13418	; 0x346a
 a60:	049e77a3 	ldreq	r7, [lr], #1955	; 0x7a3

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a64:	08e00301 	stmiaeq	r0!, {r0, r8, r9}^
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a68:	0303042e 	movweq	r0, #13358	; 0x342e

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a6c:	042e77a0 	strteq	r7, [lr], #-1952	; 0xfffff860
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
 a70:	08e00301 	stmiaeq	r0!, {r0, r8, r9}^

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
 a74:	0067a02e 	rsbeq	sl, r7, lr, lsr #32
	if (offset < 0)
 a78:	4c020402 	cfstrsmi	mvf0, [r2], {2}
 a7c:	02040200 	andeq	r0, r4, #0, 4
 a80:	0402002f 	streq	r0, [r2], #-47	; 0xffffffd1
 a84:	02002d02 	andeq	r2, r0, #2, 26	; 0x80
		return -ENODEV;
 a88:	002f0204 	eoreq	r0, pc, r4, lsl #4
 a8c:	65020402 	strvs	r0, [r2, #-1026]	; 0xfffffbfe

	while (match->compatible[0]) {
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 a90:	02040200 	andeq	r0, r4, #0, 4
 a94:	7bd4032f 	blvc	ff501758 <__crc_of_fdt_unflatten_tree+0x787c019b>
 a98:	474c834a 	strbmi	r8, [ip, -sl, asr #6]
			match++;
 a9c:	30312d2f 	eorscc	r2, r1, pc, lsr #26
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
 aa0:	02003048 	andeq	r3, r0, #72	; 0x48
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 aa4:	006a0104 	rsbeq	r0, sl, r4, lsl #2
 aa8:	2a010402 	bcs	41ab8 <unflatten_and_copy_device_tree+0x40c44>
 aac:	01040200 	mrseq	r0, R12_usr
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
 ab0:	04020032 	streq	r0, [r2], #-50	; 0xffffffce
 ab4:	852f4601 	strhi	r4, [pc, #-1537]!	; 4bb <.debug_line+0x4bb>
 ab8:	042f2d2f 	strteq	r2, [pc], #-3375	; ac0 <.debug_line+0xac0>
		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
 abc:	7ca50306 	stcvc	3, cr0, [r5], #24
 ac0:	01042f4a 	tsteq	r4, sl, asr #30
 ac4:	4a03dc03 	bmi	f7ad8 <unflatten_and_copy_device_tree+0xf6c64>
		if (addr == OF_BAD_ADDR)
 ac8:	8a294f99 	bhi	a54934 <unflatten_and_copy_device_tree+0xa53ac0>
 acc:	6750686c 	ldrbvs	r6, [r0, -ip, ror #16]
 ad0:	a8030304 	stmdage	r3, {r2, r8, r9}
 ad4:	0104667b 	tsteq	r4, fp, ror r6
			return -ENXIO;
 ad8:	2e04d903 	cdpcs	9, 0, cr13, cr4, cr3, {0}
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
		if (addr == OF_BAD_ADDR)
 adc:	674a0a03 	strbvs	r0, [sl, -r3, lsl #20]
			return -ENXIO;

		of_setup_earlycon(addr, match->data);
 ae0:	01c503d7 	ldrdeq	r0, [r5, #55]	; 0x37
 ae4:	312b692e 			; <UNDEFINED> instruction: 0x312b692e
{
	if (buf)
		return 0;

	return early_init_dt_scan_chosen_serial();
}
 ae8:	4b474d31 	blmi	11d3fb4 <unflatten_and_copy_device_tree+0x11d3140>
 aec:	04623330 	strbteq	r3, [r2], #-816	; 0xfffffcd0
 af0:	79cc0303 	stmibvc	ip, {r0, r1, r8, r9}^
/*
 * called from unflatten_device_tree() to bootstrap devicetree itself
 * Architectures can override this definition if memblock isn't used
 */
void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
{
 af4:	0301042e 	movweq	r0, #5166	; 0x142e
 af8:	042e06b8 	strteq	r0, [lr], #-1720	; 0xfffff948
 afc:	79c80303 	stmibvc	r8, {r0, r1, r8, r9}^
	return __va(memblock_alloc(size, align));
 b00:	0301042e 	movweq	r0, #5166	; 0x142e
	 * 'unsigned long' cast discard upper word when
	 * phys_addr_t is 64 bit, and makes sure that inline
	 * assembler expression receives 32 bit argument
	 * in place where 'r' 32 bit operand is expected.
	 */
	__pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);
 b04:	312e06b5 			; <UNDEFINED> instruction: 0x312e06b5
}
 b08:	0303042f 	movweq	r0, #13359	; 0x342f
	memcpy(buf, initial_boot_params + off, count);
	return count;
}

static int __init of_fdt_raw_init(void)
{
 b0c:	044a79c7 	strbeq	r7, [sl], #-2503	; 0xfffff639
 b10:	06ba0301 	ldrteq	r0, [sl], r1, lsl #6
 b14:	0303042e 	movweq	r0, #13358	; 0x342e
	static struct bin_attribute of_fdt_raw_attr =
		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);

	if (!initial_boot_params)
 b18:	042e79c6 	strteq	r7, [lr], #-2502	; 0xfffff63a
 b1c:	06ba0301 	ldrteq	r0, [sl], r1, lsl #6
 b20:	4a74032e 	bmi	1d017e0 <unflatten_and_copy_device_tree+0x1d0096c>
 b24:	344a0b03 	strbcc	r0, [sl], #-2819	; 0xfffff4fd
 b28:	882e3c03 	stmdahi	lr!, {r0, r1, sl, fp, ip, sp}
 b2c:	502e7a03 	eorpl	r7, lr, r3, lsl #20
		return 0;

	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
 b30:	02002ca0 	andeq	r2, r0, #160, 24	; 0xa000
 b34:	002f0104 	eoreq	r0, pc, r4, lsl #2
 b38:	81010402 	tsthi	r1, r2, lsl #8
 b3c:	032d9f4b 			; <UNDEFINED> instruction: 0x032d9f4b
 b40:	9f2e7ed3 	svcls	0x002e7ed3
 b44:	0304044c 	movweq	r0, #17484	; 0x444c
 b48:	042e7bb5 	strteq	r7, [lr], #-2997	; 0xfffff44b
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
 b4c:	04cb0301 	strbeq	r0, [fp], #769	; 0x301
 b50:	0304042e 	movweq	r0, #17454	; 0x442e
 b54:	2f827bb6 	svccs	0x00827bb6
		return 0;
 b58:	0303042d 	movweq	r0, #13357	; 0x342d
 b5c:	042e7ef2 	strteq	r7, [lr], #-3826	; 0xfffff10e
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b60:	018f0304 	orreq	r0, pc, r4, lsl #6
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b64:	0301044a 	movweq	r0, #5194	; 0x144a
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b68:	9f4a04cb 	svcls	0x004a04cb
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b6c:	0304044c 	movweq	r0, #17484	; 0x444c
 b70:	042e7bb0 	strteq	r7, [lr], #-2992	; 0xfffff450
 b74:	04d00301 	ldrbeq	r0, [r0], #769	; 0x301
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
 b78:	0304042e 	movweq	r0, #17454	; 0x442e
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 b7c:	2f827bb1 	svccs	0x00827bb1
 b80:	04492f2d 	strbeq	r2, [r9], #-3885	; 0xfffff0d3
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 b84:	7ef20303 	cdpvc	3, 15, cr0, cr2, cr3, {0}
 b88:	0304042e 	movweq	r0, #17454	; 0x442e
 b8c:	042e018f 	strteq	r0, [lr], #-399	; 0xfffffe71
 b90:	7ef10303 	cdpvc	3, 15, cr0, cr1, cr3, {0}
	const void *blob = initial_boot_params;
 b94:	0304042e 	movweq	r0, #17454	; 0x442e
 b98:	042e018f 	strteq	r0, [lr], #-399	; 0xfffffe71
	const char *pathp;
	int offset, rc = 0, depth = -1;
 b9c:	04b40301 	ldrteq	r0, [r4], #769	; 0x301
 ba0:	2f2d2f4a 	svccs	0x002d2f4a
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 ba4:	0305042f 	movweq	r0, #21551	; 0x542f
	const void *blob = initial_boot_params;
 ba8:	044a7be1 	strbeq	r7, [sl], #-3041	; 0xfffff41f
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
 bac:	049d0301 	ldreq	r0, [sp], #769	; 0x301
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
 bb0:	2f2d304a 	svccs	0x002d304a

        for (offset = fdt_next_node(blob, -1, &depth);
 bb4:	2e01c303 	cdpcs	3, 0, cr12, cr1, cr3, {0}
 bb8:	09039f9f 	stmdbeq	r3, {r0, r1, r2, r3, r4, r7, r8, r9, sl, fp, ip, pc}
				     void *data),
			   void *data)
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
 bbc:	03c16882 	biceq	r6, r1, #8519680	; 0x820000

        for (offset = fdt_next_node(blob, -1, &depth);
 bc0:	674a7dd1 			; <UNDEFINED> instruction: 0x674a7dd1
 bc4:	bb6734bb 	bllt	19cdeb8 <unflatten_and_copy_device_tree+0x19cd044>
 bc8:	6a2e0c03 	bvs	b83bdc <unflatten_and_copy_device_tree+0xb82d68>
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bcc:	03844b9f 	orreq	r4, r4, #162816	; 0x27c00
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
 bd0:	29874a0d 	stmibcs	r7, {r0, r2, r3, r9, fp, lr}
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bd4:	08678352 	stmdaeq	r7!, {r1, r4, r6, r8, r9, pc}^
 bd8:	9f684e25 	svcls	0x00684e25
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
 bdc:	67354830 			; <UNDEFINED> instruction: 0x67354830
             offset >= 0 && depth >= 0 && !rc;
 be0:	674a7903 	strbvs	r7, [sl, -r3, lsl #18]
 be4:	2f2d9f67 	svccs	0x002d9f67
 be8:	0200a089 	andeq	sl, r0, #137	; 0x89
 bec:	032f0104 			; <UNDEFINED> instruction: 0x032f0104
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bf0:	674a0186 	strbvs	r0, [sl, -r6, lsl #3]
		if (*pathp == '/')
 bf4:	0304042d 	movweq	r0, #17453	; 0x442d

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
 bf8:	044a7acb 	strbeq	r7, [sl], #-2763	; 0xfffff535
		if (*pathp == '/')
 bfc:	05b80301 	ldreq	r0, [r8, #769]!	; 0x301
 c00:	0304044a 	movweq	r0, #17482	; 0x444a
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
	const char *tail = strrchr(path, '/');
 c04:	2f4a7ac9 	svccs	0x004a7ac9
	return tail ? tail + 1 : path;
 c08:	042d2f2d 	strteq	r2, [sp], #-3885	; 0xfffff0d3
 c0c:	7ef20303 	cdpvc	3, 15, cr0, cr2, cr3, {0}
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
 c10:	0304042e 	movweq	r0, #17454	; 0x442e
 c14:	042e018f 	strteq	r0, [lr], #-399	; 0xfffffe71
 c18:	7ef10303 	cdpvc	3, 15, cr0, cr1, cr3, {0}
 c1c:	0304042e 	movweq	r0, #17454	; 0x442e
 c20:	042e018f 	strteq	r0, [lr], #-399	; 0xfffffe71
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
 c24:	05b80301 	ldreq	r0, [r8, #769]!	; 0x301
 c28:	00e0034a 	rsceq	r0, r0, sl, asr #6

		pathp = fdt_get_name(blob, offset, NULL);
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
 c2c:	0504822e 	streq	r8, [r4, #-558]	; 0xfffffdd2
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
 c30:	8279ef03 	rsbshi	lr, r9, #3, 30
 c34:	0301042f 	movweq	r0, #5167	; 0x142f
 c38:	d8660692 	stmdale	r6!, {r1, r4, r7, r9, sl}^
 c3c:	f4750867 			; <UNDEFINED> instruction: 0xf4750867
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
	}
	return rc;
}
 c40:	2f814b4c 	svccs	0x00814b4c
 c44:	4db92f2d 	ldcmi	15, cr2, [r9, #180]!	; 0xb4
 c48:	03820e03 	orreq	r0, r2, #3, 28	; 0x30

/**
 * of_get_flat_dt_root - find the root node in the flat blob
 */
unsigned long __init of_get_flat_dt_root(void)
{
 c4c:	0e032e72 	mcreq	14, 0, r2, cr3, cr2, {3}
 c50:	30bc832e 	adcscc	r8, ip, lr, lsr #6
 c54:	9fbdbc67 	svcls	0x00bdbc67
	return 0;
}
 c58:	4a7f8003 	bmi	1fe0c6c <unflatten_and_copy_device_tree+0x1fdfdf8>
 c5c:	332f6583 			; <UNDEFINED> instruction: 0x332f6583

/**
 * of_get_flat_dt_size - Return the total size of the FDT
 */
int __init of_get_flat_dt_size(void)
{
 c60:	2d9fa151 	ldfcsd	f2, [pc, #324]	; dac <early_init_dt_verify+0x34>
 c64:	69bb2f2f 	ldmibvs	fp!, {r0, r1, r2, r3, r5, r8, r9, sl, fp, sp}
 c68:	d94e4632 	stmdble	lr, {r1, r4, r5, r9, sl, lr}^
	return fdt_totalsize(initial_boot_params);
 c6c:	864fa083 	strbhi	sl, [pc], -r3, lsl #1
 c70:	6600db03 	strvs	sp, [r0], -r3, lsl #22
 c74:	4b4b2f66 	blmi	12cca14 <unflatten_and_copy_device_tree+0x12cbba0>
 c78:	7cb6032f 	ldcvc	3, cr0, [r6], #188	; 0xbc
}
 c7c:	9fdb862e 	svcls	0x00db862e
 c80:	2f326268 	svccs	0x00326268
 * This function can be used within scan_flattened_dt callback to get
 * access to properties
 */
const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
				       int *size)
{
 c84:	032f8330 			; <UNDEFINED> instruction: 0x032f8330
 c88:	45874a45 	strmi	r4, [r7, #2629]	; 0xa45
 c8c:	0402006b 	streq	r0, [r2], #-107	; 0xffffff95
	return fdt_getprop(initial_boot_params, node, name, size);
 c90:	06660601 	strbteq	r0, [r6], -r1, lsl #12
 c94:	004a0b03 	subeq	r0, sl, r3, lsl #22
 c98:	03020402 	movweq	r0, #9218	; 0x2402
 c9c:	68034a75 	stmdavs	r3, {r0, r2, r4, r5, r6, r9, fp, lr}
 ca0:	03049fba 	movweq	r9, #20410	; 0x4fba
 ca4:	827cb003 	rsbshi	fp, ip, #3
 ca8:	d0030104 	andle	r0, r3, r4, lsl #2
}
 cac:	03042e03 	movweq	r2, #19971	; 0x4e03
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
 cb0:	2e7cb003 	cdpcs	0, 7, cr11, cr12, cr3, {0}
 cb4:	d0030104 	andle	r0, r3, r4, lsl #2
 cb8:	9f4d2e03 	svcls	0x004d2e03
	const __be32 *prop;

	if (depth != 0)
 cbc:	ac030304 	stcge	3, cr0, [r3], {4}
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
 cc0:	01044a7c 	tsteq	r4, ip, ror sl
	const __be32 *prop;

	if (depth != 0)
 cc4:	2e03d403 	cdpcs	4, 0, cr13, cr3, cr3, {0}
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 cc8:	ac030304 	stcge	3, cr0, [r3], {4}
 ccc:	01042e7c 	tsteq	r4, ip, ror lr
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
 cd0:	2e03d403 	cdpcs	4, 0, cr13, cr3, cr3, {0}
 cd4:	15039f4d 	strne	r9, [r3, #-3917]	; 0xfffff0b3
	const __be32 *prop;

	if (depth != 0)
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 cd8:	2e6b032e 	cdpcs	3, 6, cr0, cr11, cr14, {1}
 cdc:	01040200 	mrseq	r0, R12_usr
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 ce0:	4f4a1b03 	svcmi	0x004a1b03

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
 ce4:	7fa60383 	svcvc	0x00a60383
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 ce8:	03509008 	cmpeq	r0, #8
 cec:	03344a7a 	teqeq	r4, #499712	; 0x7a000
 cf0:	03342e7a 	teqeq	r4, #1952	; 0x7a0

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
 cf4:	03342e7a 	teqeq	r4, #1952	; 0x7a0
 cf8:	2d352e7a 	ldccs	14, cr2, [r5, #-488]!	; 0xfffffe18
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 cfc:	a3d7314b 	bicsge	r3, r7, #-1073741806	; 0xc0000012
 d00:	039e0b03 	orrseq	r0, lr, #3072	; 0xc00
	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
 d04:	17032e69 	strne	r2, [r3, -r9, ror #28]
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
 d08:	2e69032e 	cdpcs	3, 6, cr0, cr9, cr14, {1}
	if (prop)
 d0c:	682e0c03 	stmdavs	lr!, {r0, r1, sl, fp}
 d10:	2da18367 	stccs	3, cr8, [r1, #412]!	; 0x19c
 d14:	b6332d2f 	ldrtlt	r2, [r3], -pc, lsr #26
		dt_root_addr_cells = be32_to_cpup(prop);
 d18:	4a090381 	bmi	241b24 <unflatten_and_copy_device_tree+0x240cb0>
 d1c:	832f6749 			; <UNDEFINED> instruction: 0x832f6749
 d20:	4a3e0349 	bmi	f81a4c <unflatten_and_copy_device_tree+0xf80bd8>
 d24:	f26b03d7 	vcge.s32	q8, <illegal reg q13.5>, <illegal reg q3.5>
				   int depth, void *data)
{
	const __be32 *prop;

	if (depth != 0)
		return 0;
 d28:	2e170368 	cdpcs	3, 1, cr0, cr7, cr8, {3}
 d2c:	83662103 	cmnhi	r6, #-1073741824	; 0xc0000000
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (prop)
 d30:	f2030504 	vrshl.s8	d0, d4, d3
		dt_root_addr_cells = be32_to_cpup(prop);
	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);

	/* break now */
	return 1;
}
 d34:	042f9e7c 	strteq	r9, [pc], #-3708	; d3c <.debug_line+0xd3c>
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
 d38:	7ee90303 	cdpvc	3, 14, cr0, cr9, cr3, {0}
 d3c:	0301044a 	movweq	r0, #5194	; 0x144a
 d40:	852e04a8 	strhi	r0, [lr, #-1192]!	; 0xfffffb58
 d44:	4a03cb03 	bmi	f3958 <unflatten_and_copy_device_tree+0xf2ae4>
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d48:	044d4b67 	strbeq	r4, [sp], #-2919	; 0xfffff499
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
 d4c:	78850303 	stmvc	r5, {r0, r1, r8, r9}
 d50:	03010466 	movweq	r0, #5222	; 0x1466
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d54:	4b2e07ff 	blmi	b82d58 <unflatten_and_copy_device_tree+0xb81ee4>
 d58:	4e692f65 	cdpmi	15, 6, cr2, cr9, cr5, {3}
 d5c:	a285a168 	addge	sl, r5, #104, 2
 d60:	2f4d2f69 	svccs	0x004d2f69
 d64:	2e0b032f 	cdpcs	3, 0, cr0, cr11, cr15, {1}
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
		return 0;
 d68:	03240867 			; <UNDEFINED> instruction: 0x03240867
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d6c:	9f6a660f 	svcls	0x006a660f
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 d70:	03030467 	movweq	r0, #13415	; 0x3467
 d74:	042e77bf 	strteq	r7, [lr], #-1983	; 0xfffff841
 d78:	08c50301 	stmiaeq	r5, {r0, r8, r9}^
 d7c:	0303042e 	movweq	r0, #13358	; 0x342e
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
 d80:	044a77bb 	strbeq	r7, [sl], #-1979	; 0xfffff845
 d84:	08c50301 	stmiaeq	r5, {r0, r8, r9}^
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 d88:	674b692e 	strbvs	r6, [fp, -lr, lsr #18]
 d8c:	00040230 	andeq	r0, r4, r0, lsr r2
 d90:	Address 0x0000000000000d90 is out of bounds.


Disassembly of section .debug_str:

00000000 <.debug_str>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
       0:	65686373 	strbvs	r6, [r8, #-883]!	; 0xfffffc8d
       4:	6e655f64 	cdpvs	15, 6, cr5, cr5, cr4, {3}
       8:	79746974 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, fp, sp, lr}^
       c:	756f6600 	strbvc	r6, [pc, #-1536]!	; fffffa14 <__crc_of_fdt_unflatten_tree+0x792be457>
      10:	6800646e 	stmdavs	r0, {r1, r2, r3, r5, r6, sl, sp, lr}
      14:	74735f77 	ldrbtvc	r5, [r3], #-3959	; 0xfffff089
      18:	6570706f 	ldrbvs	r7, [r0, #-111]!	; 0xffffff91
      1c:	6f6c0064 	svcvs	0x006c0064
	return kzalloc(size, GFP_KERNEL);
}
      20:	6c20676e 	stcvs	7, cr6, [r0], #-440	; 0xfffffe48

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      24:	20676e6f 	rsbcs	r6, r7, pc, ror #28
      28:	00746e69 	rsbseq	r6, r4, r9, ror #28
      2c:	36755f5f 	uhsaxcc	r5, r5, pc	; <UNPREDICTABLE>
      30:	75610034 	strbvc	r0, [r1, #-52]!	; 0xffffffcc
      34:	5f746964 	svcpl	0x00746964
	memcpy(buf, initial_boot_params + off, count);
      38:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
      3c:	00747865 	rsbseq	r7, r4, r5, ror #16
      40:	63615f69 	cmnvs	r1, #420	; 0x1a4

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
      44:	6169006c 	cmnvs	r9, ip, rrx
	memcpy(buf, initial_boot_params + off, count);
      48:	00727474 	rsbseq	r7, r2, r4, ror r4
      4c:	6b6e696c 	blvs	1b9a604 <unflatten_and_copy_device_tree+0x1b99790>
      50:	6e6f7a00 	vmulvs.f32	s15, s30, s0
      54:	74735f65 	ldrbtvc	r5, [r3], #-3941	; 0xfffff09b
	return count;
}
      58:	695f7461 	ldmdbvs	pc, {r0, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
      5c:	006d6574 	rsbeq	r6, sp, r4, ror r5
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      60:	736e6f63 	cmnvc	lr, #396	; 0x18c
      64:	5f656c6f 	svcpl	0x00656c6f
      68:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
      6c:	76006b74 			; <UNDEFINED> instruction: 0x76006b74
      70:	61705f6d 	cmnvs	r0, sp, ror #30
      74:	705f6567 	subsvc	r6, pc, r7, ror #10
      78:	00746f72 	rsbseq	r6, r4, r2, ror pc
      7c:	5f637073 	svcpl	0x00637073
      80:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
      84:	696d696c 	stmdbvs	sp!, {r2, r3, r5, r6, r8, fp, sp, lr}^
      88:	68730074 	ldmdavs	r3!, {r2, r4, r5, r6}^
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      8c:	64657261 	strbtvs	r7, [r5], #-609	; 0xfffffd9f
      90:	006d765f 	rsbeq	r7, sp, pc, asr r6
				int *poffset,
				struct device_node *dad,
				struct device_node **nodepp,
				unsigned long fpsize,
				bool dryrun)
{
      94:	735f6d76 	cmpvc	pc, #7552	; 0x1d80
      98:	5f746174 	svcpl	0x00746174
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
      9c:	66666964 	strbtvs	r6, [r6], -r4, ror #18
	if (!pathp)
      a0:	72676300 	rsbvc	r6, r7, #0, 6
      a4:	5f70756f 	svcpl	0x0070756f
      a8:	00726469 	rsbseq	r6, r2, r9, ror #8
      ac:	655f6973 	ldrbvs	r6, [pc, #-2419]	; fffff741 <__crc_of_fdt_unflatten_tree+0x792be184>
		return mem;

	allocl = ++l;
      b0:	6f6e7272 	svcvs	0x006e7272
      b4:	73617400 	cmnvc	r1, #0, 8
      b8:	7300736b 	movwvc	r7, #875	; 0x36b
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      bc:	6b636174 	blvs	18d8694 <unflatten_and_copy_device_tree+0x18d7820>
      c0:	006d765f 	rsbeq	r7, sp, pc, asr r6
      c4:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
	unsigned int l, allocl;
	static int depth;
	int old_depth;
	int offset;
	int has_name = 0;
	int new_format = 0;
      c8:	5f61725f 	svcpl	0x0061725f
	/* version 0x10 has a more compact unit name here instead of the full
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
      cc:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
		new_format = 1;
		if (fpsize == 0) {
      d0:	65730065 	ldrbvs	r0, [r3, #-101]!	; 0xffffff9b
      d4:	74746174 	ldrbtvc	r6, [r4], #-372	; 0xfffffe8c
      d8:	6f6c0072 	svcvs	0x006c0072
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      dc:	7520676e 	strvc	r6, [r0, #-1902]!	; 0xfffff892
      e0:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
      e4:	2064656e 	rsbcs	r6, r4, lr, ror #10
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
			pathp = "";
      e8:	00746e69 	rsbseq	r6, r4, r9, ror #28
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
			allocl = 2;
			l = 1;
      ec:	6769726f 	strbvs	r7, [r9, -pc, ror #4]!
			pathp = "";
      f0:	7465725f 	strbtvc	r7, [r5], #-607	; 0xfffffda1
			/* root node: special case. fpsize accounts for path
			 * plus terminating zero. root node only has '/', so
			 * fpsize should be 2, but we want to avoid the first
			 * level nodes to have two '/' so we use fpsize 1 here
			 */
			fpsize = 1;
      f4:	6461765f 	strbtvs	r7, [r1], #-1631	; 0xfffff9a1
			allocl = 2;
			l = 1;
			pathp = "";
      f8:	6c007264 	sfmvs	f7, 4, [r0], {100}	; 0x64
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
      fc:	6565736c 	strbvs	r7, [r5, #-876]!	; 0xfffffc94
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     100:	6e69006b 	cdpvs	0, 6, cr0, cr9, cr11, {3}
     104:	64695f6f 	strbtvs	r5, [r9], #-3951	; 0xfffff091
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     108:	6f630061 	svcvs	0x00630061
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     10c:	6361706d 	cmnvs	r1, #109	; 0x6d
				unsigned long fpsize,
				bool dryrun)
{
	const __be32 *p;
	struct device_node *np;
	struct property *pp, **prev_pp = NULL;
     110:	61635f74 	smcvs	13812	; 0x35f4
     114:	64656863 	strbtvs	r6, [r5], #-2147	; 0xfffff79d
		}
	}

	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
     118:	67696d5f 			; <UNDEFINED> instruction: 0x67696d5f
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     11c:	65746172 	ldrbvs	r6, [r4, #-370]!	; 0xfffffe8e
     120:	6e66705f 	mcrvs	0, 3, r7, cr6, cr15, {2}
     124:	696c7200 	stmdbvs	ip!, {r9, ip, sp, lr}^
     128:	75635f6d 	strbvc	r5, [r3, #-3949]!	; 0xfffff093
     12c:	524e0072 	subpl	r0, lr, #114	; 0x72
     130:	52454b5f 	subpl	r4, r5, #97280	; 0x17c00

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     134:	5f4c454e 	svcpl	0x004c454e
     138:	43415453 	movtmi	r5, #5203	; 0x1453
     13c:	524c004b 	subpl	r0, ip, #75	; 0x4b
					np->phandle = be32_to_cpup(p);
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     140:	4e555f55 	mrcmi	15, 2, r5, cr5, cr5, {2}
     144:	43495645 	movtmi	r5, #38469	; 0x9645
     148:	4c424154 	stfmie	f4, [r2], {84}	; 0x54
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     14c:	69700045 	ldmdbvs	r0!, {r0, r2, r6}^
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     150:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     154:	6d74006b 	ldclvs	0, cr0, [r4, #-428]!	; 0xfffffe54
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     158:	6c696670 	stclvs	6, cr6, [r9], #-448	; 0xfffffe40
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     15c:	666f0065 	strbtvs	r0, [pc], -r5, rrx
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     160:	6165725f 	cmnvs	r5, pc, asr r2
			    (strcmp(pname, "linux,phandle") == 0)) {
     164:	756e5f64 	strbvc	r5, [lr, #-3940]!	; 0xfffff09c
     168:	7265626d 	rsbvc	r6, r5, #-805306362	; 0xd0000006
     16c:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
     170:	65746176 	ldrbvs	r6, [r4, #-374]!	; 0xfffffe8a
		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
     174:	776f6c00 	strbvc	r6, [pc, -r0, lsl #24]!
     178:	5f6d656d 	svcpl	0x006d656d
     17c:	65736572 	ldrbvs	r6, [r3, #-1394]!	; 0xfffffa8e
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
     180:	00657672 	rsbeq	r7, r5, r2, ror r6
     184:	735f7366 	cmpvc	pc, #-1744830463	; 0x98000001
     188:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
			has_name = 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     18c:	74730074 	ldrbtvc	r0, [r3], #-116	; 0xffffff8c
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     190:	5f657461 	svcpl	0x00657461
     194:	6f6d6572 	svcvs	0x006d6572
	res = *mem;
	*mem += size;
     198:	755f6576 	ldrbvc	r6, [pc, #-1398]	; fffffc2a <__crc_of_fdt_unflatten_tree+0x792be66d>
		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
			break;
		}
		if (strcmp(pname, "name") == 0)
			has_name = 1;
     19c:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
     1a0:	65735f74 	ldrbvs	r5, [r3, #-3956]!	; 0xfffff08c
		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
					__alignof__(struct property));
		if (!dryrun) {
     1a4:	7000746e 	andvc	r7, r0, lr, ror #8
     1a8:	6f737265 	svcvs	0x00737265
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1ac:	696c616e 	stmdbvs	ip!, {r1, r2, r3, r5, r6, r8, sp, lr}^
     1b0:	69007974 	stmdbvs	r0, {r2, r4, r5, r6, r8, fp, ip, sp, lr}
     1b4:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
     1b8:	656b5f6b 	strbvs	r5, [fp, #-3947]!	; 0xfffff095
     1bc:	6e690079 	mcrvs	0, 3, r0, cr9, cr9, {3}
			    (strcmp(pname, "linux,phandle") == 0)) {
     1c0:	745f7469 	ldrbvc	r7, [pc], #-1129	; 1c8 <.debug_str+0x1c8>
     1c4:	696d7265 	stmdbvs	sp!, {r0, r2, r5, r6, r9, ip, sp, lr}^
     1c8:	6500736f 	strvs	r7, [r0, #-879]	; 0xfffffc91
			/* We accept flattened tree phandles either in
			 * ePAPR-style "phandle" properties, or the
			 * legacy "linux,phandle" properties.  If both
			 * appear and have different values, things
			 * will get weird.  Don't do that. */
			if ((strcmp(pname, "phandle") == 0) ||
     1cc:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
     1d0:	6d65725f 	sfmvs	f7, 2, [r5, #-380]!	; 0xfffffe84
			    (strcmp(pname, "linux,phandle") == 0)) {
				if (np->phandle == 0)
     1d4:	5f65766f 	svcpl	0x0065766f
     1d8:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
     1dc:	61747500 	cmnvs	r4, r0, lsl #10
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     1e0:	65006b73 	strvs	r6, [r0, #-2931]	; 0xfffff48d
					np->phandle = be32_to_cpup(p);
     1e4:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     1e8:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
     1ec:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
			}
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
     1f0:	6568635f 	strbvs	r6, [r8, #-863]!	; 0xfffffca1
     1f4:	665f6b63 	ldrbvs	r6, [pc], -r3, ror #22
     1f8:	695f726f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^	; <UNPREDICTABLE>
     1fc:	7274696e 	rsbsvc	r6, r4, #1802240	; 0x1b8000
     200:	524e0064 	subpl	r0, lr, #100	; 0x64
				np->phandle = be32_to_cpup(p);
     204:	4f53495f 	svcmi	0x0053495f
     208:	4554414c 	ldrbmi	r4, [r4, #-332]	; 0xfffffeb4
     20c:	49465f44 	stmdbmi	r6, {r2, r6, r8, r9, sl, fp, ip, lr}^
			pp->name = (char *)pname;
			pp->length = sz;
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     210:	6d00454c 	cfstr32vs	mvfx4, [r0, #-304]	; 0xfffffed0
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
			pp->length = sz;
     214:	635f7061 	cmpvs	pc, #97	; 0x61
			/* And we process the "ibm,phandle" property
			 * used in pSeries dynamic device tree
			 * stuff */
			if (strcmp(pname, "ibm,phandle") == 0)
				np->phandle = be32_to_cpup(p);
			pp->name = (char *)pname;
     218:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
			pp->length = sz;
     21c:	765f6900 	ldrbvc	r6, [pc], -r0, lsl #18
			pp->value = (__be32 *)p;
			*prev_pp = pp;
     220:	69737265 	ldmdbvs	r3!, {r0, r2, r5, r6, r9, ip, sp, lr}^
			prev_pp = &pp->next;
     224:	65006e6f 	strvs	r6, [r0, #-3695]	; 0xfffff191
     228:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
     22c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
     230:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
     234:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
			np->sibling = dad->child;
			dad->child = np;
		}
	}
	/* process properties */
	for (offset = fdt_first_property_offset(blob, *poffset);
     238:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
     23c:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
	     (offset >= 0);
	     (offset = fdt_next_property_offset(blob, offset))) {
		const char *pname;
		u32 sz;

		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
     240:	5f79726f 	svcpl	0x0079726f
     244:	68637261 	stmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
     248:	72657600 	rsbvc	r7, r5, #0, 12
     24c:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
     250:	72617400 	rsbvc	r7, r1, #0, 8
     254:	5f746567 	svcpl	0x00746567
     258:	6d006e6b 	stcvs	14, cr6, [r0, #-428]	; 0xfffffe54
     25c:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
     260:	67635f79 			; <UNDEFINED> instruction: 0x67635f79
		}
	}
	/* with version 0x10 we may not have the name property, recreate
	 * it here from the unit name if absent
	 */
	if (!has_name) {
     264:	695f7072 	ldmdbvs	pc, {r1, r4, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
     268:	65720064 	ldrbvs	r0, [r2, #-100]!	; 0xffffff9c
			((char *)pp->value)[sz - 1] = 0;
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
     26c:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000
     270:	4e550065 	cdpmi	0, 5, cr0, cr5, cr5, {3}
     274:	43495645 	movtmi	r5, #38469	; 0x9645
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
     278:	4c424154 	stfmie	f4, [r2], {84}	; 0x54
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     27c:	47505f45 	ldrbmi	r5, [r0, -r5, asr #30]
     280:	41454c43 	cmpmi	r5, r3, asr #24
	*poffset = fdt_next_node(blob, *poffset, &depth);
     284:	00444552 	subeq	r4, r4, r2, asr r5
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     288:	70616d6d 	rsbvc	r6, r1, sp, ror #26
	*poffset = fdt_next_node(blob, *poffset, &depth);
     28c:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
	}

	old_depth = depth;
     290:	65720065 	ldrbvs	r0, [r2, #-101]!	; 0xffffff9b
	*poffset = fdt_next_node(blob, *poffset, &depth);
     294:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
     298:	6c625f74 	stclvs	15, cr5, [r2], #-464	; 0xfffffe30
	if (depth < 0)
     29c:	006b636f 	rsbeq	r6, fp, pc, ror #6
     2a0:	6c626973 	stclvs	9, cr6, [r2], #-460	; 0xfffffe34
		depth = 0;
     2a4:	00676e69 	rsbeq	r6, r7, r9, ror #28
     2a8:	6d5f726e 	lfmvs	f7, 2, [pc, #-440]	; f8 <.debug_str+0xf8>
     2ac:	61726769 	cmnvs	r2, r9, ror #14
     2b0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
	while (*poffset > 0 && depth > old_depth)
     2b4:	656b0073 	strbvs	r0, [fp, #-115]!	; 0xffffff8d
     2b8:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
     2bc:	6572745f 	ldrbvs	r7, [r2, #-1119]!	; 0xfffffba1
     2c0:	6c615f65 	stclvs	15, cr5, [r1], #-404	; 0xfffffe6c
     2c4:	00636f6c 	rsbeq	r6, r3, ip, ror #30
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2c8:	6579616c 	ldrbvs	r6, [r9, #-364]!	; 0xfffffe94
     2cc:	656d0072 	strbvs	r0, [sp, #-114]!	; 0xffffff8e
     2d0:	696c5f6d 	stmdbvs	ip!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     2d4:	0074696d 	rsbseq	r6, r4, sp, ror #18
     2d8:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
     2dc:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     2e0:	706f5f6b 	rsbvc	r5, pc, fp, ror #30
     2e4:	74617265 	strbtvc	r7, [r1], #-613	; 0xfffffd9b
     2e8:	736e6f69 	cmnvc	lr, #420	; 0x1a4
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
     2ec:	695f7300 	ldmdbvs	pc, {r8, r9, ip, sp, lr}^	; <UNPREDICTABLE>
     2f0:	65720064 	ldrbvs	r0, [r2, #-100]!	; 0xffffff9c
     2f4:	6f006461 	svcvs	0x00006461
     2f8:	66726576 			; <UNDEFINED> instruction: 0x66726576
     2fc:	75776f6c 	ldrbvc	r6, [r7, #-3948]!	; 0xfffff094
     300:	69006469 	stmdbvs	r0, {r0, r3, r5, r6, sl, sp, lr}
     304:	5f62775f 	svcpl	0x0062775f
     308:	5f6e7266 	svcpl	0x006e7266
     30c:	5f677661 	svcpl	0x00677661

	old_depth = depth;
	*poffset = fdt_next_node(blob, *poffset, &depth);
	if (depth < 0)
		depth = 0;
	while (*poffset > 0 && depth > old_depth)
     310:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
     314:	52475000 	subpl	r5, r7, #0
     318:	4c494645 	mcrrmi	6, 4, r4, r9, cr5
     31c:	4f4e5f4c 	svcmi	0x004e5f4c
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
     320:	4c414d52 	mcrrmi	13, 5, r4, r1, cr2
     324:	616f6900 	cmnvs	pc, r0, lsl #18

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun && np->child) {
     328:	63720063 	cmnvs	r2, #99	; 0x63
     32c:	65725f75 	ldrbvs	r5, [r2, #-3957]!	; 0xfffff08b
     330:	6c5f6461 	cfldrdvs	mvd6, [pc], {97}	; 0x61
     334:	5f6b636f 	svcpl	0x006b636f
     338:	7473656e 	ldrbtvc	r6, [r3], #-1390	; 0xfffffa92
     33c:	00676e69 	rsbeq	r6, r7, r9, ror #28
		struct device_node *child = np->child;
		np->child = NULL;
     340:	4f4e5746 	svcmi	0x004e5746
     344:	4f5f4544 	svcmi	0x005f4544
     348:	6c660046 	stclvs	0, cr0, [r6], #-280	; 0xfffffee8
		while (child) {
			struct device_node *next = child->sibling;
     34c:	5f687375 	svcpl	0x00687375
			child->sibling = np->child;
     350:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
     354:	6e61725f 	mcrvs	2, 3, r7, cr1, cr15, {2}
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     358:	61006567 	tstvs	r0, r7, ror #10
			struct device_node *next = child->sibling;
			child->sibling = np->child;
			np->child = child;
     35c:	73617475 	cmnvc	r1, #1962934272	; 0x75000000
     360:	7164006b 	cmnvc	r4, fp, rrx
	 * node order
	 */
	if (!dryrun && np->child) {
		struct device_node *child = np->child;
		np->child = NULL;
		while (child) {
     364:	6f665f69 	svcvs	0x00665f69
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     368:	74616d72 	strbtvc	r6, [r1], #-3442	; 0xfffff28e
		*nodepp = np;
     36c:	736f7000 	cmnvc	pc, #0
			np->child = child;
			child = next;
		}
	}

	if (nodepp)
     370:	74615f74 	strbtvc	r5, [r1], #-3956	; 0xfffff08c
		*nodepp = np;
     374:	68636174 	stmdavs	r3!, {r2, r4, r5, r6, r8, sp, lr}^
     378:	6c5f6300 	mrrcvs	3, 0, r6, pc, cr0	; <UNPREDICTABLE>

	return mem;
}
     37c:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
     380:	6b5f5f00 	blvs	17d7f88 <unflatten_and_copy_device_tree+0x17d7114>
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     384:	74637263 	strbtvc	r7, [r3], #-611	; 0xfffffd9d
     388:	6f5f6261 	svcvs	0x005f6261
     38c:	64665f66 	strbtvs	r5, [r6], #-3942	; 0xfffff09a
     390:	6e755f74 	mrcvs	15, 3, r5, cr5, cr4, {3}
     394:	74616c66 	strbtvc	r6, [r1], #-3174	; 0xfffff39a
     398:	5f6e6574 	svcpl	0x006e6574
			if ((*p1) == '@')
     39c:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
     3a0:	715f7300 	cmpvc	pc, r0, lsl #6
				pa = p1;
			if ((*p1) == '/')
     3a4:	00706f63 	rsbseq	r6, r0, r3, ror #30
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
			if ((*p1) == '@')
     3a8:	705f6c64 	subsvc	r6, pc, r4, ror #24
     3ac:	6f697265 	svcvs	0x00697265
				pa = p1;
			if ((*p1) == '/')
     3b0:	5f5f0064 	svcpl	0x005f0064
     3b4:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     3b8:	675f6c65 	ldrbvs	r6, [pc, -r5, ror #24]
     3bc:	32336469 	eorscc	r6, r3, #1761607680	; 0x69000000
     3c0:	6b00745f 	blvs	1d544 <unflatten_and_copy_device_tree+0x1c6d0>
     3c4:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3c8:	6c657200 	sfmvs	f7, 2, [r5], #-0
static void *unflatten_dt_alloc(void **mem, unsigned long size,
				       unsigned long align)
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
     3cc:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0xfffffe9b
     3d0:	6567615f 	strbvs	r6, [r7, #-351]!	; 0xfffffea1
				pa = p1;
			if ((*p1) == '/')
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
     3d4:	705f746e 	subsvc	r7, pc, lr, ror #8
     3d8:	00687461 	rsbeq	r7, r8, r1, ror #8
			pa = p1;
		sz = (pa - ps) + 1;
     3dc:	5f55524c 	svcpl	0x0055524c
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3e0:	49544341 	ldmdbmi	r4, {r0, r6, r8, r9, lr}^
{
	void *res;

	*mem = PTR_ALIGN(*mem, align);
	res = *mem;
	*mem += size;
     3e4:	415f4556 	cmpmi	pc, r6, asr r5	; <UNPREDICTABLE>
     3e8:	004e4f4e 	subeq	r4, lr, lr, asr #30
				ps = p1 + 1;
			p1++;
		}
		if (pa < ps)
			pa = p1;
		sz = (pa - ps) + 1;
     3ec:	5f797474 	svcpl	0x00797474
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
     3f0:	7369646c 	cmnvc	r9, #108, 8	; 0x6c000000
     3f4:	706f5f63 	rsbvc	r5, pc, r3, ror #30
			pp->name = "name";
     3f8:	6d760073 	ldclvs	0, cr0, [r6, #-460]!	; 0xfffffe34
     3fc:	0062725f 	rsbeq	r7, r2, pc, asr r2
     400:	4c414750 	mcrrmi	7, 5, r4, r1, cr0
			pp->length = sz;
			pp->value = pp + 1;
     404:	5f434f4c 	svcpl	0x00434f4c
     408:	00414d44 	subeq	r4, r1, r4, asr #26
			*prev_pp = pp;
     40c:	665f666f 	ldrbvs	r6, [pc], -pc, ror #12
		sz = (pa - ps) + 1;
		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
     410:	725f7464 	subsvc	r7, pc, #100, 8	; 0x64000000
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
			memcpy(pp->value, ps, sz - 1);
     414:	695f7761 	ldmdbvs	pc, {r0, r5, r6, r8, r9, sl, ip, sp, lr}^	; <UNPREDICTABLE>
					__alignof__(struct property));
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
     418:	0074696e 	rsbseq	r6, r4, lr, ror #18
			prev_pp = &pp->next;
     41c:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
			memcpy(pp->value, ps, sz - 1);
     420:	6e695f79 	mcrvs	15, 3, r5, cr9, cr9, {3}
		if (!dryrun) {
			pp->name = "name";
			pp->length = sz;
			pp->value = pp + 1;
			*prev_pp = pp;
			prev_pp = &pp->next;
     424:	645f7469 	ldrbvs	r7, [pc], #-1129	; 42c <.debug_str+0x42c>
			memcpy(pp->value, ps, sz - 1);
     428:	65765f74 	ldrbvs	r5, [r6, #-3956]!	; 0xfffff08c
			((char *)pp->value)[sz - 1] = 0;
     42c:	79666972 	stmdbvc	r6!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     430:	454e5500 	strbmi	r5, [lr, #-1280]	; 0xfffffb00
     434:	54434956 	strbpl	r4, [r3], #-2390	; 0xfffff6aa
     438:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     43c:	4d47505f 	stclmi	0, cr5, [r7, #-380]	; 0xfffffe84
     440:	4f4c4e55 	svcmi	0x004c4e55
		np->name = of_get_property(np, "name", NULL);
     444:	44454b43 	strbmi	r4, [r5], #-2883	; 0xfffff4bd
     448:	72726500 	rsbsvc	r6, r2, #0, 10
     44c:	6d757461 	cfldrdvs	mvd7, [r5, #-388]!	; 0xfffffe7c
     450:	3531615f 	ldrcc	r6, [r1, #-351]!	; 0xfffffea1
			pr_debug("fixed up name for %s -> %s\n", pathp,
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
     454:	3839375f 	ldmdacc	r9!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp}
		np->name = of_get_property(np, "name", NULL);
     458:	5f313831 	svcpl	0x00313831
		np->type = of_get_property(np, "device_type", NULL);
     45c:	646e6168 	strbtvs	r6, [lr], #-360	; 0xfffffe98
     460:	0072656c 	rsbseq	r6, r2, ip, ror #10
     464:	65646e69 	strbvs	r6, [r4, #-3689]!	; 0xfffff197
				(char *)pp->value);
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
     468:	656b5f78 	strbvs	r5, [fp, #-3960]!	; 0xfffff088
		np->type = of_get_property(np, "device_type", NULL);
     46c:	69640079 	stmdbvs	r4!, {r0, r3, r4, r5, r6}^
     470:	5f797472 	svcpl	0x00797472

		if (!np->name)
     474:	646f6e69 	strbtvs	r6, [pc], #-3689	; 47c <.debug_str+0x47c>
     478:	4f430065 	svcmi	0x00430065
			np->name = "<NULL>";
     47c:	4341504d 	movtmi	r5, #4173	; 0x104d
     480:	45524654 	ldrbmi	r4, [r2, #-1620]	; 0xfffff9ac
     484:	43535f45 	cmpmi	r3, #276	; 0x114
		if (!np->type)
     488:	454e4e41 	strbmi	r4, [lr, #-3649]	; 0xfffff1bf
		}
	}
	if (!dryrun) {
		*prev_pp = NULL;
		np->name = of_get_property(np, "name", NULL);
		np->type = of_get_property(np, "device_type", NULL);
     48c:	65720044 	ldrbvs	r0, [r2, #-68]!	; 0xffffffbc

		if (!np->name)
			np->name = "<NULL>";
		if (!np->type)
			np->type = "<NULL>";
     490:	73657571 	cmnvc	r5, #473956352	; 0x1c400000
     494:	75715f74 	ldrbvc	r5, [r1, #-3956]!	; 0xfffff08c
     498:	00657565 	rsbeq	r7, r5, r5, ror #10
     49c:	705f7472 	subsvc	r7, pc, r2, ror r4	; <UNPREDICTABLE>
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a0:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
	 * path. we accumulate the full path size using "fpsize", we'll rebuild
	 * it later. We detect this because the first character of the name is
	 * not '/'.
	 */
	if ((*pathp) != '/') {
		new_format = 1;
     4a4:	00797469 	rsbseq	r7, r9, r9, ror #8
			pathp = "";
		} else {
			/* account for '/' and path size minus terminal 0
			 * already in 'l'
			 */
			fpsize += l;
     4a8:	4f4e5746 	svcmi	0x004e5746
     4ac:	415f4544 	cmpmi	pc, r4, asr #10
     4b0:	00495043 	subeq	r5, r9, r3, asr #32
     4b4:	6f6a616d 	svcvs	0x006a616d
     4b8:	696c0072 	stmdbvs	ip!, {r1, r4, r5, r6}^
     4bc:	6c5f7473 	cfldrdvs	mvd7, [pc], {115}	; 0x73

/* initialize a node */
extern struct kobj_type of_node_ktype;
static inline void of_node_init(struct device_node *node)
{
	kobject_init(&node->kobj, &of_node_ktype);
     4c0:	6d5f7572 	cfldr64vs	mvdx7, [pc, #-456]	; 300 <.debug_str+0x300>
     4c4:	67636d65 	strbvs	r6, [r3, -r5, ror #26]!
     4c8:	72676e00 	rsbvc	r6, r7, #0, 28
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4cc:	7370756f 	cmnvc	r0, #465567744	; 0x1bc00000
     4d0:	63657300 	cmnvs	r5, #0, 6
		if (new_format) {
     4d4:	706d6f63 	rsbvc	r6, sp, r3, ror #30
	node->fwnode.type = FWNODE_OF;
     4d8:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     4dc:	00726574 	rsbseq	r6, r2, r4, ror r5
     4e0:	67696568 	strbvs	r6, [r9, -r8, ror #10]!
		if (new_format) {
     4e4:	61007468 	tstvs	r0, r8, ror #8
			/* rebuild full path for new format */
			if (dad && dad->parent) {
     4e8:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
     4ec:	6f6e695f 	svcvs	0x006e695f
     4f0:	73006564 	movwvc	r6, #1380	; 0x564
     4f4:	78616d5f 	stmdavc	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
     4f8:	6e696c5f 	mcrvs	12, 3, r6, cr9, cr15, {2}
				strcpy(fn, dad->full_name);
     4fc:	6300736b 	movwvs	r7, #875	; 0x36b
     500:	6f5f7570 	svcvs	0x005f7570
     504:	6e696c6e 	cdpvs	12, 6, cr6, cr9, cr14, {3}
					pr_debug("%s: p: %d, l: %d, a: %d\n",
						pathp, (int)strlen(fn),
						l, allocl);
				}
#endif
				fn += strlen(fn);
     508:	616d5f65 	cmnvs	sp, r5, ror #30
     50c:	75006b73 	strvc	r6, [r0, #-2931]	; 0xfffff48d
     510:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
			}
			*(fn++) = '/';
     514:	6500745f 	strvs	r7, [r0, #-1119]	; 0xfffffba1
     518:	5f746978 	svcpl	0x00746978
     51c:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
		}
		memcpy(fn, pathp, l);
     520:	65730065 	ldrbvs	r0, [r3, #-101]!	; 0xffffff9b
     524:	6c616972 	stclvs	9, cr6, [r1], #-456	; 0xfffffe38
     528:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 530 <.debug_str+0x530>

		prev_pp = &np->properties;
     52c:	5f730065 	svcpl	0x00730065
     530:	00696462 	rsbeq	r6, r9, r2, ror #8
#endif
				fn += strlen(fn);
			}
			*(fn++) = '/';
		}
		memcpy(fn, pathp, l);
     534:	645f726e 	ldrbvs	r7, [pc], #-622	; 53c <.debug_str+0x53c>

		prev_pp = &np->properties;
		if (dad != NULL) {
     538:	69747269 	ldmdbvs	r4!, {r0, r3, r5, r6, r9, ip, sp, lr}^
			np->parent = dad;
     53c:	74006465 	strvc	r6, [r0], #-1125	; 0xfffffb9b
			np->sibling = dad->child;
     540:	746f7268 	strbtvc	r7, [pc], #-616	; 548 <.debug_str+0x548>
     544:	5f656c74 	svcpl	0x00656c74
			dad->child = np;
     548:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93
     54c:	65730078 	ldrbvs	r0, [r3, #-120]!	; 0xffffff88
	int has_name = 0;
	int new_format = 0;

	pathp = fdt_get_name(blob, *poffset, &l);
	if (!pathp)
		return mem;
     550:	655f666c 	ldrbvs	r6, [pc, #-1644]	; fffffeec <__crc_of_fdt_unflatten_tree+0x792be92f>

	if (nodepp)
		*nodepp = np;

	return mem;
}
     554:	5f636578 	svcpl	0x00636578
     558:	64006469 	strvs	r6, [r0], #-1129	; 0xfffffb97
	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
				__alignof__(struct device_node));
	if (!dryrun) {
		char *fn;
		of_node_init(np);
		np->full_name = fn = ((char *)np) + sizeof(*np);
     55c:	65706d75 	ldrbvs	r6, [r0, #-3445]!	; 0xfffff28b
     560:	77660072 			; <UNDEFINED> instruction: 0x77660072
	 */
	if (!has_name) {
		const char *p1 = pathp, *ps = pathp, *pa = NULL;
		int sz;

		while (*p1) {
     564:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
     568:	6e61685f 	mcrvs	8, 3, r6, cr1, cr15, {2}
     56c:	00656c64 	rsbeq	r6, r5, r4, ror #24
			offset = -FDT_ERR_INTERNAL;
			break;
		}

		if (pname == NULL) {
			pr_info("Can't find property name in list !\n");
     570:	70735f69 	rsbsvc	r5, r3, r9, ror #30
     574:	61775f63 	cmnvs	r7, r3, ror #30
     578:	696c6e72 	stmdbvs	ip!, {r1, r4, r5, r6, r9, sl, fp, sp, lr}^
     57c:	0074696d 	rsbseq	r6, r4, sp, ror #18
     580:	6d697473 	cfstrdvs	mvd7, [r9, #-460]!	; 0xfffffe34
			break;
     584:	53500065 	cmppl	r0, #101	; 0x65
	while (*poffset > 0 && depth > old_depth)
		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
					fpsize, dryrun);

	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
		pr_err("unflatten: error %d processing FDT\n", *poffset);
     588:	554f5057 	strbpl	r5, [pc, #-87]	; 539 <.debug_str+0x539>
     58c:	696c0054 	stmdbvs	ip!, {r2, r4, r6}^
     590:	69007473 	stmdbvs	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
     594:	69735f61 	ldmdbvs	r3!, {r0, r5, r6, r8, r9, sl, fp, ip, lr}^
     598:	6e00657a 	cfrshl64vs	mvdx0, mvdx10, r6
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     59c:	00656d61 	rsbeq	r6, r5, r1, ror #26
     5a0:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
     5a4:	6172665f 	cmnvs	r2, pc, asr r6
     5a8:	71640067 	cmnvc	r4, r7, rrx
     5ac:	68695f62 	stmdavs	r9!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
     5b0:	6c647261 	sfmvs	f7, 2, [r4], #-388	; 0xfffffe7c
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5b4:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
 * for the resulting tree
 */
static void __unflatten_device_tree(const void *blob,
			     struct device_node **mynodes,
			     void * (*dt_alloc)(u64 size, u64 align))
{
     5b8:	72656b00 	rsbvc	r6, r5, #0, 22
     5bc:	5f6c656e 	svcpl	0x006c656e
	int start;
	void *mem;

	pr_debug(" -> unflatten_device_tree()\n");

	if (!blob) {
     5c0:	5f706163 	svcpl	0x00706163
	pr_debug("Unflattening device tree:\n");
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
     5c4:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
     5c8:	48007463 	stmdami	r0, {r0, r1, r5, r6, sl, ip, sp, lr}
     5cc:	4d495452 	cfstrdmi	mvd5, [r9, #-328]	; 0xfffffeb8
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5d0:	4d5f5245 	lfmmi	f5, 2, [pc, #-276]	; 4c4 <.debug_str+0x4c4>
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5d4:	435f5841 	cmpmi	pc, #4259840	; 0x410000
     5d8:	4b434f4c 	blmi	10d4310 <unflatten_and_copy_device_tree+0x10d349c>
     5dc:	5341425f 	movtpl	r4, #4703	; 0x125f
		pr_err("Invalid device tree blob header\n");
		return;
	}

	/* First pass, scan for size */
	start = 0;
     5e0:	73005345 	movwvc	r5, #837	; 0x345
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
     5e4:	755f6d65 	ldrbvc	r6, [pc, #-3429]	; fffff887 <__crc_of_fdt_unflatten_tree+0x792be2ca>
     5e8:	5f6f646e 	svcpl	0x006f646e
     5ec:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
     5f0:	735f6b00 	cmpvc	pc, #0, 22
     5f4:	63616769 	cmnvs	r1, #27525120	; 0x1a40000
     5f8:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     5fc:	746f7400 	strbtvc	r7, [pc], #-1024	; 604 <.debug_str+0x604>
     600:	765f6c61 	ldrbvc	r6, [pc], -r1, ror #24
     604:	7366006d 	cmnvc	r6, #109	; 0x6d
	}

	/* First pass, scan for size */
	start = 0;
	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
	size = ALIGN(size, 4);
     608:	616c665f 	cmnvs	ip, pc, asr r6
     60c:	5f007367 	svcpl	0x00007367

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     610:	66657270 			; <UNDEFINED> instruction: 0x66657270
     614:	68637465 	stmdavs	r3!, {r0, r2, r5, r6, sl, ip, sp, lr}^
	memset(mem, 0, size);
     618:	6f62615f 	svcvs	0x0062615f
	size = ALIGN(size, 4);

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
     61c:	74007472 	strvc	r7, [r0], #-1138	; 0xfffffb8e
	memset(mem, 0, size);
     620:	5f6b7361 	svcpl	0x006b7361

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     624:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
     628:	5f524e00 	svcpl	0x00524e00

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     62c:	54495257 	strbpl	r5, [r9], #-599	; 0xfffffda9

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     630:	43414245 	movtmi	r4, #4677	; 0x1245

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     634:	45545f4b 	ldrbmi	r5, [r4, #-3915]	; 0xfffff0b5
     638:	7100504d 	tstvc	r0, sp, asr #32

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     63c:	61746f75 	cmnvs	r4, r5, ror pc
     640:	616e655f 	cmnvs	lr, pc, asr r5
     644:	00656c62 	rsbeq	r6, r5, r2, ror #24
     648:	66666f6c 	strbtvs	r6, [r6], -ip, ror #30
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     64c:	6600745f 			; <UNDEFINED> instruction: 0x6600745f
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     650:	776f5f6c 	strbvc	r5, [pc, -ip, ror #30]!
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     654:	0072656e 	rsbseq	r6, r2, lr, ror #10
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     658:	625f6d6c 	subsvs	r6, pc, #108, 26	; 0x1b00
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
     65c:	6b616572 	blvs	1859c2c <unflatten_and_copy_device_tree+0x1858db8>
     660:	65766f00 	ldrbvs	r6, [r6, #-3840]!	; 0xfffff100
     664:	6f6c6672 	svcvs	0x006c6672
     668:	64696777 	strbtvs	r6, [r9], #-1911	; 0xfffff889
		pr_warning("End of tree marker overwritten: %08x\n",
			   be32_to_cpup(mem + size));

	pr_debug(" <- unflatten_device_tree()\n");
}
     66c:	6e616e00 	cdpvs	14, 6, cr6, cr1, cr0, {0}
     670:	656c736f 	strbvs	r7, [ip, #-879]!	; 0xfffffc91

	pr_debug("  size is %lx, allocating...\n", size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);
     674:	4e007065 	cdpmi	0, 0, cr7, cr0, cr5, {3}
     678:	49465f52 	stmdbmi	r6, {r1, r4, r6, r8, r9, sl, fp, ip, lr}^

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     67c:	445f454c 	ldrbmi	r4, [pc], #-1356	; 684 <.debug_str+0x684>
     680:	59545249 	ldmdbpl	r4, {r0, r3, r6, r9, ip, lr}^

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     684:	5f6c6400 	svcpl	0x006c6400

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     688:	76007762 	strvc	r7, [r0], -r2, ror #14

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
     68c:	6f6d7366 	svcvs	0x006d7366
     690:	00746e75 	rsbseq	r6, r4, r5, ror lr

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     694:	636f6c62 	cmnvs	pc, #25088	; 0x6200
	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug("  unflattening %p...\n", mem);

	/* Second pass, do actual unflattening */
	start = 0;
     698:	65645f6b 	strbvs	r5, [r4, #-3947]!	; 0xfffff095
	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
     69c:	65636976 	strbvs	r6, [r3, #-2422]!	; 0xfffff68a
     6a0:	72616800 	rsbvc	r6, r1, #0, 16
     6a4:	71726964 	cmnvc	r2, r4, ror #18
     6a8:	7369645f 	cmnvc	r9, #1593835520	; 0x5f000000
static inline __u32 __swab32p(const __u32 *p)
{
#ifdef __arch_swab32p
	return __arch_swab32p(p);
#else
	return __swab32(*p);
     6ac:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
     6b0:	6576655f 	ldrbvs	r6, [r6, #-1375]!	; 0xfffffaa1
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning("End of tree marker overwritten: %08x\n",
     6b4:	7300746e 	movwvc	r7, #1134	; 0x46e
     6b8:	736b6565 	cmnvc	fp, #423624704	; 0x19400000
     6bc:	625f6900 	subsvs	r6, pc, #0, 18
     6c0:	73657479 	cmnvc	r5, #2030043136	; 0x79000000
	pr_debug("magic: %08x\n", fdt_magic(blob));
	pr_debug("size: %08x\n", fdt_totalsize(blob));
	pr_debug("version: %08x\n", fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err("Invalid device tree blob header\n");
     6c4:	4d4f4300 	stclmi	3, cr4, [pc, #-0]	; 6cc <.debug_str+0x6cc>
     6c8:	54434150 	strbpl	r4, [r3], #-336	; 0xfffffeb0
     6cc:	4c494146 	stfmie	f4, [r9], {70}	; 0x46
		return;
     6d0:	776f6900 	strbvc	r6, [pc, -r0, lsl #18]!
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6d4:	5f746961 	svcpl	0x00746961
     6d8:	006d7573 	rsbeq	r7, sp, r3, ror r5
     6dc:	63746177 	cmnvs	r4, #-1073741795	; 0xc000001d
     6e0:	676f6468 	strbvs	r6, [pc, -r8, ror #8]!
     6e4:	6174735f 	cmnvs	r4, pc, asr r3
	mutex_lock(&of_fdt_unflatten_mutex);
     6e8:	7600706d 	strvc	r7, [r0], -sp, rrx
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void of_fdt_unflatten_tree(const unsigned long *blob,
			struct device_node **mynodes)
{
     6ec:	61665f6d 	cmnvs	r6, sp, ror #30
     6f0:	00746c75 	rsbseq	r6, r4, r5, ror ip
	mutex_lock(&of_fdt_unflatten_mutex);
     6f4:	66726570 			; <UNDEFINED> instruction: 0x66726570
     6f8:	6576655f 	ldrbvs	r6, [r6, #-1375]!	; 0xfffffaa1
	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
     6fc:	6d5f746e 	cfldrdvs	mvd7, [pc, #-440]	; 54c <.debug_str+0x54c>
     700:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
     704:	75726c00 	ldrbvc	r6, [r2, #-3072]!	; 0xfffff400
     708:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
     70c:	4c420074 	mcrrmi	0, 7, r0, r2, cr4
	mutex_unlock(&of_fdt_unflatten_mutex);
     710:	5f4b434f 	svcpl	0x004b434f
     714:	54464f53 	strbpl	r4, [r6], #-3923	; 0xfffff0ad
     718:	00515249 	subseq	r5, r1, r9, asr #4
     71c:	6c6c6563 	cfstr64vs	mvdx6, [ip], #-396	; 0xfffffe74
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     720:	7a69735f 	bvc	1a5d4a4 <unflatten_and_copy_device_tree+0x1a5c630>
     724:	6f6c0065 	svcvs	0x006c0065
     728:	775f6461 	ldrbvc	r6, [pc, -r1, ror #8]
     72c:	68676965 	stmdavs	r7!, {r0, r2, r5, r6, r8, fp, sp, lr}^
     730:	65740074 	ldrbvs	r0, [r4, #-116]!	; 0xffffff8c
     734:	6f696d72 	svcvs	0x00696d72
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     738:	77725f73 			; <UNDEFINED> instruction: 0x77725f73
     73c:	006d6573 	rsbeq	r6, sp, r3, ror r5
 * Adjust the flattened device tree to have at most 'limit' number of
 * memory entries in the /memory node. This function may be called
 * any time after initial_boot_param is set.
 */
void of_fdt_limit_memory(int limit)
{
     740:	706f7473 	rsbvc	r7, pc, r3, ror r4	; <UNPREDICTABLE>
	const uint32_t *addr_prop;
	const uint32_t *size_prop;
	int root_offset;
	int cell_size;

	root_offset = fdt_path_offset(initial_boot_params, "/");
     744:	72657000 	rsbvc	r7, r5, #0
     748:	7570635f 	ldrbvc	r6, [r0, #-863]!	; 0xfffffca1
     74c:	6761705f 			; <UNDEFINED> instruction: 0x6761705f
     750:	74657365 	strbtvc	r7, [r5], #-869	; 0xfffffc9b
	if (root_offset < 0)
     754:	65736b00 	ldrbvs	r6, [r3, #-2816]!	; 0xfffff500
     758:	65755f74 	ldrbvs	r5, [r5, #-3956]!	; 0xfffff08c
		return;

	addr_prop = fdt_getprop(initial_boot_params, root_offset,
     75c:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
     760:	73706f5f 	cmnvc	r0, #380	; 0x17c
     764:	72687400 	rsbvc	r7, r8, #0, 8
     768:	5f646165 	svcpl	0x00646165
     76c:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
     770:	73007463 	movwvc	r7, #1123	; 0x463
				"#address-cells", NULL);
	if (addr_prop)
     774:	64656863 	strbtvs	r6, [r5], #-2147	; 0xfffff79d
     778:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     77c:	6f5f7465 	svcvs	0x005f7465
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     780:	6f665f6e 	svcvs	0x00665f6e
     784:	64006b72 	strvs	r6, [r0], #-2930	; 0xfffff48e
     788:	7165735f 	cmnvc	r5, pc, asr r3
     78c:	6c707300 	ldclvs	3, cr7, [r0], #-0
     790:	5f656369 	svcpl	0x00656369
     794:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
     798:	68630065 	stmdavs	r3!, {r0, r2, r5, r6}^
				"#size-cells", NULL);
	if (size_prop)
     79c:	5f646c69 	svcpl	0x00646c69
     7a0:	745f736e 	ldrbvc	r7, [pc], #-878	; 7a8 <.debug_str+0x7a8>
     7a4:	00657079 	rsbeq	r7, r5, r9, ror r0
     7a8:	494d4750 	stmdbmi	sp, {r4, r6, r8, r9, sl, lr}^
		nr_size_cells = fdt32_to_cpu(*size_prop);
     7ac:	54415247 	strbpl	r5, [r1], #-583	; 0xfffffdb9
     7b0:	41465f45 	cmpmi	r6, r5, asr #30
     7b4:	6c004c49 	stcvs	12, cr4, [r0], {73}	; 0x49
     7b8:	00657669 	rsbeq	r7, r5, r9, ror #12

	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);

	memory = fdt_path_offset(initial_boot_params, "/memory");
     7bc:	7070616d 	rsbsvc	r6, r0, sp, ror #2
     7c0:	00676e69 	rsbeq	r6, r7, r9, ror #28
     7c4:	725f6272 	subsvc	r6, pc, #536870919	; 0x20000007
     7c8:	00746f6f 	rsbseq	r6, r4, pc, ror #30
	if (memory > 0) {
     7cc:	7a697371 	bvc	1a5d598 <unflatten_and_copy_device_tree+0x1a5c724>
     7d0:	00745f65 	rsbseq	r5, r4, r5, ror #30
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
     7d4:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
     7d8:	6b73616d 	blvs	1cd8d94 <unflatten_and_copy_device_tree+0x1cd7f20>
     7dc:	6700745f 	smlsdvs	r0, pc, r4, r7	; <UNPREDICTABLE>
     7e0:	70756f72 	rsbsvc	r6, r5, r2, ror pc
     7e4:	666e695f 			; <UNDEFINED> instruction: 0x666e695f
     7e8:	6462006f 	strbtvs	r0, [r2], #-111	; 0xffffff91
		if (len > limit*cell_size) {
     7ec:	7261705f 	rsbvc	r7, r1, #95	; 0x5f
     7f0:	69680074 	stmdbvs	r8!, {r2, r4, r5, r6}^
     7f4:	72006867 	andvc	r6, r0, #6750208	; 0x670000
     7f8:	5f646165 	svcpl	0x00646165
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
					len);
		}
	}
}
     7fc:	00343675 	eorseq	r3, r4, r5, ror r6
     800:	725f6173 	subsvc	r6, pc, #-1073741796	; 0xc000001c
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
     804:	6f747365 	svcvs	0x00747365
     808:	00726572 	rsbseq	r6, r2, r2, ror r5
     80c:	5f706163 	svcpl	0x00706163
     810:	65666665 	strbvs	r6, [r6, #-1637]!	; 0xfffff99b
     814:	76697463 	strbtvc	r7, [r9], -r3, ror #8
     818:	69750065 	ldmdbvs	r5!, {r0, r2, r5, r6}^
     81c:	3233746e 	eorscc	r7, r3, #1845493760	; 0x6e000000

	memory = fdt_path_offset(initial_boot_params, "/memory");
	if (memory > 0) {
		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
		if (len > limit*cell_size) {
			len = limit*cell_size;
     820:	6400745f 	strvs	r7, [r0], #-1119	; 0xfffffba1
			pr_debug("Limiting number of entries to %d\n", limit);
			fdt_setprop(initial_boot_params, memory, "reg", val,
     824:	64695f71 	strbtvs	r5, [r9], #-3953	; 0xfffff08f
					len);
		}
	}
}
     828:	63657200 	cmnvs	r5, #0, 4
     82c:	6d69616c 	stfvse	f6, [r9, #-432]!	; 0xfffffe50
	addr_prop = fdt_getprop(initial_boot_params, root_offset,
				"#address-cells", NULL);
	if (addr_prop)
		nr_address_cells = fdt32_to_cpu(*addr_prop);

	size_prop = fdt_getprop(initial_boot_params, root_offset,
     830:	6174735f 	cmnvs	r4, pc, asr r3
     834:	4f430074 	svcmi	0x00430074
     838:	4341504d 	movtmi	r5, #4173	; 0x104d
     83c:	4f534954 	svcmi	0x00534954
     840:	4554414c 	ldrbmi	r4, [r4, #-332]	; 0xfffffeb4
				"#size-cells", NULL);
	if (size_prop)
     844:	6f6e0044 	svcvs	0x006e0044
     848:	695f6564 	ldmdbvs	pc, {r2, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
     84c:	5f730064 	svcpl	0x00730064
		nr_size_cells = fdt32_to_cpu(*size_prop);
     850:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
void of_fdt_limit_memory(int limit)
{
	int memory;
	int len;
	const void *val;
	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     854:	69750073 	ldmdbvs	r5!, {r0, r1, r4, r5, r6}^
     858:	73616864 	cmnvc	r1, #100, 16	; 0x640000
 * On match, returns a non-zero value with smaller values returned for more
 * specific compatible values.
 */
int of_fdt_is_compatible(const void *blob,
		      unsigned long node, const char *compat)
{
     85c:	6f6e5f68 	svcvs	0x006e5f68
     860:	6d006564 	cfstr32vs	mvfx6, [r0, #-400]	; 0xfffffe70
     864:	6d5f7861 	ldclvs	8, cr7, [pc, #-388]	; 6e8 <.debug_str+0x6e8>
     868:	726e7061 	rsbvc	r7, lr, #97	; 0x61
     86c:	666f7300 	strbtvs	r7, [pc], -r0, lsl #6
     870:	71726974 	cmnvc	r2, r4, ror r9
     874:	6e6f635f 	mcrvs	3, 3, r6, cr15, cr15, {2}
	const char *cp;
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
     878:	74786574 	ldrbtvc	r6, [r8], #-1396	; 0xfffffa8c
     87c:	695f7300 	ldmdbvs	pc, {r8, r9, ip, sp, lr}^	; <UNPREDICTABLE>
     880:	726f636e 	rsbvc	r6, pc, #-1207959551	; 0xb8000001
     884:	73716465 	cmnvc	r1, #1694498816	; 0x65000000
	if (cp == NULL)
     888:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
     88c:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
		return 0;
	while (cplen > 0) {
     890:	67006e6f 	strvs	r6, [r0, -pc, ror #28]
     894:	70756f72 	rsbsvc	r6, r5, r2, ror pc
     898:	6f74735f 	svcvs	0x0074735f
     89c:	6f635f70 	svcvs	0x00635f70
     8a0:	00746e75 	rsbseq	r6, r4, r5, ror lr
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
     8a4:	74736564 	ldrbtvc	r6, [r3], #-1380	; 0xfffffa9c
     8a8:	5f796f72 	svcpl	0x00796f72
		cp += l;
		cplen -= l;
     8ac:	6f757164 	svcvs	0x00757164
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
     8b0:	705f0074 	subsvc	r0, pc, r4, ror r0	; <UNPREDICTABLE>
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8b4:	5f316461 	svcpl	0x00316461
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
			return score;
		l = strlen(cp) + 1;
		cp += l;
		cplen -= l;
     8b8:	735f7300 	cmpvc	pc, #0, 6
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
     8bc:	6b636174 	blvs	18d8e94 <unflatten_and_copy_device_tree+0x18d8020>
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8c0:	7065645f 	rsbvc	r6, r5, pc, asr r4
     8c4:	72006874 	andvc	r6, r0, #116, 16	; 0x740000
     8c8:	766f6d65 	strbtvc	r6, [pc], -r5, ror #26

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
     8cc:	69730065 	ldmdbvs	r3!, {r0, r2, r5, r6}^
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8d0:	5f6c6176 	svcpl	0x006c6176
			return score;
		l = strlen(cp) + 1;
     8d4:	00746e69 	rsbseq	r6, r4, r9, ror #28
	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
	while (cplen > 0) {
		score++;
		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
     8d8:	645f726e 	ldrbvs	r7, [pc], #-622	; 8e0 <.debug_str+0x8e0>
			return score;
     8dc:	69747269 	ldmdbvs	r4!, {r0, r3, r5, r6, r9, ip, sp, lr}^
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8e0:	705f6465 	subsvc	r6, pc, r5, ror #8
     8e4:	65737561 	ldrbvs	r7, [r3, #-1377]!	; 0xfffffa9f
	int cplen;
	unsigned long l, score = 0;

	cp = fdt_getprop(blob, node, "compatible", &cplen);
	if (cp == NULL)
		return 0;
     8e8:	5f737700 	svcpl	0x00737700
		cp += l;
		cplen -= l;
	}

	return 0;
}
     8ec:	00776f72 	rsbseq	r6, r7, r2, ror pc
     8f0:	63626f6a 	cmnvs	r2, #424	; 0x1a8
 * Returns true if the node has a "big-endian" property, or if the kernel
 * was compiled for BE *and* the node has a "native-endian" property.
 * Returns false otherwise.
 */
bool of_fdt_is_big_endian(const void *blob, unsigned long node)
{
     8f4:	70006c74 	andvc	r6, r0, r4, ror ip
     8f8:	61687375 	smcvs	34613	; 0x8735
     8fc:	5f656c62 	svcpl	0x00656c62
     900:	745f6c64 	ldrbvc	r6, [pc], #-3172	; 908 <.debug_str+0x908>
     904:	736b7361 	cmnvc	fp, #-2080374783	; 0x84000001
	if (fdt_getprop(blob, node, "big-endian", NULL))
     908:	65686300 	strbvs	r6, [r8, #-768]!	; 0xfffffd00
     90c:	6e696b63 	vnmulvs.f64	d22, d9, d19
     910:	69745f67 	ldmdbvs	r4!, {r0, r1, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     914:	0072656d 	rsbseq	r6, r2, sp, ror #10
		return true;
	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
	    fdt_getprop(blob, node, "native-endian", NULL))
		return true;
	return false;
}
     918:	6c61635f 	stclvs	3, cr6, [r1], #-380	; 0xfffffe84
     91c:	64615f6c 	strbtvs	r5, [r1], #-3948	; 0xfffff094
     920:	66007264 	strvs	r7, [r0], -r4, ror #4
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     924:	5f6e776f 	svcpl	0x006e776f
     928:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
     92c:	63007463 	movwvs	r7, #1123	; 0x463
     930:	7278616d 	rsbsvc	r6, r8, #1073741851	; 0x4000001b
     934:	5f007373 	svcpl	0x00007373
	unsigned int tmp, score = 0;

	if (!compat)
     938:	32646170 	rsbcc	r6, r4, #112, 2
/**
 * of_fdt_match - Return true if node matches a list of compatible values
 */
int of_fdt_match(const void *blob, unsigned long node,
                 const char *const *compat)
{
     93c:	6d72005f 	ldclvs	0, cr0, [r2, #-380]!	; 0xfffffe84
     940:	00726964 	rsbseq	r6, r2, r4, ror #18
	unsigned int tmp, score = 0;

	if (!compat)
     944:	736c6166 	cmnvc	ip, #-2147483623	; 0x80000019
		return 0;

	while (*compat) {
     948:	69700065 	ldmdbvs	r0!, {r0, r2, r5, r6}^
     94c:	6174735f 	cmnvs	r4, pc, asr r3
     950:	6c5f6574 	cfldr64vs	mvdx6, [pc], {116}	; 0x74
     954:	00747369 	rsbseq	r7, r4, r9, ror #6
		tmp = of_fdt_is_compatible(blob, node, *compat);
     958:	666f735f 			; <UNDEFINED> instruction: 0x666f735f
     95c:	70786574 	rsbsvc	r6, r8, r4, ror r5
     960:	73657269 	cmnvc	r5, #-1879048186	; 0x90000006
		if (tmp && (score == 0 || (tmp < score)))
     964:	6f747300 	svcvs	0x00747300
     968:	64657070 	strbtvs	r7, [r5], #-112	; 0xffffff90
     96c:	77656e00 	strbvc	r6, [r5, -r0, lsl #28]!
     970:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
     974:	0074616d 	rsbseq	r6, r4, sp, ror #2
     978:	775f6c66 	ldrbvc	r6, [pc, -r6, ror #24]
     97c:	00746961 	rsbseq	r6, r4, r1, ror #18
     980:	535f4d4d 	cmppl	pc, #4928	; 0x1340
     984:	45504157 	ldrbmi	r4, [r0, #-343]	; 0xfffffea9
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     988:	0053544e 	subseq	r5, r3, lr, asr #8
     98c:	6e5f676d 	cdpvs	7, 5, cr6, cr15, cr13, {3}
     990:	0065646f 	rsbeq	r6, r5, pc, ror #8
     994:	656c6572 	strbvs	r6, [ip, #-1394]!	; 0xfffffa8e
     998:	70657361 	rsbvc	r7, r5, r1, ror #6
                 const char *const *compat)
{
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;
     99c:	00656761 	rsbeq	r6, r5, r1, ror #14
			score = tmp;
		compat++;
	}

	return score;
}
     9a0:	655f6966 	ldrbvs	r6, [pc, #-2406]	; 42 <.debug_str+0x42>
	unsigned int tmp, score = 0;

	if (!compat)
		return 0;

	while (*compat) {
     9a4:	6e657478 	mcrvs	4, 3, r7, cr5, cr8, {3}
		if (tmp && (score == 0 || (tmp < score)))
			score = tmp;
		compat++;
	}

	return score;
     9a8:	6d5f7374 	ldclvs	3, cr7, [pc, #-464]	; 7e0 <.debug_str+0x7e0>
	}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
     9ac:	6f007861 	svcvs	0x00007861
     9b0:	6e696c6e 	cdpvs	12, 6, cr6, cr9, cr14, {3}
     9b4:	6e635f65 	cdpvs	15, 6, cr5, cr3, cr5, {3}
     9b8:	5f5f0074 	svcpl	0x005f0074
	if (buf)
     9bc:	5f746466 	svcpl	0x00746466
		return 0;
     9c0:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
	return -ENODEV;
}

static int __init setup_of_earlycon(char *buf)
{
	if (buf)
     9c4:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9c8:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
     9cc:	656d5f64 	strbvs	r5, [sp, #-3940]!	; 0xfffff09c

	offset = fdt_path_offset(fdt, "/chosen");
     9d0:	6177006d 	cmnvs	r7, sp, rrx
     9d4:	6c5f7469 	cfldrdvs	mvd7, [pc], {105}	; 0x69
{
	int offset;
	const char *p;
	int l;
	const struct of_device_id *match = __earlycon_of_table;
	const void *fdt = initial_boot_params;
     9d8:	006b636f 	rsbeq	r6, fp, pc, ror #6

	offset = fdt_path_offset(fdt, "/chosen");
     9dc:	6461705f 	strbtvs	r7, [r1], #-95	; 0xffffffa1
     9e0:	73005f33 	movwvc	r5, #3891	; 0xf33
	if (offset < 0)
     9e4:	6d65725f 	sfmvs	f7, 2, [r5, #-380]!	; 0xfffffe84
     9e8:	5f65766f 	svcpl	0x0065766f
		offset = fdt_path_offset(fdt, "/chosen@0");
     9ec:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
     9f0:	69680074 	stmdbvs	r8!, {r2, r4, r5, r6}^
     9f4:	73656867 	cmnvc	r5, #6750208	; 0x670000
     9f8:	6d765f74 	ldclvs	15, cr5, [r6, #-464]!	; 0xfffffe30
	if (offset < 0)
     9fc:	646e655f 	strbtvs	r6, [lr], #-1375	; 0xfffffaa1
     a00:	61747300 	cmnvs	r4, r0, lsl #6
		return -ENOENT;
     a04:	5f636974 	svcpl	0x00636974
     a08:	6f697270 	svcvs	0x00697270

	p = fdt_getprop(fdt, offset, "stdout-path", &l);
     a0c:	4d4f4300 	stclmi	3, cr4, [pc, #-0]	; a14 <.debug_str+0xa14>
     a10:	54434150 	strbpl	r4, [r3], #-336	; 0xfffffeb0
     a14:	4c415453 	cfstrdmi	mvd5, [r1], {83}	; 0x53
     a18:	6567004c 	strbvs	r0, [r7, #-76]!	; 0xffffffb4
     a1c:	72705f74 	rsbsvc	r5, r0, #116, 30	; 0x1d0
     a20:	64696a6f 	strbtvs	r6, [r9], #-2671	; 0xfffff591
	if (!p)
     a24:	6c696600 	stclvs	6, cr6, [r9], #-0
     a28:	6f6c5f65 	svcvs	0x006c5f65
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
     a2c:	635f6b63 	cmpvs	pc, #101376	; 0x18c00
     a30:	65746e6f 	ldrbvs	r6, [r4, #-3695]!	; 0xfffff191
     a34:	62007478 	andvs	r7, r0, #120, 8	; 0x78000000
     a38:	725f6b72 	subsvc	r6, pc, #116736	; 0x1c800
     a3c:	6f646e61 	svcvs	0x00646e61
     a40:	657a696d 	ldrbvs	r6, [sl, #-2413]!	; 0xfffff693
	if (!p || !l)
     a44:	524e0064 	subpl	r0, lr, #100	; 0x64
     a48:	4741505f 	smlsldmi	r5, r1, pc, r0	; <UNPREDICTABLE>
     a4c:	535f5345 	cmppl	pc, #335544321	; 0x14000001
     a50:	4e4e4143 	dvfmiem	f4, f6, f3
     a54:	6b004445 	blvs	11b70 <unflatten_and_copy_device_tree+0x10cfc>
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a58:	6c6c616d 	stfvse	f6, [ip], #-436	; 0xfffffe4c
     a5c:	7300636f 	movwvc	r6, #879	; 0x36f
     a60:	6974666f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r6, r9, sl, sp, lr}^

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a64:	5f737172 	svcpl	0x00737172
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a68:	62616e65 	rsbvs	r6, r1, #1616	; 0x650

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a6c:	0064656c 	rsbeq	r6, r4, ip, ror #10
		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
	if (!p || !l)
		return -ENOENT;

	/* Remove console options if present */
	l = strchrnul(p, ':') - p;
     a70:	6e5f6272 	mrcvs	2, 2, r6, cr15, cr2, {3}

	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
     a74:	0065646f 	rsbeq	r6, r5, pc, ror #8
	if (offset < 0)
     a78:	74696d78 	strbtvc	r6, [r9], #-3448	; 0xfffff288
     a7c:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
     a80:	72747300 	rsbsvc	r7, r4, #0, 6
     a84:	00706d63 	rsbseq	r6, r0, r3, ror #26
		return -ENODEV;
     a88:	52414d57 	subpl	r4, r1, #5568	; 0x15c0
     a8c:	494d5f4b 	stmdbmi	sp, {r0, r1, r3, r6, r8, r9, sl, fp, ip, lr}^

	while (match->compatible[0]) {
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     a90:	6c6e004e 	stclvs	0, cr0, [lr], #-312	; 0xfffffec8
     a94:	6f6c5f6d 	svcvs	0x006c5f6d
     a98:	776f6b63 	strbvc	r6, [pc, -r3, ror #22]!
			match++;
     a9c:	0072656e 	rsbseq	r6, r2, lr, ror #10
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     aa0:	5f555043 	svcpl	0x00555043
		u64 addr;

		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
     aa4:	5f58414d 	svcpl	0x0058414d
     aa8:	454c4449 	strbmi	r4, [ip, #-1097]	; 0xfffffbb7
     aac:	5059545f 	subspl	r5, r9, pc, asr r4
	/* Get the node specified by stdout-path */
	offset = fdt_path_offset_namelen(fdt, p, l);
	if (offset < 0)
		return -ENODEV;

	while (match->compatible[0]) {
     ab0:	6b005345 	blvs	157cc <unflatten_and_copy_device_tree+0x14958>
     ab4:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xfffff08d
     ab8:	64717269 	ldrbtvs	r7, [r1], #-617	; 0xfffffd97
		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
     abc:	766e6900 	strbtvc	r6, [lr], -r0, lsl #18
     ac0:	6965775f 	stmdbvs	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
     ac4:	00746867 	rsbseq	r6, r4, r7, ror #16
		if (addr == OF_BAD_ADDR)
     ac8:	735f6263 	cmpvc	pc, #805306374	; 0x30000006
     acc:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
     ad0:	6c5f6900 	mrrcvs	9, 0, r6, pc, cr0	; <UNPREDICTABLE>
     ad4:	70007572 	andvc	r7, r0, r2, ror r5
			return -ENXIO;
     ad8:	6d5f6e66 	ldclvs	14, cr6, [pc, #-408]	; 948 <.debug_str+0x948>
			match++;
			continue;
		}

		addr = fdt_translate_address(fdt, offset);
		if (addr == OF_BAD_ADDR)
     adc:	6972776b 	ldmdbvs	r2!, {r0, r1, r3, r5, r6, r8, r9, sl, ip, sp, lr}^
			return -ENXIO;

		of_setup_earlycon(addr, match->data);
     ae0:	62006574 	andvs	r6, r0, #116, 10	; 0x1d000000
     ae4:	696b6361 	stmdbvs	fp!, {r0, r5, r6, r8, r9, sp, lr}^
{
	if (buf)
		return 0;

	return early_init_dt_scan_chosen_serial();
}
     ae8:	645f676e 	ldrbvs	r6, [pc], #-1902	; af0 <.debug_str+0xaf0>
     aec:	695f7665 	ldmdbvs	pc, {r0, r2, r5, r6, r9, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     af0:	006f666e 	rsbeq	r6, pc, lr, ror #12
/*
 * called from unflatten_device_tree() to bootstrap devicetree itself
 * Architectures can override this definition if memblock isn't used
 */
void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
{
     af4:	76657470 			; <UNDEFINED> instruction: 0x76657470
     af8:	745f6c61 	ldrbvc	r6, [pc], #-3169	; b00 <.debug_str+0xb00>
     afc:	646e6500 	strbtvs	r6, [lr], #-1280	; 0xfffffb00
	return __va(memblock_alloc(size, align));
     b00:	7461645f 	strbtvc	r6, [r1], #-1119	; 0xfffffba1
     b04:	61700061 	cmnvs	r0, r1, rrx
}
     b08:	5f63696e 	svcpl	0x0063696e
	memcpy(buf, initial_boot_params + off, count);
	return count;
}

static int __init of_fdt_raw_init(void)
{
     b0c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
     b10:	0074756f 	rsbseq	r7, r4, pc, ror #10
     b14:	45524750 	ldrbmi	r4, [r2, #-1872]	; 0xfffff8b0
	static struct bin_attribute of_fdt_raw_attr =
		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);

	if (!initial_boot_params)
     b18:	4c4c4946 	mcrrmi	9, 4, r4, ip, cr6
     b1c:	4749485f 	smlsldmi	r4, r9, pc, r8	; <UNPREDICTABLE>
     b20:	65750048 	ldrbvs	r0, [r5, #-72]!	; 0xffffffb8
     b24:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
     b28:	7075735f 	rsbsvc	r7, r5, pc, asr r3
     b2c:	73657270 	cmnvc	r5, #112, 4
		return 0;

	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
     b30:	63610073 	cmnvs	r1, #115	; 0x73
     b34:	00726f74 	rsbseq	r6, r2, r4, ror pc
     b38:	63766e63 	cmnvs	r6, #1584	; 0x630
     b3c:	70007773 	andvc	r7, r0, r3, ror r7
     b40:	70637265 	rsbvc	r7, r3, r5, ror #4
     b44:	65725f75 	ldrbvs	r5, [r2, #-3957]!	; 0xfffff08b
     b48:	726c0066 	rsbvc	r0, ip, #102	; 0x66
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
     b4c:	63657675 	cmnvs	r5, #122683392	; 0x7500000
     b50:	73616c00 	cmnvc	r1, #0, 24
     b54:	75715f74 	ldrbvc	r5, [r1, #-3956]!	; 0xfffff08c
		return 0;
     b58:	64657565 	strbtvs	r7, [r5], #-1381	; 0xfffffa9b
     b5c:	73696400 	cmnvc	r9, #0, 8
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b60:	61645f63 	cmnvs	r4, r3, ror #30
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b64:	70006174 	andvc	r6, r0, r4, ror r1
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b68:	745f6469 	ldrbvc	r6, [pc], #-1129	; b70 <.debug_str+0xb70>
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b6c:	00657079 	rsbeq	r7, r5, r9, ror r0
     b70:	73695f63 	cmnvc	r9, #396	; 0x18c
     b74:	64656570 	strbtvs	r6, [r5], #-1392	; 0xfffffa90
	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
				     fdt_totalsize(initial_boot_params))) {
		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
		return 0;
	}
	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
     b78:	696c7000 	stmdbvs	ip!, {ip, sp, lr}^
	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
     b7c:	6e5f7473 	mrcvs	4, 2, r7, cr15, cr3, {3}
     b80:	0065646f 	rsbeq	r6, r5, pc, ror #8
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     b84:	6c6f6f62 	stclvs	15, cr6, [pc], #-392	; a04 <.debug_str+0xa04>
     b88:	64615f00 	strbtvs	r5, [r1], #-3840	; 0xfffff100
     b8c:	69007264 	stmdbvs	r0, {r2, r5, r6, r9, ip, sp, lr}
     b90:	6f6d5f61 	svcvs	0x006d5f61
	const void *blob = initial_boot_params;
     b94:	69006564 	stmdbvs	r0, {r2, r5, r6, r8, sl, sp, lr}
     b98:	745f6f6e 	ldrbvc	r6, [pc], #-3950	; ba0 <.debug_str+0xba0>
	const char *pathp;
	int offset, rc = 0, depth = -1;
     b9c:	6c656d69 	stclvs	13, cr6, [r5], #-420	; 0xfffffe5c
     ba0:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     ba4:	6d656d00 	stclvs	13, cr6, [r5, #-0]
	const void *blob = initial_boot_params;
     ba8:	6f5f6763 	svcvs	0x005f6763
 */
int __init of_scan_flat_dt(int (*it)(unsigned long node,
				     const char *uname, int depth,
				     void *data),
			   void *data)
{
     bac:	6f5f6d6f 	svcvs	0x005f6d6f
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bb0:	72656472 	rsbvc	r6, r5, #1912602624	; 0x72000000

        for (offset = fdt_next_node(blob, -1, &depth);
     bb4:	5f6c6400 	svcpl	0x006c6400
     bb8:	6f726874 	svcvs	0x00726874
				     void *data),
			   void *data)
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;
     bbc:	656c7474 	strbvs	r7, [ip, #-1140]!	; 0xfffffb8c

        for (offset = fdt_next_node(blob, -1, &depth);
     bc0:	65640064 	strbvs	r0, [r4, #-100]!	; 0xffffff9c
     bc4:	7972746e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
     bc8:	65706f5f 	ldrbvs	r6, [r0, #-3935]!	; 0xfffff0a1
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bcc:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bd0:	00736e6f 	rsbseq	r6, r3, pc, ror #28
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bd4:	685f7164 	ldmdavs	pc, {r2, r5, r6, r8, ip, sp, lr}^	; <UNPREDICTABLE>
     bd8:	00687361 	rsbeq	r7, r8, r1, ror #6
{
	const void *blob = initial_boot_params;
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
     bdc:	746f7571 	strbtvc	r7, [pc], #-1393	; be4 <.debug_str+0xbe4>
             offset >= 0 && depth >= 0 && !rc;
     be0:	6e6f5f61 	cdpvs	15, 6, cr5, cr15, cr1, {3}
     be4:	74735f00 	ldrbtvc	r5, [r3], #-3840	; 0xfffff100
     be8:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
     bec:	75706300 	ldrbvc	r6, [r0, #-768]!	; 0xfffffd00
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf0:	6974695f 	ldmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
		if (*pathp == '/')
     bf4:	0072656d 	rsbseq	r6, r2, sp, ror #10

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {

		pathp = fdt_get_name(blob, offset, NULL);
     bf8:	7a6f7266 	bvc	1bdd598 <unflatten_and_copy_device_tree+0x1bdc724>
		if (*pathp == '/')
     bfc:	73006e65 	movwvc	r6, #3685	; 0xe65
     c00:	74637379 	strbtvc	r7, [r3], #-889	; 0xfffffc87
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
	const char *tail = strrchr(path, '/');
     c04:	66765f6c 	ldrbtvs	r5, [r6], -ip, ror #30
	return tail ? tail + 1 : path;
     c08:	61635f73 	smcvs	13811	; 0x35f3
     c0c:	5f656863 	svcpl	0x00656863
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c10:	73657270 	cmnvc	r5, #112, 4
     c14:	65727573 	ldrbvs	r7, [r2, #-1395]!	; 0xfffffa8d
     c18:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
     c1c:	695f6465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
     c20:	006f666e 	rsbeq	r6, pc, lr, ror #12
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c24:	636f696b 	cmnvs	pc, #1753088	; 0x1ac000
     c28:	6f6d0062 	svcvs	0x006d0062

		pathp = fdt_get_name(blob, offset, NULL);
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
     c2c:	00746e75 	rsbseq	r6, r4, r5, ror lr
	const char *pathp;
	int offset, rc = 0, depth = -1;

        for (offset = fdt_next_node(blob, -1, &depth);
             offset >= 0 && depth >= 0 && !rc;
             offset = fdt_next_node(blob, offset, &depth)) {
     c30:	4e4f5f4e 	cdpmi	15, 4, cr5, cr15, cr14, {2}
     c34:	454e494c 	strbmi	r4, [lr, #-2380]	; 0xfffff6b4
     c38:	4f4c4200 	svcmi	0x004c4200
     c3c:	495f4b43 	ldmdbmi	pc, {r0, r1, r6, r8, r9, fp, lr}^	; <UNPREDICTABLE>
		if (*pathp == '/')
			pathp = kbasename(pathp);
		rc = it(offset, pathp, depth, data);
	}
	return rc;
}
     c40:	4c4f504f 	mcrrmi	0, 4, r5, pc, cr15
     c44:	4f535f4c 	svcmi	0x00535f4c
     c48:	52495446 	subpl	r5, r9, #1174405120	; 0x46000000

/**
 * of_get_flat_dt_root - find the root node in the flat blob
 */
unsigned long __init of_get_flat_dt_root(void)
{
     c4c:	71640051 	qdsubvc	r0, r1, r4
     c50:	75635f62 	strbvc	r5, [r3, #-3938]!	; 0xfffff09e
     c54:	6f6e6972 	svcvs	0x006e6972
	return 0;
}
     c58:	00736564 	rsbseq	r6, r3, r4, ror #10
     c5c:	6e5f6671 	mrcvs	6, 2, r6, cr15, cr1, {3}

/**
 * of_get_flat_dt_size - Return the total size of the FDT
 */
int __init of_get_flat_dt_size(void)
{
     c60:	00747865 	rsbseq	r7, r4, r5, ror #16
     c64:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
     c68:	73007075 	movwvc	r7, #117	; 0x75
	return fdt_totalsize(initial_boot_params);
     c6c:	00657a69 	rsbeq	r7, r5, r9, ror #20
     c70:	69735f69 	ldmdbvs	r3!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
     c74:	735f657a 	cmpvc	pc, #511705088	; 0x1e800000
     c78:	6f637165 	svcvs	0x00637165
}
     c7c:	00746e75 	rsbseq	r6, r4, r5, ror lr
     c80:	646e6570 	strbtvs	r6, [lr], #-1392	; 0xfffffa90
 * This function can be used within scan_flattened_dt callback to get
 * access to properties
 */
const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
				       int *size)
{
     c84:	00676e69 	rsbeq	r6, r7, r9, ror #28
     c88:	5f74696a 	svcpl	0x0074696a
     c8c:	7279656b 	rsbsvc	r6, r9, #448790528	; 0x1ac00000
	return fdt_getprop(initial_boot_params, node, name, size);
     c90:	00676e69 	rsbeq	r6, r7, r9, ror #28
     c94:	745f6363 	ldrbvc	r6, [pc], #-867	; c9c <.debug_str+0xc9c>
     c98:	73656400 	cmnvc	r5, #0, 8
     c9c:	656c5f63 	strbvs	r5, [ip, #-3939]!	; 0xfffff09d
     ca0:	6863006e 	stmdavs	r3!, {r1, r2, r3, r5, r6}^
     ca4:	5f6b6365 	svcpl	0x006b6365
     ca8:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
}
     cac:	6e690073 	mcrvs	0, 3, r0, cr9, cr3, {3}
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cb0:	776f695f 			; <UNDEFINED> instruction: 0x776f695f
     cb4:	00746961 	rsbseq	r6, r4, r1, ror #18
     cb8:	73726966 	cmnvc	r2, #1671168	; 0x198000
	const __be32 *prop;

	if (depth != 0)
     cbc:	72700074 	rsbsvc	r0, r0, #116	; 0x74
/**
 * early_init_dt_scan_root - fetch the top level address and size cells
 */
int __init early_init_dt_scan_root(unsigned long node, const char *uname,
				   int depth, void *data)
{
     cc0:	78696665 	stmdavc	r9!, {r0, r2, r5, r6, r9, sl, sp, lr}^
	const __be32 *prop;

	if (depth != 0)
     cc4:	69746d00 	ldmdbvs	r4!, {r8, sl, fp, sp, lr}^
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cc8:	7300656d 	movwvc	r6, #1389	; 0x56d
     ccc:	70637274 	rsbvc	r7, r3, r4, ror r2
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     cd0:	6f630079 	svcvs	0x00630079
     cd4:	6361706d 	cmnvs	r1, #109	; 0x6d
	const __be32 *prop;

	if (depth != 0)
		return 0;

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
     cd8:	6c625f74 	stclvs	15, cr5, [r2], #-464	; 0xfffffe30
     cdc:	736b636f 	cmnvc	fp, #-1140850687	; 0xbc000001
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
     ce0:	5f70696b 	svcpl	0x0070696b

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
     ce4:	73756c66 	cmnvc	r5, #26112	; 0x6600
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     ce8:	65670068 	strbvs	r0, [r7, #-104]!	; 0xffffff98
     cec:	65725f74 	ldrbvs	r5, [r2, #-3956]!	; 0xfffff08c
     cf0:	76726573 			; <UNDEFINED> instruction: 0x76726573

	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
     cf4:	735f6465 	cmpvc	pc, #1694498816	; 0x65000000
     cf8:	65636170 	strbvs	r6, [r3, #-368]!	; 0xfffffe90
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     cfc:	74636100 	strbtvc	r6, [r3], #-256	; 0xffffff00
     d00:	5f657669 	svcpl	0x00657669
	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
     d04:	7a006d6d 	bvc	1c2c0 <unflatten_and_copy_device_tree+0x1b44c>
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
     d08:	5f656e6f 	svcpl	0x00656e6f
	if (prop)
     d0c:	6c636572 	cfstr64vs	mvdx6, [r3], #-456	; 0xfffffe38
     d10:	5f6d6961 	svcpl	0x006d6961
     d14:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
		dt_root_addr_cells = be32_to_cpup(prop);
     d18:	5f646900 	svcpl	0x00646900
     d1c:	65657266 	strbvs	r7, [r5, #-614]!	; 0xfffffd9a
     d20:	746e635f 	strbtvc	r6, [lr], #-863	; 0xfffffca1
     d24:	775f7300 	ldrbvc	r7, [pc, -r0, lsl #6]
				   int depth, void *data)
{
	const __be32 *prop;

	if (depth != 0)
		return 0;
     d28:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
     d2c:	6b5f7372 	blvs	17ddafc <unflatten_and_copy_device_tree+0x17dcc88>
	if (prop)
		dt_root_size_cells = be32_to_cpup(prop);
	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (prop)
     d30:	73007965 	movwvc	r7, #2405	; 0x965
		dt_root_addr_cells = be32_to_cpup(prop);
	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);

	/* break now */
	return 1;
}
     d34:	6e5f7165 	rdfvsez	f7, f7, f5
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d38:	00747865 	rsbseq	r7, r4, r5, ror #16
     d3c:	6f6e7766 	svcvs	0x006e7766
     d40:	74006564 	strvc	r6, [r0], #-1380	; 0xfffffa9c
     d44:	5f656d69 	svcpl	0x00656d69
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d48:	63696c73 	cmnvs	r9, #29440	; 0x7300
	return 0;
}

int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
				     int depth, void *data)
{
     d4c:	61690065 	cmnvs	r9, r5, rrx
     d50:	6974635f 	ldmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d54:	6f00656d 	svcvs	0x0000656d
     d58:	65735f66 	ldrbvs	r5, [r3, #-3942]!	; 0xfffff09a
     d5c:	5f707574 	svcpl	0x00707574
     d60:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
     d64:	6e6f6379 	mcrvs	3, 3, r6, cr15, cr9, {3}
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
		return 0;
     d68:	665f6900 	ldrbvs	r6, [pc], -r0, lsl #18
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d6c:	7874636c 	ldmdavc	r4!, {r2, r3, r5, r6, r8, r9, sp, lr}^
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d70:	626f6b00 	rsbvs	r6, pc, #0, 22
     d74:	7463656a 	strbtvc	r6, [r3], #-1386	; 0xfffffa96
     d78:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
     d7c:	6f6c0074 	svcvs	0x006c0074
	int l;
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
     d80:	615f6461 	cmpvs	pc, r1, ror #8
     d84:	72006776 	andvc	r6, r0, #30932992	; 0x1d80000
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     d88:	696e6e75 	stmdbvs	lr!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     d8c:	6200676e 	andvs	r6, r0, #28835840	; 0x1b80000
     d90:	5f746f6f 	svcpl	0x00746f6f
     d94:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
     d98:	5f646e61 	svcpl	0x00646e61
		return 0;
     d9c:	656e696c 	strbvs	r6, [lr, #-2412]!	; 0xfffff694
	const char *p;

	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);

	if (depth != 1 || !data ||
	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
     da0:	736f7000 	cmnvc	pc, #0
	int len;
	const __be32 *prop;

	pr_debug("Looking for initrd properties... ");

	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
     da4:	745f7869 	ldrbvc	r7, [pc], #-2153	; dac <.debug_str+0xdac>
     da8:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
     dac:	0064695f 	rsbeq	r6, r4, pc, asr r9
     db0:	6b736174 	blvs	1cd9388 <unflatten_and_copy_device_tree+0x1cd8514>
     db4:	7a69735f 	bvc	1a5db38 <unflatten_and_copy_device_tree+0x1a5ccc4>
	if (!prop)
     db8:	70630065 	rsbvc	r0, r3, r5, rrx
     dbc:	64695f75 	strbtvs	r5, [r9], #-3957	; 0xfffff08b
		return;
	start = of_read_number(prop, len/4);
     dc0:	745f656c 	ldrbvc	r6, [pc], #-1388	; dc8 <.debug_str+0xdc8>
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     dc4:	00657079 	rsbeq	r7, r5, r9, ror r0
     dc8:	656a626f 	strbvs	r6, [sl, #-623]!	; 0xfffffd91
     dcc:	00737463 	rsbseq	r7, r3, r3, ror #8
     dd0:	625f726e 	subsvs	r7, pc, #-536870906	; 0xe0000006
     dd4:	00797375 	rsbseq	r7, r9, r5, ror r3
	while (size--)
     dd8:	63617274 	cmnvs	r1, #116, 4	; 0x40000007
		r = (r << 32) | be32_to_cpu(*(cell++));
     ddc:	5f676e69 	svcpl	0x00676e69

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     de0:	70617267 	rsbvc	r7, r1, r7, ror #4
     de4:	61705f68 	cmnvs	r0, r8, ror #30
     de8:	00657375 	rsbeq	r7, r5, r5, ror r3
		r = (r << 32) | be32_to_cpu(*(cell++));
     dec:	73635f65 	cmnvc	r3, #404	; 0x194
     df0:	00737465 	rsbseq	r7, r3, r5, ror #8

	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
     df4:	636f6c62 	cmnvs	pc, #25088	; 0x6200
     df8:	616d5f6b 	cmnvs	sp, fp, ror #30
     dfc:	69730078 	ldmdbvs	r3!, {r3, r4, r5, r6}^
     e00:	745f657a 	ldrbvc	r6, [pc], #-1402	; e08 <.debug_str+0xe08>
     e04:	6f746100 	svcvs	0x00746100
	if (!prop)
     e08:	5f63696d 	svcpl	0x0063696d
     e0c:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
		return;
	end = of_read_number(prop, len/4);
     e10:	73690073 	cmnvc	r9, #115	; 0x73
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
     e14:	7269645f 	rsbvc	r6, r9, #1593835520	; 0x5f000000
     e18:	775f7974 			; <UNDEFINED> instruction: 0x775f7974
     e1c:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
     e20:	6b636162 	blvs	18d93b0 <unflatten_and_copy_device_tree+0x18d853c>
     e24:	65726b00 	ldrbvs	r6, [r2, #-2816]!	; 0xfffff500
	while (size--)
     e28:	63730066 	cmnvs	r3, #102	; 0x66
		r = (r << 32) | be32_to_cpu(*(cell++));
     e2c:	5f646568 	svcpl	0x00646568

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e30:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
		r = (r << 32) | be32_to_cpu(*(cell++));
     e34:	69747369 	ldmdbvs	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
     e38:	70007363 	andvc	r7, r0, r3, ror #6

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
     e3c:	5f656761 	svcpl	0x00656761
     e40:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
		r = (r << 32) | be32_to_cpu(*(cell++));
     e44:	5f6c6600 	svcpl	0x006c6600
     e48:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
     e4c:	70786500 	rsbsvc	r6, r8, r0, lsl #10
     e50:	5f74726f 	svcpl	0x0074726f
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e54:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
	initrd_end = (unsigned long)__va(end);
     e58:	6f697461 	svcvs	0x00697461
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e5c:	6300736e 	movwvs	r7, #878	; 0x36e
	initrd_end = (unsigned long)__va(end);
     e60:	65737570 	ldrbvs	r7, [r3, #-1392]!	; 0xfffffa90
	initrd_below_start_ok = 1;
     e64:	6c735f74 	ldclvs	15, cr5, [r3], #-464	; 0xfffffe30
     e68:	735f6261 	cmpvc	pc, #268435462	; 0x10000006
     e6c:	61657270 	smcvs	22304	; 0x5720
     e70:	6f725f64 	svcvs	0x00725f64
#ifdef CONFIG_BLK_DEV_INITRD
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
     e74:	00726f74 	rsbseq	r6, r2, r4, ror pc
	initrd_end = (unsigned long)__va(end);
	initrd_below_start_ok = 1;
     e78:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
#ifndef __early_init_dt_declare_initrd
static void __early_init_dt_declare_initrd(unsigned long start,
					   unsigned long end)
{
	initrd_start = (unsigned long)__va(start);
	initrd_end = (unsigned long)__va(end);
     e7c:	6c007366 	stcvs	3, cr7, [r0], {102}	; 0x66
	initrd_below_start_ok = 1;
     e80:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
		return 0;

	early_init_dt_check_for_initrd(node);

	/* Retrieve command line */
	p = of_get_flat_dt_prop(node, "bootargs", &l);
     e84:	6165685f 	cmnvs	r5, pc, asr r8
     e88:	72700064 	rsbsvc	r0, r0, #100	; 0x64
     e8c:	5f73636f 	svcpl	0x0073636f
     e90:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
     e94:	6d656d00 	stclvs	13, cr6, [r5, #-0]
	if (p != NULL && l > 0)
     e98:	7267635f 	rsbvc	r6, r7, #2080374785	; 0x7c000001
     e9c:	0070756f 	rsbseq	r7, r0, pc, ror #10
     ea0:	61726170 	cmnvs	r2, r0, ror r1
     ea4:	6900736d 	stmdbvs	r0, {r0, r2, r3, r5, r6, r8, r9, ip, sp, lr}
     ea8:	5f74696e 	svcpl	0x0074696e
		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
     eac:	5f646970 	svcpl	0x00646970
     eb0:	6600736e 	strvs	r7, [r0], -lr, ror #6
     eb4:	72625f6c 	rsbvc	r5, r2, #108, 30	; 0x1b0
     eb8:	5f6b6165 	svcpl	0x006b6165
	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE
	 * is set in which case we override whatever was found earlier.
	 */
#ifdef CONFIG_CMDLINE
#ifndef CONFIG_CMDLINE_FORCE
	if (!((char *)data)[0])
     ebc:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
     ec0:	5f676d00 	svcpl	0x00676d00
     ec4:	6b736174 	blvs	1cd949c <unflatten_and_copy_device_tree+0x1cd8628>
#endif
		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
     ec8:	5f730073 	svcpl	0x00730073
     ecc:	00766564 	rsbseq	r6, r6, r4, ror #10
     ed0:	43534750 	cmpmi	r3, #80, 14	; 0x1400000
     ed4:	445f4e41 	ldrbmi	r4, [pc], #-3649	; edc <.debug_str+0xedc>
     ed8:	43455249 	movtmi	r5, #21065	; 0x5249
     edc:	48545f54 	ldmdami	r4, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^

	pr_debug("Command line is: %s\n", (char*)data);

	/* break now */
	return 1;
}
     ee0:	54544f52 	ldrbpl	r4, [r4], #-3922	; 0xfffff0ae
     ee4:	6d00454c 	cfstr32vs	mvfx4, [r0, #-304]	; 0xfffffed0
 * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
 * @node: node to test
 * @compat: compatible string to compare with compatible list.
 */
int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
{
     ee8:	6f635f6d 	svcvs	0x00635f6d
     eec:	00746e75 	rsbseq	r6, r4, r5, ror lr
     ef0:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
	return of_fdt_is_compatible(initial_boot_params, node, compat);
     ef4:	735f7366 	cmpvc	pc, #-1744830463	; 0x98000001
     ef8:	61637379 	smcvs	14137	; 0x3739
     efc:	6f5f6c6c 	svcvs	0x005f6c6c
     f00:	4e007370 	mcrmi	3, 0, r7, cr0, cr0, {3}
     f04:	4d454d5f 	stclmi	13, cr4, [r5, #-380]	; 0xfffffe84
     f08:	0059524f 	subseq	r5, r9, pc, asr #4
}
     f0c:	61776968 	cmnvs	r7, r8, ror #18

/**
 * of_flat_dt_match - Return true if node matches a list of compatible values
 */
int __init of_flat_dt_match(unsigned long node, const char *const *compat)
{
     f10:	5f726574 	svcpl	0x00726574
     f14:	50006d76 	andpl	r6, r0, r6, ror sp
     f18:	41435347 	cmpmi	r3, r7, asr #6
	return of_fdt_match(initial_boot_params, node, compat);
     f1c:	49445f4e 	stmdbmi	r4, {r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     f20:	54434552 	strbpl	r4, [r3], #-1362	; 0xfffffaae
     f24:	414d445f 	cmpmi	sp, pc, asr r4
     f28:	47494d00 	strbmi	r4, [r9, -r0, lsl #26]
     f2c:	45544152 	ldrbmi	r4, [r4, #-338]	; 0xfffffeae
     f30:	5059545f 	subspl	r5, r9, pc, asr r4
}
     f34:	70005345 	andvc	r5, r0, r5, asr #6
	int (*iterator)(unsigned long node, const char *uname, int depth, void *data);
	void *data;
};

const char * __init of_flat_dt_get_machine_name(void)
{
     f38:	006c6c6f 	rsbeq	r6, ip, pc, ror #24
     f3c:	6f6e7766 	svcvs	0x006e7766
     f40:	745f6564 	ldrbvc	r6, [pc], #-1380	; f48 <.debug_str+0xf48>
	const char *name;
	unsigned long dt_root = of_get_flat_dt_root();

	name = of_get_flat_dt_prop(dt_root, "model", NULL);
     f44:	00657079 	rsbeq	r7, r5, r9, ror r0
     f48:	6e5f6c66 	cdpvs	12, 5, cr6, cr15, cr6, {3}
     f4c:	64697073 	strbtvs	r7, [r9], #-115	; 0xffffff8d
     f50:	5f524e00 	svcpl	0x00524e00
     f54:	42414c53 	submi	r4, r1, #21248	; 0x5300
	if (!name)
     f58:	4345525f 	movtmi	r5, #21087	; 0x525f
     f5c:	4d49414c 	stfmie	f4, [r9, #-304]	; 0xfffffed0
		name = of_get_flat_dt_prop(dt_root, "compatible", NULL);
     f60:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
     f64:	72657000 	rsbvc	r7, r5, #0
     f68:	76655f66 	strbtvc	r5, [r5], -r6, ror #30
     f6c:	5f746e65 	svcpl	0x00746e65
	return name;
}
     f70:	70787463 	rsbsvc	r7, r8, r3, ror #8
     f74:	65766500 	ldrbvs	r6, [r6, #-1280]!	; 0xfffffb00
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f78:	7400746e 	strvc	r7, [r0], #-1134	; 0xfffffb92
     f7c:	5f656d69 	svcpl	0x00656d69
     f80:	65720074 	ldrbvs	r0, [r2, #-116]!	; 0xffffff8c
     f84:	6e727574 	mrcvs	5, 3, r7, cr2, cr4, {3}
	const void *data = NULL;
	const void *best_data = default_match;
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;
     f88:	736e695f 	cmnvc	lr, #1556480	; 0x17c000
 * Iterate through machine match tables to find the best match for the machine
 * compatible string in the FDT.
 */
const void * __init of_flat_dt_match_machine(const void *default_match,
		const void * (*get_next_compat)(const char * const**))
{
     f8c:	636e6174 	cmnvs	lr, #116, 2
     f90:	65730065 	ldrbvs	r0, [r3, #-101]!	; 0xffffff9b
	const char *const *compat;
	unsigned long dt_root;
	unsigned int best_score = ~1, score = 0;

	dt_root = of_get_flat_dt_root();
	while ((data = get_next_compat(&compat))) {
     f94:	756f6371 	strbvc	r6, [pc, #-881]!	; c2b <.debug_str+0xc2b>
     f98:	6500746e 	strvs	r7, [r0, #-1134]	; 0xfffffb92
     f9c:	00746978 	rsbseq	r6, r4, r8, ror r9
     fa0:	66726570 			; <UNDEFINED> instruction: 0x66726570
		score = of_flat_dt_match(dt_root, compat);
     fa4:	766e695f 			; <UNDEFINED> instruction: 0x766e695f
     fa8:	64696c61 	strbtvs	r6, [r9], #-3169	; 0xfffff39f
     fac:	6e6f635f 	mcrvs	3, 3, r6, cr15, cr15, {2}
		if (score > 0 && score < best_score) {
     fb0:	74786574 	ldrbtvc	r6, [r8], #-1396	; 0xfffffa8c
     fb4:	746c6100 	strbtvc	r6, [ip], #-256	; 0xffffff00
     fb8:	6570735f 	ldrbvs	r7, [r0, #-863]!	; 0xfffffca1
     fbc:	74006465 	strvc	r6, [r0], #-1125	; 0xfffffb9b
     fc0:	5f6b7361 	svcpl	0x006b7361
     fc4:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
     fc8:	65730073 	ldrbvs	r0, [r3, #-115]!	; 0xffffff8d
     fcc:	74705f74 	ldrbtvc	r5, [r0], #-3956	; 0xfffff08c
     fd0:	78655f65 	stmdavc	r5!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
			best_data = data;
			best_score = score;
		}
	}
	if (!best_data) {
     fd4:	6f780074 	svcvs	0x00780074
     fd8:	61765f6c 	cmnvs	r6, ip, ror #30
		const char *prop;
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");
     fdc:	00726464 	rsbseq	r6, r2, r4, ror #8
     fe0:	776f6873 			; <UNDEFINED> instruction: 0x776f6873
     fe4:	7461705f 	strbtvc	r7, [r1], #-95	; 0xffffffa1

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
     fe8:	71640068 	cmnvc	r4, r8, rrx
     fec:	0062735f 	rsbeq	r7, r2, pc, asr r3
     ff0:	726f6373 	rsbvc	r6, pc, #-872415231	; 0xcc000001
     ff4:	6d6d0065 	stclvs	0, cr0, [sp, #-404]!	; 0xfffffe6c
     ff8:	735f7061 	cmpvc	pc, #97	; 0x61
		if (prop) {
     ffc:	64006d65 	strvs	r6, [r0], #-3429	; 0xfffff29b
			while (size > 0) {
				printk("'%s' ", prop);
    1000:	5f74725f 	svcpl	0x0074725f
    1004:	63617073 	cmnvs	r1, #115	; 0x73
		int size;

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
    1008:	70630065 	rsbvc	r0, r3, r5, rrx
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
				prop += strlen(prop) + 1;
			}
		}
		printk("]\n\n");
    100c:	73616d75 	cmnvc	r1, #7488	; 0x1d40
    1010:	61765f6b 	cmnvs	r6, fp, ror #30
    1014:	00745f72 	rsbseq	r5, r4, r2, ror pc
		return NULL;
    1018:	636d656d 	cmnvs	sp, #457179136	; 0x1b400000
    101c:	726c5f67 	rsbvc	r5, ip, #412	; 0x19c

		pr_err("\n unrecognized device tree list:\n[ ");

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
    1020:	62007375 	andvs	r7, r0, #-738197503	; 0xd4000001
    1024:	65645f64 	strbvs	r5, [r4, #-3940]!	; 0xfffff09c
    1028:	65730076 	ldrbvs	r0, [r3, #-118]!	; 0xffffff8a
				printk("'%s' ", prop);
    102c:	636f6c71 	cmnvs	pc, #28928	; 0x7100
    1030:	00745f6b 	rsbseq	r5, r4, fp, ror #30
    1034:	65657266 	strbvs	r7, [r5, #-614]!	; 0xfffffd9a
				size -= strlen(prop) + 1;
    1038:	5f72657a 	svcpl	0x0072657a
    103c:	70726763 	rsbsvc	r6, r2, r3, ror #14
    1040:	0064695f 	rsbeq	r6, r4, pc, asr r9
    1044:	63726570 	cmnvs	r2, #112, 10	; 0x1c000000
    1048:	725f7570 	subsvc	r7, pc, #112, 10	; 0x1c000000
				prop += strlen(prop) + 1;
    104c:	665f6665 	ldrbvs	r6, [pc], -r5, ror #12

		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
		if (prop) {
			while (size > 0) {
				printk("'%s' ", prop);
				size -= strlen(prop) + 1;
    1050:	5f636e75 	svcpl	0x00636e75
				prop += strlen(prop) + 1;
    1054:	65730074 	ldrbvs	r0, [r3, #-116]!	; 0xffffff8c
    1058:	646c5f74 	strbtvs	r5, [ip], #-3956	; 0xfffff08c
    105c:	00637369 	rsbeq	r7, r3, r9, ror #6
    1060:	5f646c6f 	svcpl	0x00646c6f
		}
		printk("]\n\n");
		return NULL;
	}

	pr_info("Machine model: %s\n", of_flat_dt_get_machine_name());
    1064:	74706564 	ldrbtvc	r6, [r0], #-1380	; 0xfffffa9c
    1068:	616c0068 	cmnvs	ip, r8, rrx
    106c:	73726579 	cmnvc	r2, #507510784	; 0x1e400000
    1070:	6f757100 	svcvs	0x00757100
    1074:	656c6174 	strbvs	r6, [ip, #-372]!	; 0xfffffe8c

	return best_data;
    1078:	6462006e 	strbtvs	r0, [r2], #-110	; 0xffffff92
}
    107c:	72775f69 	rsbsvc	r5, r7, #420	; 0x1a4
    1080:	62657469 	rsbvs	r7, r5, #1761607680	; 0x69000000
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1084:	006b6361 	rsbeq	r6, fp, r1, ror #6
    1088:	54534750 	ldrbpl	r4, [r3], #-1872	; 0xfffff8b0
    108c:	5f4c4145 	svcpl	0x004c4145
	const __be32 *p = *cellp;
    1090:	4157534b 	cmpmi	r7, fp, asr #6
	/* break now */
	return 1;
}

u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
{
    1094:	4e5f4450 	mrcmi	4, 2, r4, cr15, cr0, {2}
    1098:	414d524f 	cmpmi	sp, pc, asr #4
 */

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
    109c:	7270004c 	rsbsvc	r0, r0, #76	; 0x4c
    10a0:	705f7665 	subsvc	r7, pc, r5, ror #12
	const __be32 *p = *cellp;

	*cellp = p + s;
    10a4:	6300736f 	movwvs	r7, #879	; 0x36f
    10a8:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0xfffffd8b
	while (size--)
    10ac:	6d5f746e 	cfldrdvs	mvd7, [pc, #-440]	; efc <.debug_str+0xefc>
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b0:	6d5f7961 	ldclvs	9, cr7, [pc, #-388]	; f34 <.debug_str+0xf34>

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10b4:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
		r = (r << 32) | be32_to_cpu(*(cell++));
    10b8:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^

/* Helper to read a big number; size is in cells (not bytes) */
static inline u64 of_read_number(const __be32 *cell, int size)
{
	u64 r = 0;
	while (size--)
    10bc:	735f6574 	cmpvc	pc, #116, 10	; 0x1d000000
    10c0:	78003436 	stmdavc	r0, {r1, r2, r4, r5, sl, ip, sp}
		r = (r << 32) | be32_to_cpu(*(cell++));
    10c4:	6c66725f 	sfmvs	f7, 2, [r6], #-380	; 0xfffffe84
    10c8:	73006761 	movwvc	r6, #1889	; 0x761
    10cc:	6c665f61 	stclvs	15, cr5, [r6], #-388	; 0xfffffe7c
    10d0:	00736761 	rsbseq	r6, r3, r1, ror #14
	return of_read_number(p, s);
}
    10d4:	665f6462 	ldrbvs	r6, [pc], -r2, ror #8
#ifndef MAX_MEMBLOCK_ADDR
#define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)
#endif

void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
{
    10d8:	65726673 	ldrbvs	r6, [r2, #-1651]!	; 0xfffff98d
    10dc:	5f657a65 	svcpl	0x00657a65
    10e0:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93
    10e4:	666f0078 			; <UNDEFINED> instruction: 0x666f0078
    10e8:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
    10ec:	6372635f 	cmnvs	r2, #2080374785	; 0x7c000001
    10f0:	63003233 	movwvs	r3, #563	; 0x233
    10f4:	626c6c61 	rsbvs	r6, ip, #24832	; 0x6100
	phys_addr_t t;

	if (sizeof(phys_addr_t) == 4) {
		__pv_stub(x, t, "add", __PV_BITS_31_24);
	} else {
		__pv_stub_mov_hi(t);
    10f8:	5f6b6361 	svcpl	0x006b6361
		__pv_add_carry_stub(x, t);
    10fc:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    1100:	65737500 	ldrbvs	r7, [r3, #-1280]!	; 0xfffffb00
    1104:	616e5f72 	smcvs	58866	; 0xe5f2
	const u64 phys_offset = MIN_MEMBLOCK_ADDR;
	printk("lwg:%s:%d:phys_offset = %llx\n", __func__, __LINE__, phys_offset);
    1108:	7073656d 	rsbsvc	r6, r3, sp, ror #10
    110c:	00656361 	rsbeq	r6, r5, r1, ror #6
    1110:	65766575 	ldrbvs	r6, [r6, #-1397]!	; 0xfffffa8b
    1114:	7300746e 	movwvc	r7, #1134	; 0x46e
    1118:	7065656c 	rsbvc	r6, r5, ip, ror #10
    111c:	6174735f 	cmnvs	r4, pc, asr r3
    1120:	5f007472 	svcpl	0x00007472

	if (!PAGE_ALIGNED(base)) {
    1124:	6372635f 	cmnvs	r2, #2080374785	; 0x7c000001
    1128:	5f666f5f 	svcpl	0x00666f5f
    112c:	5f746466 	svcpl	0x00746466
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
    1130:	6c666e75 	stclvs	14, cr6, [r6], #-468	; 0xfffffe2c
    1134:	65747461 	ldrbvs	r7, [r4, #-1121]!	; 0xfffffb9f
    1138:	72745f6e 	rsbsvc	r5, r4, #440	; 0x1b8
    113c:	69006565 	stmdbvs	r0, {r0, r2, r5, r6, r8, sl, sp, lr}
    1140:	7463616e 	strbtvc	r6, [r3], #-366	; 0xfffffe92
    1144:	5f657669 	svcpl	0x00657669
    1148:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
    114c:	4253006f 	subsmi	r0, r3, #111	; 0x6f
    1150:	4552465f 	ldrbmi	r4, [r2, #-1631]	; 0xfffff9a1
    1154:	5f455a45 	svcpl	0x00455a45
    1158:	504d4f43 	subpl	r4, sp, r3, asr #30
    115c:	4554454c 	ldrbmi	r4, [r4, #-1356]	; 0xfffffab4
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
    1160:	72616500 	rsbvc	r6, r1, #0, 10
    1164:	5f00796c 	svcpl	0x0000796c
    1168:	68637261 	stmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
    116c:	75716400 	ldrbvc	r6, [r1, #-1024]!	; 0xfffffc00
    1170:	6f5f746f 	svcvs	0x005f746f
    1174:	61726570 	cmnvs	r2, r0, ror r5
    1178:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    117c:	5f730073 	svcpl	0x00730073
				base, base + size);
			return;
    1180:	74627573 	strbtvc	r7, [r2], #-1395	; 0xfffffa8d
    1184:	00657079 	rsbeq	r7, r5, r9, ror r0
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    1188:	6f737361 	svcvs	0x00737361
    118c:	72615f63 	rsbvc	r5, r1, #396	; 0x18c
		base = PAGE_ALIGN(base);
    1190:	00796172 	rsbseq	r6, r9, r2, ror r1
    1194:	5f636c66 	svcpl	0x00636c66
    1198:	69736f70 	ldmdbvs	r3!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    119c:	70630078 	rsbvc	r0, r3, r8, ror r0
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11a0:	6c745f75 	ldclvs	15, cr5, [r4], #-468	; 0xfffffe2c
		base = PAGE_ALIGN(base);
    11a4:	47500062 	ldrbmi	r0, [r0, -r2, rrx]
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11a8:	4e494750 	mcrmi	7, 2, r4, cr9, cr0, {2}
		base = PAGE_ALIGN(base);
    11ac:	73616c00 	cmnvc	r1, #0, 24
    11b0:	69735f74 	ldmdbvs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    11b4:	666e6967 	strbtvs	r6, [lr], -r7, ror #18
    11b8:	7270006f 	rsbsvc	r0, r0, #111	; 0x6f
    11bc:	74617669 	strbtvc	r7, [r1], #-1641	; 0xfffff997
    11c0:	61645f65 	cmnvs	r4, r5, ror #30
		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
				base, base + size);
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
    11c4:	6b006174 	blvs	1979c <unflatten_and_copy_device_tree+0x18928>
    11c8:	666e7265 	strbtvs	r7, [lr], -r5, ror #4
		base = PAGE_ALIGN(base);
	}
	size &= PAGE_MASK;
    11cc:	6c655f73 	stclvs	15, cr5, [r5], #-460	; 0xfffffe34
    11d0:	735f6d65 	cmpvc	pc, #6464	; 0x1940
    11d4:	696c6d79 	stmdbvs	ip!, {r0, r3, r4, r5, r6, r8, sl, fp, sp, lr}^
    11d8:	73006b6e 	movwvc	r6, #2926	; 0xb6e
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
		size = MAX_MEMBLOCK_ADDR - base + 1;
	}

	if (base + size < phys_offset) {
    11dc:	5f746174 	svcpl	0x00746174
			return;
		}
		size -= PAGE_SIZE - (base & ~PAGE_MASK);
		base = PAGE_ALIGN(base);
	}
	size &= PAGE_MASK;
    11e0:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
		size = MAX_MEMBLOCK_ADDR - base + 1;
	}

	if (base + size < phys_offset) {
    11e4:	6c6f6873 	stclvs	8, cr6, [pc], #-460	; 1020 <.debug_str+0x1020>
    11e8:	5f730064 	svcpl	0x00730064
    11ec:	646f6e69 	strbtvs	r6, [pc], #-3689	; 11f4 <.debug_str+0x11f4>
    11f0:	48007365 	stmdami	r0, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
    11f4:	4d495452 	cfstrdmi	mvd5, [r9, #-328]	; 0xfffffeb8
    11f8:	425f5245 	subsmi	r5, pc, #1342177284	; 0x50000004
    11fc:	5f455341 	svcpl	0x00455341
    1200:	4f4e4f4d 	svcmi	0x004e4f4d
    1204:	494e4f54 	stmdbmi	lr, {r2, r4, r6, r8, r9, sl, fp, lr}^
    1208:	61650043 	cmnvs	r5, r3, asr #32
			   base, base + size);
		return;
    120c:	5f796c72 	svcpl	0x00796c72
	}
	if (base < phys_offset) {
    1210:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    1214:	5f74645f 	svcpl	0x0074645f
    1218:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
    121c:	6f68635f 	svcvs	0x0068635f
    1220:	5f6e6573 	svcpl	0x006e6573
    1224:	69726573 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    1228:	5f006c61 	svcpl	0x00006c61
    122c:	616d6b5f 	cmnvs	sp, pc, asr fp
    1230:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
			   base, phys_offset);
		size -= phys_offset - base;
    1234:	5f425300 	svcpl	0x00425300
    1238:	45455246 	strbmi	r5, [r5, #-582]	; 0xfffffdba
    123c:	465f455a 			; <UNDEFINED> instruction: 0x465f455a
    1240:	41500053 	cmpmi	r0, r3, asr r0
    1244:	554f4547 	strbpl	r4, [pc, #-1351]	; d05 <.debug_str+0xd05>
    1248:	4e555254 	mrcmi	2, 2, r5, cr5, cr4, {2}
		base = phys_offset;
	}
	memblock_add(base, size);
    124c:	67617000 	strbvs	r7, [r1, -r0]!
    1250:	72675f65 	rsbvc	r5, r7, #404	; 0x194
    1254:	5f70756f 	svcpl	0x0070756f
    1258:	6d5f7962 	ldclvs	9, cr7, [pc, #-392]	; 10d8 <.debug_str+0x10d8>
    125c:	6c69626f 	sfmvs	f6, 2, [r9], #-444	; 0xfffffe44
}
    1260:	5f797469 	svcpl	0x00797469
    1264:	61736964 	cmnvs	r3, r4, ror #18
/**
 * early_init_dt_scan_memory - Look for an parse memory nodes
 */
int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
				     int depth, void *data)
{
    1268:	64656c62 	strbtvs	r6, [r5], #-3170	; 0xfffff39e
    126c:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    1270:	775f6574 			; <UNDEFINED> instruction: 0x775f6574
    1274:	71746961 	cmnvc	r4, r1, ror #18
	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
    1278:	5f524e00 	svcpl	0x00524e00
    127c:	4e554f42 	cdpmi	15, 5, cr4, cr5, cr2, {2}
    1280:	63004543 	movwvs	r4, #1347	; 0x543
/**
 * early_init_dt_scan_memory - Look for an parse memory nodes
 */
int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
				     int depth, void *data)
{
    1284:	65736f6c 	ldrbvs	r6, [r3, #-3948]!	; 0xfffff094
	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
    1288:	63657200 	cmnvs	r5, #0, 4
	const __be32 *reg, *endp;
	int l;

	/* We are scanning "memory" nodes only */
	if (type == NULL) {
    128c:	65766965 	ldrbvs	r6, [r6, #-2405]!	; 0xfffff69b
    1290:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
		 * The longtrail doesn't have a device_type on the
		 * /memory node, so look for the node called /memory@0.
		 */
		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
			return 0;
	} else if (strcmp(type, "memory") != 0)
    1294:	72660032 	rsbvc	r0, r6, #50	; 0x32
    1298:	625f6565 	subsvs	r6, pc, #423624704	; 0x19400000
    129c:	616d7469 	cmnvs	sp, r9, ror #8
    12a0:	5f730070 	svcpl	0x00730070
    12a4:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
		return 0;

	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
    12a8:	6172675f 	cmnvs	r2, pc, asr r7
    12ac:	7164006e 	cmnvc	r4, lr, rrx
    12b0:	69645f69 	stmdbvs	r4!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    12b4:	5f797472 	svcpl	0x00797472
    12b8:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
	if (reg == NULL)
    12bc:	6c6d6d00 	stclvs	13, cr6, [sp], #-0
		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
			return 0;
	} else if (strcmp(type, "memory") != 0)
		return 0;

	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
    12c0:	00747369 	rsbseq	r7, r4, r9, ror #6
	if (reg == NULL)
    12c4:	5f6c6664 	svcpl	0x006c6664
		reg = of_get_flat_dt_prop(node, "reg", &l);
    12c8:	79746663 	ldmdbvc	r4!, {r0, r1, r5, r6, r9, sl, sp, lr}^
    12cc:	00736570 	rsbseq	r6, r3, r0, ror r5
    12d0:	75636573 	strbvc	r6, [r3, #-1395]!	; 0xfffffa8d
    12d4:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    12d8:	61656400 	cmnvs	r5, r0, lsl #8
    12dc:	6f727064 	svcvs	0x00727064
	if (reg == NULL)
    12e0:	64007370 	strvs	r7, [r0], #-880	; 0xfffffc90
    12e4:	746f7571 	strbtvc	r7, [pc], #-1393	; 12ec <.debug_str+0x12ec>
    12e8:	5f646200 	svcpl	0x00646200
		return 0;

	endp = reg + (l / sizeof(__be32));
    12ec:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93

	pr_debug("memory scan node %s, reg size %d,\n", uname, l);

	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
    12f0:	76650078 			; <UNDEFINED> instruction: 0x76650078
    12f4:	5f746369 	svcpl	0x00746369
	if (reg == NULL)
		reg = of_get_flat_dt_prop(node, "reg", &l);
	if (reg == NULL)
		return 0;

	endp = reg + (l / sizeof(__be32));
    12f8:	646f6e69 	strbtvs	r6, [pc], #-3689	; 1300 <.debug_str+0x1300>
    12fc:	6c650065 	stclvs	0, cr0, [r5], #-404	; 0xfffffe6c

	pr_debug("memory scan node %s, reg size %d,\n", uname, l);

	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
    1300:	77685f66 	strbvc	r5, [r8, -r6, ror #30]!
    1304:	00706163 	rsbseq	r6, r0, r3, ror #2
    1308:	5f737363 	svcpl	0x00737363
    130c:	6c66666f 	stclvs	6, cr6, [r6], #-444	; 0xfffffe44
    1310:	00656e69 	rsbeq	r6, r5, r9, ror #28
    1314:	7379656b 	cmnvc	r9, #448790528	; 0x1ac00000
    1318:	72707500 	rsbsvc	r7, r0, #0, 10
		u64 base, size;

		base = dt_mem_next_cell(dt_root_addr_cells, &reg);
    131c:	7365626f 	cmnvc	r5, #-268435450	; 0xf0000006
    1320:	6174735f 	cmnvs	r4, pc, asr r3
    1324:	50006574 	andpl	r6, r0, r4, ror r5
    1328:	41435347 	cmpmi	r3, r7, asr #6
		size = dt_mem_next_cell(dt_root_size_cells, &reg);
    132c:	49445f4e 	stmdbmi	r4, {r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1330:	54434552 	strbpl	r4, [r3], #-1362	; 0xfffffaae
    1334:	564f4d5f 			; <UNDEFINED> instruction: 0x564f4d5f
    1338:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    133c:	635f6600 	cmpvs	pc, #0, 12

		if (size == 0)
    1340:	00646572 	rsbeq	r6, r4, r2, ror r5
    1344:	5f757063 	svcpl	0x00757063
			continue;
		pr_debug(" - %llx ,  %llx\n", (unsigned long long)base,
		    (unsigned long long)size);

		early_init_dt_add_memory_arch(base, size);
    1348:	65736162 	ldrbvs	r6, [r3, #-354]!	; 0xfffffe9e
    134c:	65766f00 	ldrbvs	r6, [r6, #-3840]!	; 0xfffff100
    1350:	6e757272 	mrcvs	2, 3, r7, cr5, cr2, {3}
    1354:	44495000 	strbmi	r5, [r9], #-0
	}

	return 0;
}
    1358:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0xfffff6ac
    135c:	4449535f 	strbmi	r5, [r9], #-863	; 0xfffffca1
    1360:	72657000 	rsbvc	r7, r5, #0
	memblock_add(base, size);
}

int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
					phys_addr_t size, bool nomap)
{
    1364:	5f757063 	svcpl	0x00757063
    1368:	735f7772 	cmpvc	pc, #29884416	; 0x1c80000
    136c:	70616d65 	rsbvc	r6, r1, r5, ror #26
    1370:	65726f68 	ldrbvs	r6, [r2, #-3944]!	; 0xfffff098
	if (nomap)
    1374:	5f6d7600 	svcpl	0x006d7600
    1378:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
		return memblock_remove(base, size);
    137c:	74695f74 	strbtvc	r5, [r9], #-3956	; 0xfffff08c
    1380:	69006d65 	stmdbvs	r0, {r0, r2, r5, r6, r8, sl, fp, sp, lr}
	return memblock_reserve(base, size);
    1384:	6961776f 	stmdbvs	r1!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, ip, sp, lr}^
}
    1388:	6f635f74 	svcvs	0x00635f74
 * This function grabs memory from early allocator for device exclusive use
 * defined in device tree structures. It should be called by arch specific code
 * once the early allocator (i.e. memblock) has been fully activated.
 */
void __init early_init_fdt_scan_reserved_mem(void)
{
    138c:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1390:	65725f64 	ldrbvs	r5, [r2, #-3940]!	; 0xfffff09c
    1394:	67006c61 	strvs	r6, [r0, -r1, ror #24]
    1398:	745f7465 	ldrbvc	r7, [pc], #-1125	; 13a0 <.debug_str+0x13a0>
	int n;
	u64 base, size;

	if (!initial_boot_params)
    139c:	00656d69 	rsbeq	r6, r5, r9, ror #26
    13a0:	6c665f66 	stclvs	15, cr5, [r6], #-408	; 0xfffffe68
    13a4:	00736761 	rsbseq	r6, r3, r1, ror #14
    13a8:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
    13ac:	6e695f79 	mcrvs	15, 3, r5, cr9, cr9, {3}
    13b0:	645f7469 	ldrbvs	r7, [pc], #-1129	; 13b8 <.debug_str+0x13b8>
    13b4:	63735f74 	cmnvs	r3, #116, 30	; 0x1d0
		return;

	/* Process header /memreserve/ fields */
	for (n = 0; ; n++) {
		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
    13b8:	6e5f6e61 	cdpvs	14, 5, cr6, cr15, cr1, {3}
    13bc:	7365646f 	cmnvc	r5, #1862270976	; 0x6f000000
    13c0:	5f726e00 	svcpl	0x00726e00
    13c4:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
    13c8:	00736461 	rsbseq	r6, r3, r1, ror #8
		if (!size)
    13cc:	6e755f5f 	mrcvs	15, 3, r5, cr5, cr15, {2}
    13d0:	64657375 	strbtvs	r7, [r5], #-885	; 0xfffffc8b
    13d4:	6761745f 			; <UNDEFINED> instruction: 0x6761745f
			break;
		early_init_dt_reserve_memory_arch(base, size, 0);
    13d8:	4e41435f 	mcrmi	3, 2, r4, cr1, cr15, {2}
    13dc:	4b524f46 	blmi	14950fc <unflatten_and_copy_device_tree+0x1494288>
    13e0:	444e455f 	strbmi	r4, [lr], #-1375	; 0xfffffaa1

	if (!initial_boot_params)
		return;

	/* Process header /memreserve/ fields */
	for (n = 0; ; n++) {
    13e4:	66756200 	ldrbtvs	r6, [r5], -r0, lsl #4
		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
		if (!size)
			break;
		early_init_dt_reserve_memory_arch(base, size, 0);
    13e8:	006e656c 	rsbeq	r6, lr, ip, ror #10
	}
    13ec:	735f6468 	cmpvc	pc, #104, 8	; 0x68000000

	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
    13f0:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    13f4:	65720074 	ldrbvs	r0, [r2, #-116]!	; 0xffffff8c
    13f8:	61706461 	cmnvs	r0, r1, ror #8
    13fc:	00736567 	rsbseq	r6, r3, r7, ror #10
	fdt_init_reserved_mem();
    1400:	495f524e 	ldmdbmi	pc, {r1, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
}
    1404:	414c4f53 	cmpmi	ip, r3, asr pc
    1408:	5f444554 	svcpl	0x00444554
/**
 * fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
 */
static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
					  int depth, void *data)
{
    140c:	4e4f4e41 	cdpmi	14, 4, cr4, cr15, cr1, {2}
    1410:	73736300 	cmnvc	r3, #0, 6
    1414:	6c6c615f 	stfvse	f6, [ip], #-380	; 0xfffffe84
    1418:	7300636f 	movwvc	r6, #879	; 0x36f
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    141c:	65726168 	ldrbvs	r6, [r2, #-360]!	; 0xfffffe98
    1420:	65640064 	strbvs	r0, [r4, #-100]!	; 0xffffff9c
/**
 * fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
 */
static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
					  int depth, void *data)
{
    1424:	00677562 	rsbeq	r7, r7, r2, ror #10
    1428:	5f706163 	svcpl	0x00706163
    142c:	69626d61 	stmdbvs	r2!, {r0, r5, r6, r8, sl, fp, sp, lr}^
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    1430:	00746e65 	rsbseq	r6, r4, r5, ror #28
    1434:	746d5f69 	strbtvc	r5, [sp], #-3945	; 0xfffff097
    1438:	00656d69 	rsbeq	r6, r5, r9, ror #26
    143c:	54535144 	ldrbpl	r5, [r3], #-324	; 0xfffffebc
    1440:	4e59535f 	mrcmi	3, 2, r5, cr9, cr15, {2}
		found = 1;
		/* scan next node */
		return 0;
	} else if (!found) {
		/* scan next node */
		return 0;
    1444:	4e005343 	cdpmi	3, 0, cr5, cr0, cr3, {2}
    1448:	4c415f52 	mcrrmi	15, 5, r5, r1, cr2
{
	static int found;
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
    144c:	5f434f4c 	svcpl	0x00434f4c
    1450:	43544142 	cmpmi	r4, #-2147483632	; 0x80000010
    1454:	43500048 	cmpmi	r0, #72	; 0x48
    1458:	465f5550 			; <UNDEFINED> instruction: 0x465f5550
    145c:	55415f43 	strbpl	r5, [r1, #-3907]	; 0xfffff0bd
    1460:	63004f54 	movwvs	r4, #3924	; 0xf54
 */
static int __init __reserved_mem_check_root(unsigned long node)
{
	const __be32 *prop;

	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
    1464:	696d6d6f 	stmdbvs	sp!, {r0, r1, r2, r3, r5, r6, r8, sl, fp, sp, lr}^
    1468:	74700074 	ldrbtvc	r0, [r0], #-116	; 0xffffff8c
    146c:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    1470:	72635f72 	rsbvc	r5, r3, #456	; 0x1c8
    1474:	66006465 	strvs	r6, [r0], -r5, ror #8
	if (!prop || be32_to_cpup(prop) != dt_root_size_cells)
    1478:	63617274 	cmnvs	r1, #116, 4	; 0x40000007
    147c:	69745f65 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    1480:	7473656d 	ldrbtvc	r6, [r3], #-1389	; 0xfffffa93
    1484:	00706d61 	rsbseq	r6, r0, r1, ror #26
    1488:	69766564 	ldmdbvs	r6!, {r2, r5, r6, r8, sl, sp, lr}^
    148c:	67006563 	strvs	r6, [r0, -r3, ror #10]
    1490:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    1494:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 149c <.debug_str+0x149c>
    1498:	72670065 	rsbvc	r0, r7, #101	; 0x65
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
    149c:	79657661 	stmdbvc	r5!, {r0, r5, r6, r9, sl, ip, sp, lr}^
    14a0:	5f647261 	svcpl	0x00647261
    14a4:	6b6e696c 	blvs	1b9ba5c <unflatten_and_copy_device_tree+0x1b9abe8>
    14a8:	4e5f4e00 	cdpmi	14, 5, cr4, cr15, cr0, {0}
    14ac:	414d524f 	cmpmi	sp, pc, asr #4
	if (!prop || be32_to_cpup(prop) != dt_root_addr_cells)
    14b0:	454d5f4c 	strbmi	r5, [sp, #-3916]	; 0xfffff0b4
    14b4:	59524f4d 	ldmdbpl	r2, {r0, r2, r3, r6, r8, r9, sl, fp, lr}^
    14b8:	69755f00 	ldmdbvs	r5!, {r8, r9, sl, fp, ip, lr}^
    14bc:	6f7a0064 	svcvs	0x007a0064
    14c0:	775f656e 	ldrbvc	r6, [pc, -lr, ror #10]
    14c4:	72657461 	rsbvc	r7, r5, #1627389952	; 0x61000000
    14c8:	6b72616d 	blvs	1c99a84 <unflatten_and_copy_device_tree+0x1c98c10>
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "ranges", NULL);
    14cc:	6f740073 	svcvs	0x00740073
    14d0:	726c6174 	rsbvc	r6, ip, #116, 2
    14d4:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
    14d8:	705f6576 	subsvc	r6, pc, r6, ror r5	; <UNPREDICTABLE>
    14dc:	73656761 	cmnvc	r5, #25427968	; 0x1840000
	if (!prop)
    14e0:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
		if (__reserved_mem_check_root(node) != 0) {
			pr_err("Reserved memory: unsupported node format, ignoring\n");
			/* break scan */
			return 1;
		}
		found = 1;
    14e4:	7469726f 	strbtvc	r7, [r9], #-623	; 0xfffffd91
	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
	if (!prop || be32_to_cpup(prop) != dt_root_addr_cells)
		return -EINVAL;

	prop = of_get_flat_dt_prop(node, "ranges", NULL);
	if (!prop)
    14e8:	5f4e0079 	svcpl	0x004e0079
    14ec:	00555043 	subseq	r5, r5, r3, asr #32
		/* scan next node */
		return 0;
	} else if (!found) {
		/* scan next node */
		return 0;
	} else if (found && depth < 2) {
    14f0:	5f627164 	svcpl	0x00627164
    14f4:	73727563 	cmnvc	r2, #415236096	; 0x18c00000
		/* scanning of /reserved-memory has been finished */
		return 1;
	}

	status = of_get_flat_dt_prop(node, "status", NULL);
    14f8:	65636170 	strbvs	r6, [r3, #-368]!	; 0xfffffe90
    14fc:	65686300 	strbvs	r6, [r8, #-768]!	; 0xfffffd00
    1500:	715f6b63 	cmpvc	pc, r3, ror #22
    1504:	61746f75 	cmnvs	r4, r5, ror pc
	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
    1508:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    150c:	74730065 	ldrbtvc	r0, [r3], #-101	; 0xffffff9b
    1510:	5f737461 	svcpl	0x00737461
    1514:	6b636f6c 	blvs	18dd2cc <unflatten_and_copy_device_tree+0x18dc458>
    1518:	6d5f7300 	ldclvs	3, cr7, [pc, #-0]	; 1520 <.debug_str+0x1520>
    151c:	64006d65 	strvs	r6, [r0], #-3429	; 0xfffff29b
    1520:	6170735f 	cmnvs	r0, pc, asr r3
    1524:	6f006563 	svcvs	0x00006563
    1528:	6f6e5f66 	svcvs	0x006e5f66
    152c:	6b5f6564 	blvs	17daac4 <unflatten_and_copy_device_tree+0x17d9c50>
    1530:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    1534:	61737500 	cmnvs	r3, r0, lsl #10
    1538:	70006567 	andvc	r6, r0, r7, ror #10
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    153c:	0074726f 	rsbseq	r7, r4, pc, ror #4
    1540:	746d5f73 	strbtvc	r5, [sp], #-3955	; 0xfffff08d
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1544:	6d5f0064 	ldclvs	0, cr0, [pc, #-400]	; 13bc <.debug_str+0x13bc>
    1548:	6f637061 	svcvs	0x00637061
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    154c:	00746e75 	rsbseq	r6, r4, r5, ror lr
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1550:	6f697270 	svcvs	0x00697270
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    1554:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1558:	6f6c0074 	svcvs	0x006c0074
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    155c:	62006b63 	andvs	r6, r0, #101376	; 0x18c00
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    1560:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
 * res_mem_reserve_reg() - reserve all memory described in 'reg' property
 */
static int __init __reserved_mem_reserve_reg(unsigned long node,
					     const char *uname)
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
    1564:	0065646f 	rsbeq	r6, r5, pc, ror #8
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
	if (!prop)
    1568:	6c5f6272 	lfmvs	f6, 2, [pc], {114}	; 0x72
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;

	prop = of_get_flat_dt_prop(node, "reg", &len);
    156c:	00746665 	rsbseq	r6, r4, r5, ror #12
    1570:	69677366 	stmdbvs	r7!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}^
	if (!prop)
    1574:	72740064 	rsbsvc	r0, r4, #100	; 0x64
		return -ENOENT;

	if (len && len % t_len != 0) {
    1578:	6c5f6565 	cfldr64vs	mvdx6, [pc], {101}	; 0x65
    157c:	006b636f 	rsbeq	r6, fp, pc, ror #6
    1580:	6f6c6c61 	svcvs	0x006c6c61
    1584:	6f6c5f63 	svcvs	0x006c5f63
    1588:	67006b63 	strvs	r6, [r0, -r3, ror #22]
    158c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    1590:	6d697400 	cfstrdvs	mvd7, [r9, #-0]
		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
    1594:	65707365 	ldrbvs	r7, [r0, #-869]!	; 0xfffffc9b
    1598:	69620063 	stmdbvs	r2!, {r0, r1, r5, r6}^
    159c:	696c5f6f 	stmdbvs	ip!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    15a0:	76007473 			; <UNDEFINED> instruction: 0x76007473
    15a4:	6c6c616d 	stfvse	f6, [ip], #-436	; 0xfffffe4c
		       uname);
		return -EINVAL;
	}

	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
    15a8:	735f636f 	cmpvc	pc, #-1140850687	; 0xbc000001
    15ac:	63007165 	movwvs	r7, #357	; 0x165
    15b0:	756f7267 	strbvc	r7, [pc, #-615]!	; 1351 <.debug_str+0x1351>
    15b4:	75735f70 	ldrbvc	r5, [r3, #-3952]!	; 0xfffff090
    15b8:	73797362 	cmnvc	r9, #-2013265919	; 0x88000001
		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    15bc:	69716400 	ldmdbvs	r1!, {sl, sp, lr}^
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;
    15c0:	7267625f 	rsbvc	r6, r7, #-268435451	; 0xf0000005
		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    15c4:	00656361 	rsbeq	r6, r5, r1, ror #6
{
	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
	phys_addr_t base, size;
	int len;
	const __be32 *prop;
	int nomap, first = 1;
    15c8:	63617274 	cmnvs	r1, #116, 4	; 0x40000007
		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
		       uname);
		return -EINVAL;
	}

	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
    15cc:	65725f65 	ldrbvs	r5, [r2, #-3941]!	; 0xfffff09b
    15d0:	73727563 	cmnvc	r2, #415236096	; 0x18c00000
    15d4:	006e6f69 	rsbeq	r6, lr, r9, ror #30

	while (len >= t_len) {
    15d8:	5f797474 	svcpl	0x00797474
    15dc:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
    15e0:	6f007463 	svcvs	0x00007463
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
    15e4:	63735f66 	cmnvs	r3, #408	; 0x198
    15e8:	665f6e61 	ldrbvs	r6, [pc], -r1, ror #28
    15ec:	5f74616c 	svcpl	0x0074616c
    15f0:	66007464 	strvs	r7, [r0], -r4, ror #8
		size = dt_mem_next_cell(dt_root_size_cells, &prop);
    15f4:	776f5f6c 	strbvc	r5, [pc, -ip, ror #30]!
    15f8:	5f72656e 	svcpl	0x0072656e
    15fc:	5f660074 	svcpl	0x00660074
    1600:	6c696674 	stclvs	6, cr6, [r9], #-464	; 0xfffffe30
    1604:	6c6c5f65 	stclvs	15, cr5, [ip], #-404	; 0xfffffe6c

		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1608:	006b6e69 	rsbeq	r6, fp, r9, ror #28

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    160c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1610:	6e696c5f 	mcrvs	12, 3, r6, cr9, cr15, {2}

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    1614:	6874006b 	ldmdavs	r4!, {r0, r1, r3, r5, r6}^
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
    1618:	735f7761 	cmpvc	pc, #25427968	; 0x1840000
    161c:	72657075 	rsbvc	r7, r5, #117	; 0x75
    1620:	70616d00 	rsbvc	r6, r1, r0, lsl #26
    1624:	6761705f 			; <UNDEFINED> instruction: 0x6761705f
    1628:	69007365 	stmdbvs	r0, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    162c:	5f62735f 	svcpl	0x0062735f
	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
    1630:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    1634:	53475000 	movtpl	r5, #28672	; 0x7000
    1638:	4c414554 	cfstr64mi	mvdx4, [r1], {84}	; 0x54
    163c:	5249445f 	subpl	r4, r9, #1593835520	; 0x5f000000

	while (len >= t_len) {
		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
		size = dt_mem_next_cell(dt_root_size_cells, &prop);

		if (size &&
    1640:	5f544345 	svcpl	0x00544345
    1644:	00414d44 	subeq	r4, r1, r4, asr #26
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
		if (first) {
    1648:	5f706163 	svcpl	0x00706163
    164c:	6d726570 	cfldr64vs	mvdx6, [r2, #-448]!	; 0xfffffe40
				uname, &base, (unsigned long)size / SZ_1M);
		else
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
    1650:	65747469 	ldrbvs	r7, [r4, #-1129]!	; 0xfffffb97
    1654:	6c660064 	stclvs	0, cr0, [r6], #-400	; 0xfffffe70
    1658:	4b00755f 	blmi	1ebdc <unflatten_and_copy_device_tree+0x1dd68>
		if (first) {
    165c:	50415753 	subpl	r5, r1, r3, asr r7
			fdt_reserved_mem_save_node(node, uname, base, size);
    1660:	49485f44 	stmdbmi	r8, {r2, r6, r8, r9, sl, fp, ip, lr}^
    1664:	575f4847 	ldrbpl	r4, [pc, -r7, asr #16]
    1668:	4b52414d 	blmi	1491ba4 <unflatten_and_copy_device_tree+0x1490d30>
    166c:	5449485f 	strbpl	r4, [r9], #-2143	; 0xfffff7a1
			first = 0;
    1670:	4955515f 	ldmdbmi	r5, {r0, r1, r2, r3, r4, r6, r8, ip, lr}^
    1674:	594c4b43 	stmdbpl	ip, {r0, r1, r6, r8, r9, fp, lr}^
			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
				uname, &base, (unsigned long)size / SZ_1M);

		len -= t_len;
		if (first) {
			fdt_reserved_mem_save_node(node, uname, base, size);
    1678:	4e4f5a00 	vmlami.f32	s11, s30, s0
    167c:	4f4d5f45 	svcmi	0x004d5f45
	status = of_get_flat_dt_prop(node, "status", NULL);
	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
		return 0;

	err = __reserved_mem_reserve_reg(node, uname);
	if (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))
    1680:	4c424156 	stfmie	f4, [r2], {86}	; 0x56
    1684:	64620045 	strbtvs	r0, [r2], #-69	; 0xffffffbb
    1688:	6f6c625f 	svcvs	0x006c625f
    168c:	735f6b63 	cmpvc	pc, #101376	; 0x18c00
    1690:	00657a69 	rsbeq	r7, r5, r9, ror #20
    1694:	68737570 	ldmdavs	r3!, {r4, r5, r6, r8, sl, ip, sp, lr}^
    1698:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
		fdt_reserved_mem_save_node(node, uname, 0, 0);
    169c:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
    16a0:	6900736b 	stmdbvs	r0, {r0, r1, r3, r5, r6, r8, r9, ip, sp, lr}
    16a4:	74756d5f 	ldrbtvc	r6, [r5], #-3423	; 0xfffff2a1
    16a8:	71007865 	tstvc	r0, r5, ror #16
    16ac:	61746f75 	cmnvs	r4, r5, ror pc
    16b0:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
    16b4:	5f74616d 	svcpl	0x0074616d
    16b8:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
	const char *status;
	int err;

	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
		if (__reserved_mem_check_root(node) != 0) {
			pr_err("Reserved memory: unsupported node format, ignoring\n");
    16bc:	675f5f00 	ldrbvs	r5, [pc, -r0, lsl #30]
    16c0:	6f5f7465 	svcvs	0x005f7465
    16c4:	72656472 	rsbvc	r6, r5, #1912602624	; 0x72000000
			/* break scan */
			return 1;
    16c8:	6e5f6400 	cdpvs	4, 5, cr6, cr15, cr0, {0}
	if (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))
		fdt_reserved_mem_save_node(node, uname, 0, 0);

	/* scan next node */
	return 0;
}
    16cc:	00656d61 	rsbeq	r6, r5, r1, ror #26
    16d0:	5f75726c 	svcpl	0x0075726c
    16d4:	6b636f6c 	blvs	18dd48c <unflatten_and_copy_device_tree+0x18dc618>

/**
 * early_init_fdt_reserve_self() - reserve the memory used by the FDT blob
 */
void __init early_init_fdt_reserve_self(void)
{
    16d8:	69747500 	ldmdbvs	r4!, {r8, sl, ip, sp, lr}^
    16dc:	75735f6c 	ldrbvc	r5, [r3, #-3948]!	; 0xfffff094
    16e0:	6676006d 	ldrbtvs	r0, [r6], -sp, rrx
    16e4:	5f6b726f 	svcpl	0x006b726f
	if (!initial_boot_params)
    16e8:	656e6f64 	strbvs	r6, [lr, #-3940]!	; 0xfffff09c
    16ec:	71657300 	cmnvc	r5, r0, lsl #6
    16f0:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    16f4:	00745f74 	rsbseq	r5, r4, r4, ror pc
    16f8:	706f5f66 	rsbvc	r5, pc, r6, ror #30
	phys_addr_t t;

	if (sizeof(phys_addr_t) == 4) {
		__pv_stub(x, t, "add", __PV_BITS_31_24);
	} else {
		__pv_stub_mov_hi(t);
    16fc:	74657200 	strbtvc	r7, [r5], #-512	; 0xfffffe00
		__pv_add_carry_stub(x, t);
    1700:	5f6e7275 	svcpl	0x006e7275
    1704:	74736e69 	ldrbtvc	r6, [r3], #-3689	; 0xfffff197
    1708:	65636e61 	strbvs	r6, [r3, #-3681]!	; 0xfffff19f
		return;

	/* Reserve the dtb region */
	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
    170c:	79730073 	ldmdbvc	r3!, {r0, r1, r4, r5, r6}^
    1710:	5f736673 	svcpl	0x00736673
    1714:	61657263 	cmnvs	r5, r3, ror #4
    1718:	625f6574 	subsvs	r6, pc, #116, 10	; 0x1d000000
					  fdt_totalsize(initial_boot_params),
					  0);
}
    171c:	665f6e69 	ldrbvs	r6, [pc], -r9, ror #28
    1720:	00656c69 	rsbeq	r6, r5, r9, ror #24
	return NULL;
}
#endif

bool __init early_init_dt_verify(void *params)
{
    1724:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
    1728:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    172c:	6e695f65 	cdpvs	15, 6, cr5, cr9, cr5, {3}
	if (!params)
    1730:	62006f66 	andvs	r6, r0, #408	; 0x198
    1734:	5f747365 	svcpl	0x00747365
		return false;
    1738:	726f6373 	rsbvc	r6, pc, #-872415231	; 0xcc000001
    173c:	6e700065 	cdpvs	0, 7, cr0, cr0, cr5, {3}

	/* check device tree validity */
	if (fdt_check_header(params))
    1740:	00656d61 	rsbeq	r6, r5, r1, ror #26
    1744:	6873726e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    1748:	776f6461 	strbvc	r6, [pc, -r1, ror #8]!
    174c:	696c0073 	stmdbvs	ip!, {r0, r1, r4, r5, r6}^
		return false;

	/* Setup flat device-tree pointer */
	initial_boot_params = params;
    1750:	6c5f7473 	cfldrdvs	mvd7, [pc], {115}	; 0x73
    1754:	6e5f7572 	mrcvs	5, 2, r7, cr15, cr2, {3}
	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
    1758:	0065646f 	rsbeq	r6, r5, pc, ror #8
    175c:	61647075 	smcvs	18181	; 0x4705
    1760:	745f6574 	ldrbvc	r6, [pc], #-1396	; 1768 <.debug_str+0x1768>
	/* check device tree validity */
	if (fdt_check_header(params))
		return false;

	/* Setup flat device-tree pointer */
	initial_boot_params = params;
    1764:	00656d69 	rsbeq	r6, r5, r9, ror #26
	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
    1768:	65705f5f 	ldrbvs	r5, [r0, #-3935]!	; 0xfffff0a1
    176c:	70635f72 	rsbvc	r5, r3, r2, ror pc
    1770:	666f5f75 	uqsub16vs	r5, pc, r5	; <UNPREDICTABLE>
				fdt_totalsize(initial_boot_params));
	return true;
}
    1774:	74657366 	strbtvc	r7, [r5], #-870	; 0xfffffc9a
    1778:	5f726e00 	svcpl	0x00726e00


void __init early_init_dt_scan_nodes(void)
{
    177c:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    1780:	5f737075 	svcpl	0x00737075
    1784:	69666661 	stmdbvs	r6!, {r0, r5, r6, r9, sl, sp, lr}^
	/* Retrieve various information from the /chosen node */
	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
    1788:	7300656e 	movwvc	r6, #1390	; 0x56e
    178c:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
    1790:	646f635f 	strbtvs	r6, [pc], #-863	; 1798 <.debug_str+0x1798>
    1794:	6f6b0065 	svcvs	0x006b0065
    1798:	6e5f6a62 	vnmlavs.f32	s13, s30, s5

	/* Initialize {size,address}-cells info */
	of_scan_flat_dt(early_init_dt_scan_root, NULL);
    179c:	79745f73 	ldmdbvc	r4!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    17a0:	77006570 	smlsdxvc	r0, r0, r5, r6
    17a4:	65656b61 	strbvs	r6, [r5, #-2913]!	; 0xfffff49f
    17a8:	696c665f 	stmdbvs	ip!, {r0, r1, r2, r3, r4, r6, r9, sl, sp, lr}^

	/* Setup memory, calling early_init_dt_add_memory_arch */
	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
    17ac:	5f007370 	svcpl	0x00007370
    17b0:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
    17b4:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
    17b8:	656d5f64 	strbvs	r5, [sp, #-3940]!	; 0xfffff09c
    17bc:	68635f6d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
}

bool __init early_init_dt_scan(void *params)
{
    17c0:	5f6b6365 	svcpl	0x006b6365
    17c4:	746f6f72 	strbtvc	r6, [pc], #-3954	; 17cc <.debug_str+0x17cc>
    17c8:	6f6c6200 	svcvs	0x006c6200
	bool status;

	status = early_init_dt_verify(params);
    17cc:	65646b63 	strbvs	r6, [r4, #-2915]!	; 0xfffff49d
	if (!status)
    17d0:	75735f76 	ldrbvc	r5, [r3, #-3958]!	; 0xfffff08a
    17d4:	62726570 	rsbsvs	r6, r2, #112, 10	; 0x1c000000
		return false;

	early_init_dt_scan_nodes();
    17d8:	6b636f6c 	blvs	18dd590 <unflatten_and_copy_device_tree+0x18dc71c>
	return true;
    17dc:	636f7300 	cmnvs	pc, #0, 6
}
    17e0:	666f006b 	strbtvs	r0, [pc], -fp, rrx
 * tree of struct device_node. It also fills the "name" and "type"
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void __init unflatten_device_tree(void)
{
    17e4:	7465675f 	strbtvc	r6, [r5], #-1887	; 0xfffff8a1
    17e8:	616c665f 	cmnvs	ip, pc, asr r6
    17ec:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
	__unflatten_device_tree(initial_boot_params, &of_root,
    17f0:	6f72705f 	svcvs	0x0072705f
    17f4:	69730070 	ldmdbvs	r3!, {r4, r5, r6}^
    17f8:	67617067 	strbvs	r7, [r1, -r7, rrx]!
    17fc:	68700065 	ldmdavs	r0!, {r0, r2, r5, r6}^
    1800:	6f5f7379 	svcvs	0x005f7379
    1804:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    1808:	74730074 	ldrbtvc	r0, [r3], #-116	; 0xffffff8c
    180c:	5f747261 	svcpl	0x00747261
    1810:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
				early_init_dt_alloc_memory_arch);

	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
	of_alias_scan(early_init_dt_alloc_memory_arch);
    1814:	74726800 	ldrbtvc	r6, [r2], #-2048	; 0xfffff800
    1818:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    181c:	6f6c635f 	svcvs	0x006c635f
 * reserved such is the case when the FDT is built-in to the kernel init
 * section. If the FDT memory is reserved already then unflatten_device_tree
 * should be used instead.
 */
void __init unflatten_and_copy_device_tree(void)
{
    1820:	625f6b63 	subsvs	r6, pc, #101376	; 0x18c00
    1824:	00657361 	rsbeq	r7, r5, r1, ror #6
    1828:	5f6d6f6f 	svcpl	0x006d6f6f
	int size;
	void *dt;

	if (!initial_boot_params) {
    182c:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    1830:	6d760073 	ldclvs	0, cr0, [r6, #-460]!	; 0xfffffe34
    1834:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    1838:	75730065 	ldrbvc	r0, [r3, #-101]!	; 0xffffff9b
    183c:	5f726570 	svcpl	0x00726570
		pr_warn("No valid device tree found, continuing without\n");
    1840:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
    1844:	6f697461 	svcvs	0x00697461
    1848:	6d00736e 	stcvs	3, cr7, [r0, #-440]	; 0xfffffe48
		return;
    184c:	695f6474 	ldmdbvs	pc, {r2, r4, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
    1850:	006f666e 	rsbeq	r6, pc, lr, ror #12
	}

	size = fdt_totalsize(initial_boot_params);
	dt = early_init_dt_alloc_memory_arch(size,
    1854:	76737973 			; <UNDEFINED> instruction: 0x76737973
    1858:	006d6573 	rsbeq	r6, sp, r3, ror r5
    185c:	696d696c 	stmdbvs	sp!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    1860:	65730074 	ldrbvs	r0, [r3, #-116]!	; 0xffffff8c
    1864:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1868:	5f646c69 	svcpl	0x00646c69
					     roundup_pow_of_two(FDT_V17_SIZE));

	if (dt) {
    186c:	00646974 	rsbeq	r6, r4, r4, ror r9
    1870:	755f6169 	ldrbvc	r6, [pc, #-361]	; 170f <.debug_str+0x170f>
		memcpy(dt, initial_boot_params, size);
    1874:	68006469 	stmdavs	r0, {r0, r3, r5, r6, sl, sp, lr}
    1878:	69647261 	stmdbvs	r4!, {r0, r5, r6, r9, ip, sp, lr}^
    187c:	655f7172 	ldrbvs	r7, [pc, #-370]	; 1712 <.debug_str+0x1712>
		initial_boot_params = dt;
    1880:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
	}
	unflatten_device_tree();
    1884:	70695f65 	rsbvc	r5, r9, r5, ror #30
    1888:	725f6900 	subsvc	r6, pc, #0, 18
    188c:	00766564 	rsbseq	r6, r6, r4, ror #10
    1890:	6b636974 	blvs	18dbe68 <unflatten_and_copy_device_tree+0x18daff4>
    1894:	00737465 	rsbseq	r7, r3, r5, ror #8
    1898:	7265746b 	rsbvc	r7, r5, #1795162112	; 0x6b000000
    189c:	736f696d 	cmnvc	pc, #1785856	; 0x1b4000
    18a0:	695f6400 	ldmdbvs	pc, {sl, sp, lr}^	; <UNPREDICTABLE>
    18a4:	775f6f6e 	ldrbvc	r6, [pc, -lr, ror #30]
    18a8:	736e7261 	cmnvc	lr, #268435462	; 0x10000006
    18ac:	616d6d00 	cmnvs	sp, r0, lsl #26
    18b0:	656c5f70 	strbvs	r5, [ip, #-3952]!	; 0xfffff090
    18b4:	79636167 	stmdbvc	r3!, {r0, r1, r2, r5, r6, r8, sp, lr}^
    18b8:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005
    18bc:	65720065 	ldrbvs	r0, [r2, #-101]!	; 0xffffff9b
    18c0:	745f6c61 	ldrbvc	r6, [pc], #-3169	; 18c8 <.debug_str+0x18c8>
    18c4:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    18c8:	63636100 	cmnvs	r3, #0, 2
    18cc:	00737365 	rsbseq	r7, r3, r5, ror #6
    18d0:	5f78616d 	svcpl	0x0078616d
    18d4:	666f6770 			; <UNDEFINED> instruction: 0x666f6770
    18d8:	6f660066 	svcvs	0x00660066
    18dc:	5f656372 	svcpl	0x00656372
    18e0:	6d6f7461 	cfstrdvs	mvd7, [pc, #-388]!	; 1764 <.debug_str+0x1764>
    18e4:	4e006369 	cdpmi	3, 0, cr6, cr0, cr9, {3}
    18e8:	48535f52 	ldmdami	r3, {r1, r4, r6, r8, r9, sl, fp, ip, lr}^
    18ec:	004d454d 	subeq	r4, sp, sp, asr #10
    18f0:	65636572 	strbvs	r6, [r3, #-1394]!	; 0xfffffa8e
    18f4:	5f657669 	svcpl	0x00657669
    18f8:	00667562 	rsbeq	r7, r6, r2, ror #10
    18fc:	665f666f 	ldrbvs	r6, [pc], -pc, ror #12
    1900:	5f74616c 	svcpl	0x0074616c
    1904:	675f7464 	ldrbvs	r7, [pc, -r4, ror #8]
    1908:	6d5f7465 	cfldrdvs	mvd7, [pc, #-404]	; 177c <.debug_str+0x177c>
    190c:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
    1910:	6e5f656e 	cdpvs	5, 5, cr6, cr15, cr14, {3}
    1914:	00656d61 	rsbeq	r6, r5, r1, ror #26
    1918:	746f6f72 	strbtvc	r6, [pc], #-3954	; 1920 <.debug_str+0x1920>
    191c:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    1920:	65720074 	ldrbvs	r0, [r2, #-116]!	; 0xffffff8c
    1924:	645f6461 	ldrbvs	r6, [pc], #-1121	; 192c <.debug_str+0x192c>
    1928:	6b6c6271 	blvs	1b1a2f4 <unflatten_and_copy_device_tree+0x1b19480>
    192c:	5f667100 	svcpl	0x00667100
    1930:	656e776f 	strbvs	r7, [lr, #-1903]!	; 0xfffff891
    1934:	5f640072 	svcpl	0x00640072
    1938:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    193c:	00657261 	rsbeq	r7, r5, r1, ror #4
    1940:	69707865 	ldmdbvs	r0!, {r0, r2, r5, r6, fp, ip, sp, lr}^
    1944:	5f007972 	svcpl	0x00007972
    1948:	7265766f 	rsbvc	r7, r5, #116391936	; 0x6f00000
    194c:	006e7572 	rsbeq	r7, lr, r2, ror r5
    1950:	705f6f6e 	subsvc	r6, pc, lr, ror #30
    1954:	746e6972 	strbtvc	r6, [lr], #-2418	; 0xfffff68e
    1958:	6164006b 	cmnvs	r4, fp, rrx
    195c:	656c6174 	strbvs	r6, [ip, #-372]!	; 0xfffffe8c
    1960:	7371006e 	cmnvc	r1, #110	; 0x6e
    1964:	64007274 	strvs	r7, [r0], #-628	; 0xfffffd8c
    1968:	695f6271 	ldmdbvs	pc, {r0, r4, r5, r6, r9, sp, lr}^	; <UNPREDICTABLE>
    196c:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xfffff08d
    1970:	696d696c 	stmdbvs	sp!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    1974:	69680074 	stmdbvs	r8!, {r2, r4, r5, r6}^
    1978:	6200746e 	andvs	r7, r0, #1845493760	; 0x6e000000
    197c:	65737469 	ldrbvs	r7, [r3, #-1129]!	; 0xfffffb97
    1980:	67740074 			; <UNDEFINED> instruction: 0x67740074
    1984:	64006469 	strvs	r6, [r0], #-1129	; 0xfffffb97
    1988:	6275735f 	rsbsvs	r7, r5, #2080374785	; 0x7c000001
    198c:	73726964 	cmnvc	r2, #100, 18	; 0x190000
    1990:	725f6600 	subsvc	r6, pc, #0, 12
    1994:	65680061 	strbvs	r0, [r8, #-97]!	; 0xffffff9f
    1998:	73615f78 	cmnvc	r1, #120, 30	; 0x1e0
    199c:	524e0063 	subpl	r0, lr, #99	; 0x63
    19a0:	5f4d565f 	svcpl	0x004d565f
    19a4:	4e455645 	cdpmi	6, 4, cr5, cr5, cr5, {2}
    19a8:	54495f54 	strbpl	r5, [r9], #-3924	; 0xfffff0ac
    19ac:	00534d45 	subseq	r4, r3, r5, asr #26
    19b0:	695f6462 	ldmdbvs	pc, {r1, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
    19b4:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    19b8:	63720073 	cmnvs	r2, #115	; 0x73
    19bc:	79735f75 	ldmdbvc	r3!, {r0, r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    19c0:	745f636e 	ldrbvc	r6, [pc], #-878	; 19c8 <.debug_str+0x19c8>
    19c4:	00657079 	rsbeq	r7, r5, r9, ror r0
    19c8:	656e6f7a 	strbvs	r6, [lr, #-3962]!	; 0xfffff086
    19cc:	6174735f 	cmnvs	r4, pc, asr r3
    19d0:	705f7472 	subsvc	r7, pc, r2, ror r4	; <UNPREDICTABLE>
    19d4:	65006e66 	strvs	r6, [r0, #-3686]	; 0xfffff19a
    19d8:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
    19dc:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    19e0:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
    19e4:	6c6c615f 	stfvse	f6, [ip], #-380	; 0xfffffe84
    19e8:	6d5f636f 	ldclvs	3, cr6, [pc, #-444]	; 1834 <.debug_str+0x1834>
    19ec:	726f6d65 	rsbvc	r6, pc, #6464	; 0x1940
    19f0:	72615f79 	rsbvc	r5, r1, #484	; 0x1e4
    19f4:	73006863 	movwvc	r6, #2147	; 0x863
    19f8:	61685f61 	cmnvs	r8, r1, ror #30
    19fc:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0xfffffb92
    1a00:	72660072 	rsbvc	r0, r6, #114	; 0x72
    1a04:	61706565 	cmnvs	r0, r5, ror #10
    1a08:	64006567 	strvs	r6, [r0], #-1383	; 0xfffffa99
    1a0c:	6e616d5f 	mcrvs	13, 3, r6, cr1, cr15, {2}
    1a10:	00656761 	rsbeq	r6, r5, r1, ror #14
    1a14:	65707573 	ldrbvs	r7, [r0, #-1395]!	; 0xfffffa8d
    1a18:	6c625f72 	stclvs	15, cr5, [r2], #-456	; 0xfffffe38
    1a1c:	006b636f 	rsbeq	r6, fp, pc, ror #6
    1a20:	72666e75 	rsbvc	r6, r6, #1872	; 0x750
    1a24:	657a6565 	ldrbvs	r6, [sl, #-1381]!	; 0xfffffa9b
    1a28:	0073665f 	rsbseq	r6, r3, pc, asr r6
    1a2c:	74737973 	ldrbtvc	r7, [r3], #-2419	; 0xfffff68d
    1a30:	775f6d65 	ldrbvc	r6, [pc, -r5, ror #26]
    1a34:	5f690071 	svcpl	0x00690071
    1a38:	6c5f6f69 	mrrcvs	15, 6, r6, pc, cr9	; <UNPREDICTABLE>
    1a3c:	00747369 	rsbseq	r7, r4, r9, ror #6
    1a40:	705f6c66 	subsvc	r6, pc, r6, ror #24
    1a44:	66006469 	strvs	r6, [r0], -r9, ror #8
    1a48:	6c665f65 	stclvs	15, cr5, [r6], #-404	; 0xfffffe6c
    1a4c:	00736761 	rsbseq	r6, r3, r1, ror #14
    1a50:	6c5f726e 	lfmvs	f7, 2, [pc], {110}	; 0x6e
    1a54:	65766165 	ldrbvs	r6, [r6, #-357]!	; 0xfffffe9b
    1a58:	6e6f5f73 	mcrvs	15, 3, r5, cr15, cr3, {3}
    1a5c:	6572745f 	ldrbvs	r7, [r2, #-1119]!	; 0xfffffba1
    1a60:	69730065 	ldmdbvs	r3!, {r0, r2, r5, r6}^
    1a64:	6e616867 	cdpvs	8, 6, cr6, cr1, cr7, {3}
    1a68:	74735f64 	ldrbtvc	r5, [r3], #-3940	; 0xfffff09c
    1a6c:	74637572 	strbtvc	r7, [r3], #-1394	; 0xfffffa8e
    1a70:	765f7300 	ldrbvc	r7, [pc], -r0, lsl #6
    1a74:	725f7366 	subsvc	r7, pc, #-1744830463	; 0x98000001
    1a78:	6d616e65 	stclvs	14, cr6, [r1, #-404]!	; 0xfffffe6c
    1a7c:	756d5f65 	strbvc	r5, [sp, #-3941]!	; 0xfffff09b
    1a80:	00786574 	rsbseq	r6, r8, r4, ror r5
    1a84:	6f72705f 	svcvs	0x0072705f
    1a88:	6e695f63 	cdpvs	15, 6, cr5, cr9, cr3, {3}
    1a8c:	4e007469 	cdpmi	4, 0, cr7, cr0, cr9, {3}
    1a90:	4e495f52 	mcrmi	15, 2, r5, cr9, cr2, {2}
    1a94:	49544341 	ldmdbmi	r4, {r0, r6, r8, r9, lr}^
    1a98:	465f4556 			; <UNDEFINED> instruction: 0x465f4556
    1a9c:	00454c49 	subeq	r4, r5, r9, asr #24
    1aa0:	63727473 	cmnvs	r2, #1929379840	; 0x73000000
    1aa4:	63657361 	cmnvs	r5, #-2080374783	; 0x84000001
    1aa8:	6900706d 	stmdbvs	r0, {r0, r2, r3, r5, r6, ip, sp, lr}
    1aac:	6f6c625f 	svcvs	0x006c625f
    1ab0:	00736b63 	rsbseq	r6, r3, r3, ror #22
    1ab4:	76737973 			; <UNDEFINED> instruction: 0x76737973
    1ab8:	006d6873 	rsbeq	r6, sp, r3, ror r8
    1abc:	6576656c 	ldrbvs	r6, [r6, #-1388]!	; 0xfffffa94
    1ac0:	6462006c 	strbtvs	r0, [r2], #-108	; 0xffffff94
    1ac4:	6e6f635f 	mcrvs	3, 3, r6, cr15, cr15, {2}
    1ac8:	6e696174 	mcrvs	1, 3, r6, cr9, cr4, {3}
    1acc:	6f6d0073 	svcvs	0x006d0073
    1ad0:	656c7564 	strbvs	r7, [ip, #-1380]!	; 0xfffffa9c
    1ad4:	65726600 	ldrbvs	r6, [r2, #-1536]!	; 0xfffffa00
    1ad8:	72615f65 	rsbvc	r5, r1, #404	; 0x194
    1adc:	73006165 	movwvc	r6, #357	; 0x165
    1ae0:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    1ae4:	6464615f 	strbtvs	r6, [r4], #-351	; 0xfffffea1
    1ae8:	7665755f 			; <UNDEFINED> instruction: 0x7665755f
    1aec:	5f746e65 	svcpl	0x00746e65
    1af0:	746e6573 	strbtvc	r6, [lr], #-1395	; 0xfffffa8d
    1af4:	65786500 	ldrbvs	r6, [r8, #-1280]!	; 0xfffffb00
    1af8:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    1afc:	70670065 	rsbvc	r0, r7, r5, rrx
    1b00:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    1b04:	72700074 	rsbsvc	r0, r0, #116	; 0x74
    1b08:	6c6c6165 	stfvse	f6, [ip], #-404	; 0xfffffe6c
    1b0c:	5500636f 	strpl	r6, [r0, #-879]	; 0xfffffc91
    1b10:	4b534154 	blmi	14d2068 <unflatten_and_copy_device_tree+0x14d11f4>
    1b14:	5453535f 	ldrbpl	r5, [r3], #-863	; 0xfffffca1
    1b18:	545f5045 	ldrbpl	r5, [pc], #-69	; 1b20 <.debug_str+0x1b20>
    1b1c:	50504152 	subspl	r4, r0, r2, asr r1
    1b20:	73004445 	movwvc	r4, #1093	; 0x445
    1b24:	695f7465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    1b28:	006f666e 	rsbeq	r6, pc, lr, ror #12
    1b2c:	64697075 	strbtvs	r7, [r9], #-117	; 0xffffff8b
    1b30:	72656b00 	rsbvc	r6, r5, #0, 22
    1b34:	5f73666e 	svcpl	0x0073666e
    1b38:	6e65706f 	cdpvs	0, 6, cr7, cr5, cr15, {3}
    1b3c:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 1b44 <.debug_str+0x1b44>
    1b40:	726f0065 	rsbvc	r0, pc, #101	; 0x65
    1b44:	00726564 	rsbseq	r6, r2, r4, ror #10
    1b48:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    1b4c:	36755f65 	ldrbtcc	r5, [r5], -r5, ror #30
    1b50:	72700034 	rsbsvc	r0, r0, #52	; 0x34
    1b54:	7365636f 	cmnvc	r5, #-1140850687	; 0xbc000001
    1b58:	00736573 	rsbseq	r6, r3, r3, ror r5
    1b5c:	655f6c66 	ldrbvs	r6, [pc, #-3174]	; efe <.debug_str+0xefe>
    1b60:	6800646e 	stmdavs	r0, {r1, r2, r3, r5, r6, sl, sp, lr}
    1b64:	6d697472 	cfstrdvs	mvd7, [r9, #-456]!	; 0xfffffe38
    1b68:	625f7265 	subsvs	r7, pc, #1342177286	; 0x50000006
    1b6c:	5f657361 	svcpl	0x00657361
    1b70:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    1b74:	79747400 	ldmdbvc	r4!, {sl, ip, sp, lr}^
    1b78:	69646c5f 	stmdbvs	r4!, {r0, r1, r2, r3, r4, r6, sl, fp, sp, lr}^
    1b7c:	48006373 	stmdami	r0, {r0, r1, r4, r5, r6, r8, r9, sp, lr}
    1b80:	4f535f49 	svcmi	0x00535f49
    1b84:	52495446 	subpl	r5, r9, #1174405120	; 0x46000000
    1b88:	69620051 	stmdbvs	r2!, {r0, r4, r6}^
    1b8c:	74615f6e 	strbtvc	r5, [r1], #-3950	; 0xfffff092
    1b90:	66007274 			; <UNDEFINED> instruction: 0x66007274
    1b94:	6873756c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
    1b98:	696e6900 	stmdbvs	lr!, {r8, fp, sp, lr}^
    1b9c:	5f647274 	svcpl	0x00647274
    1ba0:	6f6c6562 	svcvs	0x006c6562
    1ba4:	74735f77 	ldrbtvc	r5, [r3], #-3959	; 0xfffff089
    1ba8:	5f747261 	svcpl	0x00747261
    1bac:	66006b6f 	strvs	r6, [r0], -pc, ror #22
    1bb0:	65725f6c 	ldrbvs	r5, [r2, #-3948]!	; 0xfffff094
    1bb4:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000
    1bb8:	72705f65 	rsbsvc	r5, r0, #404	; 0x194
    1bbc:	74617669 	strbtvc	r7, [r1], #-1641	; 0xfffff997
    1bc0:	61700065 	cmnvs	r0, r5, rrx
    1bc4:	61666567 	cmnvs	r6, r7, ror #10
    1bc8:	5f746c75 	svcpl	0x00746c75
    1bcc:	61736964 	cmnvs	r3, r4, ror #18
    1bd0:	64656c62 	strbtvs	r6, [r5], #-3170	; 0xfffff39e
    1bd4:	616d6d00 	cmnvs	sp, r0, lsl #26
    1bd8:	64657070 	strbtvs	r7, [r5], #-112	; 0xffffff90
    1bdc:	5f524e00 	svcpl	0x00524e00
    1be0:	434f4c4d 	movtmi	r4, #64589	; 0xfc4d
    1be4:	6566004b 	strbvs	r0, [r6, #-75]!	; 0xffffffb5
    1be8:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
    1bec:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
    1bf0:	75660064 	strbvc	r0, [r6, #-100]!	; 0xffffff9c
    1bf4:	7000636e 	andvc	r6, r0, lr, ror #6
    1bf8:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    1bfc:	74730074 	ldrbtvc	r0, [r3], #-116	; 0xffffff8c
    1c00:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1c04:	6a616d00 	bvs	185d00c <unflatten_and_copy_device_tree+0x185c198>
    1c08:	746c665f 	strbtvc	r6, [ip], #-1631	; 0xfffff9a1
    1c0c:	645f6900 	ldrbvs	r6, [pc], #-2304	; 1c14 <.debug_str+0x1c14>
    1c10:	75616665 	strbvc	r6, [r1, #-1637]!	; 0xfffff99b
    1c14:	615f746c 	cmpvs	pc, ip, ror #8
    1c18:	73006c63 	movwvc	r6, #3171	; 0xc63
    1c1c:	6c6c616d 	stfvse	f6, [ip], #-436	; 0xfffffe4c
    1c20:	6f6c625f 	svcvs	0x006c625f
    1c24:	6f006b63 	svcvs	0x00006b63
    1c28:	72656e77 	rsbvc	r6, r5, #1904	; 0x770
    1c2c:	63617000 	cmnvs	r1, #0
    1c30:	735f7463 	cmpvc	pc, #1660944384	; 0x63000000
    1c34:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    1c38:	73750074 	cmnvc	r5, #116	; 0x74
    1c3c:	6e5f7265 	cdpvs	2, 5, cr7, cr15, cr5, {3}
    1c40:	71640073 	smcvc	16387	; 0x4003
    1c44:	666f6e6f 	strbtvs	r6, [pc], -pc, ror #28
    1c48:	756d5f66 	strbvc	r5, [sp, #-3942]!	; 0xfffff09a
    1c4c:	00786574 	rsbseq	r6, r8, r4, ror r5
    1c50:	54534750 	ldrbpl	r4, [r3], #-1872	; 0xfffff8b0
    1c54:	5f4c4145 	svcpl	0x004c4145
    1c58:	45524944 	ldrbmi	r4, [r2, #-2372]	; 0xfffff6bc
    1c5c:	4d5f5443 	cfldrdmi	mvd5, [pc, #-268]	; 1b58 <.debug_str+0x1b58>
    1c60:	4241564f 	submi	r5, r1, #82837504	; 0x4f00000
    1c64:	4d00454c 	cfstr32mi	mvfx4, [r0, #-304]	; 0xfffffed0
    1c68:	41524749 	cmpmi	r2, r9, asr #14
    1c6c:	505f4554 	subspl	r4, pc, r4, asr r5	; <UNPREDICTABLE>
    1c70:	59545043 	ldmdbpl	r4, {r0, r1, r6, ip, lr}^
    1c74:	00534550 	subseq	r4, r3, r0, asr r5
    1c78:	76657270 			; <UNDEFINED> instruction: 0x76657270
    1c7c:	0070705f 	rsbseq	r7, r0, pc, asr r0
    1c80:	63725f69 	cmnvs	r2, #420	; 0x1a4
    1c84:	66710075 			; <UNDEFINED> instruction: 0x66710075
    1c88:	73706f5f 	cmnvc	r0, #380	; 0x17c
    1c8c:	74746100 	ldrbtvc	r6, [r4], #-256	; 0xffffff00
    1c90:	666f0072 			; <UNDEFINED> instruction: 0x666f0072
    1c94:	656d5f66 	strbvs	r5, [sp, #-3942]!	; 0xfffff09a
    1c98:	73725f6d 	cmnvc	r2, #436	; 0x1b4
    1c9c:	70616d76 	rsbvc	r6, r1, r6, ror sp
    1ca0:	52535500 	subspl	r5, r3, #0, 10
    1ca4:	544f5551 	strbpl	r5, [pc], #-1361	; 1cac <.debug_str+0x1cac>
    1ca8:	716d0041 	cmnvc	sp, r1, asr #32
    1cac:	7479625f 	ldrbtvc	r6, [r9], #-607	; 0xfffffda1
    1cb0:	74007365 	strvc	r7, [r0], #-869	; 0xfffffc9b
    1cb4:	6d636f69 	stclvs	15, cr6, [r3, #-420]!	; 0xfffffe5c
    1cb8:	00746567 	rsbseq	r6, r4, r7, ror #10
    1cbc:	666f5f63 	strbtvs	r5, [pc], -r3, ror #30
    1cc0:	0067616c 	rsbeq	r6, r7, ip, ror #2
    1cc4:	6167656c 	cmnvs	r7, ip, ror #10
    1cc8:	6d5f7963 	ldclvs	9, cr7, [pc, #-396]	; 1b44 <.debug_str+0x1b44>
    1ccc:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    1cd0:	5f627200 	svcpl	0x00627200
    1cd4:	74627573 	strbtvc	r7, [r2], #-1395	; 0xfffffa8d
    1cd8:	5f656572 	svcpl	0x00656572
    1cdc:	00706167 	rsbseq	r6, r0, r7, ror #2
    1ce0:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    1ce4:	646e756f 	strbtvs	r7, [lr], #-1391	; 0xfffffa91
    1ce8:	64726f5f 	ldrbtvs	r6, [r2], #-3935	; 0xfffff0a1
    1cec:	66007265 	strvs	r7, [r0], -r5, ror #4
    1cf0:	6f635f6c 	svcvs	0x00635f6c
    1cf4:	6c5f7970 	mrrcvs	9, 7, r7, pc, cr0	; <UNPREDICTABLE>
    1cf8:	006b636f 	rsbeq	r6, fp, pc, ror #6
    1cfc:	665f696b 	ldrbvs	r6, [pc], -fp, ror #18
    1d00:	7367616c 	cmnvc	r7, #108, 2
    1d04:	76617300 	strbtvc	r7, [r1], -r0, lsl #6
    1d08:	745f6465 	ldrbvc	r6, [pc], #-1125	; 1d10 <.debug_str+0x1d10>
    1d0c:	5f706172 	svcpl	0x00706172
    1d10:	77006f6e 	strvc	r6, [r0, -lr, ror #30]
    1d14:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    1d18:	5f6c6600 	svcpl	0x006c6600
    1d1c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    1d20:	63726100 	cmnvs	r2, #0, 2
    1d24:	68705f68 	ldmdavs	r0!, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    1d28:	745f7379 	ldrbvc	r7, [pc], #-889	; 1d30 <.debug_str+0x1d30>
    1d2c:	64695f6f 	strbtvs	r5, [r9], #-3951	; 0xfffff091
    1d30:	5f70616d 	svcpl	0x0070616d
    1d34:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1d38:	61007465 	tstvs	r0, r5, ror #8
    1d3c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    1d40:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    1d44:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    1d48:	64615f6b 	strbtvs	r5, [r1], #-3947	; 0xfffff095
    1d4c:	74730064 	ldrbtvc	r0, [r3], #-100	; 0xffffff9c
    1d50:	73656d69 	cmnvc	r5, #6720	; 0x1a40
    1d54:	656c6163 	strbvs	r6, [ip, #-355]!	; 0xfffffe9d
    1d58:	72680064 	rsbvc	r0, r8, #100	; 0x64
    1d5c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    1d60:	65725f72 	ldrbvs	r5, [r2, #-3954]!	; 0xfffff08e
    1d64:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    1d68:	6c660074 	stclvs	0, cr0, [r6], #-464	; 0xfffffe30
    1d6c:	6f6c5f63 	svcvs	0x006c5f63
    1d70:	73006b63 	movwvc	r6, #2915	; 0xb63
    1d74:	5f6e6163 	svcpl	0x006e6163
    1d78:	656a626f 	strbvs	r6, [sl, #-623]!	; 0xfffffd91
    1d7c:	00737463 	rsbseq	r7, r3, r3, ror #8
    1d80:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
    1d84:	735f6c65 	cmpvc	pc, #25856	; 0x6500
    1d88:	6f626d79 	svcvs	0x00626d79
    1d8c:	7470006c 	ldrbtvc	r0, [r0], #-108	; 0xffffff94
    1d90:	00745f65 	rsbseq	r5, r4, r5, ror #30
    1d94:	49545248 	ldmdbmi	r4, {r3, r6, r9, ip, lr}^
    1d98:	5f52454d 	svcpl	0x0052454d
    1d9c:	54534552 	ldrbpl	r4, [r3], #-1362	; 0xfffffaae
    1da0:	00545241 	subseq	r5, r4, r1, asr #4
    1da4:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    1da8:	71645f65 	cmnvc	r4, r5, ror #30
    1dac:	00746f75 	rsbseq	r6, r4, r5, ror pc
    1db0:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
    1db4:	6f5f7366 	svcvs	0x005f7366
    1db8:	5f6e6570 	svcpl	0x006e6570
    1dbc:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    1dc0:	5f756600 	svcpl	0x00756600
    1dc4:	73696c6c 	cmnvc	r9, #108, 24	; 0x6c00
    1dc8:	6e690074 	mcrvs	0, 3, r0, cr9, cr4, {3}
    1dcc:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    1dd0:	615f6576 	cmpvs	pc, r6, ror r5	; <UNPREDICTABLE>
    1dd4:	66006567 	strvs	r6, [r0], -r7, ror #10
    1dd8:	5f656c69 	svcpl	0x00656c69
    1ddc:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1de0:	61007465 	tstvs	r0, r5, ror #8
    1de4:	65726464 	ldrbvs	r6, [r2, #-1124]!	; 0xfffffb9c
    1de8:	735f7373 	cmpvc	pc, #-872415231	; 0xcc000001
    1dec:	65636170 	strbvs	r6, [r3, #-368]!	; 0xfffffe90
    1df0:	65706f5f 	ldrbvs	r6, [r0, #-3935]!	; 0xfffff0a1
    1df4:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
    1df8:	00736e6f 	rsbseq	r6, r3, pc, ror #28
    1dfc:	746c6966 	strbtvc	r6, [ip], #-2406	; 0xfffff69a
    1e00:	70007265 	andvc	r7, r0, r5, ror #4
    1e04:	696d7265 	stmdbvs	sp!, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1e08:	6f697373 	svcvs	0x00697373
    1e0c:	5f69006e 	svcpl	0x0069006e
    1e10:	00646967 	rsbeq	r6, r4, r7, ror #18
    1e14:	68746e75 	ldmdavs	r4!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
    1e18:	74746f72 	ldrbtvc	r6, [r4], #-3954	; 0xfffff08e
    1e1c:	7600656c 	strvc	r6, [r0], -ip, ror #10
    1e20:	72705f6d 	rsbsvc	r5, r0, #436	; 0x1b4
    1e24:	73007665 	movwvc	r7, #1637	; 0x665
    1e28:	6f5f7165 	svcvs	0x005f7165
    1e2c:	61726570 	cmnvs	r2, r0, ror r5
    1e30:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1e34:	6f700073 	svcvs	0x00700073
    1e38:	7963696c 	stmdbvc	r3!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    1e3c:	6f5f6100 	svcvs	0x005f6100
    1e40:	63007370 	movwvs	r7, #880	; 0x370
    1e44:	6e656c70 	mcrvs	12, 3, r6, cr5, cr0, {3}
    1e48:	5f706700 	svcpl	0x00706700
    1e4c:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    1e50:	6e630074 	mcrvs	0, 3, r0, cr3, cr4, {3}
    1e54:	73637669 	cmnvc	r3, #110100480	; 0x6900000
    1e58:	72740077 	rsbsvc	r0, r4, #119	; 0x77
    1e5c:	00656361 	rsbeq	r6, r5, r1, ror #6
    1e60:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    1e64:	5f455441 	svcpl	0x00455441
    1e68:	4c434552 	cfstr64mi	mvdx4, [r3], {82}	; 0x52
    1e6c:	414d4941 	cmpmi	sp, r1, asr #18
    1e70:	00454c42 	subeq	r4, r5, r2, asr #24
    1e74:	73676973 	cmnvc	r7, #1884160	; 0x1cc000
    1e78:	745f7465 	ldrbvc	r7, [pc], #-1125	; 1e80 <.debug_str+0x1e80>
    1e7c:	735f5f00 	cmpvc	pc, #0, 30
    1e80:	70757465 	rsbsvc	r7, r5, r5, ror #8
    1e84:	7465735f 	strbtvc	r7, [r5], #-863	; 0xfffffca1
    1e88:	6f5f7075 	svcvs	0x005f7075
    1e8c:	61655f66 	cmnvs	r5, r6, ror #30
    1e90:	63796c72 	cmnvs	r9, #29184	; 0x7200
    1e94:	73006e6f 	movwvc	r6, #3695	; 0xe6f
    1e98:	735f7165 	cmpvc	pc, #1073741849	; 0x40000019
    1e9c:	00776f68 	rsbseq	r6, r7, r8, ror #30
    1ea0:	66726570 			; <UNDEFINED> instruction: 0x66726570
    1ea4:	6576655f 	ldrbvs	r6, [r6, #-1375]!	; 0xfffffaa1
    1ea8:	745f746e 	ldrbvc	r7, [pc], #-1134	; 1eb0 <.debug_str+0x1eb0>
    1eac:	5f6b7361 	svcpl	0x006b7361
    1eb0:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
    1eb4:	00747865 	rsbseq	r7, r4, r5, ror #16
    1eb8:	6464615f 	strbtvs	r6, [r4], #-351	; 0xfffffea1
    1ebc:	6e625f72 	mcrvs	15, 3, r5, cr2, cr2, {3}
    1ec0:	75620064 	strbvc	r0, [r2, #-100]!	; 0xffffff9c
    1ec4:	766f5f66 	strbtvc	r5, [pc], -r6, ror #30
    1ec8:	75727265 	ldrbvc	r7, [r2, #-613]!	; 0xfffffd9b
    1ecc:	7470006e 	ldrbtvc	r0, [r0], #-110	; 0xffffff92
    1ed0:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    1ed4:	746e655f 	strbtvc	r6, [lr], #-1375	; 0xfffffaa1
    1ed8:	6b007972 	blvs	204a8 <unflatten_and_copy_device_tree+0x1f634>
    1edc:	6f635f69 	svcvs	0x00635f69
    1ee0:	656c706d 	strbvs	r7, [ip, #-109]!	; 0xffffff93
    1ee4:	72006574 	andvc	r6, r0, #116, 10	; 0x1d000000
    1ee8:	5f6c6165 	svcpl	0x006c6165
    1eec:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    1ef0:	0064656b 	rsbeq	r6, r4, fp, ror #10
    1ef4:	735f7772 	cmpvc	pc, #29884416	; 0x1c80000
    1ef8:	6f006d65 	svcvs	0x00006d65
    1efc:	70635f6e 	rsbvc	r5, r3, lr, ror #30
    1f00:	64700075 	ldrbtvs	r0, [r0], #-117	; 0xffffff8b
    1f04:	68746165 	ldmdavs	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    1f08:	6769735f 			; <UNDEFINED> instruction: 0x6769735f
    1f0c:	006c616e 	rsbeq	r6, ip, lr, ror #2
    1f10:	76697270 			; <UNDEFINED> instruction: 0x76697270
    1f14:	5f657461 	svcpl	0x00657461
    1f18:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    1f1c:	55435200 	strbpl	r5, [r3, #-512]	; 0xfffffe00
    1f20:	5f48425f 	svcpl	0x0048425f
    1f24:	434e5953 	movtmi	r5, #59731	; 0xe953
    1f28:	5f627200 	svcpl	0x00627200
    1f2c:	74627573 	strbtvc	r7, [r2], #-1395	; 0xfffffa8d
    1f30:	5f656572 	svcpl	0x00656572
    1f34:	7473616c 	ldrbtvc	r6, [r3], #-364	; 0xfffffe94
    1f38:	72747300 	rsbsvc	r7, r4, #0, 6
    1f3c:	7970636c 	ldmdbvc	r0!, {r2, r3, r5, r6, r8, r9, sp, lr}^
    1f40:	62757300 	rsbsvs	r7, r5, #0, 6
    1f44:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    1f48:	61657200 	cmnvs	r5, r0, lsl #4
    1f4c:	6e696c64 	cdpvs	12, 6, cr6, cr9, cr4, {3}
    1f50:	7665006b 	strbtvc	r0, [r5], -fp, rrx
    1f54:	73746e65 	cmnvc	r4, #1616	; 0x650
    1f58:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    1f5c:	47500065 	ldrbmi	r0, [r0, -r5, rrx]
    1f60:	49464552 	stmdbmi	r6, {r1, r4, r6, r8, sl, lr}^
    1f64:	4d5f4c4c 	ldclmi	12, cr4, [pc, #-304]	; 1e3c <.debug_str+0x1e3c>
    1f68:	4241564f 	submi	r5, r1, #82837504	; 0x4f00000
    1f6c:	6900454c 	stmdbvs	r0, {r2, r3, r6, r8, sl, lr}
    1f70:	6972775f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    1f74:	6f636574 	svcvs	0x00636574
    1f78:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1f7c:	665f726e 	ldrbvs	r7, [pc], -lr, ror #4
    1f80:	656c6961 	strbvs	r6, [ip, #-2401]!	; 0xfffff69f
    1f84:	696d5f64 	stmdbvs	sp!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    1f88:	74617267 	strbtvc	r7, [r1], #-615	; 0xfffffd99
    1f8c:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    1f90:	6e75725f 	mrcvs	2, 3, r7, cr5, cr15, {2}
    1f94:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
    1f98:	695f6400 	ldmdbvs	pc, {sl, sp, lr}^	; <UNPREDICTABLE>
    1f9c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    1fa0:	6d6f6f00 	stclvs	15, cr6, [pc, #-0]	; 1fa8 <.debug_str+0x1fa8>
    1fa4:	6f63735f 	svcvs	0x0063735f
    1fa8:	615f6572 	cmpvs	pc, r2, ror r5	; <UNPREDICTABLE>
    1fac:	6d5f6a64 	vldrvs	s13, [pc, #-400]	; 1e24 <.debug_str+0x1e24>
    1fb0:	74006e69 	strvc	r6, [r0], #-3689	; 0xfffff197
    1fb4:	00736761 	rsbseq	r6, r3, r1, ror #14
    1fb8:	56454e55 			; <UNDEFINED> instruction: 0x56454e55
    1fbc:	41544349 	cmpmi	r4, r9, asr #6
    1fc0:	5f454c42 	svcpl	0x00454c42
    1fc4:	4c4d4750 	mcrrmi	7, 5, r4, sp, cr0
    1fc8:	454b434f 	strbmi	r4, [fp, #-847]	; 0xfffffcb1
    1fcc:	756f0044 	strbvc	r0, [pc, #-68]!	; 1f90 <.debug_str+0x1f90>
    1fd0:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    1fd4:	7566006b 	strbvc	r0, [r6, #-107]!	; 0xffffff95
    1fd8:	6974636e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    1fdc:	73006e6f 	movwvc	r6, #3695	; 0xe6f
    1fe0:	6c66695f 	stclvs	9, cr6, [r6], #-380	; 0xfffffe84
    1fe4:	00736761 	rsbseq	r6, r3, r1, ror #14
    1fe8:	76697270 			; <UNDEFINED> instruction: 0x76697270
    1fec:	5f657461 	svcpl	0x00657461
    1ff0:	6b636f6c 	blvs	18ddda8 <unflatten_and_copy_device_tree+0x18dcf34>
    1ff4:	6f6e6900 	svcvs	0x006e6900
    1ff8:	6f5f6564 	svcvs	0x005f6564
    1ffc:	61726570 	cmnvs	r2, r0, ror r5
    2000:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2004:	49500073 	ldmdbmi	r0, {r0, r1, r4, r5, r6}^
    2008:	50595444 	subspl	r5, r9, r4, asr #8
    200c:	47505f45 	ldrbmi	r5, [r0, -r5, asr #30]
    2010:	69004449 	stmdbvs	r0, {r0, r3, r6, sl, lr}
    2014:	616d6d5f 	cmnvs	sp, pc, asr sp
    2018:	77725f70 			; <UNDEFINED> instruction: 0x77725f70
    201c:	006d6573 	rsbeq	r6, sp, r3, ror r5
    2020:	68735f73 	ldmdavs	r3!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2024:	6b6e6972 	blvs	1b9c5f4 <unflatten_and_copy_device_tree+0x1b9b780>
    2028:	6e657300 	cdpvs	3, 6, cr7, cr5, cr0, {0}
    202c:	63785f64 	cmnvs	r8, #100, 30	; 0x190
    2030:	00726168 	rsbseq	r6, r2, r8, ror #2
    2034:	745f7067 	ldrbvc	r7, [pc], #-103	; 203c <.debug_str+0x203c>
    2038:	00657079 	rsbeq	r7, r5, r9, ror r0
    203c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    2040:	65706f5f 	ldrbvs	r6, [r0, #-3935]!	; 0xfffff0a1
    2044:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
    2048:	00736e6f 	rsbseq	r6, r3, pc, ror #28
    204c:	65657266 	strbvs	r7, [r5, #-614]!	; 0xfffffd9a
    2050:	6361635f 	cmnvs	r1, #2080374785	; 0x7c000001
    2054:	5f646568 	svcpl	0x00646568
    2058:	656a626f 	strbvs	r6, [sl, #-623]!	; 0xfffffd91
    205c:	00737463 	rsbseq	r7, r3, r3, ror #8
    2060:	43534750 	cmpmi	r3, #80, 14	; 0x1400000
    2064:	445f4e41 	ldrbmi	r4, [pc], #-3649	; 206c <.debug_str+0x206c>
    2068:	43455249 	movtmi	r5, #21065	; 0x5249
    206c:	49485f54 	stmdbmi	r8, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
    2070:	73004847 	movwvc	r4, #2119	; 0x847
    2074:	6e696769 	cdpvs	7, 6, cr6, cr9, cr9, {3}
    2078:	64006f66 	strvs	r6, [r0], #-3942	; 0xfffff09a
    207c:	72747365 	rsbsvc	r7, r4, #-1811939327	; 0x94000001
    2080:	695f796f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, r8, fp, ip, sp, lr}^	; <UNPREDICTABLE>
    2084:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    2088:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
    208c:	725f6465 	subsvc	r6, pc, #1694498816	; 0x65000000
    2090:	6e655f74 	mcrvs	15, 3, r5, cr5, cr4, {3}
    2094:	79746974 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2098:	656c7300 	strbvs	r7, [ip, #-768]!	; 0xfffffd00
    209c:	6d5f7065 	ldclvs	0, cr7, [pc, #-404]	; 1f10 <.debug_str+0x1f10>
    20a0:	4d007861 	stcmi	8, cr7, [r0, #-388]	; 0xfffffe7c
    20a4:	41524749 	cmpmi	r2, r9, asr #14
    20a8:	485f4554 	ldmdami	pc, {r2, r4, r6, r8, sl, lr}^	; <UNPREDICTABLE>
    20ac:	41484749 	cmpmi	r8, r9, asr #14
    20b0:	494d4f54 	stmdbmi	sp, {r2, r4, r6, r8, r9, sl, fp, lr}^
    20b4:	6d6d0043 	stclvs	0, cr0, [sp, #-268]!	; 0xfffffef4
    20b8:	6d5f7061 	ldclvs	0, cr7, [pc, #-388]	; 1f3c <.debug_str+0x1f3c>
    20bc:	00737369 	rsbseq	r7, r3, r9, ror #6
    20c0:	5f78616d 	svcpl	0x0078616d
    20c4:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    20c8:	656c5f65 	strbvs	r5, [ip, #-3941]!	; 0xfffff09b
    20cc:	7473006e 	ldrbtvc	r0, [r3], #-110	; 0xffffff92
    20d0:	5f657461 	svcpl	0x00657461
    20d4:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    20d8:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
    20dc:	0064657a 	rsbeq	r6, r4, sl, ror r5
    20e0:	646f6d66 	strbtvs	r6, [pc], #-3430	; 20e8 <.debug_str+0x20e8>
    20e4:	00745f65 	rsbseq	r5, r4, r5, ror #30
    20e8:	645f6371 	ldrbvs	r6, [pc], #-881	; 20f0 <.debug_str+0x20f0>
    20ec:	6b6c6271 	blvs	1b1aab8 <unflatten_and_copy_device_tree+0x1b19c44>
    20f0:	74657300 	strbtvc	r7, [r5], #-768	; 0xfffffd00
    20f4:	7265745f 	rsbvc	r7, r5, #1593835520	; 0x5f000000
    20f8:	786f696d 	stmdavc	pc!, {r0, r2, r3, r5, r6, r8, fp, sp, lr}^	; <UNPREDICTABLE>
    20fc:	6b5f5f00 	blvs	17d9d04 <unflatten_and_copy_device_tree+0x17d8e90>
    2100:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    2104:	69745f6c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2108:	5f72656d 	svcpl	0x0072656d
    210c:	5f780074 	svcpl	0x00780074
    2110:	616c6673 	smcvs	50787	; 0xc663
    2114:	61770067 	cmnvs	r7, r7, rrx
    2118:	755f7469 	ldrbvc	r7, [pc, #-1129]	; 1cb7 <.debug_str+0x1cb7>
    211c:	6c69746e 	cfstrdvs	mvd7, [r9], #-440	; 0xfffffe48
    2120:	6e65735f 	mcrvs	3, 3, r7, cr5, cr15, {2}
    2124:	61750074 	cmnvs	r5, r4, ror r0
    2128:	32726464 	rsbscc	r6, r2, #100, 8	; 0x64000000
    212c:	5f646200 	svcpl	0x00646200
    2130:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    2134:	6f685f65 	svcvs	0x00685f65
    2138:	7265646c 	rsbvc	r6, r5, #108, 8	; 0x6c000000
    213c:	665f6900 	ldrbvs	r6, [pc], -r0, lsl #18
    2140:	746f6e73 	strbtvc	r6, [pc], #-3699	; 2148 <.debug_str+0x2148>
    2144:	5f796669 	svcpl	0x00796669
    2148:	6b72616d 	blvs	1c9a704 <unflatten_and_copy_device_tree+0x1c99890>
    214c:	6d760073 	ldclvs	0, cr0, [r6, #-460]!	; 0xfffffe34
    2150:	63616361 	cmnvs	r1, #-2080374783	; 0x84000001
    2154:	74006568 	strvc	r6, [r0], #-1384	; 0xfffffa98
    2158:	006c6961 	rsbeq	r6, ip, r1, ror #18
    215c:	5f766e65 	svcpl	0x00766e65
    2160:	00646e65 	rsbeq	r6, r4, r5, ror #28
    2164:	706f5f73 	rsbvc	r5, pc, r3, ror pc	; <UNPREDICTABLE>
    2168:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    216c:	79730073 	ldmdbvc	r3!, {r0, r1, r4, r5, r6}^
    2170:	735f7673 	cmpvc	pc, #120586240	; 0x7300000
    2174:	77006d65 	strvc	r6, [r0, -r5, ror #26]
    2178:	5f746961 	svcpl	0x00746961
    217c:	75657571 	strbvc	r7, [r5, #-1393]!	; 0xfffffa8f
    2180:	65685f65 	strbvs	r5, [r8, #-3941]!	; 0xfffff09b
    2184:	745f6461 	ldrbvc	r6, [pc], #-1121	; 218c <.debug_str+0x218c>
    2188:	705f6400 	subsvc	r6, pc, r0, lsl #8
    218c:	656e7572 	strbvs	r7, [lr, #-1394]!	; 0xfffffa8e
    2190:	72616d00 	rsbvc	r6, r1, #0, 26
    2194:	69645f6b 	stmdbvs	r4!, {r0, r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2198:	00797472 	rsbseq	r7, r9, r2, ror r4
    219c:	5f797474 	svcpl	0x00797474
    21a0:	76697264 	strbtvc	r7, [r9], -r4, ror #4
    21a4:	00737265 	rsbseq	r7, r3, r5, ror #4
    21a8:	43534750 	cmpmi	r3, #80, 14	; 0x1400000
    21ac:	4b5f4e41 	blmi	17d5ab8 <unflatten_and_copy_device_tree+0x17d4c44>
    21b0:	50415753 	subpl	r5, r1, r3, asr r7
    21b4:	49485f44 	stmdbmi	r8, {r2, r6, r8, r9, sl, fp, ip, lr}^
    21b8:	69004847 	stmdbvs	r0, {r0, r1, r2, r6, fp, lr}
    21bc:	65725f73 	ldrbvs	r5, [r2, #-3955]!	; 0xfffff08d
    21c0:	4154006c 	cmpmi	r4, ip, rrx
    21c4:	454c4b53 	strbmi	r4, [ip, #-2899]	; 0xfffff4ad
    21c8:	4f535f54 	svcmi	0x00535f54
    21cc:	52495446 	subpl	r5, r9, #1174405120	; 0x46000000
    21d0:	6f630051 	svcvs	0x00630051
    21d4:	745f6572 	ldrbvc	r6, [pc], #-1394	; 21dc <.debug_str+0x21dc>
    21d8:	61657268 	cmnvs	r5, r8, ror #4
    21dc:	65630064 	strbvs	r0, [r3, #-100]!	; 0xffffff9c
    21e0:	69006c6c 	stmdbvs	r0, {r2, r3, r5, r6, sl, fp, sp, lr}
    21e4:	5f72636e 	svcpl	0x0072636e
    21e8:	6f727265 	svcvs	0x00727265
    21ec:	5f5f0072 	svcpl	0x005f0072
    21f0:	6c6e5f69 	stclvs	15, cr5, [lr], #-420	; 0xfffffe5c
    21f4:	006b6e69 	rsbeq	r6, fp, r9, ror #28
    21f8:	5f766e65 	svcpl	0x00766e65
    21fc:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    2200:	63730074 	cmnvs	r3, #116	; 0x74
    2204:	5f646568 	svcpl	0x00646568
    2208:	00677661 	rsbeq	r7, r7, r1, ror #12
    220c:	6d696c72 	stclvs	12, cr6, [r9, #-456]!	; 0xfffffe38
    2210:	78616d5f 	stmdavc	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
    2214:	695f5f00 	ldmdbvs	pc, {r8, r9, sl, fp, ip, lr}^	; <UNPREDICTABLE>
    2218:	5f74696e 	svcpl	0x0074696e
    221c:	69676562 	stmdbvs	r7!, {r1, r5, r6, r8, sl, sp, lr}^
    2220:	656e006e 	strbvs	r0, [lr, #-110]!	; 0xffffff92
    2224:	66007478 			; <UNDEFINED> instruction: 0x66007478
    2228:	7461705f 	strbtvc	r7, [r1], #-95	; 0xffffffa1
    222c:	666e0068 	strbtvs	r0, [lr], -r8, rrx
    2230:	665f3473 			; <UNDEFINED> instruction: 0x665f3473
    2234:	6163006c 	cmnvs	r3, ip, rrx
    2238:	6c65636e 	stclvs	3, cr6, [r5], #-440	; 0xfffffe48
    223c:	7474615f 	ldrbtvc	r6, [r4], #-351	; 0xfffffea1
    2240:	00686361 	rsbeq	r6, r8, r1, ror #6
    2244:	6170726e 	cmnvs	r0, lr, ror #4
    2248:	00736567 	rsbseq	r6, r3, r7, ror #10
    224c:	726c5f64 	rsbvc	r5, ip, #100, 30	; 0x190
    2250:	656d0075 	strbvs	r0, [sp, #-117]!	; 0xffffff8b
    2254:	5f67636d 	svcpl	0x0067636d
    2258:	5f79616d 	svcpl	0x0079616d
    225c:	006d6f6f 	rsbeq	r6, sp, pc, ror #30
    2260:	74736564 	ldrbtvc	r6, [r3], #-1380	; 0xfffffa9c
    2264:	74637572 	strbtvc	r7, [r3], #-1394	; 0xfffffa8e
    2268:	5f726e00 	svcpl	0x00726e00
    226c:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    2270:	5f737075 	svcpl	0x00737075
    2274:	61636f6c 	cmnvs	r3, ip, ror #30
    2278:	656b006c 	strbvs	r0, [fp, #-108]!	; 0xffffff94
    227c:	65705f79 	ldrbvs	r5, [r0, #-3961]!	; 0xfffff087
    2280:	745f6d72 	ldrbvc	r6, [pc], #-3442	; 2288 <.debug_str+0x2288>
    2284:	72657000 	rsbvc	r7, r5, #0
    2288:	5f757063 	svcpl	0x00757063
    228c:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    2290:	5f726574 	svcpl	0x00726574
    2294:	63746162 	cmnvs	r4, #-2147483624	; 0x80000018
    2298:	726e0068 	rsbvc	r0, lr, #104	; 0x68
    229c:	6572665f 	ldrbvs	r6, [r2, #-1631]!	; 0xfffff9a1
    22a0:	74640065 	strbtvc	r0, [r4], #-101	; 0xffffff9b
    22a4:	6f6f725f 	svcvs	0x006f725f
    22a8:	69735f74 	ldmdbvs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    22ac:	635f657a 	cmpvs	pc, #511705088	; 0x1e800000
    22b0:	736c6c65 	cmnvc	ip, #25856	; 0x6500
    22b4:	6f727000 	svcvs	0x00727000
    22b8:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
    22bc:	7000726f 	andvc	r7, r0, pc, ror #4
    22c0:	6f697265 	svcvs	0x00697265
    22c4:	6f635f64 	svcvs	0x00635f64
    22c8:	6972746e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    22cc:	61620062 	cmnvs	r2, r2, rrx
    22d0:	5f006b63 	svcpl	0x00006b63
    22d4:	6c6f6f42 	stclvs	15, cr6, [pc], #-264	; 21d4 <.debug_str+0x21d4>
    22d8:	67656c00 	strbvs	r6, [r5, -r0, lsl #24]!
    22dc:	5f796361 	svcpl	0x00796361
    22e0:	79746663 	ldmdbvc	r4!, {r0, r1, r5, r6, r9, sl, sp, lr}^
    22e4:	00736570 	rsbseq	r6, r3, r0, ror r5
    22e8:	6967616d 	stmdbvs	r7!, {r0, r2, r3, r5, r6, r8, sp, lr}^
    22ec:	656e0063 	strbvs	r0, [lr, #-99]!	; 0xffffff9d
    22f0:	6e696c74 	mcrvs	12, 3, r6, cr9, cr4, {3}
    22f4:	736e5f6b 	cmnvc	lr, #428	; 0x1ac
    22f8:	65726600 	ldrbvs	r6, [r2, #-1536]!	; 0xfffffa00
    22fc:	73696c65 	cmnvc	r9, #25856	; 0x6500
    2300:	5f690074 	svcpl	0x00690074
    2304:	6d697461 	cfstrdvs	mvd7, [r9, #-388]!	; 0xfffffe7c
    2308:	6f7a0065 	svcvs	0x007a0065
    230c:	6600656e 	strvs	r6, [r0], -lr, ror #10
    2310:	5f656572 	svcpl	0x00656572
    2314:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    2318:	73797300 	cmnvc	r9, #0, 6
    231c:	68735f76 	ldmdavs	r3!, {r1, r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2320:	6170006d 	cmnvs	r0, sp, rrx
    2324:	746e6572 	strbtvc	r6, [lr], #-1394	; 0xfffffa8e
    2328:	6b5f5f00 	blvs	17d9f30 <unflatten_and_copy_device_tree+0x17d90bc>
    232c:	746d7973 	strbtvc	r7, [sp], #-2419	; 0xfffff68d
    2330:	6f5f6261 	svcvs	0x005f6261
    2334:	64665f66 	strbtvs	r5, [r6], #-3942	; 0xfffff09a
    2338:	6e755f74 	mrcvs	15, 3, r5, cr5, cr4, {3}
    233c:	74616c66 	strbtvc	r6, [r1], #-3174	; 0xfffff39a
    2340:	5f6e6574 	svcpl	0x006e6574
    2344:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
    2348:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 2350 <.debug_str+0x2350>
    234c:	6e756f70 	mrcvs	15, 3, r6, cr5, cr0, {3}
    2350:	74645f64 	strbtvc	r5, [r4], #-3940	; 0xfffff09c
    2354:	6d00726f 	sfmvs	f7, 4, [r0, #-444]	; 0xfffffe44
    2358:	72735f67 	rsbsvc	r5, r3, #412	; 0x19c
    235c:	67635f63 	strbvs	r5, [r3, -r3, ror #30]!
    2360:	72007072 	andvc	r7, r0, #114	; 0x72
    2364:	6b636f6c 	blvs	18de11c <unflatten_and_copy_device_tree+0x18dd2a8>
    2368:	74657300 	strbtvc	r7, [r5], #-768	; 0xfffffd00
    236c:	665f7075 			; <UNDEFINED> instruction: 0x665f7075
    2370:	00636e75 	rsbeq	r6, r3, r5, ror lr
    2374:	66765f73 	uhsub16vs	r5, r6, r3
    2378:	65725f73 	ldrbvs	r5, [r2, #-3955]!	; 0xfffff08d
    237c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    2380:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
    2384:	61656400 	cmnvs	r5, r0, lsl #8
    2388:	76697463 	strbtvc	r7, [r9], -r3, ror #8
    238c:	5f657461 	svcpl	0x00657461
    2390:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    2394:	67630071 			; <UNDEFINED> instruction: 0x67630071
    2398:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    239c:	61630074 	smcvs	12292	; 0x3004
    23a0:	73625f70 	cmnvc	r2, #112, 30	; 0x1c0
    23a4:	74007465 	strvc	r7, [r0], #-1125	; 0xfffffb9b
    23a8:	5f6b7361 	svcpl	0x006b7361
    23ac:	74757063 	ldrbtvc	r7, [r5], #-99	; 0xffffff9d
    23b0:	00656d69 	rsbeq	r6, r5, r9, ror #26
    23b4:	5f747570 	svcpl	0x00747570
    23b8:	65707573 	ldrbvs	r7, [r0, #-1395]!	; 0xfffffa8d
    23bc:	74750072 	ldrbtvc	r0, [r5], #-114	; 0xffffff8e
    23c0:	00656d69 	rsbeq	r6, r5, r9, ror #26
    23c4:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    23c8:	65746176 	ldrbvs	r6, [r4, #-374]!	; 0xfffffe8a
    23cc:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    23d0:	00797063 	rsbseq	r7, r9, r3, rrx
    23d4:	78655f73 	stmdavc	r5!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    23d8:	74726f70 	ldrbtvc	r6, [r2], #-3952	; 0xfffff090
    23dc:	00706f5f 	rsbseq	r6, r0, pc, asr pc
    23e0:	6769735f 			; <UNDEFINED> instruction: 0x6769735f
    23e4:	006c6176 	rsbeq	r6, ip, r6, ror r1
    23e8:	5f66666f 	svcpl	0x0066666f
    23ec:	735f7464 	cmpvc	pc, #100, 8	; 0x64000000
    23f0:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    23f4:	5f640074 	svcpl	0x00640074
    23f8:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    23fc:	6c630073 	stclvs	0, cr0, [r3], #-460	; 0xfffffe34
    2400:	6e69736f 	cdpvs	3, 6, cr7, cr9, cr15, {3}
    2404:	72670067 	rsbvc	r0, r7, #103	; 0x67
    2408:	5f70756f 	svcpl	0x0070756f
    240c:	6461656c 	strbtvs	r6, [r1], #-1388	; 0xfffffa94
    2410:	70007265 	andvc	r7, r0, r5, ror #4
    2414:	61775f69 	cmnvs	r7, r9, ror #30
    2418:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
    241c:	6d6c0073 	stclvs	0, cr0, [ip, #-460]!	; 0xfffffe34
    2420:	6172675f 	cmnvs	r2, pc, asr r7
    2424:	6d00746e 	cfstrsvs	mvf7, [r0, #-440]	; 0xfffffe48
    2428:	5f736d65 	svcpl	0x00736d65
    242c:	6f6c6c61 	svcvs	0x006c6c61
    2430:	00646577 	rsbeq	r6, r4, r7, ror r5
    2434:	68736168 	ldmdavs	r3!, {r3, r5, r6, r8, sp, lr}^
    2438:	6e656c5f 	mcrvs	12, 3, r6, cr5, cr15, {2}
    243c:	5f726e00 	svcpl	0x00726e00
    2440:	63726f66 	cmnvs	r2, #408	; 0x198
    2444:	6d5f6465 	cfldrdvs	mvd6, [pc, #-404]	; 22b8 <.debug_str+0x22b8>
    2448:	61726769 	cmnvs	r2, r9, ror #14
    244c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2450:	72770073 	rsbsvc	r0, r7, #115	; 0x73
    2454:	70657469 	rsbvc	r7, r5, r9, ror #8
    2458:	73656761 	cmnvc	r5, #25427968	; 0x1840000
    245c:	646f6e00 	strbtvs	r6, [pc], #-3584	; 2464 <.debug_str+0x2464>
    2460:	6f7a5f65 	svcvs	0x007a5f65
    2464:	0073656e 	rsbseq	r6, r3, lr, ror #10
    2468:	5f646163 	svcpl	0x00646163
    246c:	00646970 	rsbeq	r6, r4, r0, ror r9
    2470:	7267696d 	rsbvc	r6, r7, #1785856	; 0x1b4000
    2474:	5f657461 	svcpl	0x00657461
    2478:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
    247c:	69726400 	ldmdbvs	r2!, {sl, sp, lr}^
    2480:	73726576 	cmnvc	r2, #494927872	; 0x1d800000
    2484:	2f666f2f 	svccs	0x00666f2f
    2488:	2e746466 	cdpcs	4, 7, cr6, cr4, cr6, {3}
    248c:	65730063 	ldrbvs	r0, [r3, #-99]!	; 0xffffff9d
    2490:	61656c74 	smcvs	22212	; 0x56c4
    2494:	5f006573 	svcpl	0x00006573
    2498:	65776f6c 	ldrbvs	r6, [r7, #-3948]!	; 0xfffff094
    249c:	616c0072 	smcvs	49154	; 0xc002
    24a0:	65646e75 	strbvs	r6, [r4, #-3701]!	; 0xfffff18b
    24a4:	61705f72 	cmnvs	r0, r2, ror pc
    24a8:	77006567 	strvc	r6, [r0, -r7, ror #10]
    24ac:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    24b0:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
    24b4:	5f796d00 	svcpl	0x00796d00
    24b8:	69730071 	ldmdbvs	r3!, {r0, r4, r5, r6}^
    24bc:	666e6967 	strbtvs	r6, [lr], -r7, ror #18
    24c0:	00745f6f 	rsbseq	r5, r4, pc, ror #30
    24c4:	5f797474 	svcpl	0x00797474
    24c8:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
    24cc:	6f697461 	svcvs	0x00697461
    24d0:	6100736e 	tstvs	r0, lr, ror #6
    24d4:	616d5f63 	cmnvs	sp, r3, ror #30
    24d8:	746c666a 	strbtvc	r6, [ip], #-1642	; 0xfffff996
    24dc:	74657300 	strbtvc	r7, [r5], #-768	; 0xfffffd00
    24e0:	7265745f 	rsbvc	r7, r5, #1593835520	; 0x5f000000
    24e4:	736f696d 	cmnvc	pc, #1785856	; 0x1b4000
    24e8:	5f616600 	svcpl	0x00616600
    24ec:	6b636f6c 	blvs	18de2a4 <unflatten_and_copy_device_tree+0x18dd430>
    24f0:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
    24f4:	61745f74 	cmnvs	r4, r4, ror pc
    24f8:	5f656c62 	svcpl	0x00656c62
    24fc:	73746962 	cmnvc	r4, #1605632	; 0x188000
    2500:	635f6300 	cmpvs	pc, #0, 6
    2504:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    2508:	5f726e00 	svcpl	0x00726e00
    250c:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    2510:	6c007374 	stcvs	3, cr7, [r0], {116}	; 0x74
    2514:	5f6b636f 	svcpl	0x006b636f
    2518:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    251c:	74730074 	ldrbtvc	r0, [r3], #-116	; 0xffffff8c
    2520:	0065726f 	rsbeq	r7, r5, pc, ror #4
    2524:	645f726e 	ldrbvs	r7, [pc], #-622	; 252c <.debug_str+0x252c>
    2528:	72656665 	rsbvc	r6, r5, #105906176	; 0x6500000
    252c:	00646572 	rsbeq	r6, r4, r2, ror r5
    2530:	54535144 	ldrbpl	r5, [r3], #-324	; 0xfffffebc
    2534:	4552465f 	ldrbmi	r4, [r2, #-1631]	; 0xfffff9a1
    2538:	51445f45 	cmppl	r4, r5, asr #30
    253c:	53544f55 	cmppl	r4, #340	; 0x154
    2540:	53514400 	cmppl	r1, #0, 8
    2544:	4c415f54 	mcrrmi	15, 5, r5, r1, cr4
    2548:	5f434f4c 	svcpl	0x00434f4c
    254c:	4f555144 	svcmi	0x00555144
    2550:	4c005354 	stcmi	3, cr5, [r0], {84}	; 0x54
    2554:	495f5552 	ldmdbmi	pc, {r1, r4, r6, r8, sl, ip, lr}^	; <UNPREDICTABLE>
    2558:	5443414e 	strbpl	r4, [r3], #-334	; 0xfffffeb2
    255c:	5f455649 	svcpl	0x00455649
    2560:	454c4946 	strbmi	r4, [ip, #-2374]	; 0xfffff6ba
    2564:	5f524e00 	svcpl	0x00524e00
    2568:	54534e55 	ldrbpl	r4, [r3], #-3669	; 0xfffff1ab
    256c:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    2570:	53464e5f 	movtpl	r4, #28255	; 0x6e5f
    2574:	74726800 	ldrbtvc	r6, [r2], #-2048	; 0xfffff800
    2578:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    257c:	7570635f 	ldrbvc	r6, [r0, #-863]!	; 0xfffffca1
    2580:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005
    2584:	6f6a0065 	svcvs	0x006a0065
    2588:	616e7275 	smcvs	59173	; 0xe725
    258c:	6e695f6c 	cdpvs	15, 6, cr5, cr9, cr12, {3}
    2590:	42006f66 	andmi	r6, r0, #408	; 0x198
    2594:	4f4c4c41 	svcmi	0x004c4c41
    2598:	4d5f4e4f 	ldclmi	14, cr4, [pc, #-316]	; 2464 <.debug_str+0x2464>
    259c:	41524749 	cmpmi	r2, r9, asr #14
    25a0:	6d004554 	cfstr32vs	mvfx4, [r0, #-336]	; 0xfffffeb0
    25a4:	665f6e69 	ldrbvs	r6, [pc], -r9, ror #28
    25a8:	6500746c 	strvs	r7, [r0, #-1132]	; 0xfffffb94
    25ac:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
    25b0:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    25b4:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
    25b8:	6163735f 	cmnvs	r3, pc, asr r3
    25bc:	7674006e 	ldrbtvc	r0, [r4], -lr, rrx
    25c0:	65736e5f 	ldrbvs	r6, [r3, #-3679]!	; 0xfffff1a1
    25c4:	65730063 	ldrbvs	r0, [r3, #-99]!	; 0xffffff9d
    25c8:	71645f74 	smcvc	17908	; 0x45f4
    25cc:	006b6c62 	rsbeq	r6, fp, r2, ror #24
    25d0:	69726170 	ldmdbvs	r2!, {r4, r5, r6, r8, sp, lr}^
    25d4:	72007974 	andvc	r7, r0, #116, 18	; 0x1d0000
    25d8:	625f7563 	subsvs	r7, pc, #415236096	; 0x18c00000
    25dc:	6b636f6c 	blvs	18de394 <unflatten_and_copy_device_tree+0x18dd520>
    25e0:	6e5f6465 	cdpvs	4, 5, cr6, cr15, cr5, {3}
    25e4:	0065646f 	rsbeq	r6, r5, pc, ror #8
    25e8:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    25ec:	6200715f 	andvs	r7, r0, #-1073741801	; 0xc0000017
    25f0:	6c635f64 	stclvs	15, cr5, [r3], #-400	; 0xfffffe70
    25f4:	696d6961 	stmdbvs	sp!, {r0, r5, r6, r8, fp, sp, lr}^
    25f8:	7300676e 	movwvc	r6, #1902	; 0x76e
    25fc:	6972775f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    2600:	73726574 	cmnvc	r2, #116, 10	; 0x1d000000
    2604:	65726800 	ldrbvs	r6, [r2, #-2048]!	; 0xfffff800
    2608:	63615f73 	cmnvs	r1, #460	; 0x1cc
    260c:	65766974 	ldrbvs	r6, [r6, #-2420]!	; 0xfffff68c
    2610:	454e5500 	strbmi	r5, [lr, #-1280]	; 0xfffffb00
    2614:	54434956 	strbpl	r4, [r3], #-2390	; 0xfffff6aa
    2618:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    261c:	5347505f 	movtpl	r5, #28767	; 0x705f
    2620:	4e4e4143 	dvfmiem	f4, f6, f3
    2624:	66004445 	strvs	r4, [r0], -r5, asr #8
    2628:	616d6569 	cmnvs	sp, r9, ror #10
    262c:	78655f70 	stmdavc	r5!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2630:	746e6574 	strbtvc	r6, [lr], #-1396	; 0xfffffa8c
    2634:	64646100 	strbtvs	r6, [r4], #-256	; 0xffffff00
    2638:	72705f72 	rsbsvc	r5, r0, #456	; 0x1c8
    263c:	6d00706f 	stcvs	0, cr7, [r0, #-444]	; 0xfffffe44
    2640:	67636d65 	strbvs	r6, [r3, -r5, ror #26]!
    2644:	6d6f6f5f 	stclvs	15, cr6, [pc, #-380]!	; 24d0 <.debug_str+0x24d0>
    2648:	7066675f 	rsbvc	r6, r6, pc, asr r7
    264c:	73616d5f 	cmnvc	r1, #6080	; 0x17c0
    2650:	6173006b 	cmnvs	r3, fp, rrx
    2654:	5f646576 	svcpl	0x00646576
    2658:	76787561 	ldrbtvc	r7, [r8], -r1, ror #10
    265c:	65726600 	ldrbvs	r6, [r2, #-1536]!	; 0xfffffa00
    2660:	69665f65 	stmdbvs	r6!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    2664:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    2668:	006f666e 	rsbeq	r6, pc, lr, ror #12
    266c:	6c5f6c66 	mrrcvs	12, 6, r6, pc, cr6	; <UNPREDICTABLE>
    2670:	73706f6d 	cmnvc	r0, #436	; 0x1b4
    2674:	73736300 	cmnvc	r3, #0, 6
    2678:	6572665f 	ldrbvs	r6, [r2, #-1631]!	; 0xfffff9a1
    267c:	65720065 	ldrbvs	r0, [r2, #-101]!	; 0xffffff9b
    2680:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000
    2684:	71645f65 	cmnvc	r4, r5, ror #30
    2688:	00746f75 	rsbseq	r6, r4, r5, ror pc
    268c:	61656c63 	cmnvs	r5, r3, ror #24
    2690:	68635f72 	stmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2694:	5f646c69 	svcpl	0x00646c69
    2698:	00646974 	rsbeq	r6, r4, r4, ror r9
    269c:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	; 25e8 <.debug_str+0x25e8>
    26a0:	776c2f65 	strbvc	r2, [ip, -r5, ror #30]!
    26a4:	69742f67 	ldmdbvs	r4!, {r0, r1, r2, r5, r6, r8, r9, sl, fp, sp}^
    26a8:	6f72702d 	svcvs	0x0072702d
    26ac:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
    26b0:	732d726f 			; <UNDEFINED> instruction: 0x732d726f
    26b4:	6c2d6b64 	stcvs	11, cr6, [sp], #-400	; 0xfffffe70
    26b8:	78756e69 	ldmdavc	r5!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
    26bc:	356d612d 	strbcc	r6, [sp, #-301]!	; 0xfffffed3
    26c0:	2d787837 	ldclcs	8, cr7, [r8, #-220]!	; 0xffffff24
    26c4:	2d6d7665 	stclcs	6, cr7, [sp, #-404]!	; 0xfffffe6c
    26c8:	302e3330 	eorcc	r3, lr, r0, lsr r3
    26cc:	30302e33 	eorscc	r2, r0, r3, lsr lr
    26d0:	2d34302e 	ldccs	0, cr3, [r4, #-184]!	; 0xffffff48
    26d4:	6f622f32 	svcvs	0x00622f32
    26d8:	2d647261 	sfmcs	f7, 2, [r4, #-388]!	; 0xfffffe7c
    26dc:	70707573 	rsbsvc	r7, r0, r3, ror r5
    26e0:	2f74726f 	svccs	0x0074726f
    26e4:	756e696c 	strbvc	r6, [lr, #-2412]!	; 0xfffff694
    26e8:	2e342d78 	mrccs	13, 1, r2, cr4, cr8, {3}
    26ec:	31342e34 	teqcc	r4, r4, lsr lr
    26f0:	7469672b 	strbtvc	r6, [r9], #-1835	; 0xfffff8d5
    26f4:	4f545541 	svcmi	0x00545541
    26f8:	2b434e49 	blcs	10d6024 <unflatten_and_copy_device_tree+0x10d51b0>
    26fc:	36663966 	strbtcc	r3, [r6], -r6, ror #18
    2700:	62643066 	rsbvs	r3, r4, #102	; 0x66
    2704:	672d6432 			; <UNDEFINED> instruction: 0x672d6432
    2708:	36663966 	strbtcc	r3, [r6], -r6, ror #18
    270c:	62643066 	rsbvs	r3, r4, #102	; 0x66
    2710:	73006432 	movwvc	r6, #1074	; 0x432
    2714:	7571645f 	ldrbvc	r6, [r1, #-1119]!	; 0xfffffba1
    2718:	6c00746f 	cfstrsvs	mvf7, [r0], {111}	; 0x6f
    271c:	0064616f 	rsbeq	r6, r4, pc, ror #2
    2720:	79745f73 	ldmdbvc	r4!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2724:	69006570 	stmdbvs	r0, {r4, r5, r6, r8, sl, sp, lr}
    2728:	7874636f 	ldmdavc	r4!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    272c:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
    2730:	705f006b 	subsvc	r0, pc, fp, rrx
    2734:	64006461 	strvs	r6, [r0], #-1121	; 0xfffffb9f
    2738:	6f635f71 	svcvs	0x00635f71
    273c:	00746e75 	rsbseq	r6, r4, r5, ror lr
    2740:	6d656966 	stclvs	9, cr6, [r5, #-408]!	; 0xfffffe68
    2744:	62007061 	andvs	r7, r0, #97	; 0x61
    2748:	6b636f6c 	blvs	18de500 <unflatten_and_copy_device_tree+0x18dd68c>
    274c:	72670073 	rsbvc	r0, r7, #115	; 0x73
    2750:	635f6261 	cmpvs	pc, #268435462	; 0x10000006
    2754:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0xfffffd8b
    2758:	6e5f746e 	cdpvs	4, 5, cr7, cr15, cr14, {3}
    275c:	74620073 	strbtvc	r0, [r2], #-115	; 0xffffff8d
    2760:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    2764:	7165735f 	cmnvc	r5, pc, asr r3
    2768:	74756d00 	ldrbtvc	r6, [r5], #-3328	; 0xfffff300
    276c:	755f7865 	ldrbvc	r7, [pc, #-2149]	; 1f0f <.debug_str+0x1f0f>
    2770:	636f6c6e 	cmnvs	pc, #28160	; 0x6e00
    2774:	666b006b 	strbtvs	r0, [fp], -fp, rrx
    2778:	73706f5f 	cmnvc	r0, #380	; 0x17c
    277c:	65726300 	ldrbvs	r6, [r2, #-768]!	; 0xfffffd00
    2780:	74630064 	strbtvc	r0, [r3], #-100	; 0xffffff9c
    2784:	735f6c72 	cmpvc	pc, #29184	; 0x7200
    2788:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0xfffffe8c
    278c:	67700073 			; <UNDEFINED> instruction: 0x67700073
    2790:	00745f64 	rsbseq	r5, r4, r4, ror #30
    2794:	5f697164 	svcpl	0x00697164
    2798:	61726769 	cmnvs	r2, r9, ror #14
    279c:	61006563 	tstvs	r0, r3, ror #10
    27a0:	5f6e6f6e 	svcpl	0x006e6f6e
    27a4:	5f616d76 	svcpl	0x00616d76
    27a8:	69616863 	stmdbvs	r1!, {r0, r1, r5, r6, fp, sp, lr}^
    27ac:	6d70006e 	ldclvs	0, cr0, [r0, #-440]!	; 0xfffffe48
    27b0:	6c617664 	stclvs	6, cr7, [r1], #-400	; 0xfffffe70
    27b4:	6300745f 	movwvs	r7, #1119	; 0x45f
    27b8:	61706d6f 	cmnvs	r0, pc, ror #26
    27bc:	635f7463 	cmpvs	pc, #1660944384	; 0x63000000
    27c0:	69736e6f 	ldmdbvs	r3!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    27c4:	65726564 	ldrbvs	r6, [r2, #-1380]!	; 0xfffffa9c
    27c8:	6e690064 	cdpvs	0, 6, cr0, cr9, cr4, {3}
    27cc:	00786564 	rsbseq	r6, r8, r4, ror #10
    27d0:	636f6c63 	cmnvs	pc, #25344	; 0x6300
    27d4:	61625f6b 	cmnvs	r2, fp, ror #30
    27d8:	44006573 	strmi	r6, [r0], #-1395	; 0xfffffa8d
    27dc:	5f545351 	svcpl	0x00545351
    27e0:	54495257 	strbpl	r5, [r9], #-599	; 0xfffffda9
    27e4:	73005345 	movwvc	r5, #837	; 0x345
    27e8:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
    27ec:	7461645f 	strbtvc	r6, [r1], #-1119	; 0xfffffba1
    27f0:	64690061 	strbtvs	r0, [r9], #-97	; 0xffffff9f
    27f4:	6572665f 	ldrbvs	r6, [r2, #-1631]!	; 0xfffff9a1
    27f8:	6f6e0065 	svcvs	0x006e0065
    27fc:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2800:	756f635f 	strbvc	r6, [pc, #-863]!	; 24a9 <.debug_str+0x24a9>
    2804:	6900746e 	stmdbvs	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    2808:	5f74696e 	svcpl	0x0074696e
    280c:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    2810:	00736e5f 	rsbseq	r6, r3, pc, asr lr
    2814:	746e6573 	strbtvc	r6, [lr], #-1395	; 0xfffffa8d
    2818:	6c656e69 	stclvs	14, cr6, [r5], #-420	; 0xfffffe5c
    281c:	64617200 	strbtvs	r7, [r1], #-512	; 0xfffffe00
    2820:	745f7869 	ldrbvc	r7, [pc], #-2153	; 2828 <.debug_str+0x2828>
    2824:	5f656572 	svcpl	0x00656572
    2828:	746f6f72 	strbtvc	r6, [pc], #-3954	; 2830 <.debug_str+0x2830>
    282c:	73617400 	cmnvc	r1, #0, 8
    2830:	6d6c006b 	stclvs	0, cr0, [ip, #-428]!	; 0xfffffe54
    2834:	7465735f 	strbtvc	r7, [r5], #-863	; 0xfffffca1
    2838:	72007075 	andvc	r7, r0, #117	; 0x75
    283c:	636f6c77 	cmnvs	pc, #30464	; 0x7700
    2840:	00745f6b 	rsbseq	r5, r4, fp, ror #30
    2844:	655f6d76 	ldrbvs	r6, [pc, #-3446]	; 1ad6 <.debug_str+0x1ad6>
    2848:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
    284c:	6174735f 	cmnvs	r4, pc, asr r3
    2850:	00736574 	rsbseq	r6, r3, r4, ror r5
    2854:	69746763 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, r9, sl, sp, lr}^
    2858:	5500656d 	strpl	r6, [r0, #-1389]	; 0xfffffa93
    285c:	4956454e 	ldmdbmi	r6, {r1, r2, r3, r6, r8, sl, lr}^
    2860:	42415443 	submi	r5, r1, #1124073472	; 0x43000000
    2864:	505f454c 	subspl	r4, pc, ip, asr #10
    2868:	4c554347 	mrrcmi	3, 4, r4, r5, cr7
    286c:	0044454c 	subeq	r4, r4, ip, asr #10
    2870:	65636572 	strbvs	r6, [r3, #-1394]!	; 0xfffffa8e
    2874:	725f746e 	subsvc	r7, pc, #1845493760	; 0x6e000000
    2878:	7461746f 	strbtvc	r7, [r1], #-1135	; 0xfffffb91
    287c:	69006465 	stmdbvs	r0, {r0, r2, r5, r6, sl, sp, lr}
    2880:	6174736e 	cmnvs	r4, lr, ror #6
    2884:	41006c6c 	tstmi	r0, ip, ror #24
    2888:	434f4c4c 	movtmi	r4, #64588	; 0xfc4c
    288c:	4c415453 	cfstrdmi	mvd5, [r1], {83}	; 0x53
    2890:	6e69004c 	cdpvs	0, 6, cr0, cr9, cr12, {2}
    2894:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
    2898:	65645f79 	strbvs	r5, [r4, #-3961]!	; 0xfffff087
    289c:	74007376 	strvc	r7, [r0], #-886	; 0xfffffc8a
    28a0:	00343676 	eorseq	r3, r4, r6, ror r6
    28a4:	62616c73 	rsbvs	r6, r1, #29440	; 0x7300
    28a8:	6361635f 	cmnvs	r1, #2080374785	; 0x7c000001
    28ac:	73006568 	movwvc	r6, #1384	; 0x568
    28b0:	72746275 	rsbsvc	r6, r4, #1342177287	; 0x50000007
    28b4:	635f6565 	cmpvs	pc, #423624704	; 0x19400000
    28b8:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    28bc:	69006c6f 	stmdbvs	r0, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}
    28c0:	0062735f 	rsbeq	r7, r2, pc, asr r3
    28c4:	705f696b 	subsvc	r6, pc, fp, ror #18
    28c8:	7400736f 	strvc	r7, [r0], #-879	; 0xfffffc91
    28cc:	6c61746f 	cfstrdvs	mvd7, [r1], #-444	; 0xfffffe44
    28d0:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    28d4:	51445f00 	cmppl	r4, r0, lsl #30
    28d8:	445f5453 	ldrbmi	r5, [pc], #-1107	; 28e0 <.debug_str+0x28e0>
    28dc:	41545351 	cmpmi	r4, r1, asr r3
    28e0:	414c5f54 	cmpmi	ip, r4, asr pc
    28e4:	76005453 			; <UNDEFINED> instruction: 0x76005453
    28e8:	6e655f6d 	cdpvs	15, 6, cr5, cr5, cr13, {3}
    28ec:	72650064 	rsbvc	r0, r5, #100	; 0x64
    28f0:	00726f72 	rsbseq	r6, r2, r2, ror pc
    28f4:	7270736e 	rsbsvc	r7, r0, #-1207959551	; 0xb8000001
    28f8:	0079786f 	rsbseq	r7, r9, pc, ror #16
    28fc:	70617773 	rsbvc	r7, r1, r3, ror r7
    2900:	6165645f 	cmnvs	r5, pc, asr r4
    2904:	76697463 	strbtvc	r7, [r9], -r3, ror #8
    2908:	00657461 	rsbeq	r7, r5, r1, ror #8
    290c:	6c666e75 	stclvs	14, cr6, [r6], #-468	; 0xfffffe2c
    2910:	65747461 	ldrbvs	r7, [r4, #-1121]!	; 0xfffffb9f
    2914:	6e615f6e 	cdpvs	15, 6, cr5, cr1, cr14, {3}
    2918:	6f635f64 	svcvs	0x00635f64
    291c:	645f7970 	ldrbvs	r7, [pc], #-2416	; 2924 <.debug_str+0x2924>
    2920:	63697665 	cmnvs	r9, #105906176	; 0x6500000
    2924:	72745f65 	rsbsvc	r5, r4, #404	; 0x194
    2928:	63006565 	movwvs	r6, #1381	; 0x565
    292c:	6f736e6f 	svcvs	0x00736e6f
    2930:	6900656c 	stmdbvs	r0, {r2, r3, r5, r6, r8, sl, sp, lr}
    2934:	7665645f 			; <UNDEFINED> instruction: 0x7665645f
    2938:	73656369 	cmnvc	r5, #-1543503871	; 0xa4000001
    293c:	72617000 	rsbvc	r7, r1, #0
    2940:	5f746e65 	svcpl	0x00746e65
    2944:	63657865 	cmnvs	r5, #6619136	; 0x650000
    2948:	0064695f 	rsbeq	r6, r4, pc, asr r9
    294c:	735f6371 	cmpvc	pc, #-1006632959	; 0xc4000001
    2950:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    2954:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
    2958:	645f6465 	ldrbvs	r6, [pc], #-1125	; 2960 <.debug_str+0x2960>
    295c:	6e655f6c 	cdpvs	15, 6, cr5, cr5, cr12, {3}
    2960:	79746974 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2964:	63707300 	cmnvs	r0, #0, 6
    2968:	7261775f 	rsbvc	r7, r1, #24903680	; 0x17c0000
    296c:	6d696c6e 	stclvs	12, cr6, [r9, #-440]!	; 0xfffffe48
    2970:	69007469 	stmdbvs	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
    2974:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    2978:	70697000 	rsbvc	r7, r9, r0
    297c:	6e695f65 	cdpvs	15, 6, cr5, cr9, cr5, {3}
    2980:	5f65646f 	svcpl	0x0065646f
    2984:	6f666e69 	svcvs	0x00666e69
    2988:	5f656600 	svcpl	0x00656600
    298c:	73796870 	cmnvc	r9, #112, 16	; 0x700000
    2990:	6c616369 	stclvs	3, cr6, [r1], #-420	; 0xfffffe5c
    2994:	6e6b6d00 	cdpvs	13, 6, cr6, cr11, cr0, {0}
    2998:	6300646f 	movwvs	r6, #1135	; 0x46f
    299c:	5f6a616d 	svcpl	0x006a616d
    29a0:	00746c66 	rsbseq	r6, r4, r6, ror #24
    29a4:	61657263 	cmnvs	r5, r3, ror #4
    29a8:	74006574 	strvc	r6, [r0], #-1396	; 0xfffffa8c
    29ac:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    29b0:	65766f5f 	ldrbvs	r6, [r6, #-3935]!	; 0xfffff0a1
    29b4:	6e757272 	mrcvs	2, 3, r7, cr5, cr2, {3}
    29b8:	5f646200 	svcpl	0x00646200
    29bc:	61766e69 	cmnvs	r6, r9, ror #28
    29c0:	6164696c 	cmnvs	r4, ip, ror #18
    29c4:	00646574 	rsbeq	r6, r4, r4, ror r5
    29c8:	6374616d 	cmnvs	r4, #1073741851	; 0x4000001b
    29cc:	47500068 	ldrbmi	r0, [r0, -r8, rrx]
    29d0:	4e414353 	mcrmi	3, 2, r4, cr1, cr3, {2}
    29d4:	57534b5f 			; <UNDEFINED> instruction: 0x57534b5f
    29d8:	5f445041 	svcpl	0x00445041
    29dc:	41564f4d 	cmpmi	r6, sp, asr #30
    29e0:	00454c42 	subeq	r4, r5, r2, asr #24
    29e4:	6d5f7464 	cfldrdvs	mvd7, [pc, #-400]	; 285c <.debug_str+0x285c>
    29e8:	6e5f6d65 	cdpvs	13, 5, cr6, cr15, cr5, {3}
    29ec:	5f747865 	svcpl	0x00747865
    29f0:	6c6c6563 	cfstr64vs	mvdx6, [ip], #-396	; 0xfffffe74
    29f4:	48435300 	stmdami	r3, {r8, r9, ip, lr}^
    29f8:	535f4445 	cmppl	pc, #1157627904	; 0x45000000
    29fc:	4954464f 	ldmdbmi	r4, {r0, r1, r2, r3, r6, r9, sl, lr}^
    2a00:	69005152 	stmdbvs	r0, {r1, r4, r6, r8, ip, lr}
    2a04:	655f7172 	ldrbvs	r7, [pc, #-370]	; 289a <.debug_str+0x289a>
    2a08:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
    2a0c:	67630073 			; <UNDEFINED> instruction: 0x67630073
    2a10:	6c5f7072 	mrrcvs	0, 7, r7, pc, cr2	; <UNPREDICTABLE>
    2a14:	736b6e69 	cmnvc	fp, #1680	; 0x690
    2a18:	5f6d6c00 	svcpl	0x006d6c00
    2a1c:	6e616863 	cdpvs	8, 6, cr6, cr1, cr3, {3}
    2a20:	70006567 	andvc	r6, r0, r7, ror #10
    2a24:	6d656d66 	stclvs	13, cr6, [r5, #-408]!	; 0xfffffe68
    2a28:	6f6c6c61 	svcvs	0x006c6c61
    2a2c:	61775f63 	cmnvs	r7, r3, ror #30
    2a30:	5f007469 	svcpl	0x00007469
    2a34:	6d697473 	cfstrdvs	mvd7, [r9, #-460]!	; 0xfffffe34
    2a38:	54550065 	ldrbpl	r0, [r5], #-101	; 0xffffff9b
    2a3c:	5f4b5341 	svcpl	0x004b5341
    2a40:	45545353 	ldrbmi	r5, [r4, #-851]	; 0xfffffcad
    2a44:	77720050 			; <UNDEFINED> instruction: 0x77720050
    2a48:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
    2a4c:	6f687061 	svcvs	0x00687061
    2a50:	73006572 	movwvc	r6, #1394	; 0x572
    2a54:	69737365 	ldmdbvs	r3!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}^
    2a58:	63006e6f 	movwvs	r6, #3695	; 0xe6f
    2a5c:	65737570 	ldrbvs	r7, [r3, #-1392]!	; 0xfffffa90
    2a60:	656d5f74 	strbvs	r5, [sp, #-3956]!	; 0xfffff08c
    2a64:	70735f6d 	rsbsvc	r5, r3, sp, ror #30
    2a68:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
    2a6c:	746f725f 	strbtvc	r7, [pc], #-607	; 2a74 <.debug_str+0x2a74>
    2a70:	5000726f 	andpl	r7, r0, pc, ror #4
    2a74:	46455247 	strbmi	r5, [r5], -r7, asr #4
    2a78:	5f4c4c49 	svcpl	0x004c4c49
    2a7c:	00414d44 	subeq	r4, r1, r4, asr #26
    2a80:	6f6c5f73 	svcvs	0x006c5f73
    2a84:	6b5f6b63 	blvs	17dd818 <unflatten_and_copy_device_tree+0x17dc9a4>
    2a88:	70007965 	andvc	r7, r0, r5, ror #18
    2a8c:	635f7475 	cmpvs	pc, #1962934272	; 0x75000000
    2a90:	00726168 	rsbseq	r6, r2, r8, ror #2
    2a94:	5f707865 	svcpl	0x00707865
    2a98:	6465656e 	strbtvs	r6, [r5], #-1390	; 0xfffffa92
    2a9c:	0073715f 	rsbseq	r7, r3, pc, asr r1
    2aa0:	69616863 	stmdbvs	r1!, {r0, r1, r5, r6, fp, sp, lr}^
    2aa4:	0064656e 	rsbeq	r6, r4, lr, ror #10
    2aa8:	5f736168 	svcpl	0x00736168
    2aac:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    2ab0:	0074756f 	rsbseq	r7, r4, pc, ror #10
    2ab4:	5f646970 	svcpl	0x00646970
    2ab8:	69616863 	stmdbvs	r1!, {r0, r1, r5, r6, fp, sp, lr}^
    2abc:	6172006e 	cmnvs	r2, lr, rrx
    2ac0:	5f786964 	svcpl	0x00786964
    2ac4:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
    2ac8:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 2ad0 <.debug_str+0x2ad0>
    2acc:	41420065 	cmpmi	r2, r5, rrx
    2ad0:	4f4f4c4c 	svcmi	0x004f4c4c
    2ad4:	45445f4e 	strbmi	r5, [r4, #-3918]	; 0xfffff0b2
    2ad8:	54414c46 	strbpl	r4, [r1], #-3142	; 0xfffff3ba
    2adc:	69660045 	stmdbvs	r6!, {r0, r2, r6}^
    2ae0:	5f73656c 	svcpl	0x0073656c
    2ae4:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
    2ae8:	73007463 	movwvc	r7, #1123	; 0x463
    2aec:	616e6769 	cmnvs	lr, r9, ror #14
    2af0:	6966006c 	stmdbvs	r6!, {r2, r3, r5, r6}^
    2af4:	6c5f656c 	cfldr64vs	mvdx6, [pc], {108}	; 0x6c
    2af8:	006b636f 	rsbeq	r6, fp, pc, ror #6
    2afc:	6b636f6c 	blvs	18de8b4 <unflatten_and_copy_device_tree+0x18dda40>
    2b00:	616c635f 	cmnvs	ip, pc, asr r3
    2b04:	6b5f7373 	blvs	17df8d8 <unflatten_and_copy_device_tree+0x17dea64>
    2b08:	66007965 	strvs	r7, [r0], -r5, ror #18
    2b0c:	616d6569 	cmnvs	sp, r9, ror #10
    2b10:	78655f70 	stmdavc	r5!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2b14:	746e6574 	strbtvc	r6, [lr], #-1396	; 0xfffffa8c
    2b18:	666e695f 			; <UNDEFINED> instruction: 0x666e695f
    2b1c:	6173006f 	cmnvs	r3, pc, rrx
    2b20:	73616d5f 	cmnvc	r1, #6080	; 0x17c0
    2b24:	5f5f006b 	svcpl	0x005f006b
    2b28:	74726976 	ldrbtvc	r6, [r2], #-2422	; 0xfffff68a
    2b2c:	5f6f745f 	svcpl	0x006f745f
    2b30:	73796870 	cmnvc	r9, #112, 16	; 0x700000
    2b34:	67617000 	strbvs	r7, [r1, -r0]!
    2b38:	70670065 	rsbvc	r0, r7, r5, rrx
    2b3c:	6174735f 	cmnvs	r4, pc, asr r3
    2b40:	61006574 	tstvs	r0, r4, ror r5
    2b44:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
    2b48:	6c62006c 	stclvs	0, cr0, [r2], #-432	; 0xfffffe50
    2b4c:	656b636f 	strbvs	r6, [fp, #-879]!	; 0xfffffc91
    2b50:	706f5f64 	rsbvc	r5, pc, r4, ror #30
    2b54:	4e006e65 	cdpmi	14, 0, cr6, cr0, cr5, {3}
    2b58:	49465f52 	stmdbmi	r6, {r1, r4, r6, r8, r9, sl, fp, ip, lr}^
    2b5c:	505f454c 	subspl	r4, pc, ip, asr #10
    2b60:	53454741 	movtpl	r4, #22337	; 0x5741
    2b64:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
    2b68:	745f6465 	ldrbvc	r6, [pc], #-1125	; 2b70 <.debug_str+0x2b70>
    2b6c:	5f6b7361 	svcpl	0x006b7361
    2b70:	756f7267 	strbvc	r7, [pc, #-615]!	; 2911 <.debug_str+0x2911>
    2b74:	5f690070 	svcpl	0x00690070
    2b78:	7a006277 	bvc	1b55c <unflatten_and_copy_device_tree+0x1a6e8>
    2b7c:	5f656e6f 	svcpl	0x00656e6f
    2b80:	00786469 	rsbseq	r6, r8, r9, ror #8
    2b84:	746e7572 	strbtvc	r7, [lr], #-1394	; 0xfffffa8e
    2b88:	00656d69 	rsbeq	r6, r5, r9, ror #26
    2b8c:	6b6f6f6c 	blvs	1bde944 <unflatten_and_copy_device_tree+0x1bddad0>
    2b90:	69007075 	stmdbvs	r0, {r0, r2, r4, r5, r6, ip, sp, lr}
    2b94:	6c61766e 	stclvs	6, cr7, [r1], #-440	; 0xfffffe48
    2b98:	74616469 	strbtvc	r6, [r1], #-1129	; 0xfffffb97
    2b9c:	67617065 	strbvs	r7, [r1, -r5, rrx]!
    2ba0:	645f0065 	ldrbvs	r0, [pc], #-101	; 2ba8 <.debug_str+0x2ba8>
    2ba4:	5f617461 	svcpl	0x00617461
    2ba8:	726f6261 	rsbvc	r6, pc, #268435462	; 0x10000006
    2bac:	65640074 	strbvs	r0, [r4, #-116]!	; 0xffffff8c
    2bb0:	65636976 	strbvs	r6, [r3, #-2422]!	; 0xfffff68a
    2bb4:	67635f73 			; <UNDEFINED> instruction: 0x67635f73
    2bb8:	695f7072 	ldmdbvs	pc, {r1, r4, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
    2bbc:	5f4e0064 	svcpl	0x004e0064
    2bc0:	48474948 	stmdami	r7, {r3, r6, r8, fp, lr}^
    2bc4:	4d454d5f 	stclmi	13, cr4, [r5, #-380]	; 0xfffffe84
    2bc8:	0059524f 	subseq	r5, r9, pc, asr #4
    2bcc:	65736572 	ldrbvs	r6, [r3, #-1394]!	; 0xfffffa8e
    2bd0:	64657672 	strbtvs	r7, [r5], #-1650	; 0xfffff98e
    2bd4:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 2bdc <.debug_str+0x2bdc>
    2bd8:	6e756f70 	mrcvs	15, 3, r6, cr5, cr0, {3}
    2bdc:	61705f64 	cmnvs	r0, r4, ror #30
    2be0:	645f6567 	ldrbvs	r6, [pc], #-1383	; 2be8 <.debug_str+0x2be8>
    2be4:	73726f74 	cmnvc	r2, #116, 30	; 0x1d0
    2be8:	57534b00 	ldrbpl	r4, [r3, -r0, lsl #22]
    2bec:	5f445041 	svcpl	0x00445041
    2bf0:	5f574f4c 	svcpl	0x00574f4c
    2bf4:	52414d57 	subpl	r4, r1, #5568	; 0x15c0
    2bf8:	49485f4b 	stmdbmi	r8, {r0, r1, r3, r6, r8, r9, sl, fp, ip, lr}^
    2bfc:	55515f54 	ldrbpl	r5, [r1, #-3924]	; 0xfffff0ac
    2c00:	4c4b4349 	mcrrmi	3, 4, r4, fp, cr9
    2c04:	5f640059 	svcpl	0x00640059
    2c08:	6c696863 	stclvs	8, cr6, [r9], #-396	; 0xfffffe74
    2c0c:	5f660064 	svcpl	0x00660064
    2c10:	5f736f70 	svcpl	0x00736f70
    2c14:	6b636f6c 	blvs	18de9cc <unflatten_and_copy_device_tree+0x18ddb58>
    2c18:	6c656300 	stclvs	3, cr6, [r5], #-0
    2c1c:	6700706c 	strvs	r7, [r0, -ip, rrx]
    2c20:	745f6469 	ldrbvc	r6, [pc], #-1129	; 2c28 <.debug_str+0x2c28>
    2c24:	5f666f00 	svcpl	0x00666f00
    2c28:	5f746466 	svcpl	0x00746466
    2c2c:	6c666e75 	stclvs	14, cr6, [r6], #-468	; 0xfffffe2c
    2c30:	65747461 	ldrbvs	r7, [r4, #-1121]!	; 0xfffffb9f
    2c34:	72745f6e 	rsbsvc	r5, r4, #440	; 0x1b8
    2c38:	72006565 	andvc	r6, r0, #423624704	; 0x19400000
    2c3c:	70735f74 	rsbsvc	r5, r3, r4, ror pc
    2c40:	69745f63 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    2c44:	696c656d 	stmdbvs	ip!, {r0, r2, r3, r5, r6, r8, sl, sp, lr}^
    2c48:	0074696d 	rsbseq	r6, r4, sp, ror #18
    2c4c:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    2c50:	5f746361 	svcpl	0x00746361
    2c54:	68636163 	stmdavs	r3!, {r0, r1, r5, r6, r8, sp, lr}^
    2c58:	665f6465 	ldrbvs	r6, [pc], -r5, ror #8
    2c5c:	5f656572 	svcpl	0x00656572
    2c60:	006e6670 	rsbeq	r6, lr, r0, ror r6
    2c64:	78746573 	ldmdavc	r4!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    2c68:	72747461 	rsbsvc	r7, r4, #1627389952	; 0x61000000
    2c6c:	6f687300 	svcvs	0x00687300
    2c70:	75207472 	strvc	r7, [r0, #-1138]!	; 0xfffffb8e
    2c74:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
    2c78:	2064656e 	rsbcs	r6, r4, lr, ror #10
    2c7c:	00746e69 	rsbseq	r6, r4, r9, ror #28
    2c80:	63666572 	cmnvs	r6, #478150656	; 0x1c800000
    2c84:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
    2c88:	76656400 	strbtvc	r6, [r5], -r0, lsl #8
    2c8c:	5f656369 	svcpl	0x00656369
    2c90:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    2c94:	5f726e00 	svcpl	0x00726e00
    2c98:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    2c9c:	5f737075 	svcpl	0x00737075
    2ca0:	73736170 	cmnvc	r3, #112, 2
    2ca4:	00657669 	rsbeq	r7, r5, r9, ror #12
    2ca8:	675f666f 	ldrbvs	r6, [pc, -pc, ror #12]
    2cac:	705f7465 	subsvc	r7, pc, r5, ror #8
    2cb0:	65706f72 	ldrbvs	r6, [r0, #-3954]!	; 0xfffff08e
    2cb4:	00797472 	rsbseq	r7, r9, r2, ror r4
    2cb8:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    2cbc:	0073665f 	rsbseq	r6, r3, pc, asr r6
    2cc0:	5f726570 	svcpl	0x00726570
    2cc4:	5f757063 	svcpl	0x00757063
    2cc8:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    2ccc:	5f690073 	svcpl	0x00690073
    2cd0:	76656463 	strbtvc	r6, [r5], -r3, ror #8
    2cd4:	61747300 	cmnvs	r4, r0, lsl #6
    2cd8:	695f6574 	ldmdbvs	pc, {r2, r4, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    2cdc:	79735f6e 	ldmdbvc	r3!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2ce0:	00736673 	rsbseq	r6, r3, r3, ror r6
    2ce4:	55504350 	ldrbpl	r4, [r0, #-848]	; 0xfffffcb0
    2ce8:	5f43465f 	svcpl	0x0043465f
    2cec:	45424d45 	strbmi	r4, [r2, #-3397]	; 0xfffff2bb
    2cf0:	63610044 	cmnvs	r1, #68	; 0x44
    2cf4:	65766974 	ldrbvs	r6, [r6, #-2420]!	; 0xfffff68c
    2cf8:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005
    2cfc:	68007365 	stmdavs	r0, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    2d00:	75676e61 	strbvc	r6, [r7, #-3681]!	; 0xfffff19f
    2d04:	6f775f70 	svcvs	0x00775f70
    2d08:	61006b72 	tstvs	r0, r2, ror fp
    2d0c:	6c665f63 	stclvs	15, cr5, [r6], #-396	; 0xfffffe74
    2d10:	6f006761 	svcvs	0x00006761
    2d14:	6c615f66 	stclvs	15, cr5, [r1], #-408	; 0xfffffe68
    2d18:	5f736169 	svcpl	0x00736169
    2d1c:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
    2d20:	755f7300 	ldrbvc	r7, [pc, #-768]	; 2a28 <.debug_str+0x2a28>
    2d24:	6e756f6d 	cdpvs	15, 7, cr6, cr5, cr13, {3}
    2d28:	72670074 	rsbvc	r0, r7, #116	; 0x74
    2d2c:	5f70756f 	svcpl	0x0070756f
    2d30:	74697865 	strbtvc	r7, [r9], #-2149	; 0xfffff79b
    2d34:	7361745f 	cmnvc	r1, #1593835520	; 0x5f000000
    2d38:	6f63006b 	svcvs	0x0063006b
    2d3c:	756f706d 	strbvc	r7, [pc, #-109]!	; 2cd7 <.debug_str+0x2cd7>
    2d40:	705f646e 	subsvc	r6, pc, lr, ror #8
    2d44:	5f656761 	svcpl	0x00656761
    2d48:	726f7464 	rsbvc	r7, pc, #100, 8	; 0x64000000
    2d4c:	5f646200 	svcpl	0x00646200
    2d50:	76697270 			; <UNDEFINED> instruction: 0x76697270
    2d54:	00657461 	rsbeq	r7, r5, r1, ror #8
    2d58:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    2d5c:	5f455441 	svcpl	0x00455441
    2d60:	4c4f5349 	mcrrmi	3, 4, r5, pc, cr9
    2d64:	00455441 	subeq	r5, r5, r1, asr #8
    2d68:	6469705f 	strbtvs	r7, [r9], #-95	; 0xffffffa1
    2d6c:	726f7700 	rsbvc	r7, pc, #0, 14
    2d70:	74735f6b 	ldrbtvc	r5, [r3], #-3947	; 0xfffff095
    2d74:	74637572 	strbtvc	r7, [r3], #-1394	; 0xfffffa8e
    2d78:	625f6900 	subsvs	r6, pc, #0, 18
    2d7c:	69626b6c 	stmdbvs	r2!, {r2, r3, r5, r6, r8, r9, fp, sp, lr}^
    2d80:	6f007374 	svcvs	0x00007374
    2d84:	64665f66 	strbtvs	r5, [r6], #-3942	; 0xfffff09a
    2d88:	73695f74 	cmnvc	r9, #116, 30	; 0x1d0
    2d8c:	6769625f 			; <UNDEFINED> instruction: 0x6769625f
    2d90:	646e655f 	strbtvs	r6, [lr], #-1375	; 0xfffffaa1
    2d94:	006e6169 	rsbeq	r6, lr, r9, ror #2
    2d98:	736e6f63 	cmnvc	lr, #396	; 0x18c
    2d9c:	746e6174 	strbtvc	r6, [lr], #-372	; 0xfffffe8c
    2da0:	736c665f 	cmnvc	ip, #99614720	; 0x5f00000
    2da4:	72616800 	rsbvc	r6, r1, #0, 16
    2da8:	71726964 	cmnvc	r2, r4, ror #18
    2dac:	6e655f73 	mcrvs	15, 3, r5, cr5, cr3, {3}
    2db0:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
    2db4:	73690064 	cmnvc	r9, #100	; 0x64
    2db8:	6968635f 	stmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
    2dbc:	735f646c 	cmpvc	pc, #108, 8	; 0x6c000000
    2dc0:	65726275 	ldrbvs	r6, [r2, #-629]!	; 0xfffffd8b
    2dc4:	72657061 	rsbvc	r7, r5, #97	; 0x61
    2dc8:	5f716400 	svcpl	0x00716400
    2dcc:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    2dd0:	756e755f 	strbvc	r7, [lr, #-1375]!	; 0xfffffaa1
    2dd4:	00646573 	rsbeq	r6, r4, r3, ror r5
    2dd8:	4157534b 	cmpmi	r7, fp, asr #6
    2ddc:	495f4450 	ldmdbmi	pc, {r4, r6, sl, lr}^	; <UNPREDICTABLE>
    2de0:	45444f4e 	strbmi	r4, [r4, #-3918]	; 0xfffff0b2
    2de4:	41455453 	cmpmi	r5, r3, asr r4
    2de8:	6564004c 	strbvs	r0, [r4, #-76]!	; 0xffffffb4
    2dec:	696c6461 	stmdbvs	ip!, {r0, r5, r6, sl, sp, lr}^
    2df0:	6d00656e 	cfstr32vs	mvfx6, [r0, #-440]	; 0xfffffe48
    2df4:	67636d65 	strbvs	r6, [r3, -r5, ror #26]!
    2df8:	736f6800 	cmnvc	pc, #0, 16
    2dfc:	65700074 	ldrbvs	r0, [r0, #-116]!	; 0xffffff8c
    2e00:	685f6672 	ldmdavs	pc, {r1, r4, r5, r6, r9, sl, sp, lr}^	; <UNPREDICTABLE>
    2e04:	6f635f77 	svcvs	0x00635f77
    2e08:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    2e0c:	70630074 	rsbvc	r0, r3, r4, ror r0
    2e10:	69745f75 	ldmdbvs	r4!, {r0, r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2e14:	7372656d 	cmnvc	r2, #457179136	; 0x1b400000
    2e18:	74656700 	strbtvc	r6, [r5], #-1792	; 0xfffff900
    2e1c:	74746178 	ldrbtvc	r6, [r4], #-376	; 0xfffffe88
    2e20:	6e690072 	mcrvs	0, 3, r0, cr9, cr2, {3}
    2e24:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
    2e28:	61775f79 	cmnvs	r7, r9, ror pc
    2e2c:	65686374 	strbvs	r6, [r8, #-884]!	; 0xfffffc8c
    2e30:	74690073 	strbtvc	r0, [r9], #-115	; 0xffffff8d
    2e34:	6165725f 	cmnvs	r5, pc, asr r2
    2e38:	6e695f6c 	cdpvs	15, 6, cr5, cr9, cr12, {3}
    2e3c:	66007263 	strvs	r7, [r0], -r3, ror #4
    2e40:	5f70655f 	svcpl	0x0070655f
    2e44:	6b6e696c 	blvs	1b9d3fc <unflatten_and_copy_device_tree+0x1b9c588>
    2e48:	6f630073 	svcvs	0x00630073
    2e4c:	6f6c6275 	svcvs	0x006c6275
    2e50:	72006b63 	andvc	r6, r0, #101376	; 0x18c00
    2e54:	71785f6d 	cmnvc	r8, sp, ror #30
    2e58:	61746f75 	cmnvs	r4, r5, ror pc
    2e5c:	706f7000 	rsbvc	r7, pc, r0
    2e60:	74616c75 	strbtvc	r6, [r1], #-3189	; 0xfffff38b
    2e64:	635f6465 	cmpvs	pc, #1694498816	; 0x65000000
    2e68:	5a00746e 	bpl	20028 <unflatten_and_copy_device_tree+0x1f1b4>
    2e6c:	5f454e4f 	svcpl	0x00454e4f
    2e70:	48474948 	stmdami	r7, {r3, r6, r8, fp, lr}^
    2e74:	004d454d 	subeq	r4, sp, sp, asr #10
    2e78:	6465656e 	strbtvs	r6, [r5], #-1390	; 0xfffffa92
    2e7c:	0073715f 	rsbseq	r7, r3, pc, asr r1
    2e80:	5f797474 	svcpl	0x00797474
    2e84:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    2e88:	71640073 	smcvc	16387	; 0x4003
    2e8c:	68625f62 	stmdavs	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    2e90:	6c647261 	sfmvs	f7, 2, [r4], #-388	; 0xfffffe7c
    2e94:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
    2e98:	725f7300 	subsvc	r7, pc, #0, 6
    2e9c:	00746f6f 	rsbseq	r6, r4, pc, ror #30
    2ea0:	6f6d6572 	svcvs	0x006d6572
    2ea4:	5f746e75 	svcpl	0x00746e75
    2ea8:	6b007366 	blvs	1fc48 <unflatten_and_copy_device_tree+0x1edd4>
    2eac:	666e7265 	strbtvs	r7, [lr], -r5, ror #4
    2eb0:	6c655f73 	stclvs	15, cr5, [r5], #-460	; 0xfffffe34
    2eb4:	645f6d65 	ldrbvs	r6, [pc], #-3429	; 2ebc <.debug_str+0x2ebc>
    2eb8:	6e007269 	cdpvs	2, 0, cr7, cr0, cr9, {3}
    2ebc:	65725f72 	ldrbvs	r5, [r2, #-3954]!	; 0xfffff08e
    2ec0:	65697274 	strbvs	r7, [r9, #-628]!	; 0xfffffd8c
    2ec4:	524e0073 	subpl	r0, lr, #115	; 0x73
    2ec8:	534d565f 	movtpl	r5, #54879	; 0xd65f
    2ecc:	5f4e4143 	svcpl	0x004e4143
    2ed0:	54495257 	strbpl	r5, [r9], #-599	; 0xfffffda9
    2ed4:	74610045 	strbtvc	r0, [r1], #-69	; 0xffffffbb
    2ed8:	63696d6f 	cmnvs	r9, #7104	; 0x1bc0
    2edc:	6972775f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    2ee0:	6c5f6574 	cfldr64vs	mvdx6, [pc], {116}	; 0x74
    2ee4:	62006e65 	andvs	r6, r0, #1616	; 0x650
    2ee8:	00626f6c 	rsbeq	r6, r2, ip, ror #30
    2eec:	5f616469 	svcpl	0x00616469
    2ef0:	6d746962 	ldclvs	9, cr6, [r4, #-392]!	; 0xfffffe78
    2ef4:	69007061 	stmdbvs	r0, {r0, r5, r6, ip, sp, lr}
    2ef8:	6f6e695f 	svcvs	0x006e695f
    2efc:	7261775f 	rsbvc	r7, r1, #24903680	; 0x17c0000
    2f00:	6d696c6e 	stclvs	12, cr6, [r9, #-440]!	; 0xfffffe48
    2f04:	72007469 	andvc	r7, r0, #1761607680	; 0x69000000
    2f08:	69656365 	stmdbvs	r5!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    2f0c:	725f6576 	subsvc	r6, pc, #494927872	; 0x1d800000
    2f10:	006d6f6f 	rsbeq	r6, sp, pc, ror #30
    2f14:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    2f18:	5f746361 	svcpl	0x00746361
    2f1c:	65666564 	strbvs	r6, [r6, #-1380]!	; 0xfffffa9c
    2f20:	68735f72 	ldmdavs	r3!, {r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2f24:	00746669 	rsbseq	r6, r4, r9, ror #12
    2f28:	54535144 	ldrbpl	r5, [r3], #-324	; 0xfffffebc
    2f2c:	4f4f4c5f 	svcmi	0x004f4c5f
    2f30:	5350554b 	cmppl	r0, #314572800	; 0x12c00000
    2f34:	65786500 	ldrbvs	r6, [r8, #-1280]!	; 0xfffffb00
    2f38:	74735f63 	ldrbtvc	r5, [r3], #-3939	; 0xfffff09d
    2f3c:	00747261 	rsbseq	r7, r4, r1, ror #4
    2f40:	79746663 	ldmdbvc	r4!, {r0, r1, r5, r6, r9, sl, sp, lr}^
    2f44:	72006570 	andvc	r6, r0, #112, 10	; 0x1c000000
    2f48:	735f7563 	cmpvc	pc, #415236096	; 0x18c00000
    2f4c:	69636570 	stmdbvs	r3!, {r4, r5, r6, r8, sl, sp, lr}^
    2f50:	65006c61 	strvs	r6, [r0, #-3169]	; 0xfffff39f
    2f54:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
    2f58:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    2f5c:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
    2f60:	6163735f 	cmnvs	r3, pc, asr r3
    2f64:	68635f6e 	stmdavs	r3!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2f68:	6e65736f 	cdpvs	3, 6, cr7, cr5, cr15, {3}
    2f6c:	64646100 	strbtvs	r6, [r4], #-256	; 0xffffff00
    2f70:	61620072 	smcvs	8194	; 0x2002
    2f74:	63006573 	movwvs	r6, #1395	; 0x573
    2f78:	00707267 	rsbseq	r7, r0, r7, ror #4
    2f7c:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    2f80:	00737365 	rsbseq	r7, r3, r5, ror #6
    2f84:	5f746567 	svcpl	0x00746567
    2f88:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    2f8c:	65730065 	ldrbvs	r0, [r3, #-101]!	; 0xffffff9b
    2f90:	69665f71 	stmdbvs	r6!, {r0, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2f94:	6b00656c 	blvs	1c54c <unflatten_and_copy_device_tree+0x1b6d8>
    2f98:	6a6f7270 	bvs	1bdf960 <unflatten_and_copy_device_tree+0x1bdeaec>
    2f9c:	745f6469 	ldrbvc	r6, [pc], #-1129	; 2fa4 <.debug_str+0x2fa4>
    2fa0:	626f6b00 	rsbvs	r6, pc, #0, 22
    2fa4:	7573006a 	ldrbvc	r0, [r3, #-106]!	; 0xffffff96
    2fa8:	63735f6d 	cmnvs	r3, #436	; 0x1b4
    2fac:	5f646568 	svcpl	0x00646568
    2fb0:	746e7572 	strbtvc	r7, [lr], #-1394	; 0xfffffa8e
    2fb4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    2fb8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
    2fbc:	61006b74 	tstvs	r0, r4, ror fp
    2fc0:	696d5f63 	stmdbvs	sp!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    2fc4:	746c666e 	strbtvc	r6, [ip], #-1646	; 0xfffff992
    2fc8:	775f6400 	ldrbvc	r6, [pc, -r0, lsl #8]
    2fcc:	5f6b6165 	svcpl	0x006b6165
    2fd0:	61766572 	cmnvs	r6, r2, ror r5
    2fd4:	6164696c 	cmnvs	r4, ip, ror #18
    2fd8:	77006574 	smlsdxvc	r0, r4, r5, r6
    2fdc:	00746961 	rsbseq	r6, r4, r1, ror #18
    2fe0:	4b524f57 	blmi	1496d44 <unflatten_and_copy_device_tree+0x1495ed0>
    2fe4:	53474e49 	movtpl	r4, #32329	; 0x7e49
    2fe8:	4e5f5445 	cdpmi	4, 5, cr5, cr15, cr5, {2}
    2fec:	5245444f 	subpl	r4, r5, #1325400064	; 0x4f000000
    2ff0:	414c4345 	cmpmi	ip, r5, asr #6
    2ff4:	73004d49 	movwvc	r4, #3401	; 0xd49
    2ff8:	5f776f68 	svcpl	0x00776f68
    2ffc:	6e696466 	cdpvs	4, 6, cr6, cr9, cr6, {3}
    3000:	70006f66 	andvc	r6, r0, r6, ror #30
    3004:	66666f67 	strbtvs	r6, [r6], -r7, ror #30
    3008:	4e574600 	cdpmi	6, 5, cr4, cr7, cr0, {0}
    300c:	5f45444f 	svcpl	0x0045444f
    3010:	54414450 	strbpl	r4, [r1], #-1104	; 0xfffffbb0
    3014:	64630041 	strbtvs	r0, [r3], #-65	; 0xffffffbf
    3018:	00737665 	rsbseq	r7, r3, r5, ror #12
    301c:	63657865 	cmnvs	r5, #6619136	; 0x650000
    3020:	006d765f 	rsbeq	r7, sp, pc, asr r6
    3024:	78696e75 	stmdavc	r9!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
    3028:	666e695f 			; <UNDEFINED> instruction: 0x666e695f
    302c:	6867696c 	stmdavs	r7!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    3030:	6f700074 	svcvs	0x00700074
    3034:	655f6c6c 	ldrbvs	r6, [pc, #-3180]	; 23d0 <.debug_str+0x23d0>
    3038:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
    303c:	5f726e00 	svcpl	0x00726e00
    3040:	6c6f7369 	stclvs	3, cr7, [pc], #-420	; 2ea4 <.debug_str+0x2ea4>
    3044:	5f657461 	svcpl	0x00657461
    3048:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    304c:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    3050:	6564006b 	strbvs	r0, [r4, #-107]!	; 0xffffff95
    3054:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    3058:	69745f74 	ldmdbvs	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    305c:	5f72656d 	svcpl	0x0072656d
    3060:	63616c73 	cmnvs	r1, #29440	; 0x7300
    3064:	736e5f6b 	cmnvc	lr, #428	; 0x1ac
    3068:	69686300 	stmdbvs	r8!, {r8, r9, sp, lr}^
    306c:	6400646c 	strvs	r6, [r0], #-1132	; 0xfffffb94
    3070:	63657269 	cmnvs	r5, #-1879048186	; 0x90000006
    3074:	4f495f74 	svcmi	0x00495f74
    3078:	4d495400 	cfstrdmi	mvd5, [r9, #-0]
    307c:	535f5245 	cmppl	pc, #1342177284	; 0x50000004
    3080:	4954464f 	ldmdbmi	r4, {r0, r1, r2, r3, r6, r9, sl, lr}^
    3084:	70005152 	andvc	r5, r0, r2, asr r1
    3088:	5f757063 	svcpl	0x00757063
    308c:	6e006366 	cdpvs	3, 0, cr6, cr0, cr6, {3}
    3090:	77736376 			; <UNDEFINED> instruction: 0x77736376
    3094:	696c6100 	stmdbvs	ip!, {r8, sp, lr}^
    3098:	6f006e67 	svcvs	0x00006e67
    309c:	6c665f66 	stclvs	15, cr5, [r6], #-408	; 0xfffffe68
    30a0:	645f7461 	ldrbvs	r7, [pc], #-1121	; 30a8 <.debug_str+0x30a8>
    30a4:	73695f74 	cmnvc	r9, #116, 30	; 0x1d0
    30a8:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	; 2f34 <.debug_str+0x2f34>
    30ac:	69746170 	ldmdbvs	r4!, {r4, r5, r6, r8, sp, lr}^
    30b0:	00656c62 	rsbeq	r6, r5, r2, ror #24
    30b4:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    30b8:	6974656c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, sp, lr}^
    30bc:	76006e6f 	strvc	r6, [r0], -pc, ror #28
    30c0:	006f7364 	rsbeq	r7, pc, r4, ror #6
    30c4:	4c414750 	mcrrmi	7, 5, r4, r1, cr0
    30c8:	5f434f4c 	svcpl	0x00434f4c
    30cc:	4d524f4e 	ldclmi	15, cr4, [r2, #-312]	; 0xfffffec8
    30d0:	76004c41 	strvc	r4, [r0], -r1, asr #24
    30d4:	72615f6d 	rsbvc	r5, r1, #436	; 0x1b4
    30d8:	735f6165 	cmpvc	pc, #1073741849	; 0x40000019
    30dc:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    30e0:	5f640074 	svcpl	0x00640074
    30e4:	735f7472 	cmpvc	pc, #1912602624	; 0x72000000
    30e8:	775f6370 			; <UNDEFINED> instruction: 0x775f6370
    30ec:	736e7261 	cmnvc	lr, #268435462	; 0x10000006
    30f0:	6c677000 	stclvs	0, cr7, [r7], #-0
    30f4:	5f747369 	svcpl	0x00747369
    30f8:	61746164 	cmnvs	r4, r4, ror #2
    30fc:	70666700 	rsbvc	r6, r6, r0, lsl #14
    3100:	73616d5f 	cmnvc	r1, #6080	; 0x17c0
    3104:	6169006b 	cmnvs	r9, fp, rrx
    3108:	6c61765f 	stclvs	6, cr7, [r1], #-380	; 0xfffffe84
    310c:	50006469 	andpl	r6, r0, r9, ror #8
    3110:	55514a52 	ldrbpl	r4, [r1, #-2642]	; 0xfffff5ae
    3114:	0041544f 	subeq	r5, r1, pc, asr #8
    3118:	72706770 	rsbsvc	r6, r0, #112, 14	; 0x1c00000
    311c:	745f746f 	ldrbvc	r7, [pc], #-1135	; 3124 <.debug_str+0x3124>
    3120:	6f687300 	svcvs	0x00687300
    3124:	64690077 	strbtvs	r0, [r9], #-119	; 0xffffff89
    3128:	616c5f72 	smcvs	50674	; 0xc5f2
    312c:	00726579 	rsbseq	r6, r2, r9, ror r5
    3130:	6d6f7461 	cfstrdvs	mvd7, [pc, #-388]!	; 2fb4 <.debug_str+0x2fb4>
    3134:	6f5f6369 	svcvs	0x005f6369
    3138:	006e6570 	rsbeq	r6, lr, r0, ror r5
    313c:	61785f73 	cmnvs	r8, r3, ror pc
    3140:	00727474 	rsbseq	r7, r2, r4, ror r4
    3144:	6e616870 	mcrvs	8, 3, r6, cr1, cr0, {3}
    3148:	00656c64 	rsbeq	r6, r5, r4, ror #24
    314c:	70735f64 	rsbsvc	r5, r3, r4, ror #30
    3150:	61685f63 	cmnvs	r8, r3, ror #30
    3154:	696c6472 	stmdbvs	ip!, {r1, r4, r5, r6, sl, sp, lr}^
    3158:	0074696d 	rsbseq	r6, r4, sp, ror #18
    315c:	415f4d4d 	cmpmi	pc, sp, asr #26
    3160:	504e4f4e 	subpl	r4, lr, lr, asr #30
    3164:	53454741 	movtpl	r4, #22337	; 0x5741
    3168:	74656700 	strbtvc	r6, [r5], #-1792	; 0xfffff900
    316c:	6271645f 	rsbsvs	r6, r1, #1593835520	; 0x5f000000
    3170:	50006b6c 	andpl	r6, r0, ip, ror #22
    3174:	45545347 	ldrbmi	r5, [r4, #-839]	; 0xfffffcb9
    3178:	4b5f4c41 	blmi	17d6284 <unflatten_and_copy_device_tree+0x17d5410>
    317c:	50415753 	subpl	r5, r1, r3, asr r7
    3180:	49485f44 	stmdbmi	r8, {r2, r6, r8, r9, sl, fp, ip, lr}^
    3184:	69004847 	stmdbvs	r0, {r0, r1, r2, r6, fp, lr}
    3188:	7461645f 	strbtvc	r6, [r1], #-1119	; 0xfffffba1
    318c:	69760061 	ldmdbvs	r6!, {r0, r5, r6}^
    3190:	61757472 	cmnvs	r5, r2, ror r4
    3194:	64615f6c 	strbtvs	r5, [r1], #-3948	; 0xfffff094
    3198:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
    319c:	61770073 	cmnvs	r7, r3, ror r0
    31a0:	745f7469 	ldrbvc	r7, [pc], #-1129	; 31a8 <.debug_str+0x31a8>
    31a4:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
    31a8:	7361685f 	cmnvc	r1, #6225920	; 0x5f0000
    31ac:	726e5f68 	rsbvc	r5, lr, #104, 30	; 0x1a0
    31b0:	746e655f 	strbtvc	r6, [lr], #-1375	; 0xfffffaa1
    31b4:	73656972 	cmnvc	r5, #1867776	; 0x1c8000
    31b8:	79747400 	ldmdbvc	r4!, {sl, ip, sp, lr}^
    31bc:	726f705f 	rsbvc	r7, pc, #95	; 0x5f
    31c0:	454e0074 	strbmi	r0, [lr, #-116]	; 0xffffff8c
    31c4:	58545f54 	ldmdapl	r4, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
    31c8:	464f535f 			; <UNDEFINED> instruction: 0x464f535f
    31cc:	51524954 	cmppl	r2, r4, asr r9
    31d0:	635f5f00 	cmpvs	pc, #0, 30
    31d4:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
    31d8:	736e7500 	cmnvc	lr, #0, 10
    31dc:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0xfffff897
    31e0:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
    31e4:	72007261 	andvc	r7, r0, #268435462	; 0x10000006
    31e8:	00766564 	rsbseq	r6, r6, r4, ror #10
    31ec:	756f6d75 	strbvc	r6, [pc, #-3445]!	; 247f <.debug_str+0x247f>
    31f0:	625f746e 	subsvs	r7, pc, #1845493760	; 0x6e000000
    31f4:	6e696765 	cdpvs	7, 6, cr6, cr9, cr5, {3}
    31f8:	696b5f00 	stmdbvs	fp!, {r8, r9, sl, fp, ip, lr}^
    31fc:	62006c6c 	andvs	r6, r0, #108, 24	; 0x6c00
    3200:	696c5f64 	stmdbvs	ip!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    3204:	73007473 	movwvc	r7, #1139	; 0x473
    3208:	61766769 	cmnvs	r6, r9, ror #14
    320c:	00745f6c 	rsbseq	r5, r4, ip, ror #30
    3210:	72636e69 	rsbvc	r6, r3, #1680	; 0x690
    3214:	5f716400 	svcpl	0x00716400
    3218:	7400706f 	strvc	r7, [r0], #-111	; 0xffffff91
    321c:	61657268 	cmnvs	r5, r8, ror #4
    3220:	656b5f64 	strbvs	r5, [fp, #-3940]!	; 0xfffff09c
    3224:	6e697279 	mcrvs	2, 3, r7, cr9, cr9, {3}
    3228:	656c0067 	strbvs	r0, [ip, #-103]!	; 0xffffff99
    322c:	79636167 	stmdbvc	r3!, {r0, r1, r2, r5, r6, r8, sp, lr}^
    3230:	6d616e5f 	stclvs	14, cr6, [r1, #-380]!	; 0xfffffe84
    3234:	75630065 	strbvc	r0, [r3, #-101]!	; 0xffffff9b
    3238:	725f7272 	subsvc	r7, pc, #536870919	; 0x20000007
    323c:	735f7465 	cmpvc	pc, #1694498816	; 0x65000000
    3240:	6b636174 	blvs	18db818 <unflatten_and_copy_device_tree+0x18da9a4>
    3244:	53475000 	movtpl	r5, #28672	; 0x7000
    3248:	4c414554 	cfstr64mi	mvdx4, [r1], {84}	; 0x54
    324c:	57534b5f 			; <UNDEFINED> instruction: 0x57534b5f
    3250:	5f445041 	svcpl	0x00445041
    3254:	41564f4d 	cmpmi	r6, sp, asr #30
    3258:	00454c42 	subeq	r4, r5, r2, asr #24
    325c:	6f72705f 	svcvs	0x0072705f
    3260:	69665f63 	stmdbvs	r6!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    3264:	6c64006e 	stclvs	0, cr0, [r4], #-440	; 0xfffffe48
    3268:	77656e5f 			; <UNDEFINED> instruction: 0x77656e5f
    326c:	5f616600 	svcpl	0x00616600
    3270:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0xfffffa92
    3274:	69747500 	ldmdbvs	r4!, {r8, sl, ip, sp, lr}^
    3278:	76615f6c 	strbtvc	r5, [r1], -ip, ror #30
    327c:	6c730067 	ldclvs	0, cr0, [r3], #-412	; 0xfffffe64
    3280:	006b636f 	rsbeq	r6, fp, pc, ror #6
    3284:	63725f64 	cmnvs	r2, #100, 30	; 0x190
    3288:	5f5f0075 	svcpl	0x005f0075
    328c:	705f6272 	subsvc	r6, pc, r2, ror r2	; <UNPREDICTABLE>
    3290:	6e657261 	cdpvs	2, 6, cr7, cr5, cr1, {3}
    3294:	6f635f74 	svcvs	0x00635f74
    3298:	00726f6c 	rsbseq	r6, r2, ip, ror #30
    329c:	74736562 	ldrbtvc	r6, [r3], #-1378	; 0xfffffa9e
    32a0:	7461645f 	strbtvc	r6, [r1], #-1119	; 0xfffffba1
    32a4:	51440061 	cmppl	r4, r1, rrx
    32a8:	525f5453 	subspl	r5, pc, #1392508928	; 0x53000000
    32ac:	53444145 	movtpl	r4, #16709	; 0x4145
    32b0:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; 23b8 <.debug_str+0x23b8>
    32b4:	6573756e 	ldrbvs	r7, [r3, #-1390]!	; 0xfffffa92
    32b8:	61745f64 	cmnvs	r4, r4, ror #30
    32bc:	41435f67 	cmpmi	r3, r7, ror #30
    32c0:	524f464e 	subpl	r4, pc, #81788928	; 0x4e00000
    32c4:	54535f4b 	ldrbpl	r5, [r3], #-3915	; 0xfffff0b5
    32c8:	00545241 	subseq	r5, r4, r1, asr #4
    32cc:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    32d0:	776b6d5f 			; <UNDEFINED> instruction: 0x776b6d5f
    32d4:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    32d8:	626c7400 	rsbvs	r7, ip, #0, 8
    32dc:	756c665f 	strbvc	r6, [ip, #-1631]!	; 0xfffff9a1
    32e0:	705f6873 	subsvc	r6, pc, r3, ror r8	; <UNPREDICTABLE>
    32e4:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    32e8:	6f00676e 	svcvs	0x0000676e
    32ec:	64665f66 	strbtvs	r5, [r6], #-3942	; 0xfffff09a
    32f0:	61725f74 	cmnvs	r2, r4, ror pc
    32f4:	65725f77 	ldrbvs	r5, [r2, #-3959]!	; 0xfffff089
    32f8:	70006461 	andvc	r6, r0, r1, ror #8
    32fc:	696a6f72 	stmdbvs	sl!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    3300:	5f5f0064 	svcpl	0x005f0064
    3304:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
    3308:	635f6c65 	cmpvs	pc, #25856	; 0x6500
    330c:	6b636f6c 	blvs	18df0c4 <unflatten_and_copy_device_tree+0x18de250>
    3310:	745f6469 	ldrbvc	r6, [pc], #-1129	; 3318 <.debug_str+0x3318>
    3314:	79617000 	stmdbvc	r1!, {ip, sp, lr}^
    3318:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xfffff094
    331c:	53514400 	cmppl	r1, #0, 8
    3320:	52445f54 	subpl	r5, r4, #84, 30	; 0x150
    3324:	0053504f 	subseq	r5, r3, pc, asr #32
    3328:	665f726e 	ldrbvs	r7, [pc], -lr, ror #4
    332c:	656c6961 	strbvs	r6, [ip, #-2401]!	; 0xfffff69f
    3330:	696d5f64 	stmdbvs	sp!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    3334:	74617267 	strbtvc	r7, [r1], #-615	; 0xfffffd99
    3338:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    333c:	6666615f 			; <UNDEFINED> instruction: 0x6666615f
    3340:	00656e69 	rsbeq	r6, r5, r9, ror #28
    3344:	616e6572 	smcvs	58962	; 0xe652
    3348:	6500656d 	strvs	r6, [r0, #-1389]	; 0xfffffa93
    334c:	00646975 	rsbeq	r6, r4, r5, ror r9
    3350:	69747268 	ldmdbvs	r4!, {r3, r5, r6, r9, ip, sp, lr}^
    3354:	5f72656d 	svcpl	0x0072656d
    3358:	6f736572 	svcvs	0x00736572
    335c:	6974756c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
    3360:	6e006e6f 	cdpvs	14, 0, cr6, cr0, cr15, {3}
    3364:	5f7a686f 	svcpl	0x007a686f
    3368:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    336c:	72006576 	andvc	r6, r0, #494927872	; 0x1d800000
    3370:	5f646165 	svcpl	0x00646165
    3374:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
    3378:	74726800 	ldrbtvc	r6, [r2], #-2048	; 0xfffff800
    337c:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    3380:	6f6c6600 	svcvs	0x006c6600
    3384:	62006b63 	andvs	r6, r0, #101376	; 0x18c00
    3388:	615f6e69 	cmpvs	pc, r9, ror #28
    338c:	69727474 	ldmdbvs	r2!, {r2, r4, r5, r6, sl, ip, sp, lr}^
    3390:	65747562 	ldrbvs	r7, [r4, #-1378]!	; 0xfffffa9e
    3394:	617a6b00 	cmnvs	sl, r0, lsl #22
    3398:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
    339c:	74646600 	strbtvc	r6, [r4], #-1536	; 0xfffffa00
    33a0:	7465735f 	strbtvc	r7, [r5], #-863	; 0xfffffca1
    33a4:	706f7270 	rsbvc	r7, pc, r0, ror r2	; <UNPREDICTABLE>
    33a8:	79687000 	stmdbvc	r8!, {ip, sp, lr}^
    33ac:	64615f73 	strbtvs	r5, [r1], #-3955	; 0xfffff08d
    33b0:	745f7264 	ldrbvc	r7, [pc], #-612	; 33b8 <.debug_str+0x33b8>
    33b4:	6f726400 	svcvs	0x00726400
    33b8:	736e5f70 	cmnvc	lr, #112, 30	; 0x1c0
    33bc:	5f6d7600 	svcpl	0x006d7600
    33c0:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    33c4:	5f666f00 	svcpl	0x00666f00
    33c8:	74616c66 	strbtvc	r6, [r1], #-3174	; 0xfffff39a
    33cc:	5f74645f 	svcpl	0x0074645f
    33d0:	6374616d 	cmnvs	r4, #1073741851	; 0x4000001b
    33d4:	616d5f68 	cmnvs	sp, r8, ror #30
    33d8:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    33dc:	51440065 	cmppl	r4, r5, rrx
    33e0:	52505f46 	subspl	r5, r0, #280	; 0x118
    33e4:	54415649 	strbpl	r5, [r1], #-1609	; 0xfffff9b7
    33e8:	5f690045 	svcpl	0x00690045
    33ec:	68736168 	ldmdavs	r3!, {r3, r5, r6, r8, sp, lr}^
    33f0:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
    33f4:	00746e63 	rsbseq	r6, r4, r3, ror #28
    33f8:	70766e65 	rsbsvc	r6, r6, r5, ror #28
    33fc:	44475000 	strbmi	r5, [r7], #-0
    3400:	54434145 	strbpl	r4, [r3], #-325	; 0xfffffebb
    3404:	54415649 	strbpl	r5, [r1], #-1609	; 0xfffff9b7
    3408:	75720045 	ldrbvc	r0, [r2, #-69]!	; 0xffffffbb
    340c:	65645f6e 	strbvs	r5, [r4, #-3950]!	; 0xfffff092
    3410:	0079616c 	rsbseq	r6, r9, ip, ror #2
    3414:	69665f69 	stmdbvs	r6!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    3418:	6d646c65 	stclvs	12, cr6, [r4, #-404]!	; 0xfffffe6c
    341c:	006b7361 	rsbeq	r7, fp, r1, ror #6
    3420:	5f79656b 	svcpl	0x0079656b
    3424:	6c796170 	ldfvse	f6, [r9], #-448	; 0xfffffe40
    3428:	0064616f 	rsbeq	r6, r4, pc, ror #2
    342c:	69746f6e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    3430:	6e5f7966 	cdpvs	9, 5, cr7, cr15, cr6, {3}
    3434:	00747865 	rsbseq	r7, r4, r5, ror #16
    3438:	5f706163 	svcpl	0x00706163
    343c:	65686e69 	strbvs	r6, [r8, #-3689]!	; 0xfffff197
    3440:	61746972 	cmnvs	r4, r2, ror r9
    3444:	00656c62 	rsbeq	r6, r5, r2, ror #24
    3448:	72797264 	rsbsvc	r7, r9, #100, 4	; 0x40000006
    344c:	69006e75 	stmdbvs	r0, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}
    3450:	67635f6f 	strbvs	r5, [r3, -pc, ror #30]!
    3454:	695f7072 	ldmdbvs	pc, {r1, r4, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
    3458:	52440064 	subpl	r0, r4, #100	; 0x64
    345c:	505f504f 	subspl	r5, pc, pc, asr #32
    3460:	43454741 	movtmi	r4, #22337	; 0x5741
    3464:	45484341 	strbmi	r4, [r8, #-833]	; 0xfffffcbf
    3468:	47494d00 	strbmi	r4, [r9, -r0, lsl #26]
    346c:	45544152 	ldrbmi	r4, [r4, #-338]	; 0xfffffeae
    3470:	564f4d5f 			; <UNDEFINED> instruction: 0x564f4d5f
    3474:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    3478:	77736b00 	ldrbvc	r6, [r3, -r0, lsl #22]!
    347c:	5f647061 	svcpl	0x00647061
    3480:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    3484:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    3488:	695f6574 	ldmdbvs	pc, {r2, r4, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    348c:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    3490:	5f636100 	svcpl	0x00636100
    3494:	74697865 	strbtvc	r7, [r9], #-2149	; 0xfffff79b
    3498:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xfffff09d
    349c:	735f5f00 	cmpvc	pc, #0, 30
    34a0:	61686769 	cmnvs	r8, r9, ror #14
    34a4:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0xfffffb92
    34a8:	00745f72 	rsbseq	r5, r4, r2, ror pc
    34ac:	656b5f5f 	strbvs	r5, [fp, #-3935]!	; 0xfffff0a1
    34b0:	6c656e72 	stclvs	14, cr6, [r5], #-456	; 0xfffffe38
    34b4:	6469705f 	strbtvs	r7, [r9], #-95	; 0xffffffa1
    34b8:	6600745f 			; <UNDEFINED> instruction: 0x6600745f
    34bc:	685f7464 	ldmdavs	pc, {r2, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    34c0:	65646165 	strbvs	r6, [r4, #-357]!	; 0xfffffe9b
    34c4:	66630072 			; <UNDEFINED> instruction: 0x66630072
    34c8:	71725f73 	cmnvc	r2, r3, ror pc
    34cc:	73656400 	cmnvc	r5, #0, 8
    34d0:	796f7274 	stmdbvc	pc!, {r2, r4, r5, r6, r9, ip, sp, lr}^	; <UNPREDICTABLE>
    34d4:	726f775f 	rsbvc	r7, pc, #24903680	; 0x17c0000
    34d8:	6564006b 	strbvs	r0, [r4, #-107]!	; 0xffffff95
    34dc:	646e6570 	strbtvs	r6, [lr], #-1392	; 0xfffffa90
    34e0:	6e6f5f73 	mcrvs	15, 3, r5, cr15, cr3, {3}
    34e4:	79747400 	ldmdbvc	r4!, {sl, ip, sp, lr}^
    34e8:	726f705f 	rsbvc	r7, pc, #95	; 0x5f
    34ec:	706f5f74 	rsbvc	r5, pc, r4, ror pc	; <UNPREDICTABLE>
    34f0:	74617265 	strbtvc	r7, [r1], #-613	; 0xfffffd9b
    34f4:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    34f8:	6f6e6900 	svcvs	0x006e6900
    34fc:	7261775f 	rsbvc	r7, r1, #24903680	; 0x17c0000
    3500:	6d696c6e 	stclvs	12, cr6, [r9, #-440]!	; 0xfffffe48
    3504:	74007469 	strvc	r7, [r0], #-1129	; 0xfffffb97
    3508:	5f6b7361 	svcpl	0x006b7361
    350c:	67617266 	strbvs	r7, [r1, -r6, ror #4]!
    3510:	5f646200 	svcpl	0x00646200
    3514:	646c6f68 	strbtvs	r6, [ip], #-3944	; 0xfffff098
    3518:	645f7265 	ldrbvs	r7, [pc], #-613	; 3520 <.debug_str+0x3520>
    351c:	736b7369 	cmnvc	fp, #-1543503871	; 0xa4000001
    3520:	69646c00 	stmdbvs	r4!, {sl, fp, sp, lr}^
    3524:	73006373 	movwvc	r6, #883	; 0x373
    3528:	6e6f6365 	cdpvs	3, 6, cr6, cr15, cr5, {3}
    352c:	79726164 	ldmdbvc	r2!, {r2, r5, r6, r8, sp, lr}^
    3530:	726f7700 	rsbvc	r7, pc, #0, 14
    3534:	6575716b 	ldrbvs	r7, [r5, #-363]!	; 0xfffffe95
    3538:	735f6575 	cmpvc	pc, #490733568	; 0x1d400000
    353c:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    3540:	47500074 			; <UNDEFINED> instruction: 0x47500074
    3544:	4e414353 	mcrmi	3, 2, r4, cr1, cr3, {2}
    3548:	57534b5f 			; <UNDEFINED> instruction: 0x57534b5f
    354c:	5f445041 	svcpl	0x00445041
    3550:	4d524f4e 	ldclmi	15, cr4, [r2, #-312]	; 0xfffffec8
    3554:	72004c41 	andvc	r4, r0, #16640	; 0x4100
    3558:	74657365 	strbtvc	r7, [r5], #-869	; 0xfffffc9b
    355c:	62656400 	rsbvs	r6, r5, #0, 8
    3560:	695f6775 	ldmdbvs	pc, {r0, r2, r4, r5, r6, r8, r9, sl, sp, lr}^	; <UNPREDICTABLE>
    3564:	006f666e 	rsbeq	r6, pc, lr, ror #12
    3568:	5f736173 	svcpl	0x00736173
    356c:	735f7373 	cmpvc	pc, #-872415231	; 0xcc000001
    3570:	64660070 	strbtvs	r0, [r6], #-112	; 0xffffff90
    3574:	65675f74 	strbvs	r5, [r7, #-3956]!	; 0xfffff08c
    3578:	6f727074 	svcvs	0x00727074
    357c:	79740070 	ldmdbvc	r4!, {r4, r5, r6}^
    3580:	73006570 	movwvc	r6, #1392	; 0x570
    3584:	6f6d755f 	svcvs	0x006d755f
    3588:	5f746e75 	svcpl	0x00746e75
    358c:	0079656b 	rsbseq	r6, r9, fp, ror #10
    3590:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    3594:	6165725f 	cmnvs	r5, pc, asr r2
    3598:	73726564 	cmnvc	r2, #100, 10	; 0x19000000
    359c:	5f6d6c00 	svcpl	0x006d6c00
    35a0:	5f746567 	svcpl	0x00746567
    35a4:	656e776f 	strbvs	r7, [lr, #-1903]!	; 0xfffff891
    35a8:	69730072 	ldmdbvs	r3!, {r1, r4, r5, r6}^
    35ac:	6e616867 	cdpvs	8, 6, cr6, cr1, cr7, {3}
    35b0:	47430064 	strbmi	r0, [r3, -r4, rrx]
    35b4:	50554f52 	subspl	r4, r5, r2, asr pc
    35b8:	4e41435f 	mcrmi	3, 2, r4, cr1, cr15, {2}
    35bc:	4b524f46 	blmi	14972dc <unflatten_and_copy_device_tree+0x1496468>
    35c0:	4154535f 	cmpmi	r4, pc, asr r3
    35c4:	63005452 	movwvs	r5, #1106	; 0x452
    35c8:	5f6e696d 	svcpl	0x006e696d
    35cc:	00746c66 	rsbseq	r6, r4, r6, ror #24
    35d0:	74726964 	ldrbtvc	r6, [r2], #-2404	; 0xfffff69c
    35d4:	5f646569 	svcpl	0x00646569
    35d8:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    35dc:	6568775f 	strbvs	r7, [r8, #-1887]!	; 0xfffff8a1
    35e0:	6564006e 	strbvs	r0, [r4, #-110]!	; 0xffffff92
    35e4:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
    35e8:	6f697470 	svcvs	0x00697470
    35ec:	6e69006e 	cdpvs	0, 6, cr0, cr9, cr14, {3}
    35f0:	6578655f 	ldrbvs	r6, [r8, #-1375]!	; 0xfffffaa1
    35f4:	00657663 	rsbeq	r7, r5, r3, ror #12
    35f8:	6e645f64 	cdpvs	15, 6, cr5, cr4, cr4, {3}
    35fc:	00656d61 	rsbeq	r6, r5, r1, ror #26
    3600:	5f646364 	svcpl	0x00646364
    3604:	6e616863 	cdpvs	8, 6, cr6, cr1, cr3, {3}
    3608:	64006567 	strvs	r6, [r0], #-1383	; 0xfffffa99
    360c:	6f6c5f71 	svcvs	0x006c5f71
    3610:	6e006b63 	vmlsvs.f64	d6, d0, d19
    3614:	64615f72 	strbtvs	r5, [r1], #-3954	; 0xfffff08e
    3618:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
    361c:	65635f73 	strbvs	r5, [r3, #-3955]!	; 0xfffff08d
    3620:	00736c6c 	rsbseq	r6, r3, ip, ror #24
    3624:	6d6d5f69 	stclvs	15, cr5, [sp, #-420]!	; 0xfffffe5c
    3628:	71007061 	tstvc	r0, r1, rrx
    362c:	61746f75 	cmnvs	r4, r5, ror pc
    3630:	726f665f 	rsbvc	r6, pc, #99614720	; 0x5f00000
    3634:	5f74616d 	svcpl	0x0074616d
    3638:	0073706f 	rsbseq	r7, r3, pc, rrx
    363c:	6c666e75 	stclvs	14, cr6, [r6], #-468	; 0xfffffe2c
    3640:	65747461 	ldrbvs	r7, [r4, #-1121]!	; 0xfffffb9f
    3644:	65645f6e 	strbvs	r5, [r4, #-3950]!	; 0xfffff092
    3648:	65636976 	strbvs	r6, [r3, #-2422]!	; 0xfffff68a
    364c:	6572745f 	ldrbvs	r7, [r2, #-1119]!	; 0xfffffba1
    3650:	6c720065 	ldclvs	0, cr0, [r2], #-404	; 0xfffffe6c
    3654:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
    3658:	5f726e00 	svcpl	0x00726e00
    365c:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    3660:	6c65635f 	stclvs	3, cr6, [r5], #-380	; 0xfffffe84
    3664:	6d00736c 	stcvs	3, cr7, [r0, #-432]	; 0xfffffe50
    3668:	645f6d65 	ldrbvs	r6, [pc], #-3429	; 3670 <.debug_str+0x3670>
    366c:	6b6c6271 	blvs	1b1c038 <unflatten_and_copy_device_tree+0x1b1b1c4>
    3670:	63616200 	cmnvs	r1, #0, 4
    3674:	0070756b 	rsbseq	r7, r0, fp, ror #10
    3678:	755f6361 	ldrbvc	r6, [pc, #-865]	; 331f <.debug_str+0x331f>
    367c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    3680:	72657000 	rsbvc	r7, r5, #0
    3684:	5f757063 	svcpl	0x00757063
    3688:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    368c:	00726574 	rsbseq	r6, r2, r4, ror r5
    3690:	6c616572 	cfstr64vs	mvdx6, [r1], #-456	; 0xfffffe38
    3694:	6572635f 	ldrbvs	r6, [r2, #-863]!	; 0xfffffca1
    3698:	69700064 	ldmdbvs	r0!, {r2, r5, r6}^
    369c:	6174735f 	cmnvs	r4, pc, asr r3
    36a0:	635f6574 	cmpvs	pc, #116, 10	; 0x1d000000
    36a4:	65686361 	strbvs	r6, [r8, #-865]!	; 0xfffffc9f
    36a8:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
    36ac:	6e755f74 	mrcvs	15, 3, r5, cr5, cr4, {3}
    36b0:	7a6f7266 	bvc	1be0050 <unflatten_and_copy_device_tree+0x1bdf1dc>
    36b4:	6e006e65 	cdpvs	14, 0, cr6, cr0, cr5, {3}
    36b8:	65626d75 	strbvs	r6, [r2, #-3445]!	; 0xfffff28b
    36bc:	73007372 	movwvc	r7, #882	; 0x372
    36c0:	6f635f69 	svcvs	0x00635f69
    36c4:	73006564 	movwvc	r6, #1380	; 0x564
    36c8:	6165725f 	cmnvs	r5, pc, asr r2
    36cc:	6c6e6f64 	stclvs	15, cr6, [lr], #-400	; 0xfffffe70
    36d0:	65725f79 	ldrbvs	r5, [r2, #-3961]!	; 0xfffff087
    36d4:	6e756f6d 	cdpvs	15, 7, cr6, cr5, cr13, {3}
    36d8:	70660074 	rsbvc	r0, r6, r4, ror r0
    36dc:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    36e0:	5f6d6d00 	svcpl	0x006d6d00
    36e4:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
    36e8:	64007463 	strvs	r7, [r0], #-1123	; 0xfffffb9d
    36ec:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    36f0:	6e696c6e 	cdpvs	12, 6, cr6, cr9, cr14, {3}
    36f4:	5f64006b 	svcpl	0x0064006b
    36f8:	65726170 	ldrbvs	r6, [r2, #-368]!	; 0xfffffe90
    36fc:	6e00746e 	cdpvs	4, 0, cr7, cr0, cr14, {3}
    3700:	5f347366 	svcpl	0x00347366
    3704:	6b636f6c 	blvs	18df4bc <unflatten_and_copy_device_tree+0x18de648>
    3708:	6174735f 	cmnvs	r4, pc, asr r3
    370c:	61006574 	tstvs	r0, r4, ror r5
    3710:	696d6f74 	stmdbvs	sp!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    3714:	00745f63 	rsbseq	r5, r4, r3, ror #30
    3718:	6c66666f 	stclvs	6, cr6, [r6], #-444	; 0xfffffe44
    371c:	5f656e69 	svcpl	0x00656e69
    3720:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    3724:	61700071 	cmnvs	r0, r1, ror r0
    3728:	68006874 	stmdavs	r0, {r2, r4, r5, r6, fp, sp, lr}
    372c:	61726569 	cmnvs	r2, r9, ror #10
    3730:	79686372 	stmdbvc	r8!, {r1, r4, r5, r6, r8, r9, sp, lr}^
    3734:	0064695f 	rsbeq	r6, r4, pc, asr r9
    3738:	665f6169 	ldrbvs	r6, [pc], -r9, ror #2
    373c:	00656c69 	rsbeq	r6, r5, r9, ror #24
    3740:	6e6f6e61 	cdpvs	14, 6, cr6, cr15, cr1, {3}
    3744:	616d765f 	cmnvs	sp, pc, asr r6
    3748:	5f646200 	svcpl	0x00646200
    374c:	646c6f68 	strbtvs	r6, [ip], #-3944	; 0xfffff098
    3750:	00737265 	rsbseq	r7, r3, r5, ror #4
    3754:	635f6d6c 	cmpvs	pc, #108, 26	; 0x1b00
    3758:	61706d6f 	cmnvs	r0, pc, ror #26
    375c:	6f5f6572 	svcvs	0x005f6572
    3760:	72656e77 	rsbvc	r6, r5, #1904	; 0x770
    3764:	666e7500 	strbtvs	r7, [lr], -r0, lsl #10
    3768:	7474616c 	ldrbtvc	r6, [r4], #-364	; 0xfffffe94
    376c:	645f6e65 	ldrbvs	r6, [pc], #-3685	; 3774 <.debug_str+0x3774>
    3770:	6f6e5f74 	svcvs	0x006e5f74
    3774:	64006564 	strvs	r6, [r0], #-1380	; 0xfffffa9c
    3778:	61746c65 	cmnvs	r4, r5, ror #24
    377c:	72736d5f 	rsbsvc	r6, r3, #6080	; 0x17c0
    3780:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    3784:	6f730074 	svcvs	0x00730074
    3788:	72697466 	rsbvc	r7, r9, #1711276032	; 0x66000000
    378c:	6e655f71 	mcrvs	15, 3, r5, cr5, cr1, {3}
    3790:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
    3794:	0070695f 	rsbseq	r6, r0, pc, asr r9
    3798:	74736166 	ldrbtvc	r6, [r3], #-358	; 0xfffffe9a
    379c:	6165725f 	cmnvs	r5, pc, asr r2
    37a0:	74635f64 	strbtvc	r5, [r3], #-3940	; 0xfffff09c
    37a4:	524c0072 	subpl	r0, ip, #114	; 0x72
    37a8:	4e495f55 	mcrmi	15, 2, r5, cr9, cr5, {2}
    37ac:	49544341 	ldmdbmi	r4, {r0, r6, r8, r9, lr}^
    37b0:	415f4556 	cmpmi	pc, r6, asr r5	; <UNPREDICTABLE>
    37b4:	004e4f4e 	subeq	r4, lr, lr, asr #30
    37b8:	73657270 	cmnvc	r5, #112, 4
    37bc:	5f746e65 	svcpl	0x00746e65
    37c0:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    37c4:	75630073 	strbvc	r0, [r3, #-115]!	; 0xffffff8d
    37c8:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    37cc:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xfffff08c
    37d0:	5f6b6361 	svcpl	0x006b6361
    37d4:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    37d8:	00726574 	rsbseq	r6, r2, r4, ror r5
    37dc:	43534750 	cmpmi	r3, #80, 14	; 0x1400000
    37e0:	4b5f4e41 	blmi	17d70ec <unflatten_and_copy_device_tree+0x17d6278>
    37e4:	50415753 	subpl	r5, r1, r3, asr r7
    37e8:	4d445f44 	stclmi	15, cr5, [r4, #-272]	; 0xfffffef0
    37ec:	72660041 	rsbvc	r0, r6, #65	; 0x41
    37f0:	72006565 	andvc	r6, r0, #423624704	; 0x19400000
    37f4:	0070746d 	rsbseq	r7, r0, sp, ror #8
    37f8:	616d5f73 	smcvs	54771	; 0xd5f3
    37fc:	00636967 	rsbeq	r6, r3, r7, ror #18
    3800:	6f6c5f64 	svcvs	0x006c5f64
    3804:	65726b63 	ldrbvs	r6, [r2, #-2915]!	; 0xfffff49d
    3808:	6e690066 	cdpvs	0, 6, cr0, cr9, cr6, {3}
    380c:	70006f66 	andvc	r6, r0, r6, ror #30
    3810:	5f667265 	svcpl	0x00667265
    3814:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    3818:	696c5f74 	stmdbvs	ip!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    381c:	72007473 	andvc	r7, r0, #1929379840	; 0x73000000
    3820:	7375626f 	cmnvc	r5, #-268435450	; 0xf0000006
    3824:	696c5f74 	stmdbvs	ip!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    3828:	685f7473 	ldmdavs	pc, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    382c:	00646165 	rsbeq	r6, r4, r5, ror #2
    3830:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    3834:	735f6472 	cmpvc	pc, #1912602624	; 0x72000000
    3838:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
    383c:	5f737700 	svcpl	0x00737700
    3840:	78697078 	stmdavc	r9!, {r3, r4, r5, r6, ip, sp, lr}^
    3844:	75006c65 	strvc	r6, [r0, #-3173]	; 0xfffff39b
    3848:	626f7270 	rsbvs	r7, pc, #112, 4
    384c:	61745f65 	cmnvs	r4, r5, ror #30
    3850:	735f6b73 	cmpvc	pc, #117760	; 0x1cc00
    3854:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    3858:	73616c00 	cmnvc	r1, #0, 24
    385c:	72615f74 	rsbvc	r5, r1, #116, 30	; 0x1d0
    3860:	61766972 	cmnvs	r6, r2, ror r9
    3864:	6f7a006c 	svcvs	0x007a006c
    3868:	705f656e 	subsvc	r6, pc, lr, ror #10
    386c:	69646461 	stmdbvs	r4!, {r0, r5, r6, sl, sp, lr}^
    3870:	7000676e 	andvc	r6, r0, lr, ror #14
    3874:	6c5f7475 	cfldrdvs	mvd7, [pc], {117}	; 0x75
    3878:	006b6e69 	rsbeq	r6, fp, r9, ror #28
    387c:	64657263 	strbtvs	r7, [r5], #-611	; 0xfffffd9d
    3880:	6175675f 	cmnvs	r5, pc, asr r7
    3884:	6d5f6472 	cfldrdvs	mvd6, [pc, #-456]	; 36c4 <.debug_str+0x36c4>
    3888:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    388c:	616d6b00 	cmnvs	sp, r0, lsl #22
    3890:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
    3894:	72616c5f 	rsbvc	r6, r1, #24320	; 0x5f00
    3898:	6d006567 	cfstr32vs	mvfx6, [r0, #-412]	; 0xfffffe64
    389c:	61726769 	cmnvs	r2, r9, ror #14
    38a0:	61706574 	cmnvs	r0, r4, ror r5
    38a4:	73006567 	movwvc	r6, #1383	; 0x567
    38a8:	00706f5f 	rsbseq	r6, r0, pc, asr pc
    38ac:	5f555043 	svcpl	0x00555043
    38b0:	4c57454e 	cfldr64mi	mvdx4, [r7], {78}	; 0x4e
    38b4:	44495f59 	strbmi	r5, [r9], #-3929	; 0xfffff0a7
    38b8:	7300454c 	movwvc	r4, #1356	; 0x54c
    38bc:	6974666f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r6, r9, sl, sp, lr}^
    38c0:	645f7172 	ldrbvs	r7, [pc], #-370	; 38c8 <.debug_str+0x38c8>
    38c4:	62617369 	rsbvs	r7, r1, #-1543503871	; 0xa4000001
    38c8:	655f656c 	ldrbvs	r6, [pc, #-1388]	; 3364 <.debug_str+0x3364>
    38cc:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
    38d0:	5f6c6600 	svcpl	0x006c6600
    38d4:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    38d8:	6f630074 	svcvs	0x00630074
    38dc:	735f6572 	cmpvc	pc, #478150656	; 0x1c800000
    38e0:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    38e4:	6f687300 	svcvs	0x00687300
    38e8:	65645f77 	strbvs	r5, [r4, #-3959]!	; 0xfffff089
    38ec:	6d616e76 	stclvs	14, cr6, [r1, #-472]!	; 0xfffffe28
    38f0:	61690065 	cmnvs	r9, r5, rrx
    38f4:	6469675f 	strbtvs	r6, [r9], #-1887	; 0xfffff8a1
    38f8:	725f5f00 	subsvc	r5, pc, #0, 30
    38fc:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
    3900:	5f646576 	svcpl	0x00646576
    3904:	5f6d656d 	svcpl	0x006d656d
    3908:	65736572 	ldrbvs	r6, [r3, #-1394]!	; 0xfffffa8e
    390c:	5f657672 	svcpl	0x00657672
    3910:	00676572 	rsbeq	r6, r7, r2, ror r5
    3914:	74657363 	strbtvc	r7, [r5], #-867	; 0xfffffc9d
    3918:	6e696c5f 	mcrvs	12, 3, r6, cr9, cr15, {2}
    391c:	6400736b 	strvs	r7, [r0], #-875	; 0xfffffc95
    3920:	75735f6f 	ldrbvc	r5, [r3, #-3951]!	; 0xfffff091
    3924:	6e657073 	mcrvs	0, 3, r7, cr5, cr3, {3}
    3928:	61760064 	cmnvs	r6, r4, rrx
    392c:	0065756c 	rsbeq	r7, r5, ip, ror #10
    3930:	63727473 	cmnvs	r2, #1929379840	; 0x73000000
    3934:	756e7268 	strbvc	r7, [lr, #-616]!	; 0xfffffd98
    3938:	4253006c 	subsmi	r0, r3, #108	; 0x6c
    393c:	4552465f 	ldrbmi	r4, [r2, #-1631]	; 0xfffff9a1
    3940:	5f455a45 	svcpl	0x00455a45
    3944:	45474150 	strbmi	r4, [r7, #-336]	; 0xfffffeb0
    3948:	4c554146 	ldfmie	f4, [r5], {70}	; 0x46
    394c:	6f6b0054 	svcvs	0x006b0054
    3950:	755f6a62 	ldrbvc	r6, [pc, #-2658]	; 2ef6 <.debug_str+0x2ef6>
    3954:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    3958:	6e655f74 	mcrvs	15, 3, r5, cr5, cr4, {3}
    395c:	75730076 	ldrbvc	r0, [r3, #-118]!	; 0xffffff8a
    3960:	73006469 	movwvc	r6, #1129	; 0x469
    3964:	63746977 	cmnvs	r4, #1949696	; 0x1dc000
    3968:	6d6d5f68 	stclvs	15, cr5, [sp, #-416]!	; 0xfffffe60
    396c:	766f6900 	strbtvc	r6, [pc], -r0, lsl #18
    3970:	6574695f 	ldrbvs	r6, [r4, #-2399]!	; 0xfffff6a1
    3974:	4e550072 	mrcmi	0, 2, r0, cr5, cr2, {3}
    3978:	43495645 	movtmi	r5, #38469	; 0x9645
    397c:	4c424154 	stfmie	f4, [r2], {84}	; 0x54
    3980:	47505f45 	ldrbmi	r5, [r0, -r5, asr #30]
    3984:	41525453 	cmpmi	r2, r3, asr r4
    3988:	4445444e 	strbmi	r4, [r5], #-1102	; 0xfffffbb2
    398c:	5f524e00 	svcpl	0x00524e00
    3990:	454c4946 	strbmi	r4, [ip, #-2374]	; 0xfffff6ba
    3994:	50414d5f 	subpl	r4, r1, pc, asr sp
    3998:	00444550 	subeq	r4, r4, r0, asr r5
    399c:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    39a0:	5f455441 	svcpl	0x00455441
    39a4:	4f4d4e55 	svcmi	0x004d4e55
    39a8:	4c424156 	stfmie	f4, [r2], {86}	; 0x56
    39ac:	65730045 	ldrbvs	r0, [r3, #-69]!	; 0xffffffbb
    39b0:	6f697373 	svcvs	0x00697373
    39b4:	656b5f6e 	strbvs	r5, [fp, #-3950]!	; 0xfffff092
    39b8:	6e697279 	mcrvs	2, 3, r7, cr9, cr9, {3}
    39bc:	6c660067 	stclvs	0, cr0, [r6], #-412	; 0xfffffe64
    39c0:	635f776f 	cmpvs	pc, #29097984	; 0x1bc0000
    39c4:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    39c8:	72700065 	rsbsvc	r0, r0, #101	; 0x65
    39cc:	635f7665 	cmpvs	pc, #105906176	; 0x6500000
    39d0:	69747570 	ldmdbvs	r4!, {r4, r5, r6, r8, sl, ip, sp, lr}^
    39d4:	6600656d 	strvs	r6, [r0], -sp, ror #10
    39d8:	75735f73 	ldrbvc	r5, [r3, #-3955]!	; 0xfffff08d
    39dc:	73726570 	cmnvc	r2, #112, 10	; 0x1c000000
    39e0:	69676b00 	stmdbvs	r7!, {r8, r9, fp, sp, lr}^
    39e4:	00745f64 	rsbseq	r5, r4, r4, ror #30
    39e8:	65746177 	ldrbvs	r6, [r4, #-375]!	; 0xfffffe89
    39ec:	72616d72 	rsbvc	r6, r1, #7296	; 0x1c80
    39f0:	5746006b 	strbpl	r0, [r6, -fp, rrx]
    39f4:	45444f4e 	strbmi	r4, [r4, #-3918]	; 0xfffff0b2
    39f8:	5043415f 	subpl	r4, r3, pc, asr r1
    39fc:	41445f49 	cmpmi	r4, r9, asr #30
    3a00:	70004154 	andvc	r4, r0, r4, asr r1
    3a04:	74636361 	strbtvc	r6, [r3], #-865	; 0xfffffc9f
    3a08:	72687400 	rsbvc	r7, r8, #0, 8
    3a0c:	00646165 	rsbeq	r6, r4, r5, ror #2
    3a10:	685f6263 	ldmdavs	pc, {r0, r1, r5, r6, r9, sp, lr}^	; <UNPREDICTABLE>
    3a14:	00646165 	rsbeq	r6, r4, r5, ror #2
    3a18:	6e5f666f 	cdpvs	6, 5, cr6, cr15, cr15, {3}
    3a1c:	5f65646f 	svcpl	0x0065646f
    3a20:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    3a24:	6e696c00 	cdpvs	12, 6, cr6, cr9, cr0, {0}
    3a28:	625f7875 	subsvs	r7, pc, #7667712	; 0x750000
    3a2c:	6d666e69 	stclvs	14, cr6, [r6, #-420]!	; 0xfffffe5c
    3a30:	72620074 	rsbvc	r0, r2, #116	; 0x74
    3a34:	6e656b6f 	vnmulvs.f64	d22, d5, d31
    3a38:	6569685f 	strbvs	r6, [r9, #-2143]!	; 0xfffff7a1
    3a3c:	63726172 	cmnvs	r2, #-2147483620	; 0x8000001c
    3a40:	63007968 	movwvs	r7, #2408	; 0x968
    3a44:	6c66695f 	stclvs	9, cr6, [r6], #-380	; 0xfffffe84
    3a48:	70006761 	andvc	r6, r0, r1, ror #14
    3a4c:	5f667265 	svcpl	0x00667265
    3a50:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    3a54:	6f7a0074 	svcvs	0x007a0074
    3a58:	745f656e 	ldrbvc	r6, [pc], #-1390	; 3a60 <.debug_str+0x3a60>
    3a5c:	00657079 	rsbeq	r7, r5, r9, ror r0
    3a60:	72747461 	rsbsvc	r7, r4, #1627389952	; 0x61000000
    3a64:	74756269 	ldrbtvc	r6, [r5], #-617	; 0xfffffd97
    3a68:	6f690065 	svcvs	0x00690065
    3a6c:	5f787463 	svcpl	0x00787463
    3a70:	6c626174 	stfvse	f6, [r2], #-464	; 0xfffffe30
    3a74:	6d760065 	ldclvs	0, cr0, [r6, #-404]!	; 0xfffffe6c
    3a78:	6f67705f 	svcvs	0x0067705f
    3a7c:	4e006666 	cfmadd32mi	mvax3, mvfx6, mvfx0, mvfx6
    3a80:	43415f52 	movtmi	r5, #8018	; 0x1f52
    3a84:	45564954 	ldrbmi	r4, [r6, #-2388]	; 0xfffff6ac
    3a88:	4c49465f 	mcrrmi	6, 5, r4, r9, cr15
    3a8c:	65670045 	strbvs	r0, [r7, #-69]!	; 0xffffffbb
    3a90:	6e755f74 	mrcvs	15, 3, r5, cr5, cr4, {3}
    3a94:	7070616d 	rsbsvc	r6, r0, sp, ror #2
    3a98:	615f6465 	cmpvs	pc, r5, ror #8
    3a9c:	00616572 	rsbeq	r6, r1, r2, ror r5
    3aa0:	74696e75 	strbtvc	r6, [r9], #-3701	; 0xfffff18b
    3aa4:	73630073 	cmnvc	r3, #115	; 0x73
    3aa8:	5f655f73 	svcpl	0x00655f73
    3aac:	5f737363 	svcpl	0x00737363
    3ab0:	6e616863 	cdpvs	8, 6, cr6, cr1, cr3, {3}
    3ab4:	00646567 	rsbeq	r6, r4, r7, ror #10
    3ab8:	725f666f 	subsvc	r6, pc, #116391936	; 0x6f00000
    3abc:	00746f6f 	rsbseq	r6, r4, pc, ror #30
    3ac0:	6c6c6f70 	stclvs	15, cr6, [ip], #-448	; 0xfffffe40
    3ac4:	6261745f 	rsbvs	r7, r1, #1593835520	; 0x5f000000
    3ac8:	735f656c 	cmpvc	pc, #108, 10	; 0x1b000000
    3acc:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    3ad0:	5f5f0074 	svcpl	0x005f0074
    3ad4:	6e72656b 	cdpvs	5, 7, cr6, cr2, cr11, {3}
    3ad8:	6c5f6c65 	mrrcvs	12, 6, r6, pc, cr5	; <UNPREDICTABLE>
    3adc:	5f66666f 	svcpl	0x0066666f
    3ae0:	61770074 	cmnvs	r7, r4, ror r0
    3ae4:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
    3ae8:	69006d75 	stmdbvs	r0, {r0, r2, r4, r5, r6, r8, sl, fp, sp, lr}
    3aec:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    3af0:	6e5f6c61 	cdpvs	12, 5, cr6, cr15, cr1, {3}
    3af4:	61770073 	cmnvs	r7, r3, ror r0
    3af8:	635f7469 	cmpvs	pc, #1761607680	; 0x69000000
    3afc:	65646c68 	strbvs	r6, [r4, #-3176]!	; 0xfffff398
    3b00:	00746978 	rsbseq	r6, r4, r8, ror r9
    3b04:	5f646970 	svcpl	0x00646970
    3b08:	6b6e696c 	blvs	1b9e0c0 <unflatten_and_copy_device_tree+0x1b9d24c>
    3b0c:	67617000 	strbvs	r7, [r1, -r0]!
    3b10:	61745f65 	cmnvs	r4, r5, ror #30
    3b14:	5f656c62 	svcpl	0x00656c62
    3b18:	6b636f6c 	blvs	18df8d0 <unflatten_and_copy_device_tree+0x18dea5c>
    3b1c:	5f676d00 	svcpl	0x00676d00
    3b20:	6c657270 	sfmvs	f7, 2, [r5], #-448	; 0xfffffe40
    3b24:	5f64616f 	svcpl	0x0064616f
    3b28:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    3b2c:	61747300 	cmnvs	r4, r0, lsl #6
    3b30:	70006b63 	andvc	r6, r0, r3, ror #22
    3b34:	0067756c 	rsbeq	r7, r7, ip, ror #10
    3b38:	746f7571 	strbtvc	r7, [pc], #-1393	; 3b40 <.debug_str+0x3b40>
    3b3c:	6e695f61 	cdpvs	15, 6, cr5, cr9, cr1, {3}
    3b40:	63006f66 	movwvs	r6, #3942	; 0xf66
    3b44:	756f7267 	strbvc	r7, [pc, #-615]!	; 38e5 <.debug_str+0x38e5>
    3b48:	61745f70 	cmnvs	r4, r0, ror pc
    3b4c:	65736b73 	ldrbvs	r6, [r3, #-2931]!	; 0xfffff48d
    3b50:	75710074 	ldrbvc	r0, [r1, #-116]!	; 0xffffff8c
    3b54:	5f61746f 	svcpl	0x0061746f
    3b58:	0066666f 	rsbeq	r6, r6, pc, ror #12
    3b5c:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    3b60:	00726574 	rsbseq	r6, r2, r4, ror r5
    3b64:	5f746573 	svcpl	0x00746573
    3b68:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    3b6c:	7269645f 	rsbvc	r6, r9, #1593835520	; 0x5f000000
    3b70:	76007974 			; <UNDEFINED> instruction: 0x76007974
    3b74:	72705f6d 	rsbsvc	r5, r0, #436	; 0x1b4
    3b78:	74617669 	strbtvc	r7, [r1], #-1641	; 0xfffff997
    3b7c:	61645f65 	cmnvs	r4, r5, ror #30
    3b80:	66006174 			; <UNDEFINED> instruction: 0x66006174
    3b84:	6c5f636c 	mrrcvs	3, 6, r6, pc, cr12	; <UNPREDICTABLE>
    3b88:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0xfffffe9b
    3b8c:	646f6e00 	strbtvs	r6, [pc], #-3584	; 3b94 <.debug_str+0x3b94>
    3b90:	74735f65 	ldrbtvc	r5, [r3], #-3941	; 0xfffff09b
    3b94:	73657461 	cmnvc	r5, #1627389952	; 0x61000000
    3b98:	50475000 	subpl	r5, r7, r0
    3b9c:	54554f47 	ldrbpl	r4, [r5], #-3911	; 0xfffff0b9
    3ba0:	756f6300 	strbvc	r6, [pc, #-768]!	; 38a8 <.debug_str+0x38a8>
    3ba4:	4800746e 	stmdami	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    3ba8:	4d495452 	cfstrdmi	mvd5, [r9, #-328]	; 0xfffffeb8
    3bac:	535f5245 	cmppl	pc, #1342177284	; 0x50000004
    3bb0:	4954464f 	ldmdbmi	r4, {r0, r1, r2, r3, r6, r9, sl, lr}^
    3bb4:	6c005152 	stfvss	f5, [r0], {82}	; 0x52
    3bb8:	5f747369 	svcpl	0x00747369
    3bbc:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    3bc0:	5f746400 	svcpl	0x00746400
    3bc4:	6f6c6c61 	svcvs	0x006c6c61
    3bc8:	726e0063 	rsbvc	r0, lr, #99	; 0x63
    3bcc:	5f6f745f 	svcpl	0x006f745f
    3bd0:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
    3bd4:	5f726e00 	svcpl	0x00726e00
    3bd8:	73757063 	cmnvc	r5, #99	; 0x63
    3bdc:	6c6c615f 	stfvse	f6, [ip], #-380	; 0xfffffe84
    3be0:	6465776f 	strbtvs	r7, [r5], #-1903	; 0xfffff891
    3be4:	6f706500 	svcvs	0x00706500
    3be8:	775f6c6c 	ldrbvc	r6, [pc, -ip, ror #24]
    3bec:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    3bf0:	70007365 	andvc	r7, r0, r5, ror #6
    3bf4:	76657270 			; <UNDEFINED> instruction: 0x76657270
    3bf8:	5f6e6900 	svcpl	0x006e6900
    3bfc:	69747268 	ldmdbvs	r4!, {r3, r5, r6, r9, ip, sp, lr}^
    3c00:	69007172 	stmdbvs	r0, {r1, r4, r5, r6, r8, ip, sp, lr}
    3c04:	6e65675f 	mcrvs	7, 3, r6, cr5, cr15, {2}
    3c08:	74617265 	strbtvc	r7, [r1], #-613	; 0xfffffd9b
    3c0c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    3c10:	6c635f5f 	stclvs	15, cr5, [r3], #-380	; 0xfffffe84
    3c14:	5f66007a 	svcpl	0x0066007a
    3c18:	656e776f 	strbvs	r7, [lr, #-1903]!	; 0xfffff891
    3c1c:	69740072 	ldmdbvs	r4!, {r1, r4, r5, r6}^
    3c20:	7172656d 	cmnvc	r2, sp, ror #10
    3c24:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0xfffffa8b
    3c28:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 3c30 <.debug_str+0x3c30>
    3c2c:	7a5f0065 	bvc	17c3dc8 <unflatten_and_copy_device_tree+0x17c2f54>
    3c30:	72656e6f 	rsbvc	r6, r5, #1776	; 0x6f0
    3c34:	00736665 	rsbseq	r6, r3, r5, ror #12
    3c38:	4a424f4b 	bmi	109796c <unflatten_and_copy_device_tree+0x1096af8>
    3c3c:	5f534e5f 	svcpl	0x00534e5f
    3c40:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0xfffff6ac
    3c44:	6c660053 	stclvs	0, cr0, [r6], #-332	; 0xfffffeb4
    3c48:	7361665f 	cmnvc	r1, #99614720	; 0x5f00000
    3c4c:	00636e79 	rsbeq	r6, r3, r9, ror lr
    3c50:	746f7571 	strbtvc	r7, [pc], #-1393	; 3c58 <.debug_str+0x3c58>
    3c54:	79735f61 	ldmdbvc	r3!, {r0, r5, r6, r8, r9, sl, fp, ip, lr}^
    3c58:	6400636e 	strvs	r6, [r0], #-878	; 0xfffffc92
    3c5c:	6f625f6c 	svcvs	0x00625f6c
    3c60:	6574736f 	ldrbvs	r7, [r4, #-879]!	; 0xfffffc91
    3c64:	74630064 	strbtvc	r0, [r3], #-100	; 0xffffff9c
    3c68:	00656d69 	rsbeq	r6, r5, r9, ror #26
    3c6c:	645f6c66 	ldrbvs	r6, [pc], #-3174	; 3c74 <.debug_str+0x3c74>
    3c70:	676e776f 	strbvs	r7, [lr, -pc, ror #14]!
    3c74:	65646172 	strbvs	r6, [r4, #-370]!	; 0xfffffe8e
    3c78:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    3c7c:	73630065 	cmnvc	r3, #101	; 0x65
    3c80:	65725f73 	ldrbvs	r5, [r2, #-3955]!	; 0xfffff08d
    3c84:	00746573 	rsbseq	r6, r4, r3, ror r5
    3c88:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
    3c8c:	61685f6f 	cmnvs	r8, pc, ror #30
    3c90:	696c6472 	stmdbvs	ip!, {r1, r4, r5, r6, sl, sp, lr}^
    3c94:	0074696d 	rsbseq	r6, r4, sp, ror #18
    3c98:	69736572 	ldmdbvs	r3!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    3c9c:	7200657a 	andvc	r6, r0, #511705088	; 0x1e800000
    3ca0:	6e5f7563 	cdpvs	5, 5, cr7, cr15, cr3, {3}
    3ca4:	0065646f 	rsbeq	r6, r5, pc, ror #8
    3ca8:	695f6371 	ldmdbvs	pc, {r0, r4, r5, r6, r8, r9, sp, lr}^	; <UNPREDICTABLE>
    3cac:	006f666e 	rsbeq	r6, pc, lr, ror #12
    3cb0:	68637261 	stmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
    3cb4:	6970735f 	ldmdbvs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    3cb8:	636f6c6e 	cmnvs	pc, #28160	; 0x6e00
    3cbc:	00745f6b 	rsbseq	r5, r4, fp, ror #30
    3cc0:	705f6d6c 	subsvc	r6, pc, ip, ror #26
    3cc4:	6f5f7475 	svcvs	0x005f7475
    3cc8:	72656e77 	rsbvc	r6, r5, #1904	; 0x770
    3ccc:	61777300 	cmnvs	r7, r0, lsl #6
    3cd0:	6e695f70 	mcrvs	15, 3, r5, cr9, cr0, {3}
    3cd4:	735f6f66 	cmpvc	pc, #408	; 0x198
    3cd8:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    3cdc:	65640074 	strbvs	r0, [r4, #-116]!	; 0xffffff8c
    3ce0:	6c665f66 	stclvs	15, cr5, [r6], #-408	; 0xfffffe68
    3ce4:	00736761 	rsbseq	r6, r3, r1, ror #14
    3ce8:	5f646975 	svcpl	0x00646975
    3cec:	665f0074 			; <UNDEFINED> instruction: 0x665f0074
    3cf0:	7367616c 	cmnvc	r7, #108, 2
    3cf4:	765f6600 	ldrbvc	r6, [pc], -r0, lsl #12
    3cf8:	69737265 	ldmdbvs	r3!, {r0, r2, r5, r6, r9, ip, sp, lr}^
    3cfc:	75006e6f 	strvc	r6, [r0, #-3695]	; 0xfffff191
    3d00:	626f7270 	rsbvs	r7, pc, #112, 4
    3d04:	75710065 	ldrbvc	r0, [r1, #-101]!	; 0xffffff9b
    3d08:	5f61746f 	svcpl	0x0061746f
    3d0c:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    3d10:	73716400 	cmnvc	r1, #0, 8
    3d14:	73746174 	cmnvc	r4, #116, 2
    3d18:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 3d20 <.debug_str+0x3d20>
    3d1c:	69746170 	ldmdbvs	r4!, {r4, r5, r6, r8, sp, lr}^
    3d20:	00656c62 	rsbeq	r6, r5, r2, ror #24
    3d24:	555f4253 	ldrbpl	r4, [pc, #-595]	; 3ad9 <.debug_str+0x3ad9>
    3d28:	4f52464e 	svcmi	0x0052464e
    3d2c:	004e455a 	subeq	r4, lr, sl, asr r5
    3d30:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
    3d34:	64006d75 	strvs	r6, [r0], #-3445	; 0xfffff28b
    3d38:	72746e65 	rsbsvc	r6, r4, #1616	; 0x650
    3d3c:	65640079 	strbvs	r0, [r4, #-121]!	; 0xffffff87
    3d40:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    3d44:	74615f74 	strbtvc	r5, [r1], #-3956	; 0xfffff08c
    3d48:	00737274 	rsbseq	r7, r3, r4, ror r2
    3d4c:	74725f64 	ldrbtvc	r5, [r2], #-3940	; 0xfffff09c
    3d50:	6370735f 	cmnvs	r0, #2080374785	; 0x7c000001
    3d54:	7261685f 	rsbvc	r6, r1, #6225920	; 0x5f0000
    3d58:	6d696c64 	stclvs	12, cr6, [r9, #-400]!	; 0xfffffe70
    3d5c:	61007469 	tstvs	r0, r9, ror #8
    3d60:	655f6772 	ldrbvs	r6, [pc, #-1906]	; 35f6 <.debug_str+0x35f6>
    3d64:	6100646e 	tstvs	r0, lr, ror #8
    3d68:	636f7373 	cmnvs	pc, #-872415231	; 0xcc000001
    3d6c:	7272615f 	rsbsvc	r6, r2, #-1073741801	; 0xc0000017
    3d70:	705f7961 	subsvc	r7, pc, r1, ror #18
    3d74:	66007274 			; <UNDEFINED> instruction: 0x66007274
    3d78:	63725f61 	cmnvs	r2, #388	; 0x184
    3d7c:	4d4d0075 	stclmi	0, cr0, [sp, #-468]	; 0xfffffe2c
    3d80:	4c49465f 	mcrrmi	6, 5, r4, r9, cr15
    3d84:	47415045 	strbmi	r5, [r1, -r5, asr #32]
    3d88:	74005345 	strvc	r5, [r0], #-837	; 0xfffffcbb
    3d8c:	6f5f7974 	svcvs	0x005f7974
    3d90:	705f646c 	subsvc	r6, pc, ip, ror #8
    3d94:	00707267 	rsbseq	r7, r0, r7, ror #4
    3d98:	5f667562 	svcpl	0x00667562
    3d9c:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93
    3da0:	656e0078 	strbvs	r0, [lr, #-120]!	; 0xffffff88
    3da4:	6e657478 	mcrvs	4, 3, r7, cr5, cr8, {3}
    3da8:	61007374 	tstvs	r0, r4, ror r3
    3dac:	5f686372 	svcpl	0x00686372
    3db0:	6f6c7772 	svcvs	0x006c7772
    3db4:	745f6b63 	ldrbvc	r6, [pc], #-2915	; 3dbc <.debug_str+0x3dbc>
    3db8:	53475000 	movtpl	r5, #28672	; 0x7000
    3dbc:	5f4e4143 	svcpl	0x004e4143
    3dc0:	45524944 	ldrbmi	r4, [r2, #-2372]	; 0xfffff6bc
    3dc4:	4e5f5443 	cdpmi	4, 5, cr5, cr15, cr3, {2}
    3dc8:	414d524f 	cmpmi	sp, pc, asr #4
    3dcc:	524e004c 	subpl	r0, lr, #76	; 0x4c
    3dd0:	5f4d565f 	svcpl	0x004d565f
    3dd4:	454e4f5a 	strbmi	r4, [lr, #-3930]	; 0xfffff0a6
    3dd8:	4154535f 	cmpmi	r4, pc, asr r3
    3ddc:	54495f54 	strbpl	r5, [r9], #-3924	; 0xfffff0ac
    3de0:	00534d45 	subseq	r4, r3, r5, asr #26
    3de4:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    3de8:	5f455441 	svcpl	0x00455441
    3dec:	00414d43 	subeq	r4, r1, r3, asr #26
    3df0:	6c6e5f69 	stclvs	15, cr5, [lr], #-420	; 0xfffffe5c
    3df4:	006b6e69 	rsbeq	r6, fp, r9, ror #28
    3df8:	746f6f72 	strbtvc	r6, [pc], #-3954	; 3e00 <.debug_str+0x3e00>
    3dfc:	5f6d7600 	svcpl	0x006d7600
    3e00:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    3e04:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    3e08:	5f646674 	svcpl	0x00646674
    3e0c:	00787463 	rsbseq	r7, r8, r3, ror #8
    3e10:	52414d57 	subpl	r4, r1, #5568	; 0x15c0
    3e14:	4f4c5f4b 	svcmi	0x004c5f4b
    3e18:	524e0057 	subpl	r0, lr, #87	; 0x57
    3e1c:	55524c5f 	ldrbpl	r4, [r2, #-3167]	; 0xfffff3a1
    3e20:	5341425f 	movtpl	r4, #4703	; 0x125f
    3e24:	74700045 	ldrbtvc	r0, [r0], #-69	; 0xffffffbb
    3e28:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    3e2c:	73656d5f 	cmnvc	r5, #6080	; 0x17c0
    3e30:	65676173 	strbvs	r6, [r7, #-371]!	; 0xfffffe8d
    3e34:	73696c00 	cmnvc	r9, #0, 24
    3e38:	6e007374 	mcrvs	3, 0, r7, cr0, cr4, {3}
    3e3c:	616d726f 	cmnvs	sp, pc, ror #4
    3e40:	72705f6c 	rsbsvc	r5, r0, #108, 30	; 0x1b0
    3e44:	6c006f69 	stcvs	15, cr6, [r0], {105}	; 0x69
    3e48:	63736964 	cmnvs	r3, #100, 18	; 0x190000
    3e4c:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
    3e50:	71657300 	cmnvc	r5, r0, lsl #6
    3e54:	6174735f 	cmnvs	r4, pc, asr r3
    3e58:	5f007472 	svcpl	0x00007472
    3e5c:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
    3e60:	6f72657a 	svcvs	0x0072657a
    3e64:	5f6c6600 	svcpl	0x006c6600
    3e68:	6b6e696c 	blvs	1b9e420 <unflatten_and_copy_device_tree+0x1b9d5ac>
    3e6c:	72616500 	rsbvc	r6, r1, #0, 10
    3e70:	695f796c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, fp, ip, sp, lr}^	; <UNPREDICTABLE>
    3e74:	5f74696e 	svcpl	0x0074696e
    3e78:	735f7464 	cmpvc	pc, #100, 8	; 0x64000000
    3e7c:	5f6e6163 	svcpl	0x006e6163
    3e80:	6f6d656d 	svcvs	0x006d656d
    3e84:	73007972 	movwvc	r7, #2418	; 0x972
    3e88:	616e6769 	cmnvs	lr, r9, ror #14
    3e8c:	5f64666c 	svcpl	0x0064666c
    3e90:	00687177 	rsbeq	r7, r8, r7, ror r1
    3e94:	5f756372 	svcpl	0x00756372
    3e98:	61746164 	cmnvs	r4, r4, ror #2
    3e9c:	63610030 	cmnvs	r1, #48	; 0x30
    3ea0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    3ea4:	53475000 	movtpl	r5, #28672	; 0x7000
    3ea8:	4c414554 	cfstr64mi	mvdx4, [r1], {84}	; 0x54
    3eac:	57534b5f 			; <UNDEFINED> instruction: 0x57534b5f
    3eb0:	5f445041 	svcpl	0x00445041
    3eb4:	00414d44 	subeq	r4, r1, r4, asr #26
    3eb8:	705f6462 	subsvc	r6, pc, r2, ror #8
    3ebc:	5f747261 	svcpl	0x00747261
    3ec0:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    3ec4:	5f640074 	svcpl	0x00640074
    3ec8:	5f637073 	svcpl	0x00637073
    3ecc:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    3ed0:	70730072 	rsbsvc	r0, r3, r2, ror r0
    3ed4:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xfffff19f
    3ed8:	61705f64 	cmnvs	r0, r4, ror #30
    3edc:	00736567 	rsbseq	r6, r3, r7, ror #10
    3ee0:	775f726e 	ldrbvc	r7, [pc, -lr, ror #4]
    3ee4:	75656b61 	strbvc	r6, [r5, #-2913]!	; 0xfffff49f
    3ee8:	615f7370 	cmpvs	pc, r0, ror r3	; <UNPREDICTABLE>
    3eec:	6e696666 	cdpvs	6, 6, cr6, cr9, cr6, {3}
    3ef0:	74615f65 	strbtvc	r5, [r1], #-3941	; 0xfffff09b
    3ef4:	706d6574 	rsbvc	r6, sp, r4, ror r5
    3ef8:	66007374 			; <UNDEFINED> instruction: 0x66007374
    3efc:	5f776f6c 	svcpl	0x00776f6c
    3f00:	6b636f6c 	blvs	18dfcb8 <unflatten_and_copy_device_tree+0x18dee44>
    3f04:	54524800 	ldrbpl	r4, [r2], #-2048	; 0xfffff800
    3f08:	52454d49 	subpl	r4, r5, #4672	; 0x1240
    3f0c:	5341425f 	movtpl	r4, #4703	; 0x125f
    3f10:	45525f45 	ldrbmi	r5, [r2, #-3909]	; 0xfffff0bb
    3f14:	49544c41 	ldmdbmi	r4, {r0, r6, sl, fp, lr}^
    3f18:	6400454d 	strvs	r4, [r0], #-1357	; 0xfffffab3
    3f1c:	785f7075 	ldmdavc	pc, {r0, r2, r4, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
    3f20:	775f6c6f 	ldrbvc	r6, [pc, -pc, ror #24]
    3f24:	006b726f 	rsbeq	r7, fp, pc, ror #4
    3f28:	65686373 	strbvs	r6, [r8, #-883]!	; 0xfffffc8d
    3f2c:	6c635f64 	stclvs	15, cr5, [r3], #-400	; 0xfffffe70
    3f30:	00737361 	rsbseq	r7, r3, r1, ror #6
    3f34:	756d5f69 	strbvc	r5, [sp, #-3945]!	; 0xfffff097
    3f38:	5f786574 	svcpl	0x00786574
    3f3c:	0079656b 	rsbseq	r6, r9, fp, ror #10
    3f40:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    3f44:	69747369 	ldmdbvs	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
    3f48:	6b007363 	blvs	20cdc <unflatten_and_copy_device_tree+0x1fe68>
    3f4c:	5f6a626f 	svcpl	0x006a626f
    3f50:	745f736e 	ldrbvc	r7, [pc], #-878	; 3f58 <.debug_str+0x3f58>
    3f54:	5f657079 	svcpl	0x00657079
    3f58:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
    3f5c:	6f697461 	svcvs	0x00697461
    3f60:	7400736e 	strvc	r7, [r0], #-878	; 0xfffffc92
    3f64:	61657268 	cmnvs	r5, r8, ror #4
    3f68:	6f6e5f64 	svcvs	0x006e5f64
    3f6c:	6c006564 	cfstr32vs	mvfx6, [r0], {100}	; 0x64
    3f70:	5f747369 	svcpl	0x00747369
    3f74:	5f75726c 	svcpl	0x0075726c
    3f78:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    3f7c:	74725f64 	ldrbtvc	r5, [r2], #-3940	; 0xfffff09c
    3f80:	6370735f 	cmnvs	r0, #2080374785	; 0x7c000001
    3f84:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    3f88:	6f007265 	svcvs	0x00007265
    3f8c:	65675f66 	strbvs	r5, [r7, #-3942]!	; 0xfffff09a
    3f90:	6c665f74 	stclvs	15, cr5, [r6], #-464	; 0xfffffe30
    3f94:	645f7461 	ldrbvs	r7, [pc], #-1121	; 3f9c <.debug_str+0x3f9c>
    3f98:	6f725f74 	svcvs	0x00725f74
    3f9c:	5000746f 	andpl	r7, r0, pc, ror #8
    3fa0:	45545347 	ldrbmi	r5, [r4, #-839]	; 0xfffffcb9
    3fa4:	445f4c41 	ldrbmi	r4, [pc], #-3137	; 3fac <.debug_str+0x3fac>
    3fa8:	43455249 	movtmi	r5, #21065	; 0x5249
    3fac:	49485f54 	stmdbmi	r8, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
    3fb0:	75004847 	strvc	r4, [r0, #-2119]	; 0xfffff7b9
    3fb4:	5f726573 	svcpl	0x00726573
    3fb8:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
    3fbc:	65007463 	strvs	r7, [r0, #-1123]	; 0xfffffb9d
    3fc0:	5f746978 	svcpl	0x00746978
    3fc4:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xfffff09d
    3fc8:	74646600 	strbtvc	r6, [r4], #-1536	; 0xfffffa00
    3fcc:	7269665f 	rsbvc	r6, r9, #99614720	; 0x5f00000
    3fd0:	705f7473 	subsvc	r7, pc, r3, ror r4	; <UNPREDICTABLE>
    3fd4:	65706f72 	ldrbvs	r6, [r0, #-3954]!	; 0xfffff08e
    3fd8:	5f797472 	svcpl	0x00797472
    3fdc:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    3fe0:	6d007465 	cfstrsvs	mvf7, [r0, #-404]	; 0xfffffe6c
    3fe4:	67636d65 	strbvs	r6, [r3, -r5, ror #26]!
    3fe8:	5f726e5f 	svcpl	0x00726e5f
    3fec:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    3ff0:	766f5f73 	uqsub16vc	r5, pc, r3	; <UNPREDICTABLE>
    3ff4:	685f7265 	ldmdavs	pc, {r0, r2, r5, r6, r9, ip, sp, lr}^	; <UNPREDICTABLE>
    3ff8:	00686769 	rsbeq	r6, r8, r9, ror #14
    3ffc:	69705f69 	ldmdbvs	r0!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    4000:	63006570 	movwvs	r6, #1392	; 0x570
    4004:	756f7267 	strbvc	r7, [pc, #-615]!	; 3da5 <.debug_str+0x3da5>
    4008:	75735f70 	ldrbvc	r5, [r3, #-3952]!	; 0xfffff090
    400c:	73797362 	cmnvc	r9, #-2013265919	; 0x88000001
    4010:	6174735f 	cmnvs	r4, pc, asr r3
    4014:	77006574 	smlsdxvc	r0, r4, r5, r6
    4018:	5f656b61 	svcpl	0x00656b61
    401c:	72746e65 	rsbsvc	r6, r4, #1616	; 0x650
    4020:	5f730079 	svcpl	0x00730079
    4024:	646f6e69 	strbtvs	r6, [pc], #-3689	; 402c <.debug_str+0x402c>
    4028:	696c5f65 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    402c:	6c5f7473 	cfldrdvs	mvd7, [pc], {115}	; 0x73
    4030:	006b636f 	rsbeq	r6, fp, pc, ror #6
    4034:	6d69746b 	cfstrdvs	mvd7, [r9, #-428]!	; 0xfffffe54
    4038:	00745f65 	rsbseq	r5, r4, r5, ror #30
    403c:	66685f78 	uqsub16vs	r5, r8, r8
    4040:	0067616c 	rsbeq	r6, r7, ip, ror #2
    4044:	705f726e 	subsvc	r7, pc, lr, ror #4
    4048:	00736574 	rsbseq	r6, r3, r4, ror r5
    404c:	73627573 	cmnvc	r2, #482344960	; 0x1cc00000
    4050:	66007379 			; <UNDEFINED> instruction: 0x66007379
    4054:	7a656572 	bvc	195d624 <unflatten_and_copy_device_tree+0x195c7b0>
    4058:	75735f65 	ldrbvc	r5, [r3, #-3941]!	; 0xfffff09b
    405c:	00726570 	rsbseq	r6, r2, r0, ror r5
    4060:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
    4064:	6e695f79 	mcrvs	15, 3, r5, cr9, cr9, {3}
    4068:	645f7469 	ldrbvs	r7, [pc], #-1129	; 4070 <.debug_str+0x4070>
    406c:	64615f74 	strbtvs	r5, [r1], #-3956	; 0xfffff08c
    4070:	656d5f64 	strbvs	r5, [sp, #-3940]!	; 0xfffff09c
    4074:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    4078:	6372615f 	cmnvs	r2, #-1073741801	; 0xc0000017
    407c:	6c620068 	stclvs	0, cr0, [r2], #-416	; 0xfffffe60
    4080:	746e636b 	strbtvc	r6, [lr], #-875	; 0xfffffc95
    4084:	6b00745f 	blvs	21208 <unflatten_and_copy_device_tree+0x20394>
    4088:	65736162 	ldrbvs	r6, [r3, #-354]!	; 0xfffffe9e
    408c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    4090:	54524800 	ldrbpl	r4, [r2], #-2048	; 0xfffff800
    4094:	52454d49 	subpl	r4, r5, #4672	; 0x1240
    4098:	5341425f 	movtpl	r4, #4703	; 0x125f
    409c:	41545f45 	cmpmi	r4, r5, asr #30
    40a0:	5f4e0049 	svcpl	0x004e0049
    40a4:	53534f50 	cmppl	r3, #80, 30	; 0x140
    40a8:	454c4249 	strbmi	r4, [ip, #-585]	; 0xfffffdb7
    40ac:	69716b00 	ldmdbvs	r1!, {r8, r9, fp, sp, lr}^
    40b0:	656d0064 	strbvs	r0, [sp, #-100]!	; 0xffffff9c
    40b4:	615f736d 	cmpvs	pc, sp, ror #6
    40b8:	776f6c6c 	strbvc	r6, [pc, -ip, ror #24]!
    40bc:	735f6465 	cmpvc	pc, #1694498816	; 0x65000000
    40c0:	5f007165 	svcpl	0x00007165
    40c4:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    40c8:	5f6c656e 	svcpl	0x006c656e
    40cc:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    40d0:	6900745f 	stmdbvs	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
    40d4:	5f74725f 	svcpl	0x0074725f
    40d8:	5f637073 	svcpl	0x00637073
    40dc:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    40e0:	696d696c 	stmdbvs	sp!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    40e4:	65730074 	ldrbvs	r0, [r3, #-116]!	; 0xffffff8c
    40e8:	726f7463 	rsbvc	r7, pc, #1660944384	; 0x63000000
    40ec:	7000745f 	andvc	r7, r0, pc, asr r4
    40f0:	5f736469 	svcpl	0x00736469
    40f4:	70726763 	rsbsvc	r6, r2, r3, ror #14
    40f8:	0064695f 	rsbeq	r6, r4, pc, asr r9
    40fc:	55504350 	ldrbpl	r4, [r0, #-848]	; 0xfffffcb0
    4100:	5f43465f 	svcpl	0x0043465f
    4104:	7700524e 	strvc	r5, [r0, -lr, asr #4]
    4108:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    410c:	6765625f 			; <UNDEFINED> instruction: 0x6765625f
    4110:	65006e69 	strvs	r6, [r0, #-3689]	; 0xfffff197
    4114:	0070646e 	rsbseq	r6, r0, lr, ror #8
    4118:	6d6f7266 	sfmvs	f7, 2, [pc, #-408]!	; 3f88 <.debug_str+0x3f88>
    411c:	5f524e00 	svcpl	0x00524e00
    4120:	54495257 	strbpl	r5, [r9], #-599	; 0xfffffda9
    4124:	004e4554 	subeq	r4, lr, r4, asr r5
    4128:	75615f64 	strbvc	r5, [r1, #-3940]!	; 0xfffff09c
    412c:	6f6d6f74 	svcvs	0x006d6f74
    4130:	00746e75 	rsbseq	r6, r4, r5, ror lr
    4134:	65747566 	ldrbvs	r7, [r4, #-1382]!	; 0xfffffa9a
    4138:	69705f78 	ldmdbvs	r0!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    413c:	6174735f 	cmnvs	r4, pc, asr r3
    4140:	63006574 	movwvs	r6, #1396	; 0x574
    4144:	625f7570 	subsvs	r7, pc, #112, 10	; 0x1c000000
    4148:	625f7469 	subsvs	r7, pc, #1761607680	; 0x69000000
    414c:	616d7469 	cmnvs	sp, r9, ror #8
    4150:	755f0070 	ldrbvc	r0, [pc, #-112]	; 40e8 <.debug_str+0x40e8>
    4154:	72657070 	rsbvc	r7, r5, #112	; 0x70
    4158:	736f7000 	cmnvc	pc, #0
    415c:	615f7869 	cmpvs	pc, r9, ror #16
    4160:	64006c63 	strvs	r6, [r0], #-3171	; 0xfffff39d
    4164:	6e695f71 	mcrvs	15, 3, r5, cr9, cr1, {3}
    4168:	00657375 	rsbeq	r7, r5, r5, ror r3
    416c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    4170:	72625f74 	rsbvc	r5, r2, #116, 30	; 0x1d0
    4174:	666f006b 	strbtvs	r0, [pc], -fp, rrx
    4178:	616c665f 	cmnvs	ip, pc, asr r6
    417c:	74645f74 	strbtvc	r5, [r4], #-3956	; 0xfffff08c
    4180:	74616d5f 	strbtvc	r6, [r1], #-3423	; 0xfffff2a1
    4184:	69006863 	stmdbvs	r0, {r0, r1, r5, r6, fp, sp, lr}
    4188:	6f6c626e 	svcvs	0x006c626e
    418c:	69006b63 	stmdbvs	r0, {r0, r1, r5, r6, r8, r9, fp, sp, lr}
    4190:	6370735f 	cmnvs	r0, #2080374785	; 0x7c000001
    4194:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    4198:	6d696c65 	stclvs	12, cr6, [r9, #-404]!	; 0xfffffe6c
    419c:	77007469 	strvc	r7, [r0, -r9, ror #8]
    41a0:	6f635f73 	svcvs	0x00635f73
    41a4:	7270006c 	rsbsvc	r0, r0, #108	; 0x6c
    41a8:	735f7665 	cmpvc	pc, #105906176	; 0x6500000
    41ac:	655f6d75 	ldrbvs	r6, [pc, #-3445]	; 343f <.debug_str+0x343f>
    41b0:	5f636578 	svcpl	0x00636578
    41b4:	746e7572 	strbtvc	r7, [lr], #-1394	; 0xfffffa8e
    41b8:	00656d69 	rsbeq	r6, r5, r9, ror #26
    41bc:	645f7164 	ldrbvs	r7, [pc], #-356	; 41c4 <.debug_str+0x41c4>
    41c0:	79747269 	ldmdbvc	r4!, {r0, r3, r5, r6, r9, ip, sp, lr}^
    41c4:	69716400 	ldmdbvs	r1!, {sl, sp, lr}^
    41c8:	78616d5f 	stmdavc	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
    41cc:	6370735f 	cmnvs	r0, #2080374785	; 0x7c000001
    41d0:	6d696c5f 	stclvs	12, cr6, [r9, #-380]!	; 0xfffffe84
    41d4:	6e007469 	cdpvs	4, 0, cr7, cr0, cr9, {3}
    41d8:	65725f72 	ldrbvs	r5, [r2, #-3954]!	; 0xfffff08e
    41dc:	76726573 			; <UNDEFINED> instruction: 0x76726573
    41e0:	685f6465 	ldmdavs	pc, {r0, r2, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
    41e4:	61686769 	cmnvs	r8, r9, ror #14
    41e8:	696d6f74 	stmdbvs	sp!, {r2, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    41ec:	71640063 	cmnvc	r4, r3, rrx
    41f0:	6c665f69 	stclvs	15, cr5, [r6], #-420	; 0xfffffe5c
    41f4:	00736761 	rsbseq	r6, r3, r1, ror #14
    41f8:	725f6d6d 	subsvc	r6, pc, #6976	; 0x1b40
    41fc:	735f7373 	cmpvc	pc, #-872415231	; 0xcc000001
    4200:	00746174 	rsbseq	r6, r4, r4, ror r1
    4204:	61655f5f 	cmnvs	r5, pc, asr pc
    4208:	5f796c72 	svcpl	0x00796c72
    420c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    4210:	5f74645f 	svcpl	0x0074645f
    4214:	6c636564 	cfstr64vs	mvdx6, [r3], #-400	; 0xfffffe70
    4218:	5f657261 	svcpl	0x00657261
    421c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    4220:	70006472 	andvc	r6, r0, r2, ror r4
    4224:	70637265 	rsbvc	r7, r3, r5, ror #4
    4228:	6f635f75 	svcvs	0x00635f75
    422c:	5f746e75 	svcpl	0x00746e75
    4230:	00727470 	rsbseq	r7, r2, r0, ror r4
    4234:	75746573 	ldrbvc	r6, [r4, #-1395]!	; 0xfffffa8d
    4238:	666f5f70 	uqsub16vs	r5, pc, r0	; <UNPREDICTABLE>
    423c:	7261655f 	rsbvc	r6, r1, #398458880	; 0x17c00000
    4240:	6f63796c 	svcvs	0x0063796c
    4244:	494d006e 	stmdbmi	sp, {r1, r2, r3, r5, r6}^
    4248:	54415247 	strbpl	r5, [r1], #-583	; 0xfffffdb9
    424c:	59535f45 	ldmdbpl	r3, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
    4250:	6f00434e 	svcvs	0x0000434e
    4254:	64665f66 	strbtvs	r5, [r6], #-3942	; 0xfffff09a
    4258:	73695f74 	cmnvc	r9, #116, 30	; 0x1d0
    425c:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	; 40e8 <.debug_str+0x40e8>
    4260:	69746170 	ldmdbvs	r4!, {r4, r5, r6, r8, sp, lr}^
    4264:	00656c62 	rsbeq	r6, r5, r2, ror #24
    4268:	5f78616d 	svcpl	0x0078616d
    426c:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    4270:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    4274:	4f4b0065 	svcmi	0x004b0065
    4278:	4e5f4a42 	vnmlami.f32	s9, s30, s4
    427c:	59545f53 	ldmdbpl	r4, {r0, r1, r4, r6, r8, r9, sl, fp, ip, lr}^
    4280:	4e5f4550 	mrcmi	5, 2, r4, cr15, cr0, {2}
    4284:	00454e4f 	subeq	r4, r5, pc, asr #28
    4288:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    428c:	695f7461 	ldmdbvs	pc, {r0, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    4290:	6c74636f 	ldclvs	3, cr6, [r4], #-444	; 0xfffffe44
    4294:	79656b00 	stmdbvc	r5!, {r8, r9, fp, sp, lr}^
    4298:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    429c:	4f430065 	svcmi	0x00430065
    42a0:	4341504d 	movtmi	r5, #4173	; 0x104d
    42a4:	43555354 	cmpmi	r5, #84, 6	; 0x50000001
    42a8:	53534543 	cmppl	r3, #281018368	; 0x10c00000
    42ac:	6f6c7300 	svcvs	0x006c7300
    42b0:	6b007374 	blvs	21088 <unflatten_and_copy_device_tree+0x20214>
    42b4:	69727965 	ldmdbvs	r2!, {r0, r2, r5, r6, r8, fp, ip, sp, lr}^
    42b8:	695f676e 	ldmdbvs	pc, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^	; <UNPREDICTABLE>
    42bc:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
    42c0:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
    42c4:	6d5f6600 	ldclvs	6, cr6, [pc, #-0]	; 42cc <.debug_str+0x42cc>
    42c8:	69707061 	ldmdbvs	r0!, {r0, r5, r6, ip, sp, lr}^
    42cc:	6900676e 	stmdbvs	r0, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    42d0:	5f62775f 	svcpl	0x0062775f
    42d4:	5f6e7266 	svcpl	0x006e7266
    42d8:	6e6e6977 	mcrvs	9, 3, r6, cr14, cr7, {3}
    42dc:	6c007265 	sfmvs	f7, 4, [r0], {101}	; 0x65
    42e0:	5f747361 	svcpl	0x00747361
    42e4:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    42e8:	7265765f 	rsbvc	r7, r5, #99614720	; 0x5f00000
    42ec:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
    42f0:	756c6600 	strbvc	r6, [ip, #-1536]!	; 0xfffffa00
    42f4:	625f6873 	subsvs	r6, pc, #7536640	; 0x730000
    42f8:	65666675 	strbvs	r6, [r6, #-1653]!	; 0xfffff98b
    42fc:	68730072 	ldmdavs	r3!, {r1, r4, r5, r6}^
    4300:	6f647475 	svcvs	0x00647475
    4304:	70006e77 	andvc	r6, r0, r7, ror lr
    4308:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xfffff08e
    430c:	6b5f7373 	blvs	17e10e0 <unflatten_and_copy_device_tree+0x17e026c>
    4310:	69727965 	ldmdbvs	r2!, {r0, r2, r5, r6, r8, fp, ip, sp, lr}^
    4314:	6c00676e 	stcvs	7, cr6, [r0], {110}	; 0x6e
    4318:	65646165 	strbvs	r6, [r4, #-357]!	; 0xfffffe9b
    431c:	69705f72 	ldmdbvs	r0!, {r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    4320:	626e0064 	rsbvs	r0, lr, #100	; 0x64
    4324:	6b636f6c 	blvs	18e00dc <unflatten_and_copy_device_tree+0x18df268>
    4328:	5f690073 	svcpl	0x00690073
    432c:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    4330:	73610074 	cmnvc	r1, #116	; 0x74
    4334:	5f636e79 	svcpl	0x00636e79
    4338:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    433c:	646f6e00 	strbtvs	r6, [pc], #-3584	; 4344 <.debug_str+0x4344>
    4340:	745f0065 	ldrbvc	r0, [pc], #-101	; 4348 <.debug_str+0x4348>
    4344:	74006469 	strvc	r6, [r0], #-1129	; 0xfffffb97
    4348:	5f6b7361 	svcpl	0x006b7361
    434c:	74757063 	ldrbtvc	r7, [r5], #-99	; 0xffffff9d
    4350:	5f656d69 	svcpl	0x00656d69
    4354:	6d6f7461 	cfstrdvs	mvd7, [pc, #-388]!	; 41d8 <.debug_str+0x41d8>
    4358:	6b006369 	blvs	1d104 <unflatten_and_copy_device_tree+0x1c290>
    435c:	6c6c616d 	stfvse	f6, [ip], #-436	; 0xfffffe4c
    4360:	695f636f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^	; <UNPREDICTABLE>
    4364:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
    4368:	6f746100 	svcvs	0x00746100
    436c:	5f63696d 	svcpl	0x0063696d
    4370:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    4374:	6f6c5f65 	svcvs	0x006c5f65
    4378:	77006b63 	strvc	r6, [r0, -r3, ror #22]
    437c:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    4380:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    4384:	63730074 	cmnvs	r3, #116	; 0x74
    4388:	5f646568 	svcpl	0x00646568
    438c:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
    4390:	75626972 	strbvc	r6, [r2, #-2418]!	; 0xfffff68e
    4394:	5f736574 	svcpl	0x00736574
    4398:	6c5f6f74 	mrrcvs	15, 7, r6, pc, cr4	; <UNPREDICTABLE>
    439c:	0064616f 	rsbeq	r6, r4, pc, ror #2
    43a0:	63696c73 	cmnvs	r9, #29440	; 0x7300
    43a4:	616d5f65 	cmnvs	sp, r5, ror #30
    43a8:	6f730078 	svcvs	0x00730078
    43ac:	72697466 	rsbvc	r7, r9, #1711276032	; 0x66000000
    43b0:	6e655f71 	mcrvs	15, 3, r5, cr5, cr1, {3}
    43b4:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
    43b8:	6576655f 	ldrbvs	r6, [r6, #-1375]!	; 0xfffffaa1
    43bc:	5000746e 	andpl	r7, r0, lr, ror #8
    43c0:	59544449 	ldmdbpl	r4, {r0, r3, r6, sl, lr}^
    43c4:	505f4550 	subspl	r4, pc, r0, asr r5	; <UNPREDICTABLE>
    43c8:	66004449 	strvs	r4, [r0], -r9, asr #8
    43cc:	696c5f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    43d0:	73007473 	movwvc	r7, #1139	; 0x473
    43d4:	00666c65 	rsbeq	r6, r6, r5, ror #24
    43d8:	74635f69 	strbtvc	r5, [r3], #-3945	; 0xfffff097
    43dc:	00656d69 	rsbeq	r6, r5, r9, ror #26
    43e0:	414d4750 	cmpmi	sp, r0, asr r7
    43e4:	5541464a 	strbpl	r4, [r1, #-1610]	; 0xfffff9b6
    43e8:	6600544c 	strvs	r5, [r0], -ip, asr #8
    43ec:	6c665f6c 	stclvs	15, cr5, [r6], #-432	; 0xfffffe50
    43f0:	00736761 	rsbseq	r6, r3, r1, ror #14
    43f4:	5f737363 	svcpl	0x00737363
    43f8:	656c6572 	strbvs	r6, [ip, #-1394]!	; 0xfffffa8e
    43fc:	64657361 	strbtvs	r7, [r5], #-865	; 0xfffffc9f
    4400:	5f726e00 	svcpl	0x00726e00
    4404:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    4408:	5f737075 	svcpl	0x00737075
    440c:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    4410:	5f524e00 	svcpl	0x00524e00
    4414:	4e4f4e41 	cdpmi	14, 4, cr4, cr15, cr1, {2}
    4418:	4741505f 	smlsldmi	r5, r1, pc, r0	; <UNPREDICTABLE>
    441c:	6b005345 	blvs	19138 <unflatten_and_copy_device_tree+0x182c4>
    4420:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    4424:	6c007366 	stcvs	3, cr7, [r0], {102}	; 0x66
    4428:	5f6b636f 	svcpl	0x006b636f
    442c:	616e616d 	cmnvs	lr, sp, ror #2
    4430:	5f726567 	svcpl	0x00726567
    4434:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
    4438:	6f697461 	svcvs	0x00697461
    443c:	6300736e 	movwvs	r7, #878	; 0x36e
    4440:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
    4444:	6a626f5f 	bvs	18a01c8 <unflatten_and_copy_device_tree+0x189f354>
    4448:	73746365 	cmnvc	r4, #-1811939327	; 0x94000001
    444c:	6d5f6900 	ldclvs	9, cr6, [pc, #-0]	; 4454 <.debug_str+0x4454>
    4450:	0065646f 	rsbeq	r6, r5, pc, ror #8
    4454:	7473616c 	ldrbtvc	r6, [r3], #-364	; 0xfffffe94
    4458:	6470755f 	ldrbtvs	r7, [r0], #-1375	; 0xfffffaa1
    445c:	5f657461 	svcpl	0x00657461
    4460:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    4464:	78656800 	stmdavc	r5!, {fp, sp, lr}^
    4468:	6373615f 	cmnvs	r3, #-1073741801	; 0xc0000017
    446c:	7070755f 	rsbsvc	r7, r0, pc, asr r5
    4470:	65007265 	strvs	r7, [r0, #-613]	; 0xfffffd9b
    4474:	7972746e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    4478:	6d616e00 	stclvs	14, cr6, [r1, #-0]
    447c:	61646965 	cmnvs	r4, r5, ror #18
    4480:	6d006174 	stfvss	f6, [r0, #-464]	; 0xfffffe30
    4484:	62725f6d 	rsbsvs	r5, r2, #436	; 0x1b4
    4488:	6b5f5f00 	blvs	17dc090 <unflatten_and_copy_device_tree+0x17db21c>
    448c:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    4490:	69735f6c 	ldmdbvs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    4494:	745f657a 	ldrbvc	r6, [pc], #-1402	; 449c <.debug_str+0x449c>
    4498:	756e7500 	strbvc	r7, [lr, #-1280]!	; 0xfffffb00
    449c:	00646573 	rsbeq	r6, r4, r3, ror r5
    44a0:	736e6977 	cmnvc	lr, #1949696	; 0x1dc000
    44a4:	00657a69 	rsbeq	r7, r5, r9, ror #20
    44a8:	696c7073 	stmdbvs	ip!, {r0, r1, r4, r5, r6, ip, sp, lr}^
    44ac:	705f6563 	subsvc	r6, pc, r3, ror #10
    44b0:	00657069 	rsbeq	r7, r5, r9, rrx
    44b4:	5f646970 	svcpl	0x00646970
    44b8:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    44bc:	63617073 	cmnvs	r1, #115	; 0x73
    44c0:	61650065 	cmnvs	r5, r5, rrx
    44c4:	5f796c72 	svcpl	0x00796c72
    44c8:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    44cc:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
    44d0:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
    44d4:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0xfffffd9b
    44d8:	6c65735f 	stclvs	3, cr7, [r5], #-380	; 0xfffffe84
    44dc:	6c680066 	stclvs	0, cr0, [r8], #-408	; 0xfffffe68
    44e0:	00747369 	rsbseq	r7, r4, r9, ror #6
    44e4:	6e61625f 	mcrvs	2, 3, r6, cr1, cr15, {2}
    44e8:	69620064 	stmdbvs	r2!, {r2, r5, r6}^
    44ec:	64007374 	strvs	r7, [r0], #-884	; 0xfffffc8c
    44f0:	69745f6c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    44f4:	0072656d 	rsbseq	r6, r2, sp, ror #10
    44f8:	5f707564 	svcpl	0x00707564
    44fc:	5f6c6f78 	svcpl	0x006c6f78
    4500:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    4504:	6f687300 	svcvs	0x00687300
    4508:	69207472 	stmdbvs	r0!, {r1, r4, r5, r6, sl, ip, sp, lr}
    450c:	5f00746e 	svcpl	0x0000746e
    4510:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    4514:	5f6c656e 	svcpl	0x006c656e
    4518:	5f766564 	svcpl	0x00766564
    451c:	67630074 			; <UNDEFINED> instruction: 0x67630074
    4520:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    4524:	6275735f 	rsbsvs	r7, r5, #2080374785	; 0x7c000001
    4528:	5f737973 	svcpl	0x00737973
    452c:	68006469 	stmdavs	r0, {r0, r3, r5, r6, sl, sp, lr}
    4530:	69647261 	stmdbvs	r4!, {r0, r5, r6, r9, ip, sp, lr}^
    4534:	645f7172 	ldrbvs	r7, [pc], #-370	; 453c <.debug_str+0x453c>
    4538:	62617369 	rsbvs	r7, r1, #-1543503871	; 0xa4000001
    453c:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    4540:	666f0070 			; <UNDEFINED> instruction: 0x666f0070
    4544:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
    4548:	7761725f 			; <UNDEFINED> instruction: 0x7761725f
    454c:	7474615f 	ldrbtvc	r6, [r4], #-351	; 0xfffffea1
    4550:	69660072 	stmdbvs	r6!, {r1, r4, r5, r6}^
    4554:	61776d72 	cmnvs	r7, r2, ror sp
    4558:	6b5f6572 	blvs	17ddb28 <unflatten_and_copy_device_tree+0x17dccb4>
    455c:	006a626f 	rsbeq	r6, sl, pc, ror #4
    4560:	6d656d6b 	stclvs	13, cr6, [r5, #-428]!	; 0xfffffe54
    4564:	6361635f 	cmnvs	r1, #2080374785	; 0x7c000001
    4568:	64006568 	strvs	r6, [r0], #-1384	; 0xfffffa98
    456c:	75616665 	strbvc	r6, [r1, #-1637]!	; 0xfffff99b
    4570:	6d5f746c 	cfldrdvs	mvd7, [pc, #-432]	; 43c8 <.debug_str+0x43c8>
    4574:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    4578:	6e696600 	cdpvs	6, 6, cr6, cr9, cr0, {0}
    457c:	70735f64 	rsbsvc	r5, r3, r4, ror #30
    4580:	61696365 	cmnvs	r9, r5, ror #6
    4584:	61705f6c 	cmnvs	r0, ip, ror #30
    4588:	64006567 	strvs	r6, [r0], #-1383	; 0xfffffa99
    458c:	5f6f6971 	svcpl	0x006f6971
    4590:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93
    4594:	63610078 	cmnvs	r1, #120	; 0x78
    4598:	65766974 	ldrbvs	r6, [r6, #-2420]!	; 0xfffff68c
    459c:	6c666400 	cfstrdvs	mvd6, [r6], #-0
    45a0:	7267635f 	rsbvc	r6, r7, #2080374785	; 0x7c000001
    45a4:	70630070 	rsbvc	r0, r3, r0, ror r0
    45a8:	67635f75 			; <UNDEFINED> instruction: 0x67635f75
    45ac:	695f7072 	ldmdbvs	pc, {r1, r4, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
    45b0:	6f630064 	svcvs	0x00630064
    45b4:	74696d6d 	strbtvc	r6, [r9], #-3437	; 0xfffff293
    45b8:	6271645f 	rsbsvs	r6, r1, #1593835520	; 0x5f000000
    45bc:	65006b6c 	strvs	r6, [r0, #-2924]	; 0xfffff494
    45c0:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
    45c4:	646f635f 	strbtvs	r6, [pc], #-863	; 45cc <.debug_str+0x45cc>
    45c8:	5f690065 	svcpl	0x00690065
    45cc:	6c66706f 	stclvs	0, cr7, [r6], #-444	; 0xfffffe44
    45d0:	00736761 	rsbseq	r6, r3, r1, ror #14
    45d4:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    45d8:	5f616900 	svcpl	0x00616900
    45dc:	6d69746d 	cfstrdvs	mvd7, [r9, #-436]!	; 0xfffffe4c
    45e0:	67630065 	strbvs	r0, [r3, -r5, rrx]!
    45e4:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    45e8:	7268745f 	rsbvc	r7, r8, #1593835520	; 0x5f000000
    45ec:	67646165 	strbvs	r6, [r4, -r5, ror #2]!
    45f0:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    45f4:	7377725f 	cmnvc	r7, #-268435451	; 0xf0000005
    45f8:	67006d65 	strvs	r6, [r0, -r5, ror #26]
    45fc:	695f7465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    4600:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    4604:	69660074 	stmdbvs	r6!, {r2, r4, r5, r6}^
    4608:	6e00706c 	cdpvs	0, 0, cr7, cr0, cr12, {3}
    460c:	70635f72 	rsbvc	r5, r3, r2, ror pc
    4610:	64695f75 	strbtvs	r5, [r9], #-3957	; 0xfffff08b
    4614:	6c660073 	stclvs	0, cr0, [r6], #-460	; 0xfffffe34
    4618:	6f6c625f 	svcvs	0x006c625f
    461c:	6e006b63 	vmlsvs.f64	d6, d0, d19
    4620:	6f7a5f72 	svcvs	0x007a5f72
    4624:	0073656e 	rsbseq	r6, r3, lr, ror #10
    4628:	725f7464 	subsvc	r7, pc, #100, 8	; 0x64000000
    462c:	5f746f6f 	svcpl	0x00746f6f
    4630:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    4634:	6c65635f 	stclvs	3, cr6, [r5], #-380	; 0xfffffe84
    4638:	6400736c 	strvs	r7, [r0], #-876	; 0xfffffc94
    463c:	6c665f71 	stclvs	15, cr5, [r6], #-452	; 0xfffffe3c
    4640:	00736761 	rsbseq	r6, r3, r1, ror #14
    4644:	6d6f7461 	cfstrdvs	mvd7, [pc, #-388]!	; 44c8 <.debug_str+0x44c8>
    4648:	6c5f6369 	mrrcvs	3, 6, r6, pc, cr9	; <UNPREDICTABLE>
    464c:	5f676e6f 	svcpl	0x00676e6f
    4650:	79730074 	ldmdbvc	r3!, {r2, r4, r5, r6}^
    4654:	5f736673 	svcpl	0x00736673
    4658:	0073706f 	rsbseq	r7, r3, pc, rrx
    465c:	69747363 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, r9, ip, sp, lr}^
    4660:	7300656d 	movwvc	r6, #1389	; 0x56d
    4664:	72775f62 	rsbsvc	r5, r7, #392	; 0x188
    4668:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
    466c:	616e0073 	smcvs	57347	; 0xe003
    4670:	625f656d 	subsvs	r6, pc, #457179136	; 0x1b400000
    4674:	00657361 	rsbeq	r7, r5, r1, ror #6
    4678:	72727563 	rsbsvc	r7, r2, #415236096	; 0x18c00000
    467c:	7261745f 	rsbvc	r7, r1, #1593835520	; 0x5f000000
    4680:	00746567 	rsbseq	r6, r4, r7, ror #10
    4684:	635f726e 	cmpvs	pc, #-536870906	; 0xe0000006
    4688:	73707267 	cmnvc	r0, #1879048198	; 0x70000006
    468c:	656c6300 	strbvs	r6, [ip, #-768]!	; 0xfffffd00
    4690:	70756e61 	rsbsvc	r6, r5, r1, ror #28
    4694:	5f6f6900 	svcpl	0x006f6900
    4698:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
    469c:	00747865 	rsbseq	r7, r4, r5, ror #16
    46a0:	645f6c64 	ldrbvs	r6, [pc], #-3172	; 46a8 <.debug_str+0x46a8>
    46a4:	6c646165 	stfvse	f6, [r4], #-404	; 0xfffffe6c
    46a8:	00656e69 	rsbeq	r6, r5, r9, ror #28
    46ac:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    46b0:	63617073 	cmnvs	r1, #115	; 0x73
    46b4:	6c660065 	stclvs	0, cr0, [r6], #-404	; 0xfffffe6c
    46b8:	6e696c5f 	mcrvs	12, 3, r6, cr9, cr15, {2}
    46bc:	70635f6b 	rsbvc	r5, r3, fp, ror #30
    46c0:	65720075 	ldrbvs	r0, [r2, #-117]!	; 0xffffff8b
    46c4:	73657571 	cmnvc	r5, #473956352	; 0x1c400000
    46c8:	656b5f74 	strbvs	r5, [fp, #-3956]!	; 0xfffff08c
    46cc:	75615f79 	strbvc	r5, [r1, #-3961]!	; 0xfffff087
    46d0:	6b006874 	blvs	1e8a8 <unflatten_and_copy_device_tree+0x1da34>
    46d4:	666e7265 	strbtvs	r7, [lr], -r5, ror #4
    46d8:	6f725f73 	svcvs	0x00725f73
    46dc:	7700746f 	strvc	r7, [r0, -pc, ror #8]
    46e0:	5f656b61 	svcpl	0x00656b61
    46e4:	00757063 	rsbseq	r7, r5, r3, rrx
    46e8:	64627573 	strbtvs	r7, [r2], #-1395	; 0xfffffa8d
    46ec:	00737269 	rsbseq	r7, r3, r9, ror #4
    46f0:	5f736173 	svcpl	0x00736173
    46f4:	735f7373 	cmpvc	pc, #-872415231	; 0xcc000001
    46f8:	00657a69 	rsbeq	r7, r5, r9, ror #20
    46fc:	705f7369 	subsvc	r7, pc, r9, ror #6
    4700:	69747261 	ldmdbvs	r4!, {r0, r5, r6, r9, ip, sp, lr}^
    4704:	796c6c61 	stmdbvc	ip!, {r0, r5, r6, sl, fp, sp, lr}^
    4708:	7470755f 	ldrbtvc	r7, [r0], #-1375	; 0xfffffaa1
    470c:	7461646f 	strbtvc	r6, [r1], #-1135	; 0xfffffb91
    4710:	5f740065 	svcpl	0x00740065
    4714:	006e656c 	rsbeq	r6, lr, ip, ror #10
    4718:	65726874 	ldrbvs	r6, [r2, #-2164]!	; 0xfffff78c
    471c:	675f6461 	ldrbvs	r6, [pc, -r1, ror #8]
    4720:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    4724:	5f6e6f00 	svcpl	0x006e6f00
    4728:	75007172 	strvc	r7, [r0, #-370]	; 0xfffffe8e
    472c:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    4730:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    4734:	695f6574 	ldmdbvs	pc, {r2, r4, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    4738:	006f666e 	rsbeq	r6, pc, lr, ror #12
    473c:	6f5f6d6c 	svcvs	0x005f6d6c
    4740:	72656e77 	rsbvc	r6, r5, #1904	; 0x770
    4744:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
    4748:	6d5f7300 	ldclvs	3, cr7, [pc, #-0]	; 4750 <.debug_str+0x4750>
    474c:	79627861 	stmdbvc	r2!, {r0, r5, r6, fp, ip, sp, lr}^
    4750:	00736574 	rsbseq	r6, r3, r4, ror r5
    4754:	61657262 	cmnvs	r5, r2, ror #4
    4758:	74635f6b 	strbtvc	r5, [r3], #-3947	; 0xfffff095
    475c:	6f69006c 	svcvs	0x0069006c
    4760:	006c7463 	rsbeq	r7, ip, r3, ror #8
    4764:	6c666374 	stclvs	3, cr6, [r6], #-464	; 0xfffffe30
    4768:	745f6761 	ldrbvc	r6, [pc], #-1889	; 4770 <.debug_str+0x4770>
    476c:	5f666f00 	svcpl	0x00666f00
    4770:	5f746466 	svcpl	0x00746466
    4774:	6374616d 	cmnvs	r4, #1073741851	; 0x4000001b
    4778:	6e690068 	cdpvs	0, 6, cr0, cr9, cr8, {3}
    477c:	61697469 	cmnvs	r9, r9, ror #8
    4780:	6f625f6c 	svcvs	0x00625f6c
    4784:	705f746f 	subsvc	r7, pc, pc, ror #8
    4788:	6d617261 	sfmvs	f7, 2, [r1, #-388]!	; 0xfffffe7c
    478c:	6f6e0073 	svcvs	0x006e0073
    4790:	6d5f6564 	cfldr64vs	mvdx6, [pc, #-400]	; 4608 <.debug_str+0x4608>
    4794:	6d5f6d65 	ldclvs	13, cr6, [pc, #-404]	; 4608 <.debug_str+0x4608>
    4798:	68007061 	stmdavs	r0, {r0, r5, r6, ip, sp, lr}
    479c:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    47a0:	5f6c625f 	svcpl	0x006c625f
    47a4:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    47a8:	5f667100 	svcpl	0x00667100
    47ac:	5f746d66 	svcpl	0x00746d66
    47b0:	66006469 	strvs	r6, [r0], -r9, ror #8
    47b4:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    47b8:	5f524e00 	svcpl	0x00524e00
    47bc:	42414c53 	submi	r4, r1, #21248	; 0x5300
    47c0:	524e555f 	subpl	r5, lr, #398458880	; 0x17c00000
    47c4:	414c4345 	cmpmi	ip, r5, asr #6
    47c8:	42414d49 	submi	r4, r1, #4672	; 0x1240
    47cc:	7400454c 	strvc	r4, [r0], #-1356	; 0xfffffab4
    47d0:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    47d4:	616c735f 	cmnvs	ip, pc, asr r3
    47d8:	6e5f6b63 	vnmlavs.f64	d22, d15, d19
    47dc:	736b0073 	cmnvc	fp, #115	; 0x73
    47e0:	5f007465 	svcpl	0x00007465
    47e4:	6177735f 	cmnvs	r7, pc, asr r3
    47e8:	70323362 	eorsvc	r3, r2, r2, ror #6
    47ec:	6f727000 	svcvs	0x00727000
    47f0:	666f0070 			; <UNDEFINED> instruction: 0x666f0070
    47f4:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
    47f8:	666e755f 			; <UNDEFINED> instruction: 0x666e755f
    47fc:	7474616c 	ldrbtvc	r6, [r4], #-364	; 0xfffffe94
    4800:	6d5f6e65 	ldclvs	14, cr6, [pc, #-404]	; 4674 <.debug_str+0x4674>
    4804:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    4808:	68637300 	stmdavs	r3!, {r8, r9, ip, sp, lr}^
    480c:	6d5f6465 	cfldrdvs	mvd6, [pc, #-404]	; 4680 <.debug_str+0x4680>
    4810:	61726769 	cmnvs	r2, r9, ror #14
    4814:	00646574 	rsbeq	r6, r4, r4, ror r5
    4818:	6f6e696d 	svcvs	0x006e696d
    481c:	74735f72 	ldrbtvc	r5, [r3], #-3954	; 0xfffff08e
    4820:	00747261 	rsbseq	r7, r4, r1, ror #4
    4824:	6e615f73 	mcrvs	15, 3, r5, cr1, cr3, {3}
    4828:	4e006e6f 	cdpmi	14, 0, cr6, cr0, cr15, {3}
    482c:	4d565f52 	ldclmi	15, cr5, [r6, #-328]	; 0xfffffeb8
    4830:	4e414353 	mcrmi	3, 2, r4, cr1, cr3, {2}
    4834:	4d4d495f 	stclmi	9, cr4, [sp, #-380]	; 0xfffffe84
    4838:	41494445 	cmpmi	r9, r5, asr #8
    483c:	61004554 	tstvs	r0, r4, asr r5
    4840:	5f686372 	svcpl	0x00686372
    4844:	6f727075 	svcvs	0x00727075
    4848:	745f6562 	ldrbvc	r6, [pc], #-1378	; 4850 <.debug_str+0x4850>
    484c:	006b7361 	rsbeq	r7, fp, r1, ror #6
    4850:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
    4854:	746e6920 	strbtvc	r6, [lr], #-2336	; 0xfffff6e0
    4858:	6e6f7a00 	vmulvs.f32	s15, s30, s0
    485c:	73696c65 	cmnvc	r9, #25856	; 0x6500
    4860:	6c660074 	stclvs	0, cr0, [r6], #-464	; 0xfffffe30
    4864:	5f687375 	svcpl	0x00687375
    4868:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    486c:	6e61725f 	mcrvs	2, 3, r7, cr1, cr15, {2}
    4870:	63006567 	movwvs	r6, #1383	; 0x567
    4874:	6b636f6c 	blvs	18e062c <unflatten_and_copy_device_tree+0x18df7b8>
    4878:	7361775f 	cmnvc	r1, #24903680	; 0x17c0000
    487c:	7465735f 	strbtvc	r7, [r5], #-863	; 0xfffffca1
    4880:	7165735f 	cmnvc	r5, pc, asr r3
    4884:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
    4888:	646e6570 	strbtvs	r6, [lr], #-1392	; 0xfffffa90
    488c:	00676e69 	rsbeq	r6, r7, r9, ror #28
    4890:	75715f73 	ldrbvc	r5, [r1, #-3955]!	; 0xfffff08d
    4894:	5f61746f 	svcpl	0x0061746f
    4898:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    489c:	64660073 	strbtvs	r0, [r6], #-115	; 0xffffff8d
    48a0:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    48a4:	5f6b6365 	svcpl	0x006b6365
    48a8:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    48ac:	63007265 	movwvs	r7, #613	; 0x265
    48b0:	746e756f 	strbtvc	r7, [lr], #-1391	; 0xfffffa91
    48b4:	00737265 	rsbseq	r7, r3, r5, ror #4
    48b8:	69726873 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, fp, sp, lr}^
    48bc:	635f6b6e 	cmpvs	pc, #112640	; 0x1b800
    48c0:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    48c4:	77006c6f 	strvc	r6, [r0, -pc, ror #24]
    48c8:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    48cc:	6b61775f 	blvs	1862650 <unflatten_and_copy_device_tree+0x18617dc>
    48d0:	00707565 	rsbseq	r7, r0, r5, ror #10
    48d4:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    48d8:	5f690074 	svcpl	0x00690074
    48dc:	735f7472 	cmpvc	pc, #1912602624	; 0x72000000
    48e0:	775f6370 			; <UNDEFINED> instruction: 0x775f6370
    48e4:	6c6e7261 	sfmvs	f7, 2, [lr], #-388	; 0xfffffe7c
    48e8:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
    48ec:	72657000 	rsbvc	r7, r5, #0
    48f0:	76655f66 	strbtvc	r5, [r5], -r6, ror #30
    48f4:	5f746e65 	svcpl	0x00746e65
    48f8:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
    48fc:	00747865 	rsbseq	r7, r4, r5, ror #16
    4900:	5f677261 	svcpl	0x00677261
    4904:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    4908:	646c0074 	strbtvs	r0, [ip], #-116	; 0xffffff8c
    490c:	6d65735f 	stclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
    4910:	6f687061 	svcvs	0x00687061
    4914:	73006572 	movwvc	r6, #1394	; 0x572
    4918:	6f6c625f 	svcvs	0x006c625f
    491c:	69736b63 	ldmdbvs	r3!, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^
    4920:	625f657a 	subsvs	r6, pc, #511705088	; 0x1e800000
    4924:	00737469 	rsbseq	r7, r3, r9, ror #8
    4928:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    492c:	5f746361 	svcpl	0x00746361
    4930:	6564726f 	strbvs	r7, [r4, #-623]!	; 0xfffffd91
    4934:	61665f72 	smcvs	26098	; 0x65f2
    4938:	64656c69 	strbtvs	r6, [r5], #-3177	; 0xfffff397
    493c:	63657200 	cmnvs	r5, #0, 4
    4940:	5f746e65 	svcpl	0x00746e65
    4944:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
    4948:	0064656e 	rsbeq	r6, r4, lr, ror #10
    494c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    4950:	00707574 	rsbseq	r7, r0, r4, ror r5
    4954:	715f6462 	cmpvc	pc, r2, ror #8
    4958:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0xfffffa8b
    495c:	6e697000 	cdpvs	0, 6, cr7, cr9, cr0, {0}
    4960:	5f64656e 	svcpl	0x0064656e
    4964:	4e006d76 	mcrmi	13, 0, r6, cr0, cr6, {3}
    4968:	4f4e5f52 	svcmi	0x004e5f52
    496c:	535f4544 	cmppl	pc, #68, 10	; 0x11000000
    4970:	45544154 	ldrbmi	r4, [r4, #-340]	; 0xfffffeac
    4974:	73630053 	cmnvc	r3, #83	; 0x53
    4978:	64695f73 	strbtvs	r5, [r9], #-3955	; 0xfffff08d
    497c:	64660072 	strbtvs	r0, [r6], #-114	; 0xffffff8e
    4980:	61705f74 	cmnvs	r0, r4, ror pc
    4984:	6f5f6874 	svcvs	0x005f6874
    4988:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    498c:	5f640074 	svcpl	0x00640074
    4990:	5f6f6e69 	svcpl	0x006f6e69
    4994:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    4998:	6d700072 	ldclvs	0, cr0, [r0, #-456]!	; 0xfffffe38
    499c:	00745f64 	rsbseq	r5, r4, r4, ror #30
    49a0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    49a4:	6c6c6163 	stfvse	f6, [ip], #-396	; 0xfffffe74
    49a8:	6f00745f 	svcvs	0x0000745f
    49ac:	5f6e6570 	svcpl	0x006e6570
    49b0:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    49b4:	41545500 	cmpmi	r4, r0, lsl #10
    49b8:	525f4b53 	subspl	r4, pc, #84992	; 0x14c00
    49bc:	494e4e55 	stmdbmi	lr, {r0, r2, r4, r6, r9, sl, fp, lr}^
    49c0:	7500474e 	strvc	r4, [r0, #-1870]	; 0xfffff8b2
    49c4:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    49c8:	706f5f74 	rsbvc	r5, pc, r4, ror pc	; <UNPREDICTABLE>
    49cc:	69730073 	ldmdbvs	r3!, {r0, r1, r4, r5, r6}^
    49d0:	645f657a 	ldrbvs	r6, [pc], #-1402	; 49d8 <.debug_str+0x49d8>
    49d4:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xfffff08c
    49d8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
    49dc:	64610073 	strbtvs	r0, [r1], #-115	; 0xffffff8d
    49e0:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
    49e4:	70735f73 	rsbsvc	r5, r3, r3, ror pc
    49e8:	00656361 	rsbeq	r6, r5, r1, ror #6
    49ec:	5f6c6f78 	svcpl	0x006c6f78
    49f0:	61657261 	cmnvs	r5, r1, ror #4
    49f4:	6f6c7300 	svcvs	0x006c7300
    49f8:	65725f77 	ldrbvs	r5, [r2, #-3959]!	; 0xfffff089
    49fc:	635f6461 	cmpvs	pc, #1627389952	; 0x61000000
    4a00:	6f007274 	svcvs	0x00007274
    4a04:	6d697470 	cfstrdvs	mvd7, [r9, #-448]!	; 0xfffffe40
    4a08:	69747369 	ldmdbvs	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
    4a0c:	70735f63 	rsbsvc	r5, r3, r3, ror #30
    4a10:	715f6e69 	cmpvc	pc, r9, ror #28
    4a14:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0xfffffa8b
    4a18:	6d797300 	ldclvs	3, cr7, [r9, #-0]
    4a1c:	6b6e696c 	blvs	1b9efd4 <unflatten_and_copy_device_tree+0x1b9e160>
    4a20:	5f696600 	svcpl	0x00696600
    4a24:	65747865 	ldrbvs	r7, [r4, #-2149]!	; 0xfffff79b
    4a28:	5f73746e 	svcpl	0x0073746e
    4a2c:	7070616d 	rsbsvc	r6, r0, sp, ror #2
    4a30:	64006465 	strvs	r6, [r0], #-1125	; 0xfffffb9b
    4a34:	75725f6c 	ldrbvc	r5, [r2, #-3948]!	; 0xfffff094
    4a38:	6d69746e 	cfstrdvs	mvd7, [r9, #-440]!	; 0xfffffe48
    4a3c:	65660065 	strbvs	r0, [r6, #-101]!	; 0xffffff9b
    4a40:	676f6c5f 			; <UNDEFINED> instruction: 0x676f6c5f
    4a44:	6c616369 	stclvs	3, cr6, [r1], #-420	; 0xfffffe5c
    4a48:	5f524e00 	svcpl	0x00524e00
    4a4c:	45455246 	strbmi	r5, [r5, #-582]	; 0xfffffdba
    4a50:	414d435f 	cmpmi	sp, pc, asr r3
    4a54:	4741505f 	smlsldmi	r5, r1, pc, r0	; <UNPREDICTABLE>
    4a58:	72005345 	andvc	r5, r0, #335544321	; 0x14000001
    4a5c:	5f646165 	svcpl	0x00646165
    4a60:	00736f70 	rsbseq	r6, r3, r0, ror pc
    4a64:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    4a68:	756f635f 	strbvc	r6, [pc, #-863]!	; 4711 <.debug_str+0x4711>
    4a6c:	6b00746e 	blvs	21c2c <unflatten_and_copy_device_tree+0x20db8>
    4a70:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    4a74:	61726400 	cmnvs	r2, r0, lsl #8
    4a78:	645f6e69 	ldrbvs	r6, [pc], #-3689	; 4a80 <.debug_str+0x4a80>
    4a7c:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
    4a80:	5f646200 	svcpl	0x00646200
    4a84:	72667366 	rsbvc	r7, r6, #-1744830463	; 0x98000001
    4a88:	657a6565 	ldrbvs	r6, [sl, #-1381]!	; 0xfffffa9b
    4a8c:	756f635f 	strbvc	r6, [pc, #-863]!	; 4735 <.debug_str+0x4735>
    4a90:	6e00746e 	cdpvs	4, 0, cr7, cr0, cr14, {3}
    4a94:	00736466 	rsbseq	r6, r3, r6, ror #8
    4a98:	4a424f4b 	bmi	10987cc <unflatten_and_copy_device_tree+0x1097958>
    4a9c:	5f534e5f 	svcpl	0x00534e5f
    4aa0:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0xfffff6ac
    4aa4:	54454e5f 	strbpl	r4, [r5], #-3679	; 0xfffff1a1
    4aa8:	72656b00 	rsbvc	r6, r5, #0, 22
    4aac:	5f73666e 	svcpl	0x0073666e
    4ab0:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    4ab4:	756e7500 	strbvc	r7, [lr, #-1280]!	; 0xfffffb00
    4ab8:	5f646573 	svcpl	0x00646573
    4abc:	6c727463 	cfldrdvs	mvd7, [r2], #-396	; 0xfffffe74
    4ac0:	4e574600 	cdpmi	6, 5, cr4, cr7, cr0, {0}
    4ac4:	5f45444f 	svcpl	0x0045444f
    4ac8:	43515249 	cmpmi	r1, #-1879048188	; 0x90000004
    4acc:	00504948 	subseq	r4, r0, r8, asr #18
    4ad0:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    4ad4:	65730065 	ldrbvs	r0, [r3, #-101]!	; 0xffffff9b
    4ad8:	6c616972 	stclvs	9, cr6, [r1], #-456	; 0xfffffe38
    4adc:	6f63695f 	svcvs	0x0063695f
    4ae0:	65746e75 	ldrbvs	r6, [r4, #-3701]!	; 0xfffff18b
    4ae4:	74735f72 	ldrbtvc	r5, [r3], #-3954	; 0xfffff08e
    4ae8:	74637572 	strbtvc	r7, [r3], #-1394	; 0xfffffa8e
    4aec:	72656b00 	rsbvc	r6, r5, #0, 22
    4af0:	5f73666e 	svcpl	0x0073666e
    4af4:	74746169 	ldrbtvc	r6, [r4], #-361	; 0xfffffe97
    4af8:	6d007372 	stcvs	3, cr7, [r0, #-456]	; 0xfffffe38
    4afc:	646f6e79 	strbtvs	r6, [pc], #-3705	; 4b04 <.debug_str+0x4b04>
    4b00:	61007365 	tstvs	r0, r5, ror #6
    4b04:	76697463 	strbtvc	r7, [r9], -r3, ror #8
    4b08:	70755f65 	rsbsvc	r5, r5, r5, ror #30
    4b0c:	65626f72 	strbvs	r6, [r2, #-3954]!	; 0xfffff08e
    4b10:	72657000 	rsbvc	r7, r5, #0
    4b14:	5f66006d 	svcpl	0x0066006d
    4b18:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
    4b1c:	6e616300 	cdpvs	3, 6, cr6, cr1, cr0, {0}
    4b20:	5f6c6563 	svcpl	0x006c6563
    4b24:	6b726f66 	blvs	1ca08c4 <unflatten_and_copy_device_tree+0x1c9fa50>
    4b28:	69756b00 	ldmdbvs	r5!, {r8, r9, fp, sp, lr}^
    4b2c:	00745f64 	rsbseq	r5, r4, r4, ror #30
    4b30:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0xfffffa92
    4b34:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    4b38:	65007265 	strvs	r7, [r0, #-613]	; 0xfffffd9b
    4b3c:	72697078 	rsbvc	r7, r9, #120	; 0x78
    4b40:	6e5f7365 	cdpvs	3, 5, cr7, cr15, cr5, {3}
    4b44:	00747865 	rsbseq	r7, r4, r5, ror #16
    4b48:	76656463 	strbtvc	r6, [r5], -r3, ror #8
    4b4c:	41475000 	mrsmi	r5, (UNDEF: 71)
    4b50:	434f4c4c 	movtmi	r4, #64588	; 0xfc4c
    4b54:	564f4d5f 			; <UNDEFINED> instruction: 0x564f4d5f
    4b58:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    4b5c:	75706300 	ldrbvc	r6, [r0, #-768]!	; 0xfffffd00
    4b60:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    4b64:	6f74615f 	svcvs	0x0074615f
    4b68:	0063696d 	rsbeq	r6, r3, sp, ror #18
    4b6c:	555f524e 	ldrbpl	r5, [pc, #-590]	; 4926 <.debug_str+0x4926>
    4b70:	4956454e 	ldmdbmi	r6, {r1, r2, r3, r6, r8, sl, lr}^
    4b74:	42415443 	submi	r5, r1, #1124073472	; 0x43000000
    4b78:	7200454c 	andvc	r4, r0, #76, 10	; 0x13000000
    4b7c:	5f646165 	svcpl	0x00646165
    4b80:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    4b84:	6c696600 	stclvs	6, cr6, [r9], #-0
    4b88:	77007365 	strvc	r7, [r0, -r5, ror #6]
    4b8c:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    4b90:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    4b94:	6e695f65 	cdpvs	15, 6, cr5, cr9, cr5, {3}
    4b98:	73006f66 	movwvc	r6, #3942	; 0xf66
    4b9c:	615f7465 	cmpvs	pc, r5, ror #8
    4ba0:	66006c63 	strvs	r6, [r0], -r3, ror #24
    4ba4:	5f776f6c 	svcpl	0x00776f6c
    4ba8:	706f7473 	rsbvc	r7, pc, r3, ror r4	; <UNPREDICTABLE>
    4bac:	00646570 	rsbeq	r6, r4, r0, ror r5
    4bb0:	63746162 	cmnvs	r4, #-2147483624	; 0x80000018
    4bb4:	656d0068 	strbvs	r0, [sp, #-104]!	; 0xffffff98
    4bb8:	616d5f6d 	cmnvs	sp, sp, ror #30
    4bbc:	47500070 			; <UNDEFINED> instruction: 0x47500070
    4bc0:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    4bc4:	5f455441 	svcpl	0x00455441
    4bc8:	43435553 	movtmi	r5, #13651	; 0x3553
    4bcc:	00535345 	subseq	r5, r3, r5, asr #6
    4bd0:	6e695f73 	mcrvs	15, 3, r5, cr9, cr3, {3}
    4bd4:	6e617473 	mcrvs	4, 3, r7, cr1, cr3, {3}
    4bd8:	00736563 	rsbseq	r6, r3, r3, ror #10
    4bdc:	61727466 	cmnvs	r2, r6, ror #8
    4be0:	725f6563 	subsvc	r6, pc, #415236096	; 0x18c00000
    4be4:	735f7465 	cmpvc	pc, #1694498816	; 0x65000000
    4be8:	6b636174 	blvs	18dd1c0 <unflatten_and_copy_device_tree+0x18dc34c>
    4bec:	646f6e00 	strbtvs	r6, [pc], #-3584	; 4bf4 <.debug_str+0x4bf4>
    4bf0:	74735f65 	ldrbtvc	r5, [r3], #-3941	; 0xfffff09b
    4bf4:	5f747261 	svcpl	0x00747261
    4bf8:	006e6670 	rsbeq	r6, lr, r0, ror r6
    4bfc:	67696577 			; <UNDEFINED> instruction: 0x67696577
    4c00:	62007468 	andvs	r7, r0, #104, 8	; 0x68000000
    4c04:	5f766564 	svcpl	0x00766564
    4c08:	5f797274 	svcpl	0x00797274
    4c0c:	665f6f74 	usub16vs	r6, pc, r4	; <UNPREDICTABLE>
    4c10:	5f656572 	svcpl	0x00656572
    4c14:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    4c18:	5f726e00 	svcpl	0x00726e00
    4c1c:	656b6177 	strbvs	r6, [fp, #-375]!	; 0xfffffe89
    4c20:	00737075 	rsbseq	r7, r3, r5, ror r0
    4c24:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    4c28:	6f72705f 	svcvs	0x0072705f
    4c2c:	64620070 	strbtvs	r0, [r2], #-112	; 0xffffff90
    4c30:	65706f5f 	ldrbvs	r6, [r0, #-3935]!	; 0xfffff0a1
    4c34:	7372656e 	cmnvc	r2, #461373440	; 0x1b800000
    4c38:	79747400 	ldmdbvc	r4!, {sl, ip, sp, lr}^
    4c3c:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
    4c40:	00726566 	rsbseq	r6, r2, r6, ror #10
    4c44:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    4c48:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    4c4c:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    4c50:	61626574 	smcvs	9812	; 0x2654
    4c54:	635f6b63 	cmpvs	pc, #101376	; 0x18c00
    4c58:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    4c5c:	73006c6f 	movwvc	r6, #3183	; 0xc6f
    4c60:	6e69705f 	mcrvs	0, 3, r7, cr9, cr15, {2}
    4c64:	65720073 	ldrbvs	r0, [r2, #-115]!	; 0xffffff8d
    4c68:	735f6c61 	cmpvc	pc, #24832	; 0x6100
    4c6c:	74726174 	ldrbtvc	r6, [r2], #-372	; 0xfffffe8c
    4c70:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    4c74:	70630065 	rsbvc	r0, r3, r5, rrx
    4c78:	74657375 	strbtvc	r7, [r5], #-885	; 0xfffffc8b
    4c7c:	7267635f 	rsbvc	r6, r7, #2080374785	; 0x7c000001
    4c80:	64695f70 	strbtvs	r5, [r9], #-3952	; 0xfffff090
    4c84:	73696c00 	cmnvc	r9, #0, 24
    4c88:	726c5f74 	rsbvc	r5, ip, #116, 30	; 0x1d0
    4c8c:	5f690075 	svcpl	0x00690075
    4c90:	6b6e696c 	blvs	1b9f248 <unflatten_and_copy_device_tree+0x1b9e3d4>
    4c94:	625f6900 	subsvs	r6, pc, #0, 18
    4c98:	00766564 	rsbseq	r6, r6, r4, ror #10
    4c9c:	66726570 			; <UNDEFINED> instruction: 0x66726570
    4ca0:	5f726e5f 	svcpl	0x00726e5f
    4ca4:	6b736174 	blvs	1cdd27c <unflatten_and_copy_device_tree+0x1cdc408>
    4ca8:	6e6f635f 	mcrvs	3, 3, r6, cr15, cr15, {2}
    4cac:	74786574 	ldrbtvc	r6, [r8], #-1396	; 0xfffffa8c
    4cb0:	69660073 	stmdbvs	r6!, {r0, r1, r4, r5, r6}^
    4cb4:	7478655f 	ldrbtvc	r6, [r8], #-1375	; 0xfffffaa1
    4cb8:	73746e65 	cmnvc	r4, #1616	; 0x650
    4cbc:	6174735f 	cmnvs	r4, pc, asr r3
    4cc0:	43007472 	movwmi	r7, #1138	; 0x472
    4cc4:	41504d4f 	cmpmi	r0, pc, asr #26
    4cc8:	494d5443 	stmdbmi	sp, {r0, r1, r6, sl, ip, lr}^
    4ccc:	54415247 	strbpl	r5, [r1], #-583	; 0xfffffdb9
    4cd0:	43535f45 	cmpmi	r3, #276	; 0x114
    4cd4:	454e4e41 	strbmi	r4, [lr, #-3649]	; 0xfffff1bf
    4cd8:	5f660044 	svcpl	0x00660044
    4cdc:	646f6e69 	strbtvs	r6, [pc], #-3689	; 4ce4 <.debug_str+0x4ce4>
    4ce0:	72740065 	rsbsvc	r0, r4, #101	; 0x65
    4ce4:	66006575 			; <UNDEFINED> instruction: 0x66006575
    4ce8:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    4cec:	6b6c6200 	blvs	1b1d4f4 <unflatten_and_copy_device_tree+0x1b1c680>
    4cf0:	756c705f 	strbvc	r7, [ip, #-95]!	; 0xffffffa1
    4cf4:	65720067 	ldrbvs	r0, [r2, #-103]!	; 0xffffff99
    4cf8:	61706461 	cmnvs	r0, r1, ror #8
    4cfc:	70006567 	andvc	r6, r0, r7, ror #10
    4d00:	696c6469 	stmdbvs	ip!, {r0, r3, r5, r6, sl, sp, lr}^
    4d04:	6d5f7473 	cfldrdvs	mvd7, [pc, #-460]	; 4b40 <.debug_str+0x4b40>
    4d08:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    4d0c:	6f727000 	svcvs	0x00727000
    4d10:	74726570 	ldrbtvc	r6, [r2], #-1392	; 0xfffffa90
    4d14:	00736569 	rsbseq	r6, r3, r9, ror #10
    4d18:	6974755f 	ldmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, sl, ip, sp, lr}^
    4d1c:	7400656d 	strvc	r6, [r0], #-1389	; 0xfffffa93
    4d20:	00656d69 	rsbeq	r6, r5, r9, ror #26
    4d24:	6e695f69 	cdpvs	15, 6, cr5, cr9, cr9, {3}
    4d28:	69745f6f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    4d2c:	696c656d 	stmdbvs	ip!, {r0, r2, r3, r5, r6, r8, sl, sp, lr}^
    4d30:	0074696d 	rsbseq	r6, r4, sp, ror #18
    4d34:	76657270 			; <UNDEFINED> instruction: 0x76657270
    4d38:	63657300 	cmnvs	r5, #0, 6
    4d3c:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    4d40:	74646600 	strbtvc	r6, [r4], #-1536	; 0xfffffa00
    4d44:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    4d48:	65725f74 	ldrbvs	r5, [r2, #-3956]!	; 0xfffff08c
    4d4c:	76726573 			; <UNDEFINED> instruction: 0x76726573
    4d50:	6d5f6465 	cfldrdvs	mvd6, [pc, #-404]	; 4bc4 <.debug_str+0x4bc4>
    4d54:	63006d65 	movwvs	r6, #3429	; 0xd65
    4d58:	6e61656c 	cdpvs	5, 6, cr6, cr1, cr12, {3}
    4d5c:	68636163 	stmdavs	r3!, {r0, r1, r5, r6, r8, sp, lr}^
    4d60:	6f705f65 	svcvs	0x00705f65
    4d64:	64696c6f 	strbtvs	r6, [r9], #-3183	; 0xfffff391
    4d68:	64667500 	strbtvs	r7, [r6], #-1280	; 0xfffffb00
    4d6c:	5f5f0073 	svcpl	0x005f0073
    4d70:	32336562 	eorscc	r6, r3, #411041792	; 0x18800000
    4d74:	6b5f5f00 	blvs	17dc97c <unflatten_and_copy_device_tree+0x17dbb08>
    4d78:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    4d7c:	6c635f6c 	stclvs	15, cr5, [r3], #-432	; 0xfffffe50
    4d80:	5f6b636f 	svcpl	0x006b636f
    4d84:	5f690074 	svcpl	0x00690074
    4d88:	5f00706f 	svcpl	0x0000706f
    4d8c:	6f6c695f 	svcvs	0x006c695f
    4d90:	755f3267 	ldrbvc	r3, [pc, #-615]	; 4b31 <.debug_str+0x4b31>
    4d94:	73003233 	movwvc	r3, #563	; 0x233
    4d98:	5f657a69 	svcpl	0x00657a69
    4d9c:	735f7464 	cmpvc	pc, #100, 8	; 0x64000000
    4da0:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    4da4:	5f730074 	svcpl	0x00730074
    4da8:	5f6f6964 	svcpl	0x006f6964
    4dac:	656e6f64 	strbvs	r6, [lr, #-3940]!	; 0xfffff09c
    4db0:	0071775f 	rsbseq	r7, r1, pc, asr r7
    4db4:	6769735f 			; <UNDEFINED> instruction: 0x6769735f
    4db8:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    4dbc:	524e0074 	subpl	r0, lr, #116	; 0x74
    4dc0:	464f535f 			; <UNDEFINED> instruction: 0x464f535f
    4dc4:	51524954 	cmppl	r2, r4, asr r9
    4dc8:	65670053 	strbvs	r0, [r7, #-83]!	; 0xffffffad
    4dcc:	74746174 	ldrbtvc	r6, [r4], #-372	; 0xfffffe8c
    4dd0:	64660072 	strbtvs	r0, [r6], #-114	; 0xffffff8e
    4dd4:	6f6e5f74 	svcvs	0x006e5f74
    4dd8:	635f6564 	cmpvs	pc, #100, 10	; 0x19000000
    4ddc:	6b636568 	blvs	18de384 <unflatten_and_copy_device_tree+0x18dd510>
    4de0:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!	; 4c6c <.debug_str+0x4c6c>
    4de4:	69746170 	ldmdbvs	r4!, {r4, r5, r6, r8, sp, lr}^
    4de8:	00656c62 	rsbeq	r6, r5, r2, ror #24
    4dec:	465f524e 	ldrbmi	r5, [pc], -lr, asr #4
    4df0:	5f454552 	svcpl	0x00454552
    4df4:	45474150 	strbmi	r4, [r7, #-336]	; 0xfffffeb0
    4df8:	524e0053 	subpl	r0, lr, #83	; 0x53
    4dfc:	5443415f 	strbpl	r4, [r3], #-351	; 0xfffffea1
    4e00:	5f455649 	svcpl	0x00455649
    4e04:	4e4f4e41 	cdpmi	14, 4, cr4, cr15, cr1, {2}
    4e08:	74746100 	ldrbtvc	r6, [r4], #-256	; 0xffffff00
    4e0c:	00686361 	rsbeq	r6, r8, r1, ror #6
    4e10:	6c5f6566 	cfldr64vs	mvdx6, [pc], {102}	; 0x66
    4e14:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xfffff19b
    4e18:	726e0068 	rsbvc	r0, lr, #104	; 0x68
    4e1c:	6b61775f 	blvs	1862ba0 <unflatten_and_copy_device_tree+0x1861d2c>
    4e20:	73707565 	cmnvc	r0, #423624704	; 0x19400000
    4e24:	6d65725f 	sfmvs	f7, 2, [r5, #-380]!	; 0xfffffe84
    4e28:	0065746f 	rsbeq	r7, r5, pc, ror #8
    4e2c:	6c636572 	cfstr64vs	mvdx6, [r3], #-456	; 0xfffffe38
    4e30:	5f6d6961 	svcpl	0x006d6961
    4e34:	74617473 	strbtvc	r7, [r1], #-1139	; 0xfffffb8d
    4e38:	656b0065 	strbvs	r0, [fp, #-101]!	; 0xffffff9b
    4e3c:	73666e72 	cmnvc	r6, #1824	; 0x720
    4e40:	73706f5f 	cmnvc	r0, #380	; 0x17c
    4e44:	54454e00 	strbpl	r4, [r5], #-3584	; 0xfffff200
    4e48:	5f58525f 	svcpl	0x0058525f
    4e4c:	54464f53 	strbpl	r4, [r6], #-3923	; 0xfffff0ad
    4e50:	00515249 	subseq	r5, r1, r9, asr #4
    4e54:	5f756372 	svcpl	0x00756372
    4e58:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    4e5c:	5f646200 	svcpl	0x00646200
    4e60:	6b736964 	blvs	1cdf3f8 <unflatten_and_copy_device_tree+0x1cde584>
    4e64:	5f666f00 	svcpl	0x00666f00
    4e68:	5f746466 	svcpl	0x00746466
    4e6c:	696d696c 	stmdbvs	sp!, {r2, r3, r5, r6, r8, fp, sp, lr}^
    4e70:	656d5f74 	strbvs	r5, [sp, #-3956]!	; 0xfffff08c
    4e74:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    4e78:	72616800 	rsbvc	r6, r1, #0, 16
    4e7c:	71726964 	cmnvc	r2, r4, ror #18
    4e80:	616e655f 	cmnvs	lr, pc, asr r5
    4e84:	5f656c62 	svcpl	0x00656c62
    4e88:	6e657665 	cdpvs	6, 6, cr7, cr5, cr5, {3}
    4e8c:	74690074 	strbtvc	r0, [r9], #-116	; 0xffffff8c
    4e90:	74617265 	strbtvc	r7, [r1], #-613	; 0xfffffd9b
    4e94:	65720065 	ldrbvs	r0, [r2, #-101]!	; 0xffffff9b
    4e98:	65766f6d 	ldrbvs	r6, [r6, #-3949]!	; 0xfffff093
    4e9c:	74746178 	ldrbtvc	r6, [r4], #-376	; 0xfffffe88
    4ea0:	5f730072 	svcpl	0x00730072
    4ea4:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    4ea8:	63006576 	movwvs	r6, #1398	; 0x576
    4eac:	69736f6c 	ldmdbvs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    4eb0:	775f676e 	ldrbvc	r6, [pc, -lr, ror #14]
    4eb4:	00746961 	rsbseq	r6, r4, r1, ror #18
    4eb8:	6f726763 	svcvs	0x00726763
    4ebc:	72007075 	andvc	r7, r0, #117	; 0x75
    4ec0:	6c5f6e75 	mrrcvs	14, 7, r6, pc, cr5	; <UNPREDICTABLE>
    4ec4:	00747369 	rsbseq	r7, r4, r9, ror #6
    4ec8:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xfffff09d
    4ecc:	00747865 	rsbseq	r7, r4, r5, ror #16
    4ed0:	65725f64 	ldrbvs	r5, [r2, #-3940]!	; 0xfffff09c
    4ed4:	696c6176 	stmdbvs	ip!, {r1, r2, r4, r5, r6, r8, sp, lr}^
    4ed8:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0xfffffe9c
    4edc:	646f6e00 	strbtvs	r6, [pc], #-3584	; 4ee4 <.debug_str+0x4ee4>
    4ee0:	6f7a5f65 	svcvs	0x007a5f65
    4ee4:	696c656e 	stmdbvs	ip!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
    4ee8:	00737473 	rsbseq	r7, r3, r3, ror r4
    4eec:	635f6d6d 	cmpvs	pc, #6976	; 0x1b40
    4ef0:	65746e6f 	ldrbvs	r6, [r4, #-3695]!	; 0xfffff191
    4ef4:	745f7478 	ldrbvc	r7, [pc], #-1144	; 4efc <.debug_str+0x4efc>
    4ef8:	636f6c00 	cmnvs	pc, #0, 24
    4efc:	5f64656b 	svcpl	0x0064656b
    4f00:	006d6873 	rsbeq	r6, sp, r3, ror r8
    4f04:	5f746567 	svcpl	0x00746567
    4f08:	006c6361 	rsbeq	r6, ip, r1, ror #6
    4f0c:	7473616c 	ldrbtvc	r6, [r3], #-364	; 0xfffffe94
    4f10:	6b61775f 	blvs	1862c94 <unflatten_and_copy_device_tree+0x1861e20>
    4f14:	73006565 	movwvc	r6, #1381	; 0x565
    4f18:	79736275 	ldmdbvc	r3!, {r0, r2, r4, r5, r6, r9, sp, lr}^
    4f1c:	616d5f73 	smcvs	54771	; 0xd5f3
    4f20:	68006b73 	stmdavs	r0, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}
    4f24:	74617769 	strbtvc	r7, [r1], #-1897	; 0xfffff897
    4f28:	725f7265 	subsvc	r7, pc, #1342177286	; 0x50000006
    4f2c:	70007373 	andvc	r7, r0, r3, ror r3
    4f30:	5f636f72 	svcpl	0x00636f72
    4f34:	5f726964 	svcpl	0x00726964
    4f38:	72746e65 	rsbsvc	r6, r4, #1616	; 0x650
    4f3c:	666e0079 			; <UNDEFINED> instruction: 0x666e0079
    4f40:	6f6c5f73 	svcvs	0x006c5f73
    4f44:	695f6b63 	ldmdbvs	pc, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^	; <UNPREDICTABLE>
    4f48:	006f666e 	rsbeq	r6, pc, lr, ror #12
    4f4c:	454e4f5a 	strbmi	r4, [lr, #-3930]	; 0xfffff0a6
    4f50:	524f4e5f 	subpl	r4, pc, #1520	; 0x5f0
    4f54:	004c414d 	subeq	r4, ip, sp, asr #2
    4f58:	504f5244 	subpl	r5, pc, r4, asr #4
    4f5c:	414c535f 	cmpmi	ip, pc, asr r3
    4f60:	735f0042 	cmpvc	pc, #66	; 0x42
    4f64:	705f7379 	subsvc	r7, pc, r9, ror r3	; <UNPREDICTABLE>
    4f68:	61766972 	cmnvs	r6, r2, ror r9
    4f6c:	64006574 	strvs	r6, [r0], #-1396	; 0xfffffa8c
    4f70:	6473665f 	ldrbtvs	r6, [r3], #-1631	; 0xfffff9a1
    4f74:	00617461 	rsbeq	r7, r1, r1, ror #8
    4f78:	725f7566 	subsvc	r7, pc, #427819008	; 0x19800000
    4f7c:	65687563 	strbvs	r7, [r8, #-1379]!	; 0xfffffa9d
    4f80:	66006461 	strvs	r6, [r0], -r1, ror #8
    4f84:	706f5f6c 	rsbvc	r5, pc, ip, ror #30
    4f88:	75660073 	strbvc	r0, [r6, #-115]!	; 0xffffff8d
    4f8c:	6e5f6c6c 	cdpvs	12, 5, cr6, cr15, cr12, {3}
    4f90:	00656d61 	rsbeq	r6, r5, r1, ror #26
    4f94:	69707865 	ldmdbvs	r0!, {r0, r2, r5, r6, fp, ip, sp, lr}^
    4f98:	00736572 	rsbseq	r6, r3, r2, ror r5
    4f9c:	725f6f64 	subsvc	r6, pc, #100, 30	; 0x190
    4fa0:	6d757365 	ldclvs	3, cr7, [r5, #-404]!	; 0xfffffe6c
    4fa4:	6f720065 	svcvs	0x00720065
    4fa8:	74737562 	ldrbtvc	r7, [r3], #-1378	; 0xfffffa9e
    4fac:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    4fb0:	5f630074 	svcpl	0x00630074
    4fb4:	63006363 	movwvs	r6, #867	; 0x363
    4fb8:	646c6968 	strbtvs	r6, [ip], #-2408	; 0xfffff698
    4fbc:	006e6572 	rsbeq	r6, lr, r2, ror r5
    4fc0:	625f6970 	subsvs	r6, pc, #112, 18	; 0x1c0000
    4fc4:	6b636f6c 	blvs	18e0d7c <unflatten_and_copy_device_tree+0x18dff08>
    4fc8:	6f5f6465 	svcvs	0x005f6465
    4fcc:	4352006e 	cmpmi	r2, #110	; 0x6e
    4fd0:	43535f55 	cmpmi	r3, #340	; 0x154
    4fd4:	5f444548 	svcpl	0x00444548
    4fd8:	434e5953 	movtmi	r5, #59731	; 0xe953
    4fdc:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    4fe0:	61626574 	smcvs	9812	; 0x2654
    4fe4:	695f6b63 	ldmdbvs	pc, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^	; <UNPREDICTABLE>
    4fe8:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
    4fec:	79747400 	ldmdbvc	r4!, {sl, ip, sp, lr}^
    4ff0:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
    4ff4:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    4ff8:	6e657300 	cdpvs	3, 6, cr7, cr5, cr0, {0}
    4ffc:	67617064 	strbvs	r7, [r1, -r4, rrx]!
    5000:	735f0065 	cmpvc	pc, #101	; 0x65
    5004:	65696669 	strbvs	r6, [r9, #-1641]!	; 0xfffff997
    5008:	0073646c 	rsbseq	r6, r3, ip, ror #8
    500c:	666e6f63 	strbtvs	r6, [lr], -r3, ror #30
    5010:	5f6d7269 	svcpl	0x006d7269
    5014:	74697773 	strbtvc	r7, [r9], #-1907	; 0xfffff88d
    5018:	64006863 	strvs	r6, [r0], #-2147	; 0xfffff79d
    501c:	725f6271 	subsvc	r6, pc, #268435463	; 0x10000007
    5020:	70737673 	rsbsvc	r7, r3, r3, ror r6
    5024:	00656361 	rsbeq	r6, r5, r1, ror #6
    5028:	656e6f7a 	strbvs	r6, [lr, #-3962]!	; 0xfffff086
    502c:	6467705f 	strbtvs	r7, [r7], #-95	; 0xffffffa1
    5030:	62007461 	andvs	r7, r0, #1627389952	; 0x61000000
    5034:	5f746f6f 	svcpl	0x00746f6f
    5038:	69757063 	ldmdbvs	r5!, {r0, r1, r5, r6, ip, sp, lr}^
    503c:	68705f64 	ldmdavs	r0!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    5040:	75007379 	strvc	r7, [r0, #-889]	; 0xfffffc87
    5044:	636f6c6e 	cmnvs	pc, #28160	; 0x6e00
    5048:	5f64656b 	svcpl	0x0064656b
    504c:	74636f69 	strbtvc	r6, [r3], #-3945	; 0xfffff097
    5050:	696e006c 	stmdbvs	lr!, {r2, r3, r5, r6}^
    5054:	77736376 			; <UNDEFINED> instruction: 0x77736376
    5058:	6d697400 	cfstrdvs	mvd7, [r9, #-0]
    505c:	75717265 	ldrbvc	r7, [r1, #-613]!	; 0xfffffd9b
    5060:	5f657565 	svcpl	0x00657565
    5064:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    5068:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    506c:	7461006f 	strbtvc	r0, [r1], #-111	; 0xffffff91
    5070:	63696d6f 	cmnvs	r9, #7104	; 0x1bc0
    5074:	745f3436 	ldrbvc	r3, [pc], #-1078	; 507c <.debug_str+0x507c>
    5078:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    507c:	76740076 			; <UNDEFINED> instruction: 0x76740076
    5080:	6365735f 	cmnvs	r5, #2080374785	; 0x7c000001
    5084:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 508c <.debug_str+0x508c>
    5088:	00746170 	rsbseq	r6, r4, r0, ror r1
    508c:	5f697164 	svcpl	0x00697164
    5090:	5f746d66 	svcpl	0x00746d66
    5094:	73006469 	movwvc	r6, #1129	; 0x469
    5098:	5f706177 	svcpl	0x00706177
    509c:	69746361 	ldmdbvs	r4!, {r0, r5, r6, r8, r9, sp, lr}^
    50a0:	65746176 	ldrbvs	r6, [r4, #-374]!	; 0xfffffe8a
    50a4:	73626f00 	cmnvc	r2, #0, 30
    50a8:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    50ac:	5f6c656e 	svcpl	0x006c656e
    50b0:	61726170 	cmnvs	r2, r0, ror r1
    50b4:	7363006d 	cmnvc	r3, #109	; 0x6d
    50b8:	65735f73 	ldrbvs	r5, [r3, #-3955]!	; 0xfffff08d
    50bc:	61700074 	cmnvs	r0, r4, ror r0
    50c0:	00736567 	rsbseq	r6, r3, r7, ror #10
    50c4:	6b736174 	blvs	1cdd69c <unflatten_and_copy_device_tree+0x1cdc828>
    50c8:	726f775f 	rsbvc	r7, pc, #24903680	; 0x17c0000
    50cc:	6f00736b 	svcvs	0x0000736b
    50d0:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    50d4:	6f770074 	svcvs	0x00770074
    50d8:	77006b72 	smlsdxvc	r0, r2, fp, r6
    50dc:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    50e0:	6f6f725f 	svcvs	0x006f725f
    50e4:	6f77006d 	svcvs	0x0077006d
    50e8:	665f6b72 			; <UNDEFINED> instruction: 0x665f6b72
    50ec:	5f636e75 	svcpl	0x00636e75
    50f0:	696c0074 	stmdbvs	ip!, {r2, r4, r5, r6}^
    50f4:	61787473 	cmnvs	r8, r3, ror r4
    50f8:	00727474 	rsbseq	r7, r2, r4, ror r4
    50fc:	6f6d5f73 	svcvs	0x006d5f73
    5100:	64006564 	strvs	r6, [r0], #-1380	; 0xfffffa9c
    5104:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e
    5108:	616e5f72 	smcvs	58866	; 0xe5f2
    510c:	6300656d 	movwvs	r6, #1389	; 0x56d
    5110:	765f7570 			; <UNDEFINED> instruction: 0x765f7570
    5114:	616d5f6d 	cmnvs	sp, sp, ror #30
    5118:	765f6b73 			; <UNDEFINED> instruction: 0x765f6b73
    511c:	5f007261 	svcpl	0x00007261
    5120:	6769735f 			; <UNDEFINED> instruction: 0x6769735f
    5124:	666c616e 	strbtvs	r6, [ip], -lr, ror #2
    5128:	00745f6e 	rsbseq	r5, r4, lr, ror #30
    512c:	705f726e 	subsvc	r7, pc, lr, ror #4
    5130:	0073646d 	rsbseq	r6, r3, sp, ror #8
    5134:	65725f64 	ldrbvs	r5, [r2, #-3940]!	; 0xfffff09c
    5138:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000
    513c:	61700065 	cmnvs	r0, r5, rrx
    5140:	74656b63 	strbtvc	r6, [r5], #-2915	; 0xfffff49d
    5144:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    5148:	6573755f 	ldrbvs	r7, [r3, #-1375]!	; 0xfffffaa1
    514c:	65700064 	ldrbvs	r0, [r0, #-100]!	; 0xffffff9c
    5150:	655f6672 	ldrbvs	r6, [pc, #-1650]	; 4ae6 <.debug_str+0x4ae6>
    5154:	746e6576 	strbtvc	r6, [lr], #-1398	; 0xfffffa8a
    5158:	7267635f 	rsbvc	r6, r7, #2080374785	; 0x7c000001
    515c:	64695f70 	strbtvs	r5, [r9], #-3952	; 0xfffff090
    5160:	6c707300 	ldclvs	3, cr7, [r0], #-0
    5164:	5f656369 	svcpl	0x00656369
    5168:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
    516c:	73736300 	cmnvc	r3, #0, 6
    5170:	6c6e6f5f 	stclvs	15, cr6, [lr], #-380	; 0xfffffe84
    5174:	00656e69 	rsbeq	r6, r5, r9, ror #28
    5178:	706f5f64 	rsbvc	r5, pc, r4, ror #30
    517c:	69735f00 	ldmdbvs	r3!, {r8, r9, sl, fp, ip, lr}^
    5180:	6c6f7067 	stclvs	0, cr7, [pc], #-412	; 4fec <.debug_str+0x4fec>
    5184:	6466006c 	strbtvs	r0, [r6], #-108	; 0xffffff94
    5188:	65675f74 	strbvs	r5, [r7, #-3956]!	; 0xfffff08c
    518c:	616e5f74 	smcvs	58868	; 0xe5f4
    5190:	6d00656d 	cfstr32vs	mvfx6, [r0, #-436]	; 0xfffffe4c
    5194:	67636d65 	strbvs	r6, [r3, -r5, ror #26]!
    5198:	5f6e695f 	svcpl	0x006e695f
    519c:	006d6f6f 	rsbeq	r6, sp, pc, ror #30
    51a0:	736b5f5f 	cmnvc	fp, #380	; 0x17c
    51a4:	61747274 	cmnvs	r4, r4, ror r2
    51a8:	666f5f62 	strbtvs	r5, [pc], -r2, ror #30
    51ac:	7464665f 	strbtvc	r6, [r4], #-1631	; 0xfffff9a1
    51b0:	666e755f 			; <UNDEFINED> instruction: 0x666e755f
    51b4:	7474616c 	ldrbtvc	r6, [r4], #-364	; 0xfffffe94
    51b8:	745f6e65 	ldrbvc	r6, [pc], #-3685	; 51c0 <.debug_str+0x51c0>
    51bc:	00656572 	rsbeq	r6, r5, r2, ror r5
    51c0:	756f7267 	strbvc	r7, [pc, #-615]!	; 4f61 <.debug_str+0x4f61>
    51c4:	78655f70 	stmdavc	r5!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    51c8:	635f7469 	cmpvs	pc, #1761607680	; 0x69000000
    51cc:	0065646f 	rsbeq	r6, r5, pc, ror #8
    51d0:	616d6f6e 	cmnvs	sp, lr, ror #30
    51d4:	6e750070 	mrcvs	0, 3, r0, cr5, cr0, {3}
    51d8:	6b6e696c 	blvs	1b9f790 <unflatten_and_copy_device_tree+0x1b9e91c>
    51dc:	73616800 	cmnvc	r1, #0, 16
    51e0:	63610068 	cmnvs	r1, #104	; 0x68
    51e4:	6974735f 	ldmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    51e8:	6300656d 	movwvs	r6, #1389	; 0x56d
    51ec:	6b636f6c 	blvs	18e0fa4 <unflatten_and_copy_device_tree+0x18e0130>
    51f0:	745f6469 	ldrbvc	r6, [pc], #-1129	; 51f8 <.debug_str+0x51f8>
    51f4:	5f726e00 	svcpl	0x00726e00
    51f8:	6d657469 	cfstrdvs	mvd7, [r5, #-420]!	; 0xfffffe5c
    51fc:	5f5f0073 	svcpl	0x005f0073
    5200:	6c726165 	ldfvse	f6, [r2], #-404	; 0xfffffe6c
    5204:	6e6f6379 	mcrvs	3, 3, r6, cr15, cr9, {3}
    5208:	5f666f5f 	svcpl	0x00666f5f
    520c:	6c626174 	stfvse	f6, [r2], #-464	; 0xfffffe30
    5210:	70630065 	rsbvc	r0, r3, r5, rrx
    5214:	6d697475 	cfstrdvs	mvd7, [r9, #-468]!	; 0xfffffe2c
    5218:	00745f65 	rsbseq	r5, r4, r5, ror #30
    521c:	795f6c64 	ldmdbvc	pc, {r2, r5, r6, sl, fp, sp, lr}^	; <UNPREDICTABLE>
    5220:	646c6569 	strbtvs	r6, [ip], #-1385	; 0xfffffa97
    5224:	73006465 	movwvc	r6, #1125	; 0x465
    5228:	756f635f 	strbvc	r6, [pc, #-863]!	; 4ed1 <.debug_str+0x4ed1>
    522c:	7700746e 	strvc	r7, [r0, -lr, ror #8]
    5230:	65656b61 	strbvs	r6, [r5, #-2913]!	; 0xfffff49f
    5234:	696c665f 	stmdbvs	ip!, {r0, r1, r2, r3, r4, r6, r9, sl, sp, lr}^
    5238:	65645f70 	strbvs	r5, [r4, #-3952]!	; 0xfffff090
    523c:	5f796163 	svcpl	0x00796163
    5240:	69007374 	stmdbvs	r0, {r2, r4, r5, r6, r8, r9, ip, sp, lr}
    5244:	6174735f 	cmnvs	r4, pc, asr r3
    5248:	66006574 			; <UNDEFINED> instruction: 0x66006574
    524c:	65725f65 	ldrbvs	r5, [r2, #-3941]!	; 0xfffff09b
    5250:	76726573 			; <UNDEFINED> instruction: 0x76726573
    5254:	34366465 	ldrtcc	r6, [r6], #-1125	; 0xfffffb9b
    5258:	454e5500 	strbmi	r5, [lr, #-1280]	; 0xfffffb00
    525c:	54434956 	strbpl	r4, [r3], #-2390	; 0xfffff6aa
    5260:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    5264:	5247505f 	subpl	r5, r7, #95	; 0x5f
    5268:	55435345 	strbpl	r5, [r3, #-837]	; 0xfffffcbb
    526c:	50004445 	andpl	r4, r0, r5, asr #8
    5270:	45545347 	ldrbmi	r5, [r4, #-839]	; 0xfffffcb9
    5274:	445f4c41 	ldrbmi	r4, [pc], #-3137	; 527c <.debug_str+0x527c>
    5278:	43455249 	movtmi	r5, #21065	; 0x5249
    527c:	4f4e5f54 	svcmi	0x004e5f54
    5280:	4c414d52 	mcrrmi	13, 5, r4, r1, cr2
    5284:	696e6900 	stmdbvs	lr!, {r8, fp, sp, lr}^
    5288:	5f647274 	svcpl	0x00647274
    528c:	00646e65 	rsbeq	r6, r4, r5, ror #28
    5290:	6b636f6c 	blvs	18e1048 <unflatten_and_copy_device_tree+0x18e01d4>
    5294:	00666572 	rsbeq	r6, r6, r2, ror r5
    5298:	725f6272 	subsvc	r6, pc, #536870919	; 0x20000007
    529c:	74686769 	strbtvc	r6, [r8], #-1897	; 0xfffff897
    52a0:	5f666f00 	svcpl	0x00666f00
    52a4:	5f746567 	svcpl	0x00746567
    52a8:	74616c66 	strbtvc	r6, [r1], #-3174	; 0xfffff39a
    52ac:	5f74645f 	svcpl	0x0074645f
    52b0:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    52b4:	73616800 	cmnvc	r1, #0, 16
    52b8:	6d616e5f 	stclvs	14, cr6, [r1, #-380]!	; 0xfffffe84
    52bc:	5f730065 	svcpl	0x00730065
    52c0:	6e756f6d 	cdpvs	15, 7, cr6, cr5, cr13, {3}
    52c4:	63007374 	movwvs	r7, #884	; 0x374
    52c8:	6c626e69 	stclvs	14, cr6, [r2], #-420	; 0xfffffe5c
    52cc:	006b636f 	rsbeq	r6, fp, pc, ror #6
    52d0:	65657073 	strbvs	r7, [r5, #-115]!	; 0xffffff8d
    52d4:	00745f64 	rsbseq	r5, r4, r4, ror #30
    52d8:	646f6e72 	strbtvs	r6, [pc], #-3698	; 52e0 <.debug_str+0x52e0>
    52dc:	69730065 	ldmdbvs	r3!, {r0, r2, r5, r6}^
    52e0:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xfffff199
    52e4:	61686320 	cmnvs	r8, r0, lsr #6
    52e8:	5f690072 	svcpl	0x00690072
    52ec:	00706f66 	rsbseq	r6, r0, r6, ror #30
    52f0:	6d726574 	cfldr64vs	mvdx6, [r2, #-464]!	; 0xfffffe30
    52f4:	5f736f69 	svcpl	0x00736f69
    52f8:	6b636f6c 	blvs	18e10b0 <unflatten_and_copy_device_tree+0x18e023c>
    52fc:	72006465 	andvc	r6, r0, #1694498816	; 0x65000000
    5300:	61705f61 	cmnvs	r0, r1, ror #30
    5304:	00736567 	rsbseq	r6, r3, r7, ror #10
    5308:	79735f73 	ldmdbvc	r3!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    530c:	6c5f636e 	mrrcvs	3, 6, r6, pc, cr14	; <UNPREDICTABLE>
    5310:	006b636f 	rsbeq	r6, fp, pc, ror #6
    5314:	6f726874 	svcvs	0x00726874
    5318:	656c7474 	strbvs	r7, [ip, #-1140]!	; 0xfffffb8c
    531c:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; 4424 <.debug_str+0x4424>
    5320:	616c666e 	cmnvs	ip, lr, ror #12
    5324:	6e657474 	mcrvs	4, 3, r7, cr5, cr4, {3}
    5328:	7665645f 			; <UNDEFINED> instruction: 0x7665645f
    532c:	5f656369 	svcpl	0x00656369
    5330:	65657274 	strbvs	r7, [r5, #-628]!	; 0xfffffd8c
    5334:	64697000 	strbtvs	r7, [r9], #-0
    5338:	5f5f0073 	svcpl	0x005f0073
    533c:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
    5340:	70005f5f 	andvc	r5, r0, pc, asr pc
    5344:	5f636f72 	svcpl	0x00636f72
    5348:	72746e65 	rsbsvc	r6, r4, #1616	; 0x650
    534c:	71640079 	smcvc	16393	; 0x4009
    5350:	74625f62 	strbtvc	r5, [r2], #-3938	; 0xfffff09e
    5354:	00656d69 	rsbeq	r6, r5, r9, ror #26
    5358:	495f524e 	ldmdbmi	pc, {r1, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
    535c:	5443414e 	strbpl	r4, [r3], #-334	; 0xfffffeb2
    5360:	5f455649 	svcpl	0x00455649
    5364:	4e4f4e41 	cdpmi	14, 4, cr4, cr15, cr1, {2}
    5368:	635f6500 	cmpvs	pc, #0, 10
    536c:	5f746573 	svcpl	0x00746573
    5370:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    5374:	72687400 	rsbvc	r7, r8, #0, 8
    5378:	5f646165 	svcpl	0x00646165
    537c:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    5380:	6c696b00 	stclvs	11, cr6, [r9], #-0
    5384:	62735f6c 	rsbsvs	r5, r3, #108, 30	; 0x1b0
    5388:	636c6600 	cmnvs	ip, #0, 12
    538c:	6f6c665f 	svcvs	0x006c665f
    5390:	4e006b63 	vmlsmi.f64	d6, d0, d19
    5394:	49445f52 	stmdbmi	r4, {r1, r4, r6, r8, r9, sl, fp, ip, lr}^
    5398:	45495452 	strbmi	r5, [r9, #-1106]	; 0xfffffbae
    539c:	726e0044 	rsbvc	r0, lr, #68	; 0x44
    53a0:	6361635f 	cmnvs	r1, #2080374785	; 0x7c000001
    53a4:	5f646568 	svcpl	0x00646568
    53a8:	656a626f 	strbvs	r6, [sl, #-623]!	; 0xfffffd91
    53ac:	00737463 	rsbseq	r7, r3, r3, ror #8
    53b0:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!	; 0xfffffe84
    53b4:	76007265 	strvc	r7, [r0], -r5, ror #4
    53b8:	74735f6d 	ldrbtvc	r5, [r3], #-3949	; 0xfffff093
    53bc:	00747261 	rsbseq	r7, r4, r1, ror #4
    53c0:	746f7571 	strbtvc	r7, [pc], #-1393	; 53c8 <.debug_str+0x53c8>
    53c4:	6c746361 	ldclvs	3, cr6, [r4], #-388	; 0xfffffe7c
    53c8:	73706f5f 	cmnvc	r0, #380	; 0x17c
    53cc:	72746300 	rsbsvc	r6, r4, #0, 6
    53d0:	6f6c5f6c 	svcvs	0x006c5f6c
    53d4:	61006b63 	tstvs	r0, r3, ror #22
    53d8:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
    53dc:	7571645f 	ldrbvc	r6, [r1, #-1119]!	; 0xfffffba1
    53e0:	6d00746f 	cfstrsvs	mvf7, [r0, #-444]	; 0xfffffe44
    53e4:	0070616d 	rsbseq	r6, r0, sp, ror #2
    53e8:	75716573 	ldrbvc	r6, [r1, #-1395]!	; 0xfffffa8d
    53ec:	65636e65 	strbvs	r6, [r3, #-3685]!	; 0xfffff19b
    53f0:	62716400 	rsbsvs	r6, r1, #0, 8
    53f4:	6f73625f 	svcvs	0x0073625f
    53f8:	696c7466 	stmdbvs	ip!, {r1, r2, r5, r6, sl, ip, sp, lr}^
    53fc:	0074696d 	rsbseq	r6, r4, sp, ror #18
    5400:	575f524e 	ldrbpl	r5, [pc, -lr, asr #4]
    5404:	45544952 	ldrbmi	r4, [r4, #-2386]	; 0xfffff6ae
    5408:	4b434142 	blmi	10d5918 <unflatten_and_copy_device_tree+0x10d4aa4>
    540c:	705f6900 	subsvc	r6, pc, r0, lsl #18
    5410:	61766972 	cmnvs	r6, r2, ror r9
    5414:	64006574 	strvs	r6, [r0], #-1396	; 0xfffffa8c
    5418:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e
    541c:	74735f72 	ldrbtvc	r5, [r3], #-3954	; 0xfffff08e
    5420:	00657461 	rsbeq	r7, r5, r1, ror #8
    5424:	69736f70 	ldmdbvs	r3!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    5428:	69745f78 	ldmdbvs	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    542c:	7372656d 	cmnvc	r2, #457179136	; 0x1b400000
    5430:	6f727000 	svcvs	0x00727000
    5434:	74726570 	ldrbtvc	r6, [r2], #-1392	; 0xfffffa90
    5438:	5f660079 	svcpl	0x00660079
    543c:	00736f70 	rsbseq	r6, r3, r0, ror pc
    5440:	73696c68 	cmnvc	r9, #104, 24	; 0x6800
    5444:	6f6e5f74 	svcvs	0x006e5f74
    5448:	73006564 	movwvc	r6, #1380	; 0x564
    544c:	6f6c6769 	svcvs	0x006c6769
    5450:	6d006b63 	vstrvs	d6, [r0, #-396]	; 0xfffffe74
    5454:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    5458:	69735f00 	ldmdbvs	r3!, {r8, r9, sl, fp, ip, lr}^
    545c:	6c686367 	stclvs	3, cr6, [r8], #-412	; 0xfffffe64
    5460:	5f640064 	svcpl	0x00640064
    5464:	53006273 	movwpl	r6, #627	; 0x273
    5468:	52465f42 	subpl	r5, r6, #264	; 0x108
    546c:	455a4545 	ldrbmi	r4, [sl, #-1349]	; 0xfffffabb
    5470:	4952575f 	ldmdbmi	r2, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    5474:	74004554 	strvc	r4, [r0], #-1364	; 0xfffffaac
    5478:	645f7974 	ldrbvs	r7, [pc], #-2420	; 5480 <.debug_str+0x5480>
    547c:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e
    5480:	65720072 	ldrbvs	r0, [r2, #-114]!	; 0xffffff8e
    5484:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xfffff08c
    5488:	006b6361 	rsbeq	r6, fp, r1, ror #6
    548c:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    5490:	6e696200 	cdpvs	2, 6, cr6, cr9, cr0, {0}
    5494:	67700064 	ldrbvs	r0, [r0, -r4, rrx]!
    5498:	75007072 	strvc	r7, [r0, #-114]	; 0xffffff8e
    549c:	616c666e 	cmnvs	ip, lr, ror #12
    54a0:	6e657474 	mcrvs	4, 3, r7, cr5, cr4, {3}
    54a4:	5f74645f 	svcpl	0x0074645f
    54a8:	6f6c6c61 	svcvs	0x006c6c61
    54ac:	41420063 	cmpmi	r2, r3, rrx
    54b0:	4f4f4c4c 	svcmi	0x004f4c4c
    54b4:	4e495f4e 	cdpmi	15, 4, cr5, cr9, cr14, {2}
    54b8:	54414c46 	strbpl	r4, [r1], #-3142	; 0xfffff3ba
    54bc:	6d6d0045 	stclvs	0, cr0, [sp, #-276]!	; 0xfffffeec
    54c0:	6573755f 	ldrbvs	r7, [r3, #-1375]!	; 0xfffffaa1
    54c4:	5f007372 	svcpl	0x00007372
    54c8:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    54cc:	62736c5f 	rsbsvs	r6, r3, #24320	; 0x5f00
    54d0:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
    54d4:	006c6176 	rsbeq	r6, ip, r6, ror r1
    54d8:	626d656d 	rsbvs	r6, sp, #457179136	; 0x1b400000
    54dc:	6b636f6c 	blvs	18e1294 <unflatten_and_copy_device_tree+0x18e0420>
    54e0:	6265645f 	rsbvs	r6, r5, #1593835520	; 0x5f000000
    54e4:	76006775 			; <UNDEFINED> instruction: 0x76006775
    54e8:	746e7572 	strbtvc	r7, [lr], #-1394	; 0xfffffa8e
    54ec:	00656d69 	rsbeq	r6, r5, r9, ror #26
    54f0:	6c696863 	stclvs	8, cr6, [r9], #-396	; 0xfffffe74
    54f4:	75735f64 	ldrbvc	r5, [r3, #-3940]!	; 0xfffff09c
    54f8:	73797362 	cmnvc	r9, #-2013265919	; 0x88000001
    54fc:	73616d5f 	cmnvc	r1, #6080	; 0x17c0
    5500:	735f006b 	cmpvc	pc, #107	; 0x6b
    5504:	61637379 	smcvs	14137	; 0x3739
    5508:	65006c6c 	strvs	r6, [r0, #-3180]	; 0xfffff394
    550c:	796c7261 	stmdbvc	ip!, {r0, r5, r6, r9, ip, sp, lr}^
    5510:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    5514:	64665f74 	strbtvs	r5, [r6], #-3956	; 0xfffff08c
    5518:	63735f74 	cmnvs	r3, #116, 30	; 0x1d0
    551c:	725f6e61 	subsvc	r6, pc, #1552	; 0x610
    5520:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
    5524:	5f646576 	svcpl	0x00646576
    5528:	006d656d 	rsbeq	r6, sp, sp, ror #10
    552c:	6d69746b 	cfstrdvs	mvd7, [r9, #-428]!	; 0xfffffe54
    5530:	61650065 	cmnvs	r5, r5, rrx
    5534:	5f796c72 	svcpl	0x00796c72
    5538:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xfffff197
    553c:	5f74645f 	svcpl	0x0074645f
    5540:	6e616373 	mcrvs	3, 3, r6, cr1, cr3, {3}
    5544:	6f6f725f 	svcvs	0x006f725f
    5548:	61630074 	smcvs	12292	; 0x3004
    554c:	6f665f6e 	svcvs	0x00665f6e
    5550:	70006b72 	andvc	r6, r0, r2, ror fp
    5554:	62656761 	rsbvs	r6, r5, #25427968	; 0x1840000
    5558:	6b636f6c 	blvs	18e1310 <unflatten_and_copy_device_tree+0x18e049c>
    555c:	616c665f 	cmnvs	ip, pc, asr r6
    5560:	64007367 	strvs	r7, [r0], #-871	; 0xfffffc99
    5564:	666f5f71 	uqsub16vs	r5, pc, r1	; <UNPREDICTABLE>
    5568:	746f0066 	strbtvc	r0, [pc], #-102	; 5570 <.debug_str+0x5570>
    556c:	00726568 	rsbseq	r6, r2, r8, ror #10
    5570:	61757063 	cmnvs	r5, r3, rrx
    5574:	5f746363 	svcpl	0x00746363
    5578:	70726763 	rsbsvc	r6, r2, r3, ror #14
    557c:	0064695f 	rsbeq	r6, r4, pc, asr r9
    5580:	5f465144 	svcpl	0x00465144
    5584:	544f4f52 	strbpl	r4, [pc], #-3922	; 558c <.debug_str+0x558c>
    5588:	5551535f 	ldrbpl	r5, [r1, #-863]	; 0xfffffca1
    558c:	5f485341 	svcpl	0x00485341
    5590:	6e690042 	cdpvs	0, 6, cr0, cr9, cr2, {2}
    5594:	00657375 	rsbeq	r7, r5, r5, ror r3
    5598:	626d656d 	rsbvs	r6, sp, #457179136	; 0x1b400000
    559c:	6b636f6c 	blvs	18e1354 <unflatten_and_copy_device_tree+0x18e04e0>
    55a0:	6d65725f 	sfmvs	f7, 2, [r5, #-380]!	; 0xfffffe84
    55a4:	0065766f 	rsbeq	r7, r5, pc, ror #12
    55a8:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    55ac:	69007070 	stmdbvs	r0, {r4, r5, r6, ip, sp, lr}
    55b0:	74615f61 	strbtvc	r5, [r1], #-3937	; 0xfffff09f
    55b4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    55b8:	33746466 	cmncc	r4, #1711276032	; 0x66000000
    55bc:	00745f32 	rsbseq	r5, r4, r2, lsr pc
    55c0:	74726964 	ldrbtvc	r6, [r2], #-2404	; 0xfffff69c
    55c4:	61705f79 	cmnvs	r0, r9, ror pc
    55c8:	64657375 	strbtvs	r7, [r5], #-885	; 0xfffffc8b
    55cc:	6568775f 	strbvs	r7, [r8, #-1887]!	; 0xfffff8a1
    55d0:	6568006e 	strbvs	r0, [r8, #-110]!	; 0xffffff92
    55d4:	73006461 	movwvc	r6, #1121	; 0x461
    55d8:	72756365 	rsbsvc	r6, r5, #-1811939327	; 0x94000001
    55dc:	74696265 	strbtvc	r6, [r9], #-613	; 0xfffffd9b
    55e0:	69700073 	ldmdbvs	r0!, {r0, r1, r4, r5, r6}^
    55e4:	00745f64 	rsbseq	r5, r4, r4, ror #30
    55e8:	6d696c72 	stclvs	12, cr6, [r9, #-456]!	; 0xfffffe38
    55ec:	6f687300 	svcvs	0x00687300
    55f0:	706f5f77 	rsbvc	r5, pc, r7, ror pc	; <UNPREDICTABLE>
    55f4:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    55f8:	6f6c0073 	svcvs	0x006c0073
    55fc:	6c20676e 	stcvs	7, cr6, [r0], #-440	; 0xfffffe48
    5600:	20676e6f 	rsbcs	r6, r7, pc, ror #28
    5604:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
    5608:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xfffff199
    560c:	746e6920 	strbtvc	r6, [lr], #-2336	; 0xfffff6e0
    5610:	49475000 	stmdbmi	r7, {ip, lr}^
    5614:	45444f4e 	strbmi	r4, [r4, #-3918]	; 0xfffff0b2
    5618:	41455453 	cmpmi	r5, r3, asr r4
    561c:	6765004c 	strbvs	r0, [r5, -ip, asr #32]!
    5620:	5f006469 	svcpl	0x00006469
    5624:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    5628:	5f6c656e 	svcpl	0x006c656e
    562c:	33646975 	cmncc	r4, #1916928	; 0x1d4000
    5630:	00745f32 	rsbseq	r5, r4, r2, lsr pc
    5634:	70735f64 	rsbsvc	r5, r3, r4, ror #30
    5638:	6f735f63 	svcvs	0x00735f63
    563c:	696c7466 	stmdbvs	ip!, {r1, r2, r5, r6, sl, ip, sp, lr}^
    5640:	0074696d 	rsbseq	r6, r4, sp, ror #18
    5644:	65706970 	ldrbvs	r6, [r0, #-2416]!	; 0xfffff690
    5648:	6675625f 			; <UNDEFINED> instruction: 0x6675625f
    564c:	47500073 			; <UNDEFINED> instruction: 0x47500073
    5650:	41544f52 	cmpmi	r4, r2, asr pc
    5654:	00444554 	subeq	r4, r4, r4, asr r5
    5658:	5f727464 	svcpl	0x00727464
    565c:	00737472 	rsbseq	r7, r3, r2, ror r4
    5660:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    5664:	6261745f 	rsbvs	r7, r1, #1593835520	; 0x5f000000
    5668:	6600656c 	strvs	r6, [r0], -ip, ror #10
    566c:	646c6c69 	strbtvs	r6, [ip], #-3177	; 0xfffff397
    5670:	745f7269 	ldrbvc	r7, [pc], #-617	; 5678 <.debug_str+0x5678>
    5674:	62656400 	rsbvs	r6, r5, #0, 8
    5678:	6c5f6775 	mrrcvs	7, 7, r6, pc, cr5	; <UNPREDICTABLE>
    567c:	736b636f 	cmnvc	fp, #-1140850687	; 0xbc000001
    5680:	61657200 	cmnvs	r5, r0, lsl #4
    5684:	61705f6c 	cmnvs	r0, ip, ror #30
    5688:	746e6572 	strbtvc	r6, [lr], #-1394	; 0xfffffa8e
    568c:	414c5300 	mrsmi	r5, SPSR_mon
    5690:	535f5342 	cmppl	pc, #134217729	; 0x8000001
    5694:	4e4e4143 	dvfmiem	f4, f6, f3
    5698:	55004445 	strpl	r4, [r0, #-1093]	; 0xfffffbbb
    569c:	4b534154 	blmi	14d5bf4 <unflatten_and_copy_device_tree+0x14d4d80>
    56a0:	5453535f 	ldrbpl	r5, [r3], #-863	; 0xfffffca1
    56a4:	415f5045 	cmpmi	pc, r5, asr #32
    56a8:	71004b43 	tstvc	r0, r3, asr #22
    56ac:	79745f63 	ldmdbvc	r4!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    56b0:	735f6570 	cmpvc	pc, #112, 10	; 0x1c000000
    56b4:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    56b8:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
    56bc:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xfffff08c
    56c0:	00747261 	rsbseq	r7, r4, r1, ror #4
    56c4:	665f6166 	ldrbvs	r6, [pc], -r6, ror #2
    56c8:	00656c69 	rsbeq	r6, r5, r9, ror #24
    56cc:	636d656d 	cmnvs	sp, #457179136	; 0x1b400000
    56d0:	6d6b5f67 	stclvs	15, cr5, [fp, #-412]!	; 0xfffffe64
    56d4:	735f6d65 	cmpvc	pc, #6464	; 0x1940
    56d8:	5f70696b 	svcpl	0x0070696b
    56dc:	6f636361 	svcvs	0x00636361
    56e0:	00746e75 	rsbseq	r6, r4, r5, ror lr
    56e4:	6e5f6d6c 	cdpvs	13, 5, cr6, cr15, cr12, {3}
    56e8:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
    56ec:	6f6c0079 	svcvs	0x006c0079
    56f0:	64656b63 	strbtvs	r6, [r5], #-2915	; 0xfffff49d
    56f4:	006d765f 	rsbeq	r7, sp, pc, asr r6
    56f8:	5f645f73 	svcpl	0x00645f73
    56fc:	6800706f 	stmdavs	r0, {r0, r1, r2, r3, r5, r6, ip, sp, lr}
    5700:	5f676e61 	svcpl	0x00676e61
    5704:	65746564 	ldrbvs	r6, [r4, #-1380]!	; 0xfffffa9c
    5708:	64657463 	strbtvs	r7, [r5], #-1123	; 0xfffffb9d
    570c:	72747300 	rsbsvc	r7, r4, #0, 6
    5710:	72686372 	rsbvc	r6, r8, #-939524095	; 0xc8000001
    5714:	705f5f00 	subsvc	r5, pc, r0, lsl #30
    5718:	68705f76 	ldmdavs	r0!, {r1, r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    571c:	705f7379 	subsvc	r7, pc, r9, ror r3	; <UNPREDICTABLE>
    5720:	6f5f6e66 	svcvs	0x005f6e66
    5724:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    5728:	65700074 	ldrbvs	r0, [r0, #-116]!	; 0xffffff8c
    572c:	735f6672 	cmpvc	pc, #119537664	; 0x7200000
    5730:	6f635f77 	svcvs	0x00635f77
    5734:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    5738:	656d0074 	strbvs	r0, [sp, #-116]!	; 0xffffff8c
    573c:	6f6c626d 	svcvs	0x006c626d
    5740:	725f6b63 	subsvc	r6, pc, #101376	; 0x18c00
    5744:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
    5748:	5f006576 	svcpl	0x00006576
    574c:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    5750:	75715f74 	ldrbvc	r5, [r1, #-3956]!	; 0xfffff08c
    5754:	5f657565 	svcpl	0x00657565
    5758:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    575c:	6d5f6900 	ldclvs	9, cr6, [pc, #-0]	; 5764 <.debug_str+0x5764>
    5760:	5f70616d 	svcpl	0x0070616d
    5764:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    5768:	656c6261 	strbvs	r6, [ip, #-609]!	; 0xfffffd9f
    576c:	6a657200 	bvs	1961f74 <unflatten_and_copy_device_tree+0x1961100>
    5770:	5f746365 	svcpl	0x00746365
    5774:	6f727265 	svcvs	0x00727265
    5778:	67630072 			; <UNDEFINED> instruction: 0x67630072
    577c:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    5780:	6f6f725f 	svcvs	0x006f725f
    5784:	696d0074 	stmdbvs	sp!, {r2, r4, r5, r6}^
    5788:	74617267 	strbtvc	r7, [r1], #-615	; 0xfffffd99
    578c:	5f6e6f69 	svcpl	0x006e6f69
    5790:	62616e65 	rsbvs	r6, r1, #1616	; 0x650
    5794:	0064656c 	rsbeq	r6, r4, ip, ror #10
    5798:	5f73666e 	svcpl	0x0073666e
    579c:	73006c66 	movwvc	r6, #3174	; 0xc66
    57a0:	6e65645f 	mcrvs	4, 3, r6, cr5, cr15, {2}
    57a4:	5f797274 	svcpl	0x00797274
    57a8:	0075726c 	rsbseq	r7, r5, ip, ror #4
    57ac:	68705f5f 	ldmdavs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}^
    57b0:	745f7379 	ldrbvc	r7, [pc], #-889	; 57b8 <.debug_str+0x57b8>
    57b4:	69765f6f 	ldmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    57b8:	74007472 	strvc	r7, [r0], #-1138	; 0xfffffb8e
    57bc:	6d636f69 	stclvs	15, cr6, [r3, #-420]!	; 0xfffffe5c
    57c0:	00746573 	rsbseq	r6, r4, r3, ror r5
    57c4:	6e726177 	mrcvs	1, 3, r6, cr2, cr7, {3}
    57c8:	625f6465 	subsvs	r6, pc, #1694498816	; 0x65000000
    57cc:	656b6f72 	strbvs	r6, [fp, #-3954]!	; 0xfffff08e
    57d0:	69685f6e 	stmdbvs	r8!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    57d4:	72617265 	rsbvc	r7, r1, #1342177286	; 0x50000006
    57d8:	00796863 	rsbseq	r6, r9, r3, ror #16
    57dc:	4c5f524e 	lfmmi	f5, 2, [pc], {78}	; 0x4e
    57e0:	4c5f5552 	cfldr64mi	mvdx5, [pc], {82}	; 0x52
    57e4:	53545349 	cmppl	r4, #603979777	; 0x24000001
    57e8:	625f7300 	subsvs	r7, pc, #0, 6
    57ec:	00766564 	rsbseq	r6, r6, r4, ror #10
    57f0:	735f7472 	cmpvc	pc, #1912602624	; 0x72000000
    57f4:	775f6370 			; <UNDEFINED> instruction: 0x775f6370
    57f8:	6c6e7261 	sfmvs	f7, 2, [lr], #-388	; 0xfffffe7c
    57fc:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
    5800:	635f7800 	cmpvs	pc, #0, 16
    5804:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    5808:	776f6300 	strbvc	r6, [pc, -r0, lsl #6]!
    580c:	6761705f 			; <UNDEFINED> instruction: 0x6761705f
    5810:	645f0065 	ldrbvs	r0, [pc], #-101	; 5818 <.debug_str+0x5818>
    5814:	64695f6f 	strbtvs	r5, [r9], #-3951	; 0xfffff091
    5818:	6400656c 	strvs	r6, [r0], #-1388	; 0xfffffa94
    581c:	68747065 	ldmdavs	r4!, {r0, r2, r5, r6, ip, sp, lr}^
    5820:	755f7300 	ldrbvc	r7, [pc, #-768]	; 5528 <.debug_str+0x5528>
    5824:	00646975 	rsbeq	r6, r4, r5, ror r9
    5828:	665f6166 	ldrbvs	r6, [pc], -r6, ror #2
    582c:	6d760064 	ldclvs	0, cr0, [r6, #-400]!	; 0xfffffe70
    5830:	6576655f 	ldrbvs	r6, [r6, #-1375]!	; 0xfffffaa1
    5834:	735f746e 	cmpvc	pc, #1845493760	; 0x6e000000
    5838:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    583c:	6c5f6300 	mrrcvs	3, 0, r6, pc, cr0	; <UNPREDICTABLE>
    5840:	00656e69 	rsbeq	r6, r5, r9, ror #28
    5844:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xfffff08d
    5848:	5f717269 	svcpl	0x00717269
    584c:	61736964 	cmnvs	r3, r4, ror #18
    5850:	5f656c62 	svcpl	0x00656c62
    5854:	6b007069 	blvs	21a00 <unflatten_and_copy_device_tree+0x20b8c>
    5858:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    585c:	61635f6c 	cmnvs	r3, ip, ror #30
    5860:	00745f70 	rsbseq	r5, r4, r0, ror pc
    5864:	69735f69 	ldmdbvs	r3!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    5868:	6400657a 	strvs	r6, [r0], #-1402	; 0xfffffa86
    586c:	6f6e695f 	svcvs	0x006e695f
    5870:	756f635f 	strbvc	r6, [pc, #-863]!	; 5519 <.debug_str+0x5519>
    5874:	6e00746e 	cdpvs	4, 0, cr7, cr0, cr14, {3}
    5878:	61685f72 	smcvs	34290	; 0x85f2
    587c:	0073676e 	rsbseq	r6, r3, lr, ror #14
    5880:	72726163 	rsbsvc	r6, r2, #-1073741800	; 0xc0000018
    5884:	5f726569 	svcpl	0x00726569
    5888:	73696172 	cmnvc	r9, #-2147483620	; 0x8000001c
    588c:	77006465 	strvc	r6, [r0, -r5, ror #8]
    5890:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0xfffff68e
    5894:	746e635f 	strbtvc	r6, [lr], #-863	; 0xfffffca1
    5898:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    589c:	6971645f 	ldmdbvs	r1!, {r0, r1, r2, r3, r4, r6, sl, sp, lr}^
    58a0:	006f666e 	rsbeq	r6, pc, lr, ror #12
    58a4:	66666f70 	uqsub16vs	r6, r6, r0
    58a8:	00746573 	rsbseq	r6, r4, r3, ror r5
    58ac:	6e697073 	mcrvs	0, 3, r7, cr9, cr3, {3}
    58b0:	6b636f6c 	blvs	18e1668 <unflatten_and_copy_device_tree+0x18e07f4>
    58b4:	6e00745f 	cfmvsrvs	mvf0, r7
    58b8:	5f65646f 	svcpl	0x0065646f
    58bc:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    58c0:	55524c00 	ldrbpl	r4, [r2, #-3072]	; 0xfffff400
    58c4:	5443415f 	strbpl	r4, [r3], #-351	; 0xfffffea1
    58c8:	5f455649 	svcpl	0x00455649
    58cc:	454c4946 	strbmi	r4, [ip, #-2374]	; 0xfffff6ba
    58d0:	69786500 	ldmdbvs	r8!, {r8, sl, sp, lr}^
    58d4:	69735f74 	ldmdbvs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    58d8:	6c616e67 	stclvs	14, cr6, [r1], #-412	; 0xfffffe64
    58dc:	67696800 	strbvs	r6, [r9, -r0, lsl #16]!
    58e0:	656d5f68 	strbvs	r5, [sp, #-3944]!	; 0xfffff098
    58e4:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    58e8:	626f7000 	rsbvs	r7, pc, #0
    58ec:	7463656a 	strbtvc	r6, [r3], #-1386	; 0xfffffa96
    58f0:	65720073 	ldrbvs	r0, [r2, #-115]!	; 0xffffff8d
    58f4:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000
    58f8:	67615f65 	strbvs	r5, [r1, -r5, ror #30]!
    58fc:	5f746e65 	svcpl	0x00746e65
    5900:	6b726f77 	blvs	1ca16e4 <unflatten_and_copy_device_tree+0x1ca0870>
    5904:	72687300 	rsbvc	r7, r8, #0, 6
    5908:	656b6e69 	strbvs	r6, [fp, #-3689]!	; 0xfffff197
    590c:	65720072 	ldrbvs	r0, [r2, #-114]!	; 0xffffff8e
    5910:	746e6366 	strbtvc	r6, [lr], #-870	; 0xfffffc9a
    5914:	626f6b00 	rsbvs	r6, pc, #0, 22
    5918:	7463656a 	strbtvc	r6, [r3], #-1386	; 0xfffffa96
    591c:	6d5f6900 	ldclvs	9, cr6, [pc, #-0]	; 5924 <.debug_str+0x5924>
    5920:	69707061 	ldmdbvs	r0!, {r0, r5, r6, ip, sp, lr}^
    5924:	7400676e 	strvc	r6, [r0], #-1902	; 0xfffff892
    5928:	00737974 	rsbseq	r7, r3, r4, ror r9
    592c:	5f646e65 	svcpl	0x00646e65
    5930:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xfffff09d
    5934:	5f737700 	svcpl	0x00737700
    5938:	78697079 	stmdavc	r9!, {r0, r3, r4, r5, r6, ip, sp, lr}^
    593c:	67006c65 	strvs	r6, [r0, -r5, ror #24]
    5940:	745f7066 	ldrbvc	r7, [pc], #-102	; 5948 <.debug_str+0x5948>
    5944:	626f6b00 	rsbvs	r6, pc, #0, 22
    5948:	79745f6a 	ldmdbvc	r4!, {r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    594c:	64006570 	strvs	r6, [r0], #-1392	; 0xfffffa90
    5950:	69747269 	ldmdbvs	r4!, {r0, r3, r5, r6, r9, ip, sp, lr}^
    5954:	775f6465 	ldrbvc	r6, [pc, -r5, ror #8]
    5958:	006e6568 	rsbeq	r6, lr, r8, ror #10
    595c:	5f6e7572 	svcpl	0x006e7572
    5960:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    5964:	67726100 	ldrbvs	r6, [r2, -r0, lsl #2]!
    5968:	6c660076 	stclvs	0, cr0, [r6], #-472	; 0xfffffe28
    596c:	00736761 	rsbseq	r6, r3, r1, ror #14
    5970:	64657375 	strbtvs	r7, [r5], #-885	; 0xfffffc8b
    5974:	6e696200 	cdpvs	2, 6, cr6, cr9, cr0, {0}
    5978:	00746d66 	rsbseq	r6, r4, r6, ror #26
    597c:	626d656d 	rsbvs	r6, sp, #457179136	; 0x1b400000
    5980:	6b636f6c 	blvs	18e1738 <unflatten_and_copy_device_tree+0x18e08c4>
    5984:	6c6c615f 	stfvse	f6, [ip], #-380	; 0xfffffe84
    5988:	6b00636f 	blvs	1e74c <unflatten_and_copy_device_tree+0x1d8d8>
    598c:	735f7965 	cmpvc	pc, #1654784	; 0x194000
    5990:	61697265 	cmnvs	r9, r5, ror #4
    5994:	00745f6c 	rsbseq	r5, r4, ip, ror #30
    5998:	5f716573 	svcpl	0x00716573
    599c:	706f7473 	rsbvc	r7, pc, r3, ror r4	; <UNPREDICTABLE>
    59a0:	65737500 	ldrbvs	r7, [r3, #-1280]!	; 0xfffffb00
    59a4:	656c0072 	strbvs	r0, [ip, #-114]!	; 0xffffff8e
    59a8:	72656461 	rsbvc	r6, r5, #1627389952	; 0x61000000
    59ac:	5f524e00 	svcpl	0x00524e00
    59b0:	435f4d4d 	cmpmi	pc, #4928	; 0x1340
    59b4:	544e554f 	strbpl	r5, [lr], #-1359	; 0xfffffab1
    59b8:	00535245 	subseq	r5, r3, r5, asr #4
    59bc:	73696c68 	cmnvc	r9, #104, 24	; 0x6800
    59c0:	6c625f74 	stclvs	15, cr5, [r2], #-464	; 0xfffffe30
    59c4:	6165685f 	cmnvs	r5, pc, asr r8
    59c8:	72700064 	rsbsvc	r0, r0, #100	; 0x64
    59cc:	6c6c6165 	stfvse	f6, [ip], #-404	; 0xfffffe6c
    59d0:	625f636f 	subsvs	r6, pc, #-1140850687	; 0xbc000001
    59d4:	5f006675 	svcpl	0x00006675
    59d8:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    59dc:	5f6c656e 	svcpl	0x006c656e
    59e0:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
    59e4:	7300745f 	movwvc	r7, #1119	; 0x45f
    59e8:	6c6e6970 	stclvs	9, cr6, [lr], #-448	; 0xfffffe40
    59ec:	006b636f 	rsbeq	r6, fp, pc, ror #6
    59f0:	6c6c6166 	stfvse	f6, [ip], #-408	; 0xfffffe68
    59f4:	7461636f 	strbtvc	r6, [r1], #-879	; 0xfffffc91
    59f8:	73660065 	cmnvc	r6, #101	; 0x65
    59fc:	00646975 	rsbeq	r6, r4, r5, ror r9
    5a00:	5f6d6f6f 	svcpl	0x006d6f6f
    5a04:	726f6373 	rsbvc	r6, pc, #-872415231	; 0xcc000001
    5a08:	64615f65 	strbtvs	r5, [r1], #-3941	; 0xfffff09b
    5a0c:	7164006a 	cmnvc	r4, sl, rrx
    5a10:	74695f62 	strbtvc	r5, [r9], #-3938	; 0xfffff09e
    5a14:	00656d69 	rsbeq	r6, r5, r9, ror #26
    5a18:	63616d76 	cmnvs	r1, #7552	; 0x1d80
    5a1c:	65686361 	strbvs	r6, [r8, #-865]!	; 0xfffffc9f
    5a20:	7165735f 	cmnvc	r5, pc, asr r3
    5a24:	006d756e 	rsbeq	r7, sp, lr, ror #10
    5a28:	5247494d 	subpl	r4, r7, #1261568	; 0x134000
    5a2c:	5f455441 	svcpl	0x00455441
    5a30:	434e5953 	movtmi	r5, #59731	; 0xe953
    5a34:	47494c5f 	smlsldmi	r4, r9, pc, ip	; <UNPREDICTABLE>
    5a38:	63005448 	movwvs	r5, #1096	; 0x448
    5a3c:	616d7570 	smcvs	55120	; 0xd750
    5a40:	5f006b73 	svcpl	0x00006b73
    5a44:	72656b5f 	rsbvc	r6, r5, #97280	; 0x17c00
    5a48:	5f6c656e 	svcpl	0x006c656e
    5a4c:	7a697373 	bvc	1a62820 <unflatten_and_copy_device_tree+0x1a619ac>
    5a50:	00745f65 	rsbseq	r5, r4, r5, ror #30
    5a54:	5f746466 	svcpl	0x00746466
    5a58:	70746567 	rsbsvc	r6, r4, r7, ror #10
    5a5c:	5f706f72 	svcpl	0x00706f72
    5a60:	6f5f7962 	svcvs	0x005f7962
    5a64:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    5a68:	65740074 	ldrbvs	r0, [r4, #-116]!	; 0xffffff8c
    5a6c:	6f696d72 	svcvs	0x00696d72
    5a70:	65740073 	ldrbvs	r0, [r4, #-115]!	; 0xffffff8d
    5a74:	6f696d72 	svcvs	0x00696d72
    5a78:	5f5f0078 	svcpl	0x005f0078
    5a7c:	00323373 	eorseq	r3, r2, r3, ror r3
    5a80:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    5a84:	74735f6b 	ldrbtvc	r5, [r3], #-3947	; 0xfffff095
    5a88:	00747261 	rsbseq	r7, r4, r1, ror #4
    5a8c:	72616863 	rsbvc	r6, r1, #6488064	; 0x630000
    5a90:	6f696b00 	svcvs	0x00696b00
    5a94:	5f787463 	svcpl	0x00787463
    5a98:	6c626174 	stfvse	f6, [r2], #-464	; 0xfffffe30
    5a9c:	71640065 	cmnvc	r4, r5, rrx
    5aa0:	6572665f 	ldrbvs	r6, [r2, #-1631]!	; 0xfffff9a1
    5aa4:	74640065 	strbtvc	r0, [r4], #-101	; 0xffffff9b
    5aa8:	6f6f725f 	svcvs	0x006f725f
    5aac:	75730074 	ldrbvc	r0, [r3, #-116]!	; 0xffffff8c
    5ab0:	78655f6d 	stmdavc	r5!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    5ab4:	725f6365 	subsvc	r6, pc, #-1811939327	; 0x94000001
    5ab8:	69746e75 	ldmdbvs	r4!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
    5abc:	6e00656d 	cfsh32vs	mvfx6, mvfx0, #61
    5ac0:	61775f72 	cmnvs	r7, r2, ror pc
    5ac4:	7075656b 	rsbsvc	r6, r5, fp, ror #10
    5ac8:	696d5f73 	stmdbvs	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    5acc:	74617267 	strbtvc	r7, [r1], #-615	; 0xfffffd99
    5ad0:	5f640065 	svcpl	0x00640065
    5ad4:	5f637073 	svcpl	0x00637073
    5ad8:	6e726177 	mrcvs	1, 3, r6, cr2, cr7, {3}
    5adc:	72660073 	rsbvc	r0, r6, #115	; 0x73
    5ae0:	657a6565 	ldrbvs	r6, [sl, #-1381]!	; 0xfffffa9b
    5ae4:	0073665f 	rsbseq	r6, r3, pc, asr r6
    5ae8:	64646175 	strbtvs	r6, [r4], #-373	; 0xfffffe8b
    5aec:	71640072 	smcvc	16386	; 0x4002
    5af0:	6271645f 	rsbsvs	r6, r1, #1593835520	; 0x5f000000
    5af4:	41475000 	mrsmi	r5, (UNDEF: 71)
    5af8:	434f4c4c 	movtmi	r4, #64588	; 0xfc4c
    5afc:	4749485f 	smlsldmi	r4, r9, pc, r8	; <UNPREDICTABLE>
    5b00:	6d760048 	ldclvs	0, cr0, [r6, #-288]!	; 0xfffffee0
    5b04:	78656e5f 	stmdavc	r5!, {r0, r1, r2, r3, r4, r6, r9, sl, fp, sp, lr}^
    5b08:	6f630074 	svcvs	0x00630074
    5b0c:	756f706d 	strbvc	r7, [pc, #-109]!	; 5aa7 <.debug_str+0x5aa7>
    5b10:	685f646e 	ldmdavs	pc, {r1, r2, r3, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
    5b14:	00646165 	rsbeq	r6, r4, r5, ror #2
    5b18:	51505247 	cmppl	r0, r7, asr #4
    5b1c:	41544f55 	cmpmi	r4, r5, asr pc
    5b20:	54524800 	ldrbpl	r4, [r2], #-2048	; 0xfffff800
    5b24:	52454d49 	subpl	r4, r5, #4672	; 0x1240
    5b28:	524f4e5f 	subpl	r4, pc, #1520	; 0x5f0
    5b2c:	41545345 	cmpmi	r4, r5, asr #6
    5b30:	64005452 	strvs	r5, [r0], #-1106	; 0xfffffbae
    5b34:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0xfffff68e
    5b38:	61645f72 	smcvs	17906	; 0x45f2
    5b3c:	6d006174 	stfvss	f6, [r0, #-464]	; 0xfffffe30
    5b40:	73727861 	cmnvc	r2, #6356992	; 0x610000
    5b44:	6b6d0073 	blvs	1b45d18 <unflatten_and_copy_device_tree+0x1b44ea4>
    5b48:	00726964 	rsbseq	r6, r2, r4, ror #18
    5b4c:	64696773 	strbtvs	r6, [r9], #-1907	; 0xfffff88d
    5b50:	73797300 	cmnvc	r9, #0, 6
    5b54:	6c6c6163 	stfvse	f6, [ip], #-396	; 0xfffffe74
    5b58:	73706f5f 	cmnvc	r0, #380	; 0x17c
    5b5c:	76657200 	strbtvc	r7, [r5], -r0, lsl #4
    5b60:	64656b6f 	strbtvs	r6, [r5], #-2927	; 0xfffff491
    5b64:	0074615f 	rsbseq	r6, r4, pc, asr r1
    5b68:	70737573 	rsbsvc	r7, r3, r3, ror r5
    5b6c:	5f646e65 	svcpl	0x00646e65
    5b70:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    5b74:	69716400 	ldmdbvs	r1!, {sl, sp, lr}^
    5b78:	78616d5f 	stmdavc	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
    5b7c:	6f6e695f 	svcvs	0x006e695f
    5b80:	6d696c5f 	stclvs	12, cr6, [r9, #-380]!	; 0xfffffe84
    5b84:	70007469 	andvc	r7, r0, r9, ror #8
    5b88:	5f636f72 	svcpl	0x00636f72
    5b8c:	73706f66 	cmnvc	r0, #408	; 0x198
    5b90:	5f6d7600 	svcpl	0x006d7600
    5b94:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
    5b98:	6f697461 	svcvs	0x00697461
    5b9c:	735f736e 	cmpvc	pc, #-1207959551	; 0xb8000001
    5ba0:	63757274 	cmnvs	r5, #116, 4	; 0x40000007
    5ba4:	72630074 	rsbvc	r0, r3, #116	; 0x74
    5ba8:	5f323363 	svcpl	0x00323363
    5bac:	5f006562 	svcpl	0x00006562
    5bb0:	3365625f 	cmncc	r5, #-268435451	; 0xf0000005
    5bb4:	6f745f32 	svcvs	0x00745f32
    5bb8:	7570635f 	ldrbvc	r6, [r0, #-863]!	; 0xfffffca1
    5bbc:	68630070 	stmdavs	r3!, {r4, r5, r6}^
    5bc0:	5f737261 	svcpl	0x00737261
    5bc4:	625f6e69 	subsvs	r6, pc, #1680	; 0x690
    5bc8:	65666675 	strbvs	r6, [r6, #-1653]!	; 0xfffff98b
    5bcc:	74750072 	ldrbtvc	r0, [r5], #-114	; 0xffffff8e
    5bd0:	73656d69 	cmnvc	r5, #6720	; 0x1a40
    5bd4:	656c6163 	strbvs	r6, [ip, #-355]!	; 0xfffffe9d
    5bd8:	5f730064 	svcpl	0x00730064
    5bdc:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    5be0:	776f6c00 	strbvc	r6, [pc, -r0, lsl #24]!
    5be4:	74616c5f 	strbtvc	r6, [r1], #-3167	; 0xfffff3a1
    5be8:	79636e65 	stmdbvc	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    5bec:	61636400 	cmnvs	r3, r0, lsl #8
    5bf0:	5f656863 	svcpl	0x00656863
    5bf4:	61656c63 	cmnvs	r5, r3, ror #24
    5bf8:	72615f6e 	rsbvc	r5, r1, #440	; 0x1b8
    5bfc:	74006165 	strvc	r6, [r0], #-357	; 0xfffffe9b
    5c00:	5f6b7361 	svcpl	0x006b7361
    5c04:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0xfffffb8d
    5c08:	6e007463 	cdpvs	4, 0, cr7, cr0, cr3, {3}
    5c0c:	696d5f72 	stmdbvs	sp!, {r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    5c10:	74617267 	strbtvc	r7, [r1], #-615	; 0xfffffd99
    5c14:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    5c18:	6c6f635f 	stclvs	3, cr6, [pc], #-380	; 5aa4 <.debug_str+0x5aa4>
    5c1c:	43520064 	cmpmi	r2, #100	; 0x64
    5c20:	59535f55 	ldmdbpl	r3, {r0, r2, r4, r6, r8, r9, sl, fp, ip, lr}^
    5c24:	6600434e 	strvs	r4, [r0], -lr, asr #6
    5c28:	756f635f 	strbvc	r6, [pc, #-863]!	; 58d1 <.debug_str+0x58d1>
    5c2c:	6600746e 	strvs	r7, [r0], -lr, ror #8
    5c30:	6e797361 	cdpvs	3, 7, cr7, cr9, cr1, {3}
    5c34:	6d620063 	stclvs	0, cr0, [r2, #-396]!	; 0xfffffe74
    5c38:	43007061 	movwmi	r7, #97	; 0x61
    5c3c:	554f5247 	strbpl	r5, [pc, #-583]	; 59fd <.debug_str+0x59fd>
    5c40:	41435f50 	cmpmi	r3, r0, asr pc
    5c44:	524f464e 	subpl	r4, pc, #81788928	; 0x4e00000
    5c48:	4e455f4b 	cdpmi	15, 4, cr5, cr5, cr11, {2}
    5c4c:	6c630044 	stclvs	0, cr0, [r3], #-272	; 0xfffffef0
    5c50:	5f65736f 	svcpl	0x0065736f
    5c54:	616c6564 	cmnvs	ip, r4, ror #10
    5c58:	5f640079 	svcpl	0x00640079
    5c5c:	646f6e69 	strbtvs	r6, [pc], #-3689	; 5c64 <.debug_str+0x5c64>
    5c60:	6f660065 	svcvs	0x00660065
    5c64:	776f6c6c 	strbvc	r6, [pc, -ip, ror #24]!
    5c68:	6e696c5f 	mcrvs	12, 3, r6, cr9, cr15, {2}
    5c6c:	6466006b 	strbtvs	r0, [r6], #-107	; 0xffffff95
    5c70:	72745f74 	rsbsvc	r5, r4, #116, 30	; 0x1d0
    5c74:	6c736e61 	ldclvs	14, cr6, [r3], #-388	; 0xfffffe7c
    5c78:	5f657461 	svcpl	0x00657461
    5c7c:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    5c80:	00737365 	rsbseq	r7, r3, r5, ror #6
    5c84:	76646770 			; <UNDEFINED> instruction: 0x76646770
    5c88:	745f6c61 	ldrbvc	r6, [pc], #-3169	; 5c90 <.debug_str+0x5c90>
    5c8c:	50435000 	subpl	r5, r3, r0
    5c90:	43465f55 	movtmi	r5, #28501	; 0x6f55
    5c94:	4741505f 	smlsldmi	r5, r1, pc, r0	; <UNPREDICTABLE>
    5c98:	61770045 	cmnvs	r7, r5, asr #32
    5c9c:	715f656b 	cmpvc	pc, fp, ror #10
    5ca0:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 5ca8 <.debug_str+0x5ca8>
    5ca4:	61630065 	cmnvs	r3, r5, rrx
    5ca8:	74615f6e 	strbtvc	r5, [r1], #-3950	; 0xfffff092
    5cac:	68636174 	stmdavs	r3!, {r2, r4, r5, r6, r8, sp, lr}^
    5cb0:	5f6d7600 	svcpl	0x006d7600
    5cb4:	0073706f 	rsbseq	r7, r3, pc, rrx
    5cb8:	6769735f 			; <UNDEFINED> instruction: 0x6769735f
    5cbc:	00737973 	rsbseq	r7, r3, r3, ror r9
    5cc0:	665f6966 	ldrbvs	r6, [pc], -r6, ror #18
    5cc4:	7367616c 	cmnvc	r7, #108, 2
    5cc8:	75706300 	ldrbvc	r6, [r0, #-768]!	; 0xfffffd00
    5ccc:	6c615f73 	stclvs	15, cr5, [r1], #-460	; 0xfffffe34
    5cd0:	65776f6c 	ldrbvs	r6, [r7, #-3948]!	; 0xfffff094
    5cd4:	70630064 	rsbvc	r0, r3, r4, rrx
    5cd8:	6d697475 	cfstrdvs	mvd7, [r9, #-468]!	; 0xfffffe2c
    5cdc:	78655f65 	stmdavc	r5!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    5ce0:	65726970 	ldrbvs	r6, [r2, #-2416]!	; 0xfffff690
    5ce4:	74700073 	ldrbtvc	r0, [r0], #-115	; 0xffffff8d
    5ce8:	65636172 	strbvs	r6, [r3, #-370]!	; 0xfffffe8e
    5cec:	65720064 	ldrbvs	r0, [r2, #-100]!	; 0xffffff9c
    5cf0:	656d616e 	strbvs	r6, [sp, #-366]!	; 0xfffffe92
    5cf4:	69640032 	stmdbvs	r4!, {r1, r4, r5}^
    5cf8:	6f635f72 	svcvs	0x00635f72
    5cfc:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    5d00:	67630074 			; <UNDEFINED> instruction: 0x67630074
    5d04:	70756f72 	rsbsvc	r6, r5, r2, ror pc
    5d08:	6c69665f 	stclvs	6, cr6, [r9], #-380	; 0xfffffe84
    5d0c:	6f6f0065 	svcvs	0x006f0065
    5d10:	6c665f6d 	stclvs	15, cr5, [r6], #-436	; 0xfffffe4c
    5d14:	5f736761 	svcpl	0x00736761
    5d18:	5f640074 	svcpl	0x00640074
    5d1c:	74757069 	ldrbtvc	r7, [r5], #-105	; 0xffffff97
    5d20:	5f646200 	svcpl	0x00646200
    5d24:	65707573 	ldrbvs	r7, [r0, #-1395]!	; 0xfffffa8d
    5d28:	70630072 	rsbvc	r0, r3, r2, ror r0
    5d2c:	6d697475 	cfstrdvs	mvd7, [r9, #-468]!	; 0xfffffe2c
    5d30:	6b007265 	blvs	226cc <unflatten_and_copy_device_tree+0x21858>
    5d34:	69665f69 	stmdbvs	r6!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    5d38:	7200706c 	andvc	r7, r0, #108	; 0x6c
    5d3c:	5f746f6f 	svcpl	0x00746f6f
    5d40:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    5d44:	74007465 	strvc	r7, [r0], #-1125	; 0xfffffb9b
    5d48:	5f6b7361 	svcpl	0x006b7361
    5d4c:	756f7267 	strbvc	r7, [pc, #-615]!	; 5aed <.debug_str+0x5aed>
    5d50:	6c630070 	stclvs	0, cr0, [r3], #-448	; 0xfffffe40
    5d54:	696b636f 	stmdbvs	fp!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    5d58:	73720064 	cmnvc	r2, #100	; 0x64
    5d5c:	74735f73 	ldrbtvc	r5, [r3], #-3955	; 0xfffff08d
    5d60:	73007461 	movwvc	r7, #1121	; 0x461
    5d64:	65726168 	ldrbvs	r6, [r2, #-360]!	; 0xfffffe98
    5d68:	65705f64 	ldrbvs	r5, [r0, #-3940]!	; 0xfffff09c
    5d6c:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    5d70:	6f6e0067 	svcvs	0x006e0067
    5d74:	705f6564 	subsvc	r6, pc, r4, ror #10
    5d78:	65736572 	ldrbvs	r6, [r3, #-1394]!	; 0xfffffa8e
    5d7c:	705f746e 	subsvc	r7, pc, lr, ror #8
    5d80:	73656761 	cmnvc	r5, #25427968	; 0x1840000
    5d84:	745f6400 	ldrbvc	r6, [pc], #-1024	; 5d8c <.debug_str+0x5d8c>
    5d88:	00656d69 	rsbeq	r6, r5, r9, ror #26
    5d8c:	725f666b 	subsvc	r6, pc, #112197632	; 0x6b00000
    5d90:	00746f6f 	rsbseq	r6, r4, pc, ror #30
    5d94:	65645f64 	strbvs	r5, [r4, #-3940]!	; 0xfffff09c
    5d98:	6574656c 	ldrbvs	r6, [r4, #-1388]!	; 0xfffffa94
    5d9c:	5f676d00 	svcpl	0x00676d00
    5da0:	5f747364 	svcpl	0x00747364
    5da4:	74657363 	strbtvc	r7, [r5], #-867	; 0xfffffc9d
    5da8:	6b5f5f00 	blvs	17dd9b0 <unflatten_and_copy_device_tree+0x17dcb3c>
    5dac:	656e7265 	strbvs	r7, [lr, #-613]!	; 0xfffffd9b
    5db0:	6c755f6c 	ldclvs	15, cr5, [r5], #-432	; 0xfffffe50
    5db4:	5f676e6f 	svcpl	0x00676e6f
    5db8:	64660074 	strbtvs	r0, [r6], #-116	; 0xffffff8c
    5dbc:	65675f74 	strbvs	r5, [r7, #-3956]!	; 0xfffff08c
    5dc0:	656d5f74 	strbvs	r5, [sp, #-3956]!	; 0xfffff08c
    5dc4:	73725f6d 	cmnvc	r2, #436	; 0x1b4
    5dc8:	61640076 	smcvs	16390	; 0x4006
    5dcc:	73006174 	movwvc	r6, #372	; 0x174
    5dd0:	5f73665f 	svcpl	0x0073665f
    5dd4:	6f666e69 	svcvs	0x00666e69
    5dd8:	6f727000 	svcvs	0x00727000
    5ddc:	5f64696a 	svcpl	0x0064696a
    5de0:	75710074 	ldrbvc	r0, [r1, #-116]!	; 0xffffff8c
    5de4:	5f61746f 	svcpl	0x0061746f
    5de8:	61736964 	cmnvs	r3, r4, ror #18
    5dec:	00656c62 	rsbeq	r6, r5, r2, ror #24
    5df0:	6d617266 	sfmvs	f7, 2, [r1, #-408]!	; 0xfffffe68
    5df4:	69620065 	stmdbvs	r2!, {r0, r2, r5, r6}^
    5df8:	70616d74 	rsbvc	r6, r1, r4, ror sp
    5dfc:	73666e00 	cmnvc	r6, #0, 28
    5e00:	6f6c5f34 	svcvs	0x006c5f34
    5e04:	695f6b63 	ldmdbvs	pc, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^	; <UNPREDICTABLE>
    5e08:	006f666e 	rsbeq	r6, pc, lr, ror #12
    5e0c:	73665f69 	cmnvc	r6, #420	; 0x1a4
    5e10:	69746f6e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    5e14:	6d5f7966 	ldclvs	9, cr7, [pc, #-408]	; 5c84 <.debug_str+0x5c84>
    5e18:	006b7361 	rsbeq	r7, fp, r1, ror #6
    5e1c:	74746178 	ldrbtvc	r6, [r4], #-376	; 0xfffffe88
    5e20:	61685f72 	smcvs	34290	; 0x85f2
    5e24:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0xfffffb92
    5e28:	706f0072 	rsbvc	r0, pc, r2, ror r0	; <UNPREDICTABLE>
    5e2c:	6b006e65 	blvs	217c8 <unflatten_and_copy_device_tree+0x20954>
    5e30:	6c6c616d 	stfvse	f6, [ip], #-436	; 0xfffffe4c
    5e34:	635f636f 	cmpvs	pc, #-1140850687	; 0xbc000001
    5e38:	65686361 	strbvs	r6, [r8, #-865]!	; 0xfffffc9f
    5e3c:	5f640073 	svcpl	0x00640073
    5e40:	61696c61 	cmnvs	r9, r1, ror #24
    5e44:	61700073 	cmnvs	r0, r3, ror r0
    5e48:	00706874 	rsbseq	r6, r0, r4, ror r8
    5e4c:	74697277 	strbtvc	r7, [r9], #-631	; 0xfffffd89
    5e50:	67617065 	strbvs	r7, [r1, -r5, rrx]!
    5e54:	494d0065 	stmdbmi	sp, {r0, r2, r5, r6}^
    5e58:	54415247 	strbpl	r5, [r1], #-583	; 0xfffffdb9
    5e5c:	53415f45 	movtpl	r5, #8005	; 0x1f45
    5e60:	00434e59 	subeq	r4, r3, r9, asr lr
    5e64:	61725f5f 	cmnvs	r2, pc, asr pc
    5e68:	69745f77 	ldmdbvs	r4!, {r0, r1, r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    5e6c:	74656b63 	strbtvc	r6, [r5], #-2915	; 0xfffff49d
    5e70:	6c620073 	stclvs	0, cr0, [r2], #-460	; 0xfffffe34
    5e74:	7a69736b 	bvc	1a62c28 <unflatten_and_copy_device_tree+0x1a61db4>
    5e78:	656b0065 	strbvs	r0, [fp, #-101]!	; 0xffffff9b
    5e7c:	73666e72 	cmnvc	r6, #1824	; 0x720
    5e80:	656c655f 	strbvs	r6, [ip, #-1375]!	; 0xfffffaa1
    5e84:	74615f6d 	strbtvc	r5, [r1], #-3949	; 0xfffff093
    5e88:	70007274 	andvc	r7, r0, r4, ror r2
    5e8c:	61775f69 	cmnvs	r7, r9, ror #30
    5e90:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
    5e94:	656c5f73 	strbvs	r5, [ip, #-3955]!	; 0xfffff08d
    5e98:	6f6d7466 	svcvs	0x006d7466
    5e9c:	69007473 	stmdbvs	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
    5ea0:	00797474 	rsbseq	r7, r9, r4, ror r4
    5ea4:	685f6462 	ldmdavs	pc, {r1, r5, r6, sl, sp, lr}^	; <UNPREDICTABLE>
    5ea8:	65646c6f 	strbvs	r6, [r4, #-3183]!	; 0xfffff391
    5eac:	5f5f0072 	svcpl	0x005f0072
    5eb0:	74736572 	ldrbtvc	r6, [r3], #-1394	; 0xfffffa8e
    5eb4:	6665726f 	strbtvs	r7, [r5], -pc, ror #4
    5eb8:	00745f6e 	rsbseq	r5, r4, lr, ror #30
    5ebc:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xfffff093
    5ec0:	76617300 	strbtvc	r7, [r1], -r0, lsl #6
    5ec4:	735f6465 	cmpvc	pc, #1694498816	; 0x65000000
    5ec8:	616d6769 	cmnvs	sp, r9, ror #14
    5ecc:	69006b73 	stmdbvs	r0, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}
    5ed0:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
    5ed4:	726e006b 	rsbvc	r0, lr, #107	; 0x6b
    5ed8:	6961665f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r9, sl, sp, lr}^
    5edc:	5f64656c 	svcpl	0x0064656c
    5ee0:	7267696d 	rsbvc	r6, r7, #1785856	; 0x1b4000
    5ee4:	6f697461 	svcvs	0x00697461
    5ee8:	685f736e 	ldmdavs	pc, {r1, r2, r3, r5, r6, r8, r9, ip, sp, lr}^	; <UNPREDICTABLE>
    5eec:	6400746f 	strvs	r7, [r0], #-1135	; 0xfffffb91
    5ef0:	705f6971 	subsvc	r6, pc, r1, ror r9	; <UNPREDICTABLE>
    5ef4:	00766972 	rsbseq	r6, r6, r2, ror r9
    5ef8:	6f72657a 	svcvs	0x0072657a
    5efc:	6e66705f 	mcrvs	0, 3, r7, cr6, cr15, {2}
    5f00:	67617000 	strbvs	r7, [r1, -r0]!
    5f04:	74657365 	strbtvc	r7, [r5], #-869	; 0xfffffc9b
    5f08:	735f7300 	cmpvc	pc, #0, 6
    5f0c:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0xfffffe8c
    5f10:	616c6300 	cmnvs	ip, r0, lsl #6
    5f14:	6f7a7373 	svcvs	0x007a7373
    5f18:	695f656e 	ldmdbvs	pc, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    5f1c:	69007864 	stmdbvs	r0, {r2, r5, r6, fp, ip, sp, lr}
    5f20:	616c665f 	cmnvs	ip, pc, asr r6
    5f24:	6d007367 	stcvs	3, cr7, [r0, #-412]	; 0xfffffe64
    5f28:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    5f2c:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
    5f30:	6176006b 	cmnvs	r6, fp, rrx
    5f34:	00726464 	rsbseq	r6, r2, r4, ror #8
    5f38:	6e695f64 	cdpvs	15, 6, cr5, cr9, cr4, {3}
    5f3c:	6f735f6f 	svcvs	0x00735f6f
    5f40:	696c7466 	stmdbvs	ip!, {r1, r2, r5, r6, sl, ip, sp, lr}^
    5f44:	0074696d 	rsbseq	r6, r4, sp, ror #18
    5f48:	65645f69 	strbvs	r5, [r4, #-3945]!	; 0xfffff097
    5f4c:	7972746e 	ldmdbvc	r2!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    5f50:	5f6c6600 	svcpl	0x006c6600
    5f54:	7478656e 	ldrbtvc	r6, [r8], #-1390	; 0xfffffa92
    5f58:	75637200 	strbvc	r7, [r3, #-512]!	; 0xfffffe00
    5f5c:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 5f64 <.debug_str+0x5f64>
    5f60:	6e655f65 	cdpvs	15, 6, cr5, cr5, cr5, {3}
    5f64:	00797274 	rsbseq	r7, r9, r4, ror r2
    5f68:	646e6567 	strbtvs	r6, [lr], #-1383	; 0xfffffa99
    5f6c:	006b7369 	rsbeq	r7, fp, r9, ror #6
    5f70:	74696177 	strbtvc	r6, [r9], #-375	; 0xfffffe89
    5f74:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    5f78:	64660074 	strbtvs	r0, [r6], #-116	; 0xffffff8c
    5f7c:	61705f74 	cmnvs	r0, r4, ror pc
    5f80:	6f5f6874 	svcvs	0x005f6874
    5f84:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0xfffff99a
    5f88:	616e5f74 	smcvs	58868	; 0xe5f4
    5f8c:	656c656d 	strbvs	r6, [ip, #-1389]!	; 0xfffffa93
    5f90:	4d57006e 	ldclmi	0, cr0, [r7, #-440]	; 0xfffffe48
    5f94:	5f4b5241 	svcpl	0x004b5241
    5f98:	48474948 	stmdami	r7, {r3, r6, r8, fp, lr}^
    5f9c:	6f696100 	svcvs	0x00696100
    5fa0:	7973665f 	ldmdbvc	r3!, {r0, r1, r2, r3, r4, r6, r9, sl, sp, lr}^
    5fa4:	6300636e 	movwvs	r6, #878	; 0x36e
    5fa8:	00737466 	rsbseq	r7, r3, r6, ror #8
    5fac:	775f726e 	ldrbvc	r7, [pc, -lr, ror #4]
    5fb0:	75656b61 	strbvc	r6, [r5, #-2913]!	; 0xfffff49f
    5fb4:	695f7370 	ldmdbvs	pc, {r4, r5, r6, r8, r9, ip, sp, lr}^	; <UNPREDICTABLE>
    5fb8:	00656c64 	rsbeq	r6, r5, r4, ror #24
    5fbc:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    5fc0:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xfffff08c
    5fc4:	006b6361 	rsbeq	r6, fp, r1, ror #6
    5fc8:	5f646d70 	svcpl	0x00646d70
    5fcc:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    5fd0:	6d5f0074 	ldclvs	0, cr0, [pc, #-464]	; 5e08 <.debug_str+0x5e08>
    5fd4:	00316e69 	eorseq	r6, r1, r9, ror #28
    5fd8:	6e696d5f 	mcrvs	13, 3, r6, cr9, cr15, {2}
    5fdc:	49500032 	ldmdbmi	r0, {r1, r4, r5}^
    5fe0:	50595444 	subspl	r5, r9, r4, asr #8
    5fe4:	414d5f45 	cmpmi	sp, r5, asr #30
    5fe8:	47500058 			; <UNDEFINED> instruction: 0x47500058
    5fec:	4c554146 	ldfmie	f4, [r5], {70}	; 0x46
    5ff0:	5f640054 	svcpl	0x00640054
    5ff4:	735f7472 	cmpvc	pc, #1912602624	; 0x72000000
    5ff8:	735f6370 	cmpvc	pc, #112, 6	; 0xc0000001
    5ffc:	6c74666f 	ldclvs	6, cr6, [r4], #-444	; 0xfffffe44
    6000:	74696d69 	strbtvc	r6, [r9], #-3433	; 0xfffff297
    6004:	65786500 	ldrbvs	r6, [r8, #-1280]!	; 0xfffffb00
    6008:	616d5f63 	cmnvs	sp, r3, ror #30
    600c:	61720078 	cmnvs	r2, r8, ror r0
    6010:	6f6c5f77 	svcvs	0x006c5f77
    6014:	65006b63 	strvs	r6, [r0, #-2915]	; 0xfffff49d
    6018:	5f70766e 	svcpl	0x0070766e
    601c:	00786469 	rsbseq	r6, r8, r9, ror #8
    6020:	69735f5f 	ldmdbvs	r3!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}^
    6024:	73657267 	cmnvc	r5, #1879048198	; 0x70000006
    6028:	65726f74 	ldrbvs	r6, [r2, #-3956]!	; 0xfffff08c
    602c:	7300745f 	movwvc	r7, #1119	; 0x45f
    6030:	6f6e695f 	svcvs	0x006e695f
    6034:	6c5f6564 	cfldr64vs	mvdx6, [pc], {100}	; 0x64
    6038:	66007572 			; <UNDEFINED> instruction: 0x66007572
    603c:	6e5f7464 	cdpvs	4, 5, cr7, cr15, cr4, {3}
    6040:	5f747865 	svcpl	0x00747865
    6044:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    6048:	625f7300 	subsvs	r7, pc, #0, 6
    604c:	6b636f6c 	blvs	18e1e04 <unflatten_and_copy_device_tree+0x18e0f90>
    6050:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0xfffff68d
    6054:	6d656d00 	stclvs	13, cr6, [r5, #-0]
    6058:	0079726f 	rsbseq	r7, r9, pc, ror #4
    605c:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0xfffff68c
    6060:	0074756f 	rsbseq	r7, r4, pc, ror #10
    6064:	5f776172 	svcpl	0x00776172
    6068:	6e697073 	mcrvs	0, 3, r7, cr9, cr3, {3}
    606c:	6b636f6c 	blvs	18e1e24 <unflatten_and_copy_device_tree+0x18e0fb0>
    6070:	7200745f 	andvc	r7, r0, #1593835520	; 0x5f000000
    6074:	61656c65 	cmnvs	r5, r5, ror #24
    6078:	645f6573 	ldrbvs	r6, [pc], #-1395	; 6080 <.debug_str+0x6080>
    607c:	6b6c6271 	blvs	1b1ea48 <unflatten_and_copy_device_tree+0x1b1dbd4>
    6080:	696e7500 	stmdbvs	lr!, {r8, sl, ip, sp, lr}^
    6084:	5f657571 	svcpl	0x00657571
    6088:	67006469 	strvs	r6, [r0, -r9, ror #8]
    608c:	6e5f7465 	cdpvs	4, 5, cr7, cr15, cr5, {3}
    6090:	5f747865 	svcpl	0x00747865
    6094:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    6098:	66007461 	strvs	r7, [r0], -r1, ror #8
    609c:	725f7464 	subsvc	r7, pc, #100, 8	; 0x64000000
    60a0:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
    60a4:	5f646576 	svcpl	0x00646576
    60a8:	5f6d656d 	svcpl	0x006d656d
    60ac:	65766173 	ldrbvs	r6, [r6, #-371]!	; 0xfffffe8d
    60b0:	646f6e5f 	strbtvs	r6, [pc], #-3679	; 60b8 <.debug_str+0x60b8>
    60b4:	74730065 	ldrbtvc	r0, [r3], #-101	; 0xffffff9b
    60b8:	74007461 	strvc	r7, [r0], #-1121	; 0xfffffb9f
    60bc:	665f626c 	ldrbvs	r6, [pc], -ip, ror #4
    60c0:	7367616c 	cmnvc	r7, #108, 2
    60c4:	5f697300 	svcpl	0x00697300
    60c8:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
    60cc:	6873006f 	ldmdavs	r3!, {r0, r1, r2, r3, r5, r6}^
    60d0:	735f776f 	cmpvc	pc, #29097984	; 0x1bc0000
    60d4:	73746174 	cmnvc	r4, #116, 2
    60d8:	6e6f6300 	cdpvs	3, 6, cr6, cr15, cr0, {0}
    60dc:	5f676974 	svcpl	0x00676974
    60e0:	65676170 	strbvs	r6, [r7, #-368]!	; 0xfffffe90
    60e4:	7461645f 	strbtvc	r6, [r1], #-1119	; 0xfffffba1
    60e8:	50430061 	subpl	r0, r3, r1, rrx
    60ec:	4f4e5f55 	svcmi	0x004e5f55
    60f0:	44495f54 	strbmi	r5, [r9], #-3924	; 0xfffff0ac
    60f4:	7300454c 	movwvc	r4, #1356	; 0x54c
    60f8:	616e6769 	cmnvs	lr, r9, ror #14
    60fc:	74735f6c 	ldrbtvc	r5, [r3], #-3948	; 0xfffff094
    6100:	74637572 	strbtvc	r7, [r3], #-1394	; 0xfffffa8e
    6104:	735f5f00 	cmpvc	pc, #0, 30
    6108:	70757465 	rsbsvc	r7, r5, r5, ror #8
    610c:	7274735f 	rsbsvc	r7, r4, #2080374785	; 0x7c000001
    6110:	7465735f 	strbtvc	r7, [r5], #-863	; 0xfffffca1
    6114:	6f5f7075 	svcvs	0x005f7075
    6118:	61655f66 	cmnvs	r5, r6, ror #30
    611c:	63796c72 	cmnvs	r9, #29184	; 0x7200
    6120:	69006e6f 	stmdbvs	r0, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
    6124:	6f6e695f 	svcvs	0x006e695f
    6128:	64697000 	strbtvs	r7, [r9], #-0
    612c:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
    6130:	61660073 	smcvs	24579	; 0x6003
    6134:	636e7973 	cmnvs	lr, #1884160	; 0x1cc000
    6138:	7274735f 	rsbsvc	r7, r4, #2080374785	; 0x7c000001
    613c:	00746375 	rsbseq	r6, r4, r5, ror r3
    6140:	54535144 	ldrbpl	r5, [r3], #-324	; 0xfffffebc
    6144:	4341435f 	movtmi	r4, #4959	; 0x135f
    6148:	485f4548 	ldmdami	pc, {r3, r6, r8, sl, lr}^	; <UNPREDICTABLE>
    614c:	00535449 	subseq	r5, r3, r9, asr #8
    6150:	64616564 	strbtvs	r6, [r1], #-1380	; 0xfffffa9c
    6154:	69727700 	ldmdbvs	r2!, {r8, r9, sl, ip, sp, lr}^
    6158:	655f6574 	ldrbvs	r6, [pc, #-1396]	; 5bec <.debug_str+0x5bec>
    615c:	6c00646e 	cfstrsvs	mvf6, [r0], {110}	; 0x6e
    6160:	5f747369 	svcpl	0x00747369
    6164:	6b636f6c 	blvs	18e1f1c <unflatten_and_copy_device_tree+0x18e10a8>
    6168:	6d687300 	stclvs	3, cr7, [r8, #-0]
    616c:	696c635f 	stmdbvs	ip!, {r0, r1, r2, r3, r4, r6, r8, r9, sp, lr}^
    6170:	66007473 			; <UNDEFINED> instruction: 0x66007473
    6174:	6e5f7464 	cdpvs	4, 5, cr7, cr15, cr4, {3}
    6178:	5f747865 	svcpl	0x00747865
    617c:	706f7270 	rsbvc	r7, pc, r0, ror r2	; <UNPREDICTABLE>
    6180:	79747265 	ldmdbvc	r4!, {r0, r2, r5, r6, r9, ip, sp, lr}^
    6184:	66666f5f 	uqsaxvs	r6, r6, pc	; <UNPREDICTABLE>
    6188:	00746573 	rsbseq	r6, r4, r3, ror r5
    618c:	6d5f6361 	ldclvs	3, cr6, [pc, #-388]	; 6010 <.debug_str+0x6010>
    6190:	43006d65 	movwmi	r6, #3429	; 0xd65
    6194:	495f5550 	ldmdbmi	pc, {r4, r6, r8, sl, ip, lr}^	; <UNPREDICTABLE>
    6198:	00454c44 	subeq	r4, r5, r4, asr #24
    619c:	415f524e 	cmpmi	pc, lr, asr #4
    61a0:	5f4e4f4e 	svcpl	0x004e4f4e
    61a4:	4e415254 	mcrmi	2, 2, r5, cr1, cr4, {2}
    61a8:	52415053 	subpl	r5, r1, #83	; 0x53
    61ac:	5f544e45 	svcpl	0x00544e45
    61b0:	45475548 	strbmi	r5, [r7, #-1352]	; 0xfffffab8
    61b4:	45474150 	strbmi	r4, [r7, #-336]	; 0xfffffeb0
    61b8:	75730053 	ldrbvc	r0, [r3, #-83]!	; 0xffffffad
    61bc:	73726570 	cmnvc	r2, #112, 10	; 0x1c000000
    61c0:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    61c4:	5f74645f 	svcpl	0x0074645f
    61c8:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    61cc:	0073676e 	rsbseq	r6, r3, lr, ror #14
    61d0:	756f635f 	strbvc	r6, [pc, #-863]!	; 5e79 <.debug_str+0x5e79>
    61d4:	7000746e 	andvc	r7, r0, lr, ror #8
    61d8:	666c6c6f 	strbtvs	r6, [ip], -pc, ror #24
    61dc:	52480064 	subpl	r0, r8, #100	; 0x64
    61e0:	454d4954 	strbmi	r4, [sp, #-2388]	; 0xfffff6ac
    61e4:	41425f52 	cmpmi	r2, r2, asr pc
    61e8:	425f4553 	subsmi	r4, pc, #348127232	; 0x14c00000
    61ec:	54544f4f 	ldrbpl	r4, [r4], #-3919	; 0xfffff0b1
    61f0:	00454d49 	subeq	r4, r5, r9, asr #26
    61f4:	73756c66 	cmnvc	r5, #26112	; 0x6600
    61f8:	68635f68 	stmdavs	r3!, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    61fc:	00737261 	rsbseq	r7, r3, r1, ror #4
    6200:	31755f5f 	cmncc	r5, pc, asr pc
    6204:	616c0036 	cmnvs	ip, r6, lsr r0
    6208:	755f7473 	ldrbvc	r7, [pc, #-1139]	; 5d9d <.debug_str+0x5d9d>
    620c:	5f646573 	svcpl	0x00646573
    6210:	64007461 	strvs	r7, [r0], #-1121	; 0xfffffb9f
    6214:	6c65735f 	stclvs	3, cr7, [r5], #-380	; 0xfffffe84
    6218:	5f746365 	svcpl	0x00746365
    621c:	646f6e69 	strbtvs	r6, [pc], #-3689	; 6224 <.debug_str+0x6224>
    6220:	61740065 	cmnvs	r4, r5, rrx
    6224:	695f6b73 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^	; <UNPREDICTABLE>
    6228:	63615f6f 	cmnvs	r1, #444	; 0x1bc
    622c:	6e756f63 	cdpvs	15, 7, cr6, cr5, cr3, {3}
    6230:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
    6234:	65726d00 	ldrbvs	r6, [r2, #-3328]!	; 0xfffff300
    6238:	0070616d 	rsbseq	r6, r0, sp, ror #2
    623c:	73696c6c 	cmnvc	r9, #108, 24	; 0x6c00
    6240:	6f6e5f74 	svcvs	0x006e5f74
    6244:	68006564 	stmdavs	r0, {r2, r5, r6, r8, sl, sp, lr}
    6248:	635f7361 	cmpvs	pc, #-2080374783	; 0x84000001
    624c:	646c6968 	strbtvs	r6, [ip], #-2408	; 0xfffff698
    6250:	6275735f 	rsbsvs	r7, r5, #2080374785	; 0x7c000001
    6254:	70616572 	rsbvc	r6, r1, r2, ror r5
    6258:	69007265 	stmdbvs	r0, {r0, r2, r5, r6, r9, ip, sp, lr}
    625c:	6469755f 	strbtvs	r7, [r9], #-1375	; 0xfffffaa1
    6260:	5f6d7600 	svcpl	0x006d7600
    6264:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    6268:	736b0073 	cmnvc	fp, #115	; 0x73
    626c:	64706177 	ldrbtvs	r6, [r0], #-375	; 0xfffffe89
    6270:	78616d5f 	stmdavc	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
    6274:	64726f5f 	ldrbtvs	r6, [r2], #-3935	; 0xfffff0a1
    6278:	66007265 	strvs	r7, [r0], -r5, ror #4
    627c:	746c7561 	strbtvc	r7, [ip], #-1377	; 0xfffffa9f
    6280:	75637200 	strbvc	r7, [r3, #-512]!	; 0xfffffe00
    6284:	6165725f 	cmnvs	r5, pc, asr r2
    6288:	6e755f64 	cdpvs	15, 7, cr5, cr5, cr4, {3}
    628c:	6b636f6c 	blvs	18e2044 <unflatten_and_copy_device_tree+0x18e11d0>
    6290:	6570735f 	ldrbvs	r7, [r0, #-863]!	; 0xfffffca1
    6294:	6c616963 	stclvs	9, cr6, [r1], #-396	; 0xfffffe74
    6298:	6f6c6200 	svcvs	0x006c6200
    629c:	64656b63 	strbtvs	r6, [r5], #-2915	; 0xfffff49d
    62a0:	76697300 	strbtvc	r7, [r9], -r0, lsl #6
    62a4:	705f6c61 	subsvc	r6, pc, r1, ror #24
    62a8:	72007274 	andvc	r7, r0, #116, 4	; 0x40000007
    62ac:	735f7761 	cmpvc	pc, #25427968	; 0x1840000
    62b0:	6c6e6970 	stclvs	9, cr6, [lr], #-448	; 0xfffffe40
    62b4:	006b636f 	rsbeq	r6, fp, pc, ror #6
    62b8:	5f6d7573 	svcpl	0x006d7573
    62bc:	65656c73 	strbvs	r6, [r5, #-3187]!	; 0xfffff38d
    62c0:	75725f70 	ldrbvc	r5, [r2, #-3952]!	; 0xfffff090
    62c4:	6d69746e 	cfstrdvs	mvd7, [r9, #-440]!	; 0xfffffe48
    62c8:	72770065 	rsbsvc	r0, r7, #101	; 0x65
    62cc:	5f657469 	svcpl	0x00657469
    62d0:	72657469 	rsbvc	r7, r5, #1761607680	; 0x69000000
    62d4:	77736b00 	ldrbvc	r6, [r3, -r0, lsl #22]!
    62d8:	00647061 	rsbeq	r7, r4, r1, rrx
    62dc:	6c727473 	cfldrdvs	mvd7, [r2], #-460	; 0xfffffe34
    62e0:	75006e65 	strvc	r6, [r0, #-3685]	; 0xfffff19b
    62e4:	626f7270 	rsbvs	r7, pc, #112, 4
    62e8:	61745f65 	cmnvs	r4, r5, ror #30
    62ec:	70006b73 	andvc	r6, r0, r3, ror fp
    62f0:	755f6461 	ldrbvc	r6, [pc, #-1121]	; 5e97 <.debug_str+0x5e97>
    62f4:	6c69746e 	cfstrdvs	mvd7, [r9], #-440	; 0xfffffe48
    62f8:	72657000 	rsbvc	r7, r5, #0
    62fc:	5f757063 	svcpl	0x00757063
    6300:	66697264 	strbtvs	r7, [r9], -r4, ror #4
    6304:	616d5f74 	smcvs	54772	; 0xd5f4
    6308:	5f006b72 	svcpl	0x00006b72
    630c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    6310:	6e655f74 	mcrvs	15, 3, r5, cr5, cr4, {3}
    6314:	5f640064 	svcpl	0x00640064
    6318:	6c656966 	stclvs	9, cr6, [r5], #-408	; 0xfffffe68
    631c:	73616d64 	cmnvc	r1, #100, 26	; 0x1900
    6320:	4750006b 	ldrbmi	r0, [r0, -fp, rrx]
    6324:	49544341 	ldmdbmi	r4, {r0, r6, r8, r9, lr}^
    6328:	45544156 	ldrbmi	r4, [r4, #-342]	; 0xfffffeaa
    632c:	69737300 	ldmdbvs	r3!, {r8, r9, ip, sp, lr}^
    6330:	745f657a 	ldrbvc	r6, [pc], #-1402	; 6338 <.debug_str+0x6338>
    6334:	75706300 	ldrbvc	r6, [r0, #-768]!	; 0xfffffd00
    6338:	626c745f 	rsbvs	r7, ip, #1593835520	; 0x5f000000
    633c:	736e665f 	cmnvc	lr, #99614720	; 0x5f00000
    6340:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
    6344:	616d5f74 	smcvs	54772	; 0xd5f4
    6348:	4f570078 	svcmi	0x00570078
    634c:	4e494b52 	vmovmi.8	d9[2], r4
    6350:	54455347 	strbpl	r5, [r5], #-839	; 0xfffffcb9
    6354:	4645525f 			; <UNDEFINED> instruction: 0x4645525f
    6358:	544c5541 	strbpl	r5, [ip], #-1345	; 0xfffffabf
    635c:	76656400 	strbtvc	r6, [r5], -r0, lsl #8
    6360:	6300745f 	movwvs	r7, #1119	; 0x45f
    6364:	756f7267 	strbvc	r7, [pc, #-615]!	; 6105 <.debug_str+0x6105>
    6368:	4e007370 	mcrmi	3, 0, r7, cr0, cr0, {3}
    636c:	4d575f52 	ldclmi	15, cr5, [r7, #-328]	; 0xfffffeb8
    6370:	004b5241 	subeq	r5, fp, r1, asr #4
    6374:	656e6f7a 	strbvs	r6, [lr, #-3962]!	; 0xfffff086
    6378:	00666572 	rsbeq	r6, r6, r2, ror r5
    637c:	64616572 	strbtvs	r6, [r1], #-1394	; 0xfffffa8e
    6380:	3436735f 	ldrtcc	r7, [r6], #-863	; 0xfffffca1
    6384:	695f5f00 	ldmdbvs	pc, {r8, r9, sl, fp, ip, lr}^	; <UNPREDICTABLE>
    6388:	6374696e 	cmnvs	r4, #1802240	; 0x1b8000
    638c:	5f6c6c61 	svcpl	0x006c6c61
    6390:	665f666f 	ldrbvs	r6, [pc], -pc, ror #12
    6394:	725f7464 	subsvc	r7, pc, #100, 8	; 0x64000000
    6398:	695f7761 	ldmdbvs	pc, {r0, r5, r6, r8, r9, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    639c:	3774696e 	ldrbcc	r6, [r4, -lr, ror #18]!
    63a0:	55435200 	strbpl	r5, [r3, #-512]	; 0xfffffe00
    63a4:	464f535f 			; <UNDEFINED> instruction: 0x464f535f
    63a8:	51524954 	cmppl	r2, r4, asr r9
    63ac:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; 54b4 <.debug_str+0x54b4>
    63b0:	68003233 	stmdavs	r0, {r0, r1, r4, r5, r9, ip, sp}
    63b4:	69647261 	stmdbvs	r4!, {r0, r5, r6, r9, ip, sp, lr}^
    63b8:	635f7172 	cmpvs	pc, #-2147483620	; 0x8000001c
    63bc:	65746e6f 	ldrbvs	r6, [r4, #-3695]!	; 0xfffff191
    63c0:	50007478 	andpl	r7, r0, r8, ror r4
    63c4:	45524647 	ldrbmi	r4, [r2, #-1607]	; 0xfffff9b9
    63c8:	70630045 	rsbvc	r0, r3, r5, asr #32
    63cc:	73616d75 	cmnvc	r1, #7488	; 0x1d40
    63d0:	00745f6b 	rsbseq	r5, r4, fp, ror #30
    63d4:	4b524f57 	blmi	149a138 <unflatten_and_copy_device_tree+0x14992c4>
    63d8:	53474e49 	movtpl	r4, #32329	; 0x7e49
    63dc:	415f5445 	cmpmi	pc, r5, asr #8
    63e0:	56495443 	strbpl	r5, [r9], -r3, asr #8
    63e4:	00455441 	subeq	r5, r5, r1, asr #8
    63e8:	33746e69 	cmncc	r4, #1680	; 0x690
    63ec:	00745f32 	rsbseq	r5, r4, r2, lsr pc
    63f0:	645f666f 	ldrbvs	r6, [pc], #-1647	; 63f8 <.debug_str+0x63f8>
    63f4:	63697665 	cmnvs	r9, #105906176	; 0x6500000
    63f8:	64695f65 	strbtvs	r5, [r9], #-3941	; 0xfffff09b
    63fc:	72616500 	rsbvc	r6, r1, #0, 10
    6400:	695f796c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, fp, ip, sp, lr}^	; <UNPREDICTABLE>
    6404:	0074696e 	rsbseq	r6, r4, lr, ror #18
    6408:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    640c:	6170735f 	cmnvs	r0, pc, asr r3
    6410:	64656e6e 	strbtvs	r6, [r5], #-3694	; 0xfffff192
    6414:	6761705f 			; <UNDEFINED> instruction: 0x6761705f
    6418:	74007365 	strvc	r7, [r0], #-869	; 0xfffffc9b
    641c:	61657268 	cmnvs	r5, r8, ror #4
    6420:	72675f64 	rsbvc	r5, r7, #100, 30	; 0x190
    6424:	5f70756f 	svcpl	0x0070756f
    6428:	74757063 	ldrbtvc	r7, [r5], #-99	; 0xffffff9d
    642c:	72656d69 	rsbvc	r6, r5, #6720	; 0x1a40
    6430:	57535000 	ldrbpl	r5, [r3, -r0]
    6434:	004e4950 	subeq	r4, lr, r0, asr r9
    6438:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
    643c:	61006874 	tstvs	r0, r4, ror r8
    6440:	69757163 	ldmdbvs	r5!, {r0, r1, r5, r6, r8, ip, sp, lr}^
    6444:	645f6572 	ldrbvs	r6, [pc], #-1394	; 644c <.debug_str+0x644c>
    6448:	746f7571 	strbtvc	r7, [pc], #-1393	; 6450 <.debug_str+0x6450>
    644c:	665f5f00 	ldrbvs	r5, [pc], -r0, lsl #30
    6450:	62617773 	rsbvs	r7, r1, #30146560	; 0x1cc0000
    6454:	6b003233 	blvs	12d28 <unflatten_and_copy_device_tree+0x11eb4>
    6458:	755f7965 	ldrbvc	r7, [pc, #-2405]	; 5afb <.debug_str+0x5afb>
    645c:	00726573 	rsbseq	r6, r2, r3, ror r5
    6460:	6d5f7472 	cfldrdvs	mvd7, [pc, #-456]	; 62a0 <.debug_str+0x62a0>
    6464:	78657475 	stmdavc	r5!, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    6468:	6961775f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    646c:	00726574 	rsbseq	r6, r2, r4, ror r5
    6470:	69726573 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    6474:	63006c61 	movwvs	r6, #3169	; 0xc61
    6478:	70736f5f 	rsbsvc	r6, r3, pc, asr pc
    647c:	00646565 	rsbeq	r6, r4, r5, ror #10
    6480:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0xfffff69a
    6484:	7379735f 	cmnvc	r9, #2080374785	; 0x7c000001
    6488:	5f6d6574 	svcpl	0x006d6574
    648c:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0xfffff68c
    6490:	4d5f5f00 	ldclmi	15, cr5, [pc, #-0]	; 6498 <.debug_str+0x6498>
    6494:	4e5f5841 	cdpmi	8, 5, cr5, cr15, cr1, {2}
    6498:	4f5a5f52 	svcmi	0x005a5f52
    649c:	0053454e 	subseq	r4, r3, lr, asr #10
    64a0:	736e6977 	cmnvc	lr, #1949696	; 0x1dc000
    64a4:	5f657a69 	svcpl	0x00657a69
    64a8:	6574756d 	ldrbvs	r7, [r4, #-1389]!	; 0xfffffa93
    64ac:	72640078 	rsbvc	r0, r4, #120	; 0x78
    64b0:	695f706f 	ldmdbvs	pc, {r0, r1, r2, r3, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
    64b4:	65646f6e 	strbvs	r6, [r4, #-3950]!	; 0xfffff092
    64b8:	74756300 	ldrbtvc	r6, [r5], #-768	; 0xfffffd00
    64bc:	00656d69 	rsbeq	r6, r5, r9, ror #26
    64c0:	70617274 	rsbvc	r7, r1, r4, ror r2
    64c4:	006f6e5f 	rsbeq	r6, pc, pc, asr lr	; <UNPREDICTABLE>
    64c8:	69645f69 	stmdbvs	r4!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    64cc:	6f635f6f 	svcvs	0x00635f6f
    64d0:	00746e75 	rsbseq	r6, r4, r5, ror lr
    64d4:	61727470 	cmnvs	r2, r0, ror r4
    64d8:	70006563 	andvc	r6, r0, r3, ror #10
    64dc:	7374726f 	cmnvc	r4, #-268435450	; 0xf0000006
    64e0:	72657300 	rsbvc	r7, r5, #0, 6
    64e4:	5f6c6169 	svcpl	0x006c6169
    64e8:	6600726e 	strvs	r7, [r0], -lr, ror #4
    64ec:	006b726f 	rsbeq	r7, fp, pc, ror #4
    64f0:	5f4b4153 	svcpl	0x004b4153
    64f4:	6b726f77 	blvs	1ca22d8 <unflatten_and_copy_device_tree+0x1ca1464>
    64f8:	4e574600 	cdpmi	6, 5, cr4, cr7, cr0, {0}
    64fc:	5f45444f 	svcpl	0x0045444f
    6500:	41564e49 	cmpmi	r6, r9, asr #28
    6504:	0044494c 	subeq	r4, r4, ip, asr #18
    6508:	505f524e 	subspl	r5, pc, lr, asr #4
    650c:	54454741 	strbpl	r4, [r5], #-1857	; 0xfffff8bf
    6510:	454c4241 	strbmi	r4, [ip, #-577]	; 0xfffffdbf
    6514:	52474300 	subpl	r4, r7, #0, 6
    6518:	5f50554f 	svcpl	0x0050554f
    651c:	53425553 	movtpl	r5, #9555	; 0x2553
    6520:	435f5359 	cmpmi	pc, #1677721601	; 0x64000001
    6524:	544e554f 	strbpl	r5, [lr], #-1359	; 0xfffffab1
    6528:	6e616d00 	cdpvs	13, 6, cr6, cr1, cr0, {0}
    652c:	64656761 	strbtvs	r6, [r5], #-1889	; 0xfffff89f
    6530:	6761705f 			; <UNDEFINED> instruction: 0x6761705f
    6534:	64007365 	strvs	r7, [r0], #-869	; 0xfffffc9b
    6538:	7361685f 	cmnvc	r1, #6225920	; 0x5f0000
    653c:	4e470068 	cdpmi	0, 4, cr0, cr7, cr8, {3}
    6540:	38432055 	stmdacc	r3, {r0, r2, r4, r6, sp}^
    6544:	2e352039 	mrccs	0, 1, r2, cr5, cr9, {1}
    6548:	20302e34 	eorscs	r2, r0, r4, lsr lr
    654c:	36313032 			; <UNDEFINED> instruction: 0x36313032
    6550:	39303630 	ldmdbcc	r0!, {r4, r5, r9, sl, ip, sp}
    6554:	6c6d2d20 	stclvs	13, cr2, [sp], #-128	; 0xffffff80
    6558:	6c747469 	cfldrdvs	mvd7, [r4], #-420	; 0xfffffe5c
    655c:	6e652d65 	cdpvs	13, 6, cr2, cr5, cr5, {3}
    6560:	6e616964 	cdpvs	9, 6, cr6, cr1, cr4, {3}
    6564:	616d2d20 	cmnvs	sp, r0, lsr #26
    6568:	20736370 	rsbscs	r6, r3, r0, ror r3
    656c:	6f6e6d2d 	svcvs	0x006e6d2d
    6570:	6863732d 	stmdavs	r3!, {r0, r2, r3, r5, r8, r9, ip, sp, lr}^
    6574:	702d6465 	eorvc	r6, sp, r5, ror #8
    6578:	6f6c6f72 	svcvs	0x006c6f72
    657c:	6d2d2067 	stcvs	0, cr2, [sp, #-412]!	; 0xfffffe64
    6580:	3d696261 	sfmcc	f6, 2, [r9, #-388]!	; 0xfffffe7c
    6584:	63706161 	cmnvs	r0, #1073741848	; 0x40000018
    6588:	696c2d73 	stmdbvs	ip!, {r0, r1, r4, r5, r6, r8, sl, fp, sp}^
    658c:	2078756e 	rsbscs	r7, r8, lr, ror #10
    6590:	6f6e6d2d 	svcvs	0x006e6d2d
    6594:	7568742d 	strbvc	r7, [r8, #-1069]!	; 0xfffffbd3
    6598:	692d626d 	pushvs	{r0, r2, r3, r5, r6, r9, sp, lr}
    659c:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    65a0:	6b726f77 	blvs	1ca2384 <unflatten_and_copy_device_tree+0x1ca1510>
    65a4:	666d2d20 	strbtvs	r2, [sp], -r0, lsr #26
    65a8:	763d7570 			; <UNDEFINED> instruction: 0x763d7570
    65ac:	2d207066 	stccs	0, cr7, [r0, #-408]!	; 0xfffffe68
    65b0:	6d72616d 	ldfvse	f6, [r2, #-436]!	; 0xfffffe4c
    65b4:	616d2d20 	cmnvs	sp, r0, lsr #26
    65b8:	3d686372 	stclcc	3, cr6, [r8, #-456]!	; 0xfffffe38
    65bc:	766d7261 	strbtvc	r7, [sp], -r1, ror #4
    65c0:	20612d37 	rsbcs	r2, r1, r7, lsr sp
    65c4:	6c666d2d 	stclvs	13, cr6, [r6], #-180	; 0xffffff4c
    65c8:	2d74616f 	ldfcse	f6, [r4, #-444]!	; 0xfffffe44
    65cc:	3d696261 	sfmcc	f6, 2, [r9, #-388]!	; 0xfffffe7c
    65d0:	74666f73 	strbtvc	r6, [r6], #-3955	; 0xfffff08d
    65d4:	746d2d20 	strbtvc	r2, [sp], #-3360	; 0xfffff2e0
    65d8:	642d736c 	strtvs	r7, [sp], #-876	; 0xfffffc94
    65dc:	656c6169 	strbvs	r6, [ip, #-361]!	; 0xfffffe97
    65e0:	673d7463 	ldrvs	r7, [sp, -r3, ror #8]!
    65e4:	2d20756e 	cfstr32cs	mvfx7, [r0, #-440]!	; 0xfffffe48
    65e8:	4f2d2067 	svcmi	0x002d2067
    65ec:	732d2032 			; <UNDEFINED> instruction: 0x732d2032
    65f0:	673d6474 			; <UNDEFINED> instruction: 0x673d6474
    65f4:	3039756e 	eorscc	r7, r9, lr, ror #10
    65f8:	20702d20 	rsbscs	r2, r0, r0, lsr #26
    65fc:	6f6e662d 	svcvs	0x006e662d
    6600:	7274732d 	rsbsvc	r7, r4, #-1275068416	; 0xb4000000
    6604:	2d746369 	ldclcs	3, cr6, [r4, #-420]!	; 0xfffffe5c
    6608:	61696c61 	cmnvs	r9, r1, ror #24
    660c:	676e6973 			; <UNDEFINED> instruction: 0x676e6973
    6610:	6e662d20 	cdpvs	13, 6, cr2, cr6, cr0, {1}
    6614:	6f632d6f 	svcvs	0x00632d6f
    6618:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    661c:	6e662d20 	cdpvs	13, 6, cr2, cr6, cr0, {1}
    6620:	49502d6f 	ldmdbmi	r0, {r0, r1, r2, r3, r5, r6, r8, sl, fp, sp}^
    6624:	662d2045 	strtvs	r2, [sp], -r5, asr #32
    6628:	642d6f6e 	strtvs	r6, [sp], #-3950	; 0xfffff092
    662c:	66726177 			; <UNDEFINED> instruction: 0x66726177
    6630:	66632d32 			; <UNDEFINED> instruction: 0x66632d32
    6634:	73612d69 	cmnvc	r1, #6720	; 0x1a40
    6638:	662d206d 	strtvs	r2, [sp], -sp, rrx
    663c:	692d6f6e 	pushvs	{r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}
    6640:	732d6170 			; <UNDEFINED> instruction: 0x732d6170
    6644:	2d206172 	stfcss	f6, [r0, #-456]!	; 0xfffffe38
    6648:	2d6f6e66 	stclcs	14, cr6, [pc, #-408]!	; 64b8 <.debug_str+0x64b8>
    664c:	656c6564 	strbvs	r6, [ip, #-1380]!	; 0xfffffa9c
    6650:	6e2d6574 	mcrvs	5, 1, r6, cr13, cr4, {3}
    6654:	2d6c6c75 	stclcs	12, cr6, [ip, #-468]!	; 0xfffffe2c
    6658:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    665c:	2d726574 	cfldr64cs	mvdx6, [r2, #-464]!	; 0xfffffe30
    6660:	63656863 	cmnvs	r5, #6488064	; 0x630000
    6664:	2d20736b 	stccs	3, cr7, [r0, #-428]!	; 0xfffffe54
    6668:	2d6f6e66 	stclcs	14, cr6, [pc, #-408]!	; 64d8 <.debug_str+0x64d8>
    666c:	63617473 	cmnvs	r1, #1929379840	; 0x73000000
    6670:	72702d6b 	rsbsvc	r2, r0, #6848	; 0x1ac0
    6674:	6365746f 	cmnvs	r5, #1862270976	; 0x6f000000
    6678:	20726f74 	rsbscs	r6, r2, r4, ror pc
    667c:	6f6e662d 	svcvs	0x006e662d
    6680:	696d6f2d 	stmdbvs	sp!, {r0, r2, r3, r5, r8, r9, sl, fp, sp, lr}^
    6684:	72662d74 	rsbvc	r2, r6, #116, 26	; 0x1d00
    6688:	2d656d61 	stclcs	13, cr6, [r5, #-388]!	; 0xfffffe7c
    668c:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    6690:	20726574 	rsbscs	r6, r2, r4, ror r5
    6694:	6f6e662d 	svcvs	0x006e662d
    6698:	74706f2d 	ldrbtvc	r6, [r0], #-3885	; 0xfffff0d3
    669c:	7a696d69 	bvc	1a61c48 <unflatten_and_copy_device_tree+0x1a60dd4>
    66a0:	69732d65 	ldmdbvs	r3!, {r0, r2, r5, r6, r8, sl, fp, sp}^
    66a4:	6e696c62 	cdpvs	12, 6, cr6, cr9, cr2, {3}
    66a8:	61632d67 	cmnvs	r3, r7, ror #26
    66ac:	20736c6c 	rsbscs	r6, r3, ip, ror #24
    66b0:	6f6e662d 	svcvs	0x006e662d
    66b4:	7261762d 	rsbvc	r7, r1, #47185920	; 0x2d00000
    66b8:	6172742d 	cmnvs	r2, sp, lsr #8
    66bc:	6e696b63 	vnmulvs.f64	d22, d9, d19
    66c0:	73612d67 	cmnvc	r1, #6592	; 0x19c0
    66c4:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
    66c8:	746e656d 	strbtvc	r6, [lr], #-1389	; 0xfffffa93
    66cc:	662d2073 			; <UNDEFINED> instruction: 0x662d2073
    66d0:	732d6f6e 			; <UNDEFINED> instruction: 0x732d6f6e
    66d4:	63697274 	cmnvs	r9, #116, 4	; 0x40000007
    66d8:	766f2d74 			; <UNDEFINED> instruction: 0x766f2d74
    66dc:	6c667265 	sfmvs	f7, 2, [r6], #-404	; 0xfffffe6c
    66e0:	2d20776f 	stccs	7, cr7, [r0, #-444]!	; 0xfffffe44
    66e4:	6e6f6366 	cdpvs	3, 6, cr6, cr15, cr6, {3}
    66e8:	76726573 			; <UNDEFINED> instruction: 0x76726573
    66ec:	74732d65 	ldrbtvc	r2, [r3], #-3429	; 0xfffff29b
    66f0:	206b6361 	rsbcs	r6, fp, r1, ror #6
    66f4:	61702d2d 	cmnvs	r0, sp, lsr #26
    66f8:	206d6172 	rsbcs	r6, sp, r2, ror r1
    66fc:	6f6c6c61 	svcvs	0x006c6c61
    6700:	74732d77 	ldrbtvc	r2, [r3], #-3447	; 0xfffff289
    6704:	2d65726f 	sfmcs	f7, 2, [r5, #-444]!	; 0xfffffe44
    6708:	61746164 	cmnvs	r4, r4, ror #2
    670c:	6361722d 	cmnvs	r1, #-805306366	; 0xd0000002
    6710:	303d7365 	eorscc	r7, sp, r5, ror #6
    6714:	6c5f6600 	mrrcvs	6, 0, r6, pc, cr0	; <UNPREDICTABLE>
    6718:	006b636f 	rsbeq	r6, fp, pc, ror #6
    671c:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xfffff094
    6720:	6d75735f 	ldclvs	3, cr7, [r5, #-380]!	; 0xfffffe84
    6724:	775f6900 	ldrbvc	r6, [pc, -r0, lsl #18]
    6728:	72665f62 	rsbvc	r5, r6, #392	; 0x188
    672c:	69685f6e 	stmdbvs	r8!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    6730:	726f7473 	rsbvc	r7, pc, #1929379840	; 0x73000000
    6734:	72640079 	rsbvc	r0, r4, #121	; 0x79
    6738:	72657669 	rsbvc	r7, r5, #110100480	; 0x6900000
    673c:	736e7500 	cmnvc	lr, #0, 10
    6740:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0xfffff897
    6744:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
    6748:	6c680074 	stclvs	0, cr0, [r8], #-464	; 0xfffffe30
    674c:	5f747369 	svcpl	0x00747369
    6750:	64616568 	strbtvs	r6, [r1], #-1384	; 0xfffffa98
    6754:	5f6d7600 	svcpl	0x006d7600
    6758:	5a006d6d 	bpl	21d14 <unflatten_and_copy_device_tree+0x20ea0>
    675c:	5f454e4f 	svcpl	0x00454e4f
    6760:	00414d44 	subeq	r4, r1, r4, asr #26
    6764:	5f646975 	svcpl	0x00646975
    6768:	7279656b 	rsbsvc	r6, r9, #448790528	; 0x1ac00000
    676c:	00676e69 	rsbeq	r6, r7, r9, ror #28
    6770:	5f465144 	svcpl	0x00465144
    6774:	5f535953 	svcpl	0x00535953
    6778:	454c4946 	strbmi	r4, [ip, #-2374]	; 0xfffff6ba
    677c:	6900425f 	stmdbvs	r0, {r0, r1, r2, r3, r4, r6, r9, lr}
    6780:	74756d5f 	ldrbtvc	r6, [r5], #-3423	; 0xfffff2a1
    6784:	645f7865 	ldrbvs	r7, [pc], #-2149	; 678c <.debug_str+0x678c>
    6788:	6b5f7269 	blvs	17e3134 <unflatten_and_copy_device_tree+0x17e22c0>
    678c:	75007965 	strvc	r7, [r0, #-2405]	; 0xfffff69b
    6790:	5f6f646e 	svcpl	0x006f646e
    6794:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0xfffff694
	...

Disassembly of section .comment:

00000000 <.comment>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	43434700 	movtmi	r4, #14080	; 0x3700
   4:	5528203a 	strpl	r2, [r8, #-58]!	; 0xffffffc6
   8:	746e7562 	strbtvc	r7, [lr], #-1378	; 0xfffffa9e
   c:	694c2f75 	stmdbvs	ip, {r0, r2, r4, r5, r6, r8, r9, sl, fp, sp}^
  10:	6f72616e 	svcvs	0x0072616e
  14:	342e3520 	strtcc	r3, [lr], #-1312	; 0xfffffae0
  18:	362d302e 	strtcc	r3, [sp], -lr, lsr #32
  1c:	6e756275 	mrcvs	2, 3, r6, cr5, cr5, {3}
	return kzalloc(size, GFP_KERNEL);
}
  20:	7e317574 	mrcvc	5, 1, r7, cr1, cr4, {3}

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	302e3631 	eorcc	r3, lr, r1, lsr r6
  28:	29392e34 	ldmdbcs	r9!, {r2, r4, r5, r9, sl, fp, sp}
  2c:	342e3520 	strtcc	r3, [lr], #-1312	; 0xfffffae0
  30:	3220302e 	eorcc	r3, r0, #46	; 0x2e
  34:	30363130 	eorscc	r3, r6, r0, lsr r1
	memcpy(buf, initial_boot_params + off, count);
  38:	00393036 	eorseq	r3, r9, r6, lsr r0

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00002e41 	andeq	r2, r0, r1, asr #28
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  10:	412d3705 			; <UNDEFINED> instruction: 0x412d3705
  14:	070a0600 	streq	r0, [sl, -r0, lsl #12]
  18:	09010841 	stmdbeq	r1, {r0, r6, fp}
  1c:	14041202 	strne	r1, [r4], #-514	; 0xfffffdfe
	return kzalloc(size, GFP_KERNEL);
}
  20:	17011501 	strne	r1, [r1, -r1, lsl #10]

#ifdef CONFIG_SYSFS
static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
			       struct bin_attribute *bin_attr,
			       char *buf, loff_t off, size_t count)
{
  24:	19011803 	stmdbne	r1, {r0, r1, fp, ip}
  28:	1e021a01 	vmlane.f32	s2, s4, s2
  2c:	Address 0x000000000000002c is out of bounds.


Disassembly of section __mcount_loc:

00000000 <__mcount_loc>:

	pr_debug(" <- unflatten_device_tree()\n");
}

static void *kernel_tree_alloc(u64 size, u64 align)
{
   0:	00000010 	andeq	r0, r0, r0, lsl r0
   4:	00000034 	andeq	r0, r0, r4, lsr r0
   8:	00000074 	andeq	r0, r0, r4, ror r0
   c:	000005b0 			; <UNDEFINED> instruction: 0x000005b0
  10:	000006e4 	andeq	r0, r0, r4, ror #13
  14:	00000734 	andeq	r0, r0, r4, lsr r7
  18:	00000870 	andeq	r0, r0, r0, ror r8
  1c:	00000904 	andeq	r0, r0, r4, lsl #18
	return kzalloc(size, GFP_KERNEL);
}
  20:	00000934 	andeq	r0, r0, r4, lsr r9
